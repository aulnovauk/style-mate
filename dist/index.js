var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// shared/schema.ts
var schema_exports = {};
__export(schema_exports, {
  ADJUSTMENT_TYPES: () => ADJUSTMENT_TYPES,
  BOOKING_STATUSES: () => BOOKING_STATUSES,
  CAMPAIGN_STATUSES: () => CAMPAIGN_STATUSES,
  CANCELLATION_REASON_CODES: () => CANCELLATION_REASON_CODES,
  CHANNEL_TYPES: () => CHANNEL_TYPES,
  CHECK_IN_METHODS: () => CHECK_IN_METHODS,
  DEMAND_LEVELS: () => DEMAND_LEVELS,
  DISCOUNT_TYPES: () => DISCOUNT_TYPES,
  IMPORTED_CUSTOMER_STATUSES: () => IMPORTED_CUSTOMER_STATUSES,
  IMPORT_BATCH_STATUSES: () => IMPORT_BATCH_STATUSES,
  JOB_CARD_PAYMENT_STATUSES: () => JOB_CARD_PAYMENT_STATUSES,
  JOB_CARD_STATUSES: () => JOB_CARD_STATUSES,
  JOB_CARD_STATUS_TRANSITIONS: () => JOB_CARD_STATUS_TRANSITIONS,
  LATE_ARRIVAL_DELAY_OPTIONS: () => LATE_ARRIVAL_DELAY_OPTIONS,
  MESSAGE_STATUSES: () => MESSAGE_STATUSES,
  PAYMENT_METHODS: () => PAYMENT_METHODS,
  PRICING_RULE_TYPES: () => PRICING_RULE_TYPES,
  REDEMPTION_STATUSES: () => REDEMPTION_STATUSES,
  SERVICE_PACKAGE_CATEGORIES: () => SERVICE_PACKAGE_CATEGORIES,
  SUBSCRIPTION_STATUSES: () => SUBSCRIPTION_STATUSES,
  SUBSCRIPTION_TIERS: () => SUBSCRIPTION_TIERS,
  WAITLIST_NOTIFICATION_TYPE: () => WAITLIST_NOTIFICATION_TYPE,
  WAITLIST_PRIORITY: () => WAITLIST_PRIORITY,
  WAITLIST_RESPONSE: () => WAITLIST_RESPONSE,
  WAITLIST_STATUS: () => WAITLIST_STATUS,
  abTestCampaigns: () => abTestCampaigns,
  abTestCampaignsRelations: () => abTestCampaignsRelations,
  acknowledgeDepartureAlertSchema: () => acknowledgeDepartureAlertSchema,
  acknowledgeLateArrivalSchema: () => acknowledgeLateArrivalSchema,
  addJobCardProductSchema: () => addJobCardProductSchema,
  addJobCardServiceSchema: () => addJobCardServiceSchema,
  addJobCardTipSchema: () => addJobCardTipSchema,
  addToCartSchema: () => addToCartSchema,
  addToWishlistSchema: () => addToWishlistSchema,
  adminAuditLogs: () => adminAuditLogs,
  adminAuditLogsRelations: () => adminAuditLogsRelations,
  aiLookOptions: () => aiLookOptions,
  aiLookProducts: () => aiLookProducts,
  aiLookSessions: () => aiLookSessions,
  applyJobCardDiscountSchema: () => applyJobCardDiscountSchema,
  approveRejectOfferSchema: () => approveRejectOfferSchema,
  assignShopRoleSchema: () => assignShopRoleSchema,
  automatedActionLogs: () => automatedActionLogs,
  automatedActionLogsRelations: () => automatedActionLogsRelations,
  automationConfigurations: () => automationConfigurations,
  automationConfigurationsRelations: () => automationConfigurationsRelations,
  availabilityPatterns: () => availabilityPatterns,
  availabilityPatternsRelations: () => availabilityPatternsRelations,
  beautyProducts: () => beautyProducts,
  bookPackageSchema: () => bookPackageSchema,
  bookingCancellations: () => bookingCancellations,
  bookingCancellationsRelations: () => bookingCancellationsRelations,
  bookingServices: () => bookingServices,
  bookingServicesRelations: () => bookingServicesRelations,
  bookingSettings: () => bookingSettings,
  bookings: () => bookings,
  bookingsRelations: () => bookingsRelations,
  budgets: () => budgets,
  budgetsRelations: () => budgetsRelations,
  bulkUpdateBookingSchema: () => bulkUpdateBookingSchema,
  campaignOptimizationInsights: () => campaignOptimizationInsights,
  campaignOptimizationInsightsRelations: () => campaignOptimizationInsightsRelations,
  cancelOrderAdminSchema: () => cancelOrderAdminSchema,
  cancelOrderSchema: () => cancelOrderSchema,
  cancelRegistrationSchema: () => cancelRegistrationSchema,
  cancellationPolicies: () => cancellationPolicies,
  cancellationPoliciesRelations: () => cancellationPoliciesRelations,
  cartItems: () => cartItems,
  chatConversations: () => chatConversations,
  chatConversationsRelations: () => chatConversationsRelations,
  chatMessageReads: () => chatMessageReads,
  chatMessageReadsRelations: () => chatMessageReadsRelations,
  chatMessages: () => chatMessages,
  chatMessagesRelations: () => chatMessagesRelations,
  chatParticipants: () => chatParticipants,
  chatParticipantsRelations: () => chatParticipantsRelations,
  checkInCustomerSchema: () => checkInCustomerSchema,
  clientFormulas: () => clientFormulas,
  clientFormulasRelations: () => clientFormulasRelations,
  clientNotes: () => clientNotes,
  clientNotesRelations: () => clientNotesRelations,
  clientPhotos: () => clientPhotos,
  clientPhotosRelations: () => clientPhotosRelations,
  clientProfiles: () => clientProfiles,
  clientProfilesRelations: () => clientProfilesRelations,
  commissionRates: () => commissionRates,
  commissionRatesRelations: () => commissionRatesRelations,
  commissionReversals: () => commissionReversals,
  commissionReversalsRelations: () => commissionReversalsRelations,
  commissions: () => commissions,
  commissionsRelations: () => commissionsRelations,
  communicationAnalytics: () => communicationAnalytics,
  communicationAnalyticsRelations: () => communicationAnalyticsRelations,
  communicationCampaigns: () => communicationCampaigns,
  communicationCampaignsRelations: () => communicationCampaignsRelations,
  communicationHistory: () => communicationHistory,
  communicationHistoryRelations: () => communicationHistoryRelations,
  communicationPreferences: () => communicationPreferences,
  communicationPreferencesRelations: () => communicationPreferencesRelations,
  configureRetailSchema: () => configureRetailSchema,
  createDemandOverrideSchema: () => createDemandOverrideSchema,
  createEventSchema: () => createEventSchema,
  createLateArrivalNotificationSchema: () => createLateArrivalNotificationSchema,
  createOfferSchema: () => createOfferSchema,
  createPackageSchema: () => createPackageSchema,
  createPaymentOrderSchema: () => createPaymentOrderSchema,
  createPricingRuleSchema: () => createPricingRuleSchema,
  createProductOrderSchema: () => createProductOrderSchema,
  createRebookingCycleSchema: () => createRebookingCycleSchema,
  createReviewSchema: () => createReviewSchema,
  createSalonSchema: () => createSalonSchema,
  createServicePackageSchema: () => createServicePackageSchema,
  createTicketTypeSchema: () => createTicketTypeSchema,
  customerDeparturePreferences: () => customerDeparturePreferences,
  customerDeparturePreferencesRelations: () => customerDeparturePreferencesRelations,
  customerImportBatches: () => customerImportBatches,
  customerImportBatchesRelations: () => customerImportBatchesRelations,
  customerMemberships: () => customerMemberships,
  customerMembershipsRelations: () => customerMembershipsRelations,
  customerProfiles: () => customerProfiles,
  customerProfilesRelations: () => customerProfilesRelations,
  customerRebookingStats: () => customerRebookingStats,
  customerRebookingStatsRelations: () => customerRebookingStatsRelations,
  customerSavedCards: () => customerSavedCards,
  customerSavedCardsRelations: () => customerSavedCardsRelations,
  customerSegments: () => customerSegments,
  customerSegmentsRelations: () => customerSegmentsRelations,
  customerTimingPreferences: () => customerTimingPreferences,
  customizeRebookSchema: () => customizeRebookSchema,
  deliverySettings: () => deliverySettings,
  demandDateOverrides: () => demandDateOverrides,
  demandDateOverridesRelations: () => demandDateOverridesRelations,
  departureAlertSettings: () => departureAlertSettings,
  departureAlertSettingsRelations: () => departureAlertSettingsRelations,
  departureAlerts: () => departureAlerts,
  departureAlertsRelations: () => departureAlertsRelations,
  depositSettings: () => depositSettings,
  depositSettingsRelations: () => depositSettingsRelations,
  depositTransactions: () => depositTransactions,
  depositTransactionsRelations: () => depositTransactionsRelations,
  dismissRebookSuggestionSchema: () => dismissRebookSuggestionSchema,
  dismissRebookingSchema: () => dismissRebookingSchema,
  dynamicPricingRules: () => dynamicPricingRules,
  dynamicPricingRulesRelations: () => dynamicPricingRulesRelations,
  effectPresets: () => effectPresets,
  emailVerificationTokens: () => emailVerificationTokens,
  eventAnalyticsDaily: () => eventAnalyticsDaily,
  eventGroupDiscounts: () => eventGroupDiscounts,
  eventNotificationPreferences: () => eventNotificationPreferences,
  eventNotifications: () => eventNotifications,
  eventPromoCodes: () => eventPromoCodes,
  eventRegistrationPayments: () => eventRegistrationPayments,
  eventRegistrationPaymentsRelations: () => eventRegistrationPaymentsRelations,
  eventRegistrationSchema: () => eventRegistrationSchema,
  eventRegistrations: () => eventRegistrations,
  eventRegistrationsRelations: () => eventRegistrationsRelations,
  eventReviewSchema: () => eventReviewSchema,
  eventReviews: () => eventReviews,
  eventReviewsRelations: () => eventReviewsRelations,
  eventSchedules: () => eventSchedules,
  eventSchedulesRelations: () => eventSchedulesRelations,
  eventSpeakers: () => eventSpeakers,
  eventSpeakersRelations: () => eventSpeakersRelations,
  eventTicketTypes: () => eventTicketTypes,
  eventTicketTypesRelations: () => eventTicketTypesRelations,
  eventTypes: () => eventTypes,
  eventTypesRelations: () => eventTypesRelations,
  eventViews: () => eventViews,
  events: () => events,
  eventsRelations: () => eventsRelations,
  expenseCategories: () => expenseCategories,
  expenseCategoriesRelations: () => expenseCategoriesRelations,
  expenses: () => expenses,
  expensesRelations: () => expensesRelations,
  favoriteSalons: () => favoriteSalons,
  favoriteSalonsRelations: () => favoriteSalonsRelations,
  favoriteStylists: () => favoriteStylists,
  favoriteStylistsRelations: () => favoriteStylistsRelations,
  financialReports: () => financialReports,
  financialReportsRelations: () => financialReportsRelations,
  geocodeLocations: () => geocodeLocations,
  giftCardDeliveries: () => giftCardDeliveries,
  giftCardDeliveriesRelations: () => giftCardDeliveriesRelations,
  giftCardTemplates: () => giftCardTemplates,
  giftCardTemplatesRelations: () => giftCardTemplatesRelations,
  giftCardTransactions: () => giftCardTransactions,
  giftCardTransactionsRelations: () => giftCardTransactionsRelations,
  giftCards: () => giftCards,
  giftCardsRelations: () => giftCardsRelations,
  googlePlacesCache: () => googlePlacesCache,
  importedCustomers: () => importedCustomers,
  importedCustomersRelations: () => importedCustomersRelations,
  insertAbTestCampaignSchema: () => insertAbTestCampaignSchema,
  insertAdminAuditLogSchema: () => insertAdminAuditLogSchema,
  insertAiLookOptionSchema: () => insertAiLookOptionSchema,
  insertAiLookProductSchema: () => insertAiLookProductSchema,
  insertAiLookSessionSchema: () => insertAiLookSessionSchema,
  insertAutomatedActionLogSchema: () => insertAutomatedActionLogSchema,
  insertAutomationConfigurationSchema: () => insertAutomationConfigurationSchema,
  insertAvailabilityPatternSchema: () => insertAvailabilityPatternSchema,
  insertBeautyProductSchema: () => insertBeautyProductSchema,
  insertBookingCancellationSchema: () => insertBookingCancellationSchema,
  insertBookingSchema: () => insertBookingSchema,
  insertBookingServiceSchema: () => insertBookingServiceSchema,
  insertBookingSettingsSchema: () => insertBookingSettingsSchema,
  insertBudgetSchema: () => insertBudgetSchema,
  insertCampaignOptimizationInsightSchema: () => insertCampaignOptimizationInsightSchema,
  insertCancellationPolicySchema: () => insertCancellationPolicySchema,
  insertCartItemSchema: () => insertCartItemSchema,
  insertChatConversationSchema: () => insertChatConversationSchema,
  insertChatMessageSchema: () => insertChatMessageSchema,
  insertClientFormulaSchema: () => insertClientFormulaSchema,
  insertClientNoteSchema: () => insertClientNoteSchema,
  insertClientPhotoSchema: () => insertClientPhotoSchema,
  insertClientProfileSchema: () => insertClientProfileSchema,
  insertCommissionRateSchema: () => insertCommissionRateSchema,
  insertCommissionReversalSchema: () => insertCommissionReversalSchema,
  insertCommissionSchema: () => insertCommissionSchema,
  insertCommunicationAnalyticsSchema: () => insertCommunicationAnalyticsSchema,
  insertCommunicationCampaignSchema: () => insertCommunicationCampaignSchema,
  insertCommunicationHistorySchema: () => insertCommunicationHistorySchema,
  insertCommunicationPreferencesSchema: () => insertCommunicationPreferencesSchema,
  insertCustomerDeparturePreferencesSchema: () => insertCustomerDeparturePreferencesSchema,
  insertCustomerImportBatchSchema: () => insertCustomerImportBatchSchema,
  insertCustomerMembershipSchema: () => insertCustomerMembershipSchema,
  insertCustomerProfileSchema: () => insertCustomerProfileSchema,
  insertCustomerRebookingStatSchema: () => insertCustomerRebookingStatSchema,
  insertCustomerSegmentSchema: () => insertCustomerSegmentSchema,
  insertDeliverySettingsSchema: () => insertDeliverySettingsSchema,
  insertDemandDateOverrideSchema: () => insertDemandDateOverrideSchema,
  insertDepartureAlertSchema: () => insertDepartureAlertSchema,
  insertDepartureAlertSettingsSchema: () => insertDepartureAlertSettingsSchema,
  insertDepositSettingsSchema: () => insertDepositSettingsSchema,
  insertDepositTransactionSchema: () => insertDepositTransactionSchema,
  insertDynamicPricingRuleSchema: () => insertDynamicPricingRuleSchema,
  insertEffectPresetSchema: () => insertEffectPresetSchema,
  insertEventAnalyticsDailySchema: () => insertEventAnalyticsDailySchema,
  insertEventGroupDiscountSchema: () => insertEventGroupDiscountSchema,
  insertEventNotificationPreferencesSchema: () => insertEventNotificationPreferencesSchema,
  insertEventNotificationSchema: () => insertEventNotificationSchema,
  insertEventPromoCodeSchema: () => insertEventPromoCodeSchema,
  insertEventRegistrationPaymentSchema: () => insertEventRegistrationPaymentSchema,
  insertEventRegistrationSchema: () => insertEventRegistrationSchema,
  insertEventReviewSchema: () => insertEventReviewSchema,
  insertEventScheduleSchema: () => insertEventScheduleSchema,
  insertEventSchema: () => insertEventSchema,
  insertEventSpeakerSchema: () => insertEventSpeakerSchema,
  insertEventTicketTypeSchema: () => insertEventTicketTypeSchema,
  insertEventTypeSchema: () => insertEventTypeSchema,
  insertEventViewSchema: () => insertEventViewSchema,
  insertExpenseCategorySchema: () => insertExpenseCategorySchema,
  insertExpenseSchema: () => insertExpenseSchema,
  insertFinancialReportSchema: () => insertFinancialReportSchema,
  insertGeocodeLocationSchema: () => insertGeocodeLocationSchema,
  insertGiftCardDeliverySchema: () => insertGiftCardDeliverySchema,
  insertGiftCardSchema: () => insertGiftCardSchema,
  insertGiftCardTemplateSchema: () => insertGiftCardTemplateSchema,
  insertGiftCardTransactionSchema: () => insertGiftCardTransactionSchema,
  insertGooglePlacesCacheSchema: () => insertGooglePlacesCacheSchema,
  insertImportedCustomerSchema: () => insertImportedCustomerSchema,
  insertInventoryAdjustmentItemSchema: () => insertInventoryAdjustmentItemSchema,
  insertInventoryAdjustmentSchema: () => insertInventoryAdjustmentSchema,
  insertInvitationCampaignSchema: () => insertInvitationCampaignSchema,
  insertInvitationMessageSchema: () => insertInvitationMessageSchema,
  insertJobCardActivityLogSchema: () => insertJobCardActivityLogSchema,
  insertJobCardPaymentSchema: () => insertJobCardPaymentSchema,
  insertJobCardProductSchema: () => insertJobCardProductSchema,
  insertJobCardSchema: () => insertJobCardSchema,
  insertJobCardServiceSchema: () => insertJobCardServiceSchema,
  insertJobCardTipSchema: () => insertJobCardTipSchema,
  insertLateArrivalNotificationSchema: () => insertLateArrivalNotificationSchema,
  insertLaunchOfferSchema: () => insertLaunchOfferSchema,
  insertLocationAliasSchema: () => insertLocationAliasSchema,
  insertMediaAssetSchema: () => insertMediaAssetSchema,
  insertMembershipCreditTransactionSchema: () => insertMembershipCreditTransactionSchema,
  insertMembershipPaymentSchema: () => insertMembershipPaymentSchema,
  insertMembershipPlanSchema: () => insertMembershipPlanSchema,
  insertMembershipPlanServiceSchema: () => insertMembershipPlanServiceSchema,
  insertMembershipServiceUsageSchema: () => insertMembershipServiceUsageSchema,
  insertMessageTemplateSchema: () => insertMessageTemplateSchema,
  insertOptimizationRecommendationSchema: () => insertOptimizationRecommendationSchema,
  insertOrgUserSchema: () => insertOrgUserSchema,
  insertOrganizationSchema: () => insertOrganizationSchema,
  insertPackageBookingSchema: () => insertPackageBookingSchema,
  insertPackageServiceSchema: () => insertPackageServiceSchema,
  insertPasswordResetOtpSchema: () => insertPasswordResetOtpSchema,
  insertPaymentSchema: () => insertPaymentSchema,
  insertPayoutAccountSchema: () => insertPayoutAccountSchema,
  insertPerformanceMonitoringSettingSchema: () => insertPerformanceMonitoringSettingSchema,
  insertPermissionSchema: () => insertPermissionSchema,
  insertPlatformCommissionSchema: () => insertPlatformCommissionSchema,
  insertPlatformConfigSchema: () => insertPlatformConfigSchema,
  insertPlatformOfferSchema: () => insertPlatformOfferSchema,
  insertPlatformPayoutSchema: () => insertPlatformPayoutSchema,
  insertPricingAdjustmentLogSchema: () => insertPricingAdjustmentLogSchema,
  insertProductCategorySchema: () => insertProductCategorySchema,
  insertProductOrderItemSchema: () => insertProductOrderItemSchema,
  insertProductOrderSchema: () => insertProductOrderSchema,
  insertProductRetailConfigSchema: () => insertProductRetailConfigSchema,
  insertProductReviewSchema: () => insertProductReviewSchema,
  insertProductSchema: () => insertProductSchema,
  insertProductUsageSchema: () => insertProductUsageSchema,
  insertProductVariantSchema: () => insertProductVariantSchema,
  insertProductViewSchema: () => insertProductViewSchema,
  insertProfileVisibilitySettingsSchema: () => insertProfileVisibilitySettingsSchema,
  insertPublishStateSchema: () => insertPublishStateSchema,
  insertPurchaseOrderItemSchema: () => insertPurchaseOrderItemSchema,
  insertPurchaseOrderSchema: () => insertPurchaseOrderSchema,
  insertRebookingReminderSchema: () => insertRebookingReminderSchema,
  insertRebookingSettingsSchema: () => insertRebookingSettingsSchema,
  insertReorderRuleSchema: () => insertReorderRuleSchema,
  insertResourceSchema: () => insertResourceSchema,
  insertRoleSchema: () => insertRoleSchema,
  insertSalonInventorySchema: () => insertSalonInventorySchema,
  insertSalonReviewSchema: () => insertSalonReviewSchema,
  insertSalonSchema: () => insertSalonSchema,
  insertScheduledMessageSchema: () => insertScheduledMessageSchema,
  insertServiceDepositRuleSchema: () => insertServiceDepositRuleSchema,
  insertServicePackageSchema: () => insertServicePackageSchema,
  insertServiceRebookingCycleSchema: () => insertServiceRebookingCycleSchema,
  insertServiceResourceSchema: () => insertServiceResourceSchema,
  insertServiceSchema: () => insertServiceSchema,
  insertServiceTemplateSchema: () => insertServiceTemplateSchema,
  insertShopRoleAssignmentSchema: () => insertShopRoleAssignmentSchema,
  insertShopRolePermissionSchema: () => insertShopRolePermissionSchema,
  insertShoppingCartSchema: () => insertShoppingCartSchema,
  insertSlotWaitlistSchema: () => insertSlotWaitlistSchema,
  insertStaffAdjustmentSchema: () => insertStaffAdjustmentSchema,
  insertStaffPayoutSchema: () => insertStaffPayoutSchema,
  insertStaffQueueStatusSchema: () => insertStaffQueueStatusSchema,
  insertStaffSchema: () => insertStaffSchema,
  insertStaffServiceSchema: () => insertStaffServiceSchema,
  insertStockMovementSchema: () => insertStockMovementSchema,
  insertTaxRateSchema: () => insertTaxRateSchema,
  insertTaxSettingSchema: () => insertTaxSettingSchema,
  insertTestMetricSchema: () => insertTestMetricSchema,
  insertTestResultSchema: () => insertTestResultSchema,
  insertTestVariantSchema: () => insertTestVariantSchema,
  insertTimeSlotDemandSchema: () => insertTimeSlotDemandSchema,
  insertTimeSlotSchema: () => insertTimeSlotSchema,
  insertTrustedCustomerSchema: () => insertTrustedCustomerSchema,
  insertUserNotificationSchema: () => insertUserNotificationSchema,
  insertUserOfferUsageSchema: () => insertUserOfferUsageSchema,
  insertUserRoleSchema: () => insertUserRoleSchema,
  insertUserSavedLocationSchema: () => insertUserSavedLocationSchema,
  insertUserSchema: () => insertUserSchema,
  insertUserWalletSchema: () => insertUserWalletSchema,
  insertVariantGenerationRuleSchema: () => insertVariantGenerationRuleSchema,
  insertVendorSchema: () => insertVendorSchema,
  insertWaitlistNotificationSchema: () => insertWaitlistNotificationSchema,
  insertWalletTransactionSchema: () => insertWalletTransactionSchema,
  insertWelcomeOfferRedemptionSchema: () => insertWelcomeOfferRedemptionSchema,
  insertWelcomeOfferSchema: () => insertWelcomeOfferSchema,
  insertWishlistSchema: () => insertWishlistSchema,
  inventoryAdjustmentItems: () => inventoryAdjustmentItems,
  inventoryAdjustmentItemsRelations: () => inventoryAdjustmentItemsRelations,
  inventoryAdjustments: () => inventoryAdjustments,
  inventoryAdjustmentsRelations: () => inventoryAdjustmentsRelations,
  invitationCampaigns: () => invitationCampaigns,
  invitationCampaignsRelations: () => invitationCampaignsRelations,
  invitationMessages: () => invitationMessages,
  invitationMessagesRelations: () => invitationMessagesRelations,
  jobCardActivityLog: () => jobCardActivityLog,
  jobCardActivityLogRelations: () => jobCardActivityLogRelations,
  jobCardPayments: () => jobCardPayments,
  jobCardPaymentsRelations: () => jobCardPaymentsRelations,
  jobCardProducts: () => jobCardProducts,
  jobCardProductsRelations: () => jobCardProductsRelations,
  jobCardServices: () => jobCardServices,
  jobCardServicesRelations: () => jobCardServicesRelations,
  jobCardTips: () => jobCardTips,
  jobCardTipsRelations: () => jobCardTipsRelations,
  jobCards: () => jobCards,
  jobCardsRelations: () => jobCardsRelations,
  joinWaitlistSchema: () => joinWaitlistSchema,
  lateArrivalNotifications: () => lateArrivalNotifications,
  lateArrivalNotificationsRelations: () => lateArrivalNotificationsRelations,
  launchOffers: () => launchOffers,
  locationAliases: () => locationAliases,
  loyaltyTiers: () => loyaltyTiers,
  mediaAssets: () => mediaAssets,
  membershipCreditTransactions: () => membershipCreditTransactions,
  membershipCreditTransactionsRelations: () => membershipCreditTransactionsRelations,
  membershipPayments: () => membershipPayments,
  membershipPaymentsRelations: () => membershipPaymentsRelations,
  membershipPlanServices: () => membershipPlanServices,
  membershipPlanServicesRelations: () => membershipPlanServicesRelations,
  membershipPlans: () => membershipPlans,
  membershipPlansRelations: () => membershipPlansRelations,
  membershipServiceUsage: () => membershipServiceUsage,
  membershipServiceUsageRelations: () => membershipServiceUsageRelations,
  messageTemplates: () => messageTemplates,
  messageTemplatesRelations: () => messageTemplatesRelations,
  metaBookingRefs: () => metaBookingRefs,
  metaBookingRefsRelations: () => metaBookingRefsRelations,
  metaIntegrations: () => metaIntegrations,
  metaIntegrationsRelations: () => metaIntegrationsRelations,
  metaWebhookEvents: () => metaWebhookEvents,
  normalizePhoneNumber: () => normalizePhoneNumber,
  optimizationRecommendations: () => optimizationRecommendations,
  optimizationRecommendationsRelations: () => optimizationRecommendationsRelations,
  orgUsers: () => orgUsers,
  orgUsersRelations: () => orgUsersRelations,
  organizations: () => organizations,
  organizationsRelations: () => organizationsRelations,
  packageBookings: () => packageBookings,
  packageBookingsRelations: () => packageBookingsRelations,
  packageServiceEntrySchema: () => packageServiceEntrySchema,
  packageServices: () => packageServices,
  packageServicesRelations: () => packageServicesRelations,
  passwordResetOtps: () => passwordResetOtps,
  payments: () => payments,
  paymentsRelations: () => paymentsRelations,
  payoutAccounts: () => payoutAccounts,
  performanceMonitoringSettings: () => performanceMonitoringSettings,
  performanceMonitoringSettingsRelations: () => performanceMonitoringSettingsRelations,
  permissionCategories: () => permissionCategories,
  permissions: () => permissions,
  phoneVerificationTokens: () => phoneVerificationTokens,
  placesAutocompleteResponseSchema: () => placesAutocompleteResponseSchema,
  placesAutocompleteSchema: () => placesAutocompleteSchema,
  placesDetailsResponseSchema: () => placesDetailsResponseSchema,
  placesDetailsSchema: () => placesDetailsSchema,
  placesGeocodeResponseSchema: () => placesGeocodeResponseSchema,
  placesGeocodeSchema: () => placesGeocodeSchema,
  platformCommissions: () => platformCommissions,
  platformConfig: () => platformConfig,
  platformOffers: () => platformOffers,
  platformPayouts: () => platformPayouts,
  platformSettingsSchema: () => platformSettingsSchema,
  pointTransactions: () => pointTransactions,
  pointTransactionsRelations: () => pointTransactionsRelations,
  predictionAccuracyLogs: () => predictionAccuracyLogs,
  preferencesSchema: () => preferencesSchema,
  pricingAdjustmentsLog: () => pricingAdjustmentsLog,
  pricingAdjustmentsLogRelations: () => pricingAdjustmentsLogRelations,
  processJobCardPaymentSchema: () => processJobCardPaymentSchema,
  productCategories: () => productCategories,
  productCategoriesRelations: () => productCategoriesRelations,
  productOrderItems: () => productOrderItems,
  productOrders: () => productOrders,
  productRetailConfig: () => productRetailConfig,
  productReviews: () => productReviews,
  productUsage: () => productUsage,
  productUsageRelations: () => productUsageRelations,
  productVariants: () => productVariants,
  productViews: () => productViews,
  products: () => products,
  productsRelations: () => productsRelations,
  profileUpdateSchema: () => profileUpdateSchema,
  profileVisibilitySettings: () => profileVisibilitySettings,
  profileVisibilitySettingsRelations: () => profileVisibilitySettingsRelations,
  publishState: () => publishState,
  purchaseGiftCardSchema: () => purchaseGiftCardSchema,
  purchaseOrderItems: () => purchaseOrderItems,
  purchaseOrderItemsRelations: () => purchaseOrderItemsRelations,
  purchaseOrders: () => purchaseOrders,
  purchaseOrdersRelations: () => purchaseOrdersRelations,
  quickRebookSchema: () => quickRebookSchema,
  razorpayWebhookEvents: () => razorpayWebhookEvents,
  rebookSuggestions: () => rebookSuggestions,
  rebookSuggestionsRelations: () => rebookSuggestionsRelations,
  rebookingReminders: () => rebookingReminders,
  rebookingRemindersRelations: () => rebookingRemindersRelations,
  rebookingSettings: () => rebookingSettings,
  rebookingSettingsRelations: () => rebookingSettingsRelations,
  rebookingSuggestionSchema: () => rebookingSuggestionSchema,
  redeemGiftCardSchema: () => redeemGiftCardSchema,
  referralCodes: () => referralCodes,
  referralCodesRelations: () => referralCodesRelations,
  referrals: () => referrals,
  referralsRelations: () => referralsRelations,
  refreshTokens: () => refreshTokens,
  reorderRules: () => reorderRules,
  reorderRulesRelations: () => reorderRulesRelations,
  rescheduleBookingInputSchema: () => rescheduleBookingInputSchema,
  resources: () => resources,
  respondWaitlistSchema: () => respondWaitlistSchema,
  revokeShopRoleSchema: () => revokeShopRoleSchema,
  rewards: () => rewards,
  roles: () => roles,
  salonInventory: () => salonInventory,
  salonOfferSchema: () => salonOfferSchema,
  salonReviews: () => salonReviews,
  salonSearchResultSchema: () => salonSearchResultSchema,
  salonSearchSchema: () => salonSearchSchema,
  salonSubscriptions: () => salonSubscriptions,
  salonSubscriptionsRelations: () => salonSubscriptionsRelations,
  salons: () => salons,
  salonsRelations: () => salonsRelations,
  savedOffers: () => savedOffers,
  savedOffersRelations: () => savedOffersRelations,
  scheduledMessages: () => scheduledMessages,
  scheduledMessagesRelations: () => scheduledMessagesRelations,
  serviceDepositRules: () => serviceDepositRules,
  serviceDepositRulesRelations: () => serviceDepositRulesRelations,
  servicePackages: () => servicePackages,
  servicePackagesRelations: () => servicePackagesRelations,
  serviceRebookingCycles: () => serviceRebookingCycles,
  serviceRebookingCyclesRelations: () => serviceRebookingCyclesRelations,
  serviceResources: () => serviceResources,
  serviceTemplates: () => serviceTemplates,
  serviceTimingAnalytics: () => serviceTimingAnalytics,
  services: () => services,
  servicesRelations: () => servicesRelations,
  sessions: () => sessions,
  shopAdminListItemSchema: () => shopAdminListItemSchema,
  shopRoleAssignments: () => shopRoleAssignments,
  shopRoleAssignmentsRelations: () => shopRoleAssignmentsRelations,
  shopRolePermissions: () => shopRolePermissions,
  shopRolePermissionsRelations: () => shopRolePermissionsRelations,
  shopRoleTypes: () => shopRoleTypes,
  shoppingCarts: () => shoppingCarts,
  slotWaitlist: () => slotWaitlist,
  slotWaitlistRelations: () => slotWaitlistRelations,
  socialBookingAnalytics: () => socialBookingAnalytics,
  staff: () => staff,
  staffAdjustments: () => staffAdjustments,
  staffAdjustmentsRelations: () => staffAdjustmentsRelations,
  staffPayouts: () => staffPayouts,
  staffPayoutsRelations: () => staffPayoutsRelations,
  staffPerformancePatterns: () => staffPerformancePatterns,
  staffQueueStatus: () => staffQueueStatus,
  staffQueueStatusRelations: () => staffQueueStatusRelations,
  staffRelations: () => staffRelations,
  staffServices: () => staffServices,
  stockMovements: () => stockMovements,
  stockMovementsRelations: () => stockMovementsRelations,
  subscriptionPayments: () => subscriptionPayments,
  subscriptionPaymentsRelations: () => subscriptionPaymentsRelations,
  subscriptionRefunds: () => subscriptionRefunds,
  subscriptionTiers: () => subscriptionTiers,
  subscriptionTiersRelations: () => subscriptionTiersRelations,
  taxRates: () => taxRates,
  taxSettings: () => taxSettings,
  taxSettingsRelations: () => taxSettingsRelations,
  testMetrics: () => testMetrics,
  testMetricsRelations: () => testMetricsRelations,
  testResults: () => testResults,
  testResultsRelations: () => testResultsRelations,
  testVariants: () => testVariants,
  testVariantsRelations: () => testVariantsRelations,
  timeSlotDemand: () => timeSlotDemand,
  timeSlotDemandRelations: () => timeSlotDemandRelations,
  timeSlots: () => timeSlots,
  timeSlotsRelations: () => timeSlotsRelations,
  toggleOfferStatusSchema: () => toggleOfferStatusSchema,
  trackProductViewSchema: () => trackProductViewSchema,
  trustedCustomers: () => trustedCustomers,
  trustedCustomersRelations: () => trustedCustomersRelations,
  updateBookingSchema: () => updateBookingSchema,
  updateCancellationPolicySchema: () => updateCancellationPolicySchema,
  updateCartItemSchema: () => updateCartItemSchema,
  updateClientProfileSchema: () => updateClientProfileSchema,
  updateCustomerNotesSchema: () => updateCustomerNotesSchema,
  updateCustomerProfileSchema: () => updateCustomerProfileSchema,
  updateCustomerRebookingStatSchema: () => updateCustomerRebookingStatSchema,
  updateDeliverySettingsSchema: () => updateDeliverySettingsSchema,
  updateDeparturePreferencesSchema: () => updateDeparturePreferencesSchema,
  updateDepositSettingsSchema: () => updateDepositSettingsSchema,
  updateEventSchema: () => updateEventSchema,
  updateGiftCardSchema: () => updateGiftCardSchema,
  updateGiftCardTemplateSchema: () => updateGiftCardTemplateSchema,
  updateJobCardStatusSchema: () => updateJobCardStatusSchema,
  updateOfferSchema: () => updateOfferSchema,
  updateOrderStatusSchema: () => updateOrderStatusSchema,
  updatePackageSchema: () => updatePackageSchema,
  updatePricingRuleSchema: () => updatePricingRuleSchema,
  updateRebookingCycleSchema: () => updateRebookingCycleSchema,
  updateRebookingSettingsRequestSchema: () => updateRebookingSettingsRequestSchema,
  updateRebookingSettingsSchema: () => updateRebookingSettingsSchema,
  updateSalonDepartureSettingsSchema: () => updateSalonDepartureSettingsSchema,
  updateServicePackageSchema: () => updateServicePackageSchema,
  updateServiceRebookingCycleSchema: () => updateServiceRebookingCycleSchema,
  updateShopRoleSchema: () => updateShopRoleSchema,
  userBookingPreferences: () => userBookingPreferences,
  userBookingPreferencesRelations: () => userBookingPreferencesRelations,
  userNotifications: () => userNotifications,
  userOfferUsage: () => userOfferUsage,
  userPoints: () => userPoints,
  userPointsRelations: () => userPointsRelations,
  userPushTokens: () => userPushTokens,
  userRedeemedRewards: () => userRedeemedRewards,
  userRedeemedRewardsRelations: () => userRedeemedRewardsRelations,
  userRoles: () => userRoles,
  userRolesRelations: () => userRolesRelations,
  userSalonPermissionsSchema: () => userSalonPermissionsSchema,
  userSavedLocations: () => userSavedLocations,
  userSavedLocationsRelations: () => userSavedLocationsRelations,
  userWallets: () => userWallets,
  users: () => users,
  usersRelations: () => usersRelations,
  validateGiftCardSchema: () => validateGiftCardSchema,
  validateJobCardStatusTransition: () => validateJobCardStatusTransition,
  validateStatusTransition: () => validateStatusTransition,
  variantGenerationRules: () => variantGenerationRules,
  variantGenerationRulesRelations: () => variantGenerationRulesRelations,
  vendors: () => vendors,
  vendorsRelations: () => vendorsRelations,
  verifyPaymentSchema: () => verifyPaymentSchema,
  waitlistNotifications: () => waitlistNotifications,
  waitlistNotificationsRelations: () => waitlistNotificationsRelations,
  walletTransactions: () => walletTransactions,
  welcomeOfferRedemptions: () => welcomeOfferRedemptions,
  welcomeOfferRedemptionsRelations: () => welcomeOfferRedemptionsRelations,
  welcomeOffers: () => welcomeOffers,
  welcomeOffersRelations: () => welcomeOffersRelations,
  wishlists: () => wishlists
});
import { sql, relations } from "drizzle-orm";
import { pgTable, text, varchar, integer, timestamp, decimal, index, jsonb, check, foreignKey, unique, uniqueIndex } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";
function validateJobCardStatusTransition(currentStatus, newStatus) {
  if (currentStatus === newStatus) {
    return { valid: true };
  }
  const allowedTransitions = JOB_CARD_STATUS_TRANSITIONS[currentStatus];
  if (!allowedTransitions) {
    return { valid: false, error: `Unknown current status: ${currentStatus}` };
  }
  if (!allowedTransitions.includes(newStatus)) {
    return {
      valid: false,
      error: `Invalid status transition from '${currentStatus}' to '${newStatus}'. Allowed: ${allowedTransitions.join(", ") || "none (terminal state)"}`
    };
  }
  return { valid: true };
}
function normalizePhoneNumber(phone) {
  let normalized = phone.replace(/\D/g, "");
  if (normalized.startsWith("91") && normalized.length === 12) {
    normalized = normalized.slice(2);
  } else if (normalized.startsWith("0") && normalized.length === 11) {
    normalized = normalized.slice(1);
  }
  return normalized;
}
var sessions, emailVerificationTokens, refreshTokens, users, insertUserSchema, profileUpdateSchema, phoneVerificationTokens, preferencesSchema, userSavedLocations, insertUserSavedLocationSchema, userSavedLocationsRelations, roles, insertRoleSchema, userRoles, insertUserRoleSchema, organizations, insertOrganizationSchema, orgUsers, insertOrgUserSchema, platformConfig, insertPlatformConfigSchema, platformCommissions, insertPlatformCommissionSchema, platformPayouts, insertPlatformPayoutSchema, salons, insertSalonSchema, salonReviews, insertSalonReviewSchema, googlePlacesCache, insertGooglePlacesCacheSchema, usersRelations, salonsRelations, services, insertServiceSchema, serviceTemplates, insertServiceTemplateSchema, servicesRelations, staff, insertStaffSchema, availabilityPatterns, insertAvailabilityPatternSchema, timeSlots, insertTimeSlotSchema, servicePackages, SERVICE_PACKAGE_CATEGORIES, insertServicePackageSchema, packageServices, insertPackageServiceSchema, packageBookings, insertPackageBookingSchema, servicePackagesRelations, packageBookingsRelations, packageServicesRelations, packageServiceEntrySchema, baseServicePackageSchema, createServicePackageSchema, updateServicePackageSchema, bookPackageSchema, bookings, insertBookingSchema, bookingServices, insertBookingServiceSchema, bookingServicesRelations, bookingsRelations, payments, insertPaymentSchema, bookingCancellations, insertBookingCancellationSchema, bookingCancellationsRelations, CANCELLATION_REASON_CODES, lateArrivalNotifications, insertLateArrivalNotificationSchema, lateArrivalNotificationsRelations, LATE_ARRIVAL_DELAY_OPTIONS, createLateArrivalNotificationSchema, acknowledgeLateArrivalSchema, userRolesRelations, organizationsRelations, orgUsersRelations, paymentsRelations, customerProfiles, insertCustomerProfileSchema, customerProfilesRelations, createPaymentOrderSchema, createSalonSchema, verifyPaymentSchema, bookingStatusEnum, BOOKING_STATUSES, updateBookingSchema, bulkUpdateBookingSchema, rescheduleBookingInputSchema, createPackageSchema, updatePackageSchema, validateStatusTransition, staffRelations, availabilityPatternsRelations, timeSlotsRelations, bookingSettings, staffServices, resources, serviceResources, mediaAssets, taxRates, payoutAccounts, publishState, insertBookingSettingsSchema, insertStaffServiceSchema, insertResourceSchema, insertServiceResourceSchema, insertMediaAssetSchema, insertTaxRateSchema, insertPayoutAccountSchema, insertPublishStateSchema, updateCustomerNotesSchema, updateCustomerProfileSchema, expenseCategories, expenses, commissionRates, commissions, staffPayouts, staffAdjustments, commissionReversals, budgets, financialReports, taxSettings, expenseCategoriesRelations, expensesRelations, commissionRatesRelations, commissionsRelations, staffPayoutsRelations, staffAdjustmentsRelations, commissionReversalsRelations, budgetsRelations, financialReportsRelations, taxSettingsRelations, insertExpenseCategorySchema, insertExpenseSchema, insertCommissionRateSchema, insertCommissionSchema, insertStaffPayoutSchema, insertStaffAdjustmentSchema, insertCommissionReversalSchema, insertBudgetSchema, insertFinancialReportSchema, insertTaxSettingSchema, messageTemplates, insertMessageTemplateSchema, customerSegments, insertCustomerSegmentSchema, communicationCampaigns, insertCommunicationCampaignSchema, communicationHistory, insertCommunicationHistorySchema, communicationPreferences, insertCommunicationPreferencesSchema, scheduledMessages, insertScheduledMessageSchema, communicationAnalytics, insertCommunicationAnalyticsSchema, messageTemplatesRelations, customerSegmentsRelations, communicationCampaignsRelations, communicationHistoryRelations, communicationPreferencesRelations, scheduledMessagesRelations, communicationAnalyticsRelations, abTestCampaigns, insertAbTestCampaignSchema, testVariants, insertTestVariantSchema, testMetrics, insertTestMetricSchema, testResults, insertTestResultSchema, abTestCampaignsRelations, testVariantsRelations, testMetricsRelations, testResultsRelations, automationConfigurations, insertAutomationConfigurationSchema, variantGenerationRules, insertVariantGenerationRuleSchema, performanceMonitoringSettings, insertPerformanceMonitoringSettingSchema, optimizationRecommendations, insertOptimizationRecommendationSchema, automatedActionLogs, insertAutomatedActionLogSchema, campaignOptimizationInsights, insertCampaignOptimizationInsightSchema, automationConfigurationsRelations, variantGenerationRulesRelations, performanceMonitoringSettingsRelations, optimizationRecommendationsRelations, automatedActionLogsRelations, campaignOptimizationInsightsRelations, vendors, insertVendorSchema, productCategories, insertProductCategorySchema, products, insertProductSchema, stockMovements, insertStockMovementSchema, purchaseOrders, insertPurchaseOrderSchema, purchaseOrderItems, insertPurchaseOrderItemSchema, productUsage, insertProductUsageSchema, reorderRules, insertReorderRuleSchema, inventoryAdjustments, insertInventoryAdjustmentSchema, inventoryAdjustmentItems, insertInventoryAdjustmentItemSchema, vendorsRelations, productCategoriesRelations, productsRelations, stockMovementsRelations, purchaseOrdersRelations, purchaseOrderItemsRelations, productUsageRelations, reorderRulesRelations, inventoryAdjustmentsRelations, inventoryAdjustmentItemsRelations, salonSearchSchema, salonSearchResultSchema, placesAutocompleteSchema, placesDetailsSchema, placesGeocodeSchema, placesAutocompleteResponseSchema, placesDetailsResponseSchema, placesGeocodeResponseSchema, platformOffers, insertPlatformOfferSchema, createOfferSchema, updateOfferSchema, approveRejectOfferSchema, toggleOfferStatusSchema, salonOfferSchema, platformSettingsSchema, userWallets, walletTransactions, userOfferUsage, launchOffers, insertUserWalletSchema, insertWalletTransactionSchema, insertUserOfferUsageSchema, insertLaunchOfferSchema, passwordResetOtps, insertPasswordResetOtpSchema, geocodeLocations, locationAliases, insertGeocodeLocationSchema, insertLocationAliasSchema, beautyProducts, effectPresets, salonInventory, aiLookSessions, aiLookOptions, aiLookProducts, insertBeautyProductSchema, insertEffectPresetSchema, insertSalonInventorySchema, insertAiLookSessionSchema, insertAiLookOptionSchema, insertAiLookProductSchema, productRetailConfig, insertProductRetailConfigSchema, productVariants, insertProductVariantSchema, shoppingCarts, insertShoppingCartSchema, cartItems, insertCartItemSchema, productOrders, insertProductOrderSchema, productOrderItems, insertProductOrderItemSchema, wishlists, insertWishlistSchema, productReviews, insertProductReviewSchema, deliverySettings, insertDeliverySettingsSchema, productViews, insertProductViewSchema, addToCartSchema, updateCartItemSchema, createProductOrderSchema, cancelOrderSchema, addToWishlistSchema, createReviewSchema, trackProductViewSchema, configureRetailSchema, updateOrderStatusSchema, cancelOrderAdminSchema, updateDeliverySettingsSchema, eventTypes, insertEventTypeSchema, events, insertEventSchema, eventSpeakers, insertEventSpeakerSchema, eventSchedules, insertEventScheduleSchema, eventTicketTypes, insertEventTicketTypeSchema, eventGroupDiscounts, insertEventGroupDiscountSchema, eventPromoCodes, insertEventPromoCodeSchema, eventRegistrations, insertEventRegistrationSchema, eventRegistrationPayments, insertEventRegistrationPaymentSchema, eventReviews, insertEventReviewSchema, eventNotifications, insertEventNotificationSchema, eventNotificationPreferences, insertEventNotificationPreferencesSchema, eventAnalyticsDaily, insertEventAnalyticsDailySchema, eventViews, insertEventViewSchema, eventTypesRelations, eventsRelations, eventSpeakersRelations, eventSchedulesRelations, eventTicketTypesRelations, eventRegistrationsRelations, eventRegistrationPaymentsRelations, eventReviewsRelations, createEventSchema, updateEventSchema, createTicketTypeSchema, eventRegistrationSchema, eventReviewSchema, cancelRegistrationSchema, userNotifications, insertUserNotificationSchema, userPushTokens, loyaltyTiers, userPoints, pointTransactions, rewards, userRedeemedRewards, favoriteSalons, favoriteStylists, referralCodes, referrals, referralCodesRelations, referralsRelations, userPointsRelations, pointTransactionsRelations, userRedeemedRewardsRelations, favoriteSalonsRelations, favoriteStylistsRelations, chatConversations, chatParticipants, chatMessages, chatMessageReads, chatConversationsRelations, chatParticipantsRelations, chatMessagesRelations, chatMessageReadsRelations, insertChatConversationSchema, insertChatMessageSchema, clientProfiles, clientNotes, clientFormulas, clientPhotos, profileVisibilitySettings, clientProfilesRelations, clientNotesRelations, clientFormulasRelations, clientPhotosRelations, profileVisibilitySettingsRelations, insertClientProfileSchema, updateClientProfileSchema, insertClientNoteSchema, insertClientFormulaSchema, insertClientPhotoSchema, insertProfileVisibilitySettingsSchema, depositSettings, serviceDepositRules, cancellationPolicies, trustedCustomers, depositTransactions, customerSavedCards, customerSavedCardsRelations, depositSettingsRelations, serviceDepositRulesRelations, cancellationPoliciesRelations, trustedCustomersRelations, depositTransactionsRelations, insertDepositSettingsSchema, updateDepositSettingsSchema, insertServiceDepositRuleSchema, insertCancellationPolicySchema, updateCancellationPolicySchema, insertTrustedCustomerSchema, insertDepositTransactionSchema, giftCardTemplates, giftCards, giftCardTransactions, giftCardDeliveries, giftCardTemplatesRelations, giftCardsRelations, giftCardTransactionsRelations, giftCardDeliveriesRelations, insertGiftCardTemplateSchema, updateGiftCardTemplateSchema, insertGiftCardSchema, updateGiftCardSchema, insertGiftCardTransactionSchema, insertGiftCardDeliverySchema, purchaseGiftCardSchema, redeemGiftCardSchema, validateGiftCardSchema, serviceRebookingCycles, customerRebookingStats, rebookingReminders, rebookingSettings, userBookingPreferences, rebookSuggestions, userBookingPreferencesRelations, rebookSuggestionsRelations, serviceRebookingCyclesRelations, customerRebookingStatsRelations, rebookingRemindersRelations, rebookingSettingsRelations, insertServiceRebookingCycleSchema, updateServiceRebookingCycleSchema, insertCustomerRebookingStatSchema, updateCustomerRebookingStatSchema, insertRebookingReminderSchema, insertRebookingSettingsSchema, updateRebookingSettingsSchema, createRebookingCycleSchema, updateRebookingCycleSchema, updateRebookingSettingsRequestSchema, rebookingSuggestionSchema, quickRebookSchema, customizeRebookSchema, dismissRebookSuggestionSchema, dismissRebookingSchema, shopRoleTypes, permissionCategories, permissions, insertPermissionSchema, shopRolePermissions, insertShopRolePermissionSchema, shopRoleAssignments, insertShopRoleAssignmentSchema, adminAuditLogs, insertAdminAuditLogSchema, shopRoleAssignmentsRelations, shopRolePermissionsRelations, adminAuditLogsRelations, assignShopRoleSchema, revokeShopRoleSchema, updateShopRoleSchema, userSalonPermissionsSchema, shopAdminListItemSchema, jobCards, jobCardServices, jobCardProducts, jobCardPayments, jobCardTips, jobCardActivityLog, jobCardsRelations, jobCardServicesRelations, jobCardProductsRelations, jobCardPaymentsRelations, jobCardTipsRelations, jobCardActivityLogRelations, insertJobCardSchema, insertJobCardServiceSchema, insertJobCardProductSchema, insertJobCardPaymentSchema, insertJobCardTipSchema, insertJobCardActivityLogSchema, checkInCustomerSchema, addJobCardServiceSchema, addJobCardProductSchema, processJobCardPaymentSchema, addJobCardTipSchema, applyJobCardDiscountSchema, updateJobCardStatusSchema, JOB_CARD_STATUSES, JOB_CARD_STATUS_TRANSITIONS, JOB_CARD_PAYMENT_STATUSES, CHECK_IN_METHODS, PAYMENT_METHODS, customerImportBatches, insertCustomerImportBatchSchema, importedCustomers, insertImportedCustomerSchema, welcomeOffers, insertWelcomeOfferSchema, invitationCampaigns, insertInvitationCampaignSchema, invitationMessages, insertInvitationMessageSchema, welcomeOfferRedemptions, insertWelcomeOfferRedemptionSchema, customerImportBatchesRelations, importedCustomersRelations, welcomeOffersRelations, invitationCampaignsRelations, invitationMessagesRelations, welcomeOfferRedemptionsRelations, IMPORT_BATCH_STATUSES, IMPORTED_CUSTOMER_STATUSES, CAMPAIGN_STATUSES, MESSAGE_STATUSES, CHANNEL_TYPES, DISCOUNT_TYPES, REDEMPTION_STATUSES, SUBSCRIPTION_TIERS, SUBSCRIPTION_STATUSES, subscriptionTiers, salonSubscriptions, subscriptionPayments, subscriptionRefunds, razorpayWebhookEvents, metaIntegrations, metaBookingRefs, metaWebhookEvents, socialBookingAnalytics, subscriptionTiersRelations, salonSubscriptionsRelations, subscriptionPaymentsRelations, metaIntegrationsRelations, metaBookingRefsRelations, savedOffers, savedOffersRelations, WAITLIST_STATUS, WAITLIST_PRIORITY, WAITLIST_NOTIFICATION_TYPE, WAITLIST_RESPONSE, slotWaitlist, insertSlotWaitlistSchema, waitlistNotifications, insertWaitlistNotificationSchema, slotWaitlistRelations, waitlistNotificationsRelations, joinWaitlistSchema, respondWaitlistSchema, DEMAND_LEVELS, PRICING_RULE_TYPES, ADJUSTMENT_TYPES, timeSlotDemand, insertTimeSlotDemandSchema, dynamicPricingRules, insertDynamicPricingRuleSchema, pricingAdjustmentsLog, insertPricingAdjustmentLogSchema, demandDateOverrides, insertDemandDateOverrideSchema, timeSlotDemandRelations, dynamicPricingRulesRelations, pricingAdjustmentsLogRelations, demandDateOverridesRelations, createPricingRuleSchema, updatePricingRuleSchema, createDemandOverrideSchema, staffQueueStatus, insertStaffQueueStatusSchema, staffQueueStatusRelations, departureAlerts, insertDepartureAlertSchema, departureAlertsRelations, departureAlertSettings, insertDepartureAlertSettingsSchema, departureAlertSettingsRelations, customerDeparturePreferences, insertCustomerDeparturePreferencesSchema, customerDeparturePreferencesRelations, updateDeparturePreferencesSchema, acknowledgeDepartureAlertSchema, updateSalonDepartureSettingsSchema, serviceTimingAnalytics, staffPerformancePatterns, predictionAccuracyLogs, customerTimingPreferences, membershipPlans, insertMembershipPlanSchema, membershipPlanServices, insertMembershipPlanServiceSchema, customerMemberships, insertCustomerMembershipSchema, membershipServiceUsage, insertMembershipServiceUsageSchema, membershipCreditTransactions, insertMembershipCreditTransactionSchema, membershipPayments, insertMembershipPaymentSchema, membershipPlansRelations, membershipPlanServicesRelations, customerMembershipsRelations, membershipServiceUsageRelations, membershipCreditTransactionsRelations, membershipPaymentsRelations;
var init_schema = __esm({
  "shared/schema.ts"() {
    "use strict";
    sessions = pgTable(
      "sessions",
      {
        sid: varchar("sid").primaryKey(),
        sess: jsonb("sess").notNull(),
        expire: timestamp("expire").notNull()
      },
      (table) => [index("IDX_session_expire").on(table.expire)]
    );
    emailVerificationTokens = pgTable("email_verification_tokens", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      email: varchar("email").notNull(),
      token: varchar("token").notNull().unique(),
      userId: varchar("user_id").references(() => users.id, { onDelete: "cascade" }),
      expiresAt: timestamp("expires_at").notNull(),
      createdAt: timestamp("created_at").defaultNow(),
      verifiedAt: timestamp("verified_at")
    });
    refreshTokens = pgTable("refresh_tokens", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      token: text("token").notNull().unique(),
      deviceInfo: text("device_info"),
      ipAddress: varchar("ip_address", { length: 45 }),
      expiresAt: timestamp("expires_at").notNull(),
      createdAt: timestamp("created_at").defaultNow(),
      lastUsedAt: timestamp("last_used_at"),
      revokedAt: timestamp("revoked_at")
    }, (table) => [
      index("refresh_tokens_user_id_idx").on(table.userId),
      index("refresh_tokens_expires_at_idx").on(table.expiresAt)
    ]);
    users = pgTable("users", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      username: text("username").unique(),
      // Optional - auto-generated from email
      password: text("password"),
      // Made optional for Replit Auth users
      email: varchar("email").unique(),
      // Made nullable for Replit Auth compatibility
      firstName: varchar("first_name"),
      // Replit Auth field
      lastName: varchar("last_name"),
      // Replit Auth field
      profileImageUrl: varchar("profile_image_url"),
      // Replit Auth field
      phone: text("phone"),
      workPreference: varchar("work_preference", { length: 20 }),
      // salon, home, both
      businessCategory: varchar("business_category", { length: 50 }),
      // unisex, beauty_parlour, mens_parlour
      businessName: varchar("business_name", { length: 255 }),
      // Business/Salon name
      panNumber: varchar("pan_number", { length: 10 }),
      // PAN number for tax
      gstNumber: varchar("gst_number", { length: 15 }),
      // GST number
      emailVerified: integer("email_verified").notNull().default(0),
      emailVerificationToken: varchar("email_verification_token"),
      // Email verification token
      emailVerificationExpiry: timestamp("email_verification_expiry"),
      // Email verification token expiry
      emailVerificationSentAt: timestamp("email_verification_sent_at"),
      // When verification email was last sent
      phoneVerified: integer("phone_verified").notNull().default(0),
      isActive: integer("is_active").notNull().default(1),
      passwordResetToken: varchar("password_reset_token"),
      // Password reset token
      passwordResetExpiry: timestamp("password_reset_expiry"),
      // Password reset token expiry
      // Membership fields
      hasActiveMembership: integer("has_active_membership").default(0),
      // 1 if user has active membership
      membershipTier: varchar("membership_tier", { length: 20 }),
      // 'silver', 'gold', 'platinum', etc.
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
      // Replit Auth field
    });
    insertUserSchema = createInsertSchema(users).pick({
      password: true,
      email: true,
      firstName: true,
      lastName: true,
      phone: true,
      workPreference: true,
      businessCategory: true,
      businessName: true,
      panNumber: true,
      gstNumber: true
    }).extend({
      username: z.string().optional()
      // Username is optional, auto-generated if not provided
    });
    profileUpdateSchema = createInsertSchema(users).pick({
      firstName: true,
      lastName: true,
      phone: true
    });
    phoneVerificationTokens = pgTable("phone_verification_tokens", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      phone: varchar("phone", { length: 20 }).notNull(),
      codeHash: varchar("code_hash", { length: 255 }).notNull(),
      // SHA-256 hashed OTP code
      context: varchar("context", { length: 20 }).notNull().default("booking"),
      // 'booking', 'walk_in', 'registration'
      attempts: integer("attempts").notNull().default(0),
      // Number of verification attempts
      maxAttempts: integer("max_attempts").notNull().default(3),
      expiresAt: timestamp("expires_at").notNull(),
      // OTP expiry time
      verifiedAt: timestamp("verified_at"),
      // When the OTP was verified
      verificationSessionId: varchar("verification_session_id"),
      // Session ID issued after successful verification
      sessionExpiresAt: timestamp("session_expires_at"),
      // Session expiry time
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("phone_verification_tokens_phone_idx").on(table.phone),
      index("phone_verification_tokens_session_idx").on(table.verificationSessionId)
    ]);
    preferencesSchema = z.object({
      emailNotifications: z.boolean().default(true),
      smsNotifications: z.boolean().default(false),
      marketingComms: z.boolean().default(false),
      preferredTimes: z.array(z.string()).default([]),
      preferredDays: z.array(z.string()).default([]),
      preferredCommunicationMethod: z.enum(["email", "sms", "both"]).default("email")
    });
    userSavedLocations = pgTable("user_saved_locations", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      label: varchar("label", { length: 20 }).notNull(),
      // 'home', 'office', 'custom'
      name: text("name").notNull(),
      // User-friendly name for the location
      address: text("address").notNull(),
      // Full address text
      latitude: decimal("latitude", { precision: 9, scale: 6 }).notNull(),
      // Required for proximity search
      longitude: decimal("longitude", { precision: 9, scale: 6 }).notNull(),
      // Required for proximity search
      placeId: text("place_id"),
      // Optional Google Places ID for address validation
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      // Unique constraint: each user can have only one home and one office location
      uniqueIndex("user_saved_locations_user_label_unique").on(table.userId, table.label).where(sql`${table.label} IN ('home', 'office')`),
      // Spatial index for geospatial queries
      index("user_saved_locations_lat_lng_idx").on(table.latitude, table.longitude),
      // Constraint to validate label values
      check("user_saved_locations_label_check", sql`${table.label} IN ('home', 'office', 'custom')`)
    ]);
    insertUserSavedLocationSchema = createInsertSchema(userSavedLocations).omit({
      id: true,
      createdAt: true
    });
    userSavedLocationsRelations = relations(userSavedLocations, ({ one }) => ({
      user: one(users, {
        fields: [userSavedLocations.userId],
        references: [users.id]
      })
    }));
    roles = pgTable("roles", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      name: varchar("name", { length: 50 }).notNull().unique(),
      // customer, owner, admin
      description: text("description"),
      createdAt: timestamp("created_at").defaultNow()
    });
    insertRoleSchema = createInsertSchema(roles).omit({
      id: true,
      createdAt: true
    });
    userRoles = pgTable("user_roles", {
      userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      roleId: varchar("role_id").notNull().references(() => roles.id, { onDelete: "cascade" }),
      assignedAt: timestamp("assigned_at").defaultNow()
    }, (table) => ({
      pk: { primaryKey: [table.userId, table.roleId] }
    }));
    insertUserRoleSchema = createInsertSchema(userRoles).omit({
      assignedAt: true
    });
    organizations = pgTable("organizations", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      name: text("name").notNull(),
      description: text("description"),
      website: text("website"),
      ownerUserId: varchar("owner_user_id").notNull().references(() => users.id, { onDelete: "restrict" }),
      status: varchar("status", { length: 20 }).notNull().default("active"),
      // active, suspended, inactive
      createdAt: timestamp("created_at").defaultNow()
    });
    insertOrganizationSchema = createInsertSchema(organizations).omit({
      id: true,
      createdAt: true
    });
    orgUsers = pgTable("org_users", {
      orgId: varchar("org_id").notNull().references(() => organizations.id, { onDelete: "cascade" }),
      userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      orgRole: varchar("org_role", { length: 50 }).notNull().default("staff"),
      // owner, manager, staff
      invitedAt: timestamp("invited_at"),
      joinedAt: timestamp("joined_at").defaultNow(),
      isActive: integer("is_active").notNull().default(1)
    }, (table) => ({
      pk: { primaryKey: [table.orgId, table.userId] }
    }));
    insertOrgUserSchema = createInsertSchema(orgUsers).omit({
      joinedAt: true
    });
    platformConfig = pgTable("platform_config", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      configKey: varchar("config_key", { length: 100 }).notNull().unique(),
      // commission_rate, booking_rules, etc
      configValue: jsonb("config_value").notNull(),
      // Flexible JSON storage for any config
      description: text("description"),
      updatedBy: varchar("updated_by").references(() => users.id),
      updatedAt: timestamp("updated_at").defaultNow(),
      createdAt: timestamp("created_at").defaultNow()
    });
    insertPlatformConfigSchema = createInsertSchema(platformConfig).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    platformCommissions = pgTable("platform_commissions", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      bookingId: varchar("booking_id").notNull().references(() => bookings.id, { onDelete: "cascade" }),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      bookingAmountPaisa: integer("booking_amount_paisa").notNull(),
      commissionRate: decimal("commission_rate", { precision: 5, scale: 2 }).notNull(),
      // e.g., 15.00 for 15%
      commissionAmountPaisa: integer("commission_amount_paisa").notNull(),
      salonEarningsPaisa: integer("salon_earnings_paisa").notNull(),
      currency: varchar("currency", { length: 3 }).notNull().default("INR"),
      status: varchar("status", { length: 20 }).notNull().default("pending"),
      // pending, paid, cancelled
      createdAt: timestamp("created_at").defaultNow()
    });
    insertPlatformCommissionSchema = createInsertSchema(platformCommissions).omit({
      id: true,
      createdAt: true
    });
    platformPayouts = pgTable("platform_payouts", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      amountPaisa: integer("amount_paisa").notNull(),
      // Total payout amount
      currency: varchar("currency", { length: 3 }).notNull().default("INR"),
      status: varchar("status", { length: 20 }).notNull().default("pending"),
      // pending, approved, rejected, paid
      paymentMethod: varchar("payment_method", { length: 50 }),
      // bank_transfer, upi, etc
      paymentDetails: jsonb("payment_details"),
      // Account details, UPI ID, etc
      approvedBy: varchar("approved_by").references(() => users.id),
      // Super admin who approved
      approvedAt: timestamp("approved_at"),
      paidAt: timestamp("paid_at"),
      rejectionReason: text("rejection_reason"),
      notes: text("notes"),
      createdAt: timestamp("created_at").defaultNow()
    });
    insertPlatformPayoutSchema = createInsertSchema(platformPayouts).omit({
      id: true,
      createdAt: true
    });
    salons = pgTable("salons", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      name: text("name").notNull(),
      description: text("description"),
      shopNumber: text("shop_number"),
      // Shop/unit/suite number (e.g., "Shop 12", "Suite 3B")
      address: text("address").notNull(),
      city: text("city").notNull(),
      state: text("state").notNull(),
      zipCode: text("zip_code").notNull(),
      latitude: decimal("latitude", { precision: 9, scale: 6 }),
      // For global proximity search
      longitude: decimal("longitude", { precision: 9, scale: 6 }),
      // For global proximity search
      phone: text("phone").notNull(),
      email: text("email").notNull(),
      website: text("website"),
      category: varchar("category", { length: 50 }).notNull(),
      // Hair Salon, Spa, Nails, etc
      priceRange: varchar("price_range", { length: 10 }).notNull(),
      // $, $$, $$$, $$$$
      venueType: varchar("venue_type", { length: 20 }).default("everyone"),
      // everyone, female-only, male-only
      instantBooking: integer("instant_booking").notNull().default(0),
      // 1 if salon supports instant booking, 0 otherwise
      offerDeals: integer("offer_deals").notNull().default(0),
      // 1 if salon offers deals/promotions, 0 otherwise
      acceptGroup: integer("accept_group").notNull().default(0),
      // 1 if salon accepts group bookings, 0 otherwise
      rating: decimal("rating", { precision: 3, scale: 2 }).default("0.00"),
      reviewCount: integer("review_count").notNull().default(0),
      googlePlaceId: text("google_place_id"),
      // Google Places API Place ID for syncing
      googleRating: decimal("google_rating", { precision: 3, scale: 2 }),
      // Rating from Google (0.00-5.00)
      googleReviewCount: integer("google_review_count").default(0),
      // Total review count on Google
      googleRatingSyncedAt: timestamp("google_rating_synced_at"),
      // Last time Google rating was synced
      imageUrl: text("image_url"),
      imageUrls: text("image_urls").array(),
      // Array of image URLs for carousel
      openTime: text("open_time"),
      // e.g., "9:00 AM" (legacy - kept for backward compatibility)
      closeTime: text("close_time"),
      // e.g., "8:00 PM" (legacy - kept for backward compatibility)
      businessHours: jsonb("business_hours"),
      // Structured day-by-day hours: { monday: { open: true, start: "09:00", end: "17:00" }, ... }
      isActive: integer("is_active").notNull().default(1),
      disabledBySuperAdmin: integer("disabled_by_super_admin").notNull().default(0),
      // 1 if disabled by super admin (owner cannot re-enable)
      disabledReason: text("disabled_reason"),
      // Reason for disabling (shown to salon owner)
      disabledAt: timestamp("disabled_at"),
      // When the salon was disabled
      disabledBy: varchar("disabled_by").references(() => users.id),
      // Who disabled the salon
      approvalStatus: varchar("approval_status", { length: 20 }).notNull().default("pending"),
      // pending, approved, rejected
      approvedAt: timestamp("approved_at"),
      approvedBy: varchar("approved_by").references(() => users.id),
      // Super admin who approved
      rejectionReason: text("rejection_reason"),
      // Reason for rejection if status is rejected
      setupProgress: jsonb("setup_progress"),
      // Tracks completion of 8 setup steps: businessInfo, locationContact, services, staff, resources, bookingSettings, paymentSetup, media
      ownerId: varchar("owner_id").references(() => users.id),
      // Keep for backward compatibility
      orgId: varchar("org_id").references(() => organizations.id, { onDelete: "set null" }),
      // New organization link
      // Membership fields
      membershipEnabled: integer("membership_enabled").default(0),
      // 1 if salon offers memberships
      activeMembersCount: integer("active_members_count").default(0),
      // Current active members count
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      // Spatial index for geospatial queries (lat/lng proximity search)
      index("salons_lat_lng_idx").on(table.latitude, table.longitude),
      // Index for Google Place ID lookups
      index("salons_google_place_id_idx").on(table.googlePlaceId)
    ]);
    insertSalonSchema = createInsertSchema(salons).omit({
      id: true,
      createdAt: true,
      rating: true,
      reviewCount: true
    });
    salonReviews = pgTable("salon_reviews", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      customerId: varchar("customer_id").references(() => users.id, { onDelete: "set null" }),
      // Null for Google reviews
      bookingId: varchar("booking_id").references(() => bookings.id, { onDelete: "set null" }),
      // Null for Google reviews
      rating: integer("rating").notNull(),
      // 1-5 stars
      comment: text("comment"),
      source: varchar("source", { length: 20 }).notNull().default("salonhub"),
      // 'salonhub' or 'google'
      googleAuthorName: text("google_author_name"),
      // Author name from Google (for Google reviews)
      googleAuthorPhoto: text("google_author_photo"),
      // Author photo URL from Google
      googleReviewId: text("google_review_id"),
      // Unique Google review ID for deduplication
      isVerified: integer("is_verified").notNull().default(0),
      // 1 if review is from completed booking
      createdAt: timestamp("created_at").defaultNow(),
      googlePublishedAt: timestamp("google_published_at")
      // Original publish date from Google
    }, (table) => [
      // Index for fetching reviews by salon
      index("salon_reviews_salon_id_idx").on(table.salonId),
      // Index for filtering by source
      index("salon_reviews_source_idx").on(table.source),
      // Index for checking Google review duplicates
      index("salon_reviews_google_review_id_idx").on(table.googleReviewId),
      // Unique constraint to prevent duplicate Google reviews
      uniqueIndex("salon_reviews_google_unique").on(table.salonId, table.googleReviewId).where(sql`${table.source} = 'google' AND ${table.googleReviewId} IS NOT NULL`),
      // Constraint to validate rating range
      check("salon_reviews_rating_check", sql`${table.rating} >= 1 AND ${table.rating} <= 5`),
      // Constraint to validate source values
      check("salon_reviews_source_check", sql`${table.source} IN ('salonhub', 'google')`)
    ]);
    insertSalonReviewSchema = createInsertSchema(salonReviews).omit({
      id: true,
      createdAt: true
    });
    googlePlacesCache = pgTable("google_places_cache", {
      placeId: text("place_id").primaryKey(),
      // Google Place ID
      businessName: text("business_name").notNull(),
      address: text("address").notNull(),
      latitude: decimal("latitude", { precision: 9, scale: 6 }).notNull(),
      longitude: decimal("longitude", { precision: 9, scale: 6 }).notNull(),
      rating: decimal("rating", { precision: 3, scale: 2 }),
      reviewCount: integer("review_count").default(0),
      payload: jsonb("payload").notNull(),
      // Full API response for place details
      fetchedAt: timestamp("fetched_at").notNull().defaultNow(),
      expiresAt: timestamp("expires_at").notNull()
      // 30 days from fetchedAt
    }, (table) => [
      // Index for coordinate-based proximity search
      index("google_places_cache_lat_lng_idx").on(table.latitude, table.longitude),
      // Index for finding expired cache entries
      index("google_places_cache_expires_at_idx").on(table.expiresAt),
      // Index for business name search
      index("google_places_cache_business_name_idx").on(table.businessName)
    ]);
    insertGooglePlacesCacheSchema = createInsertSchema(googlePlacesCache).omit({
      fetchedAt: true
    });
    usersRelations = relations(users, ({ many }) => ({
      bookings: many(bookings),
      ownedSalons: many(salons),
      userRoles: many(userRoles),
      ownedOrganizations: many(organizations),
      orgMemberships: many(orgUsers),
      staffProfiles: many(staff),
      savedLocations: many(userSavedLocations)
    }));
    salonsRelations = relations(salons, ({ one, many }) => ({
      owner: one(users, {
        fields: [salons.ownerId],
        references: [users.id]
      }),
      organization: one(organizations, {
        fields: [salons.orgId],
        references: [organizations.id]
      }),
      services: many(services),
      servicePackages: many(servicePackages),
      bookings: many(bookings),
      staff: many(staff),
      availabilityPatterns: many(availabilityPatterns),
      timeSlots: many(timeSlots),
      reviews: many(salonReviews),
      membershipPlans: many(membershipPlans),
      customerMemberships: many(customerMemberships)
    }));
    services = pgTable("services", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      name: text("name").notNull(),
      description: text("description"),
      durationMinutes: integer("duration_minutes").notNull(),
      priceInPaisa: integer("price_in_paisa").notNull(),
      // Store price in smallest currency unit
      currency: varchar("currency", { length: 3 }).notNull().default("INR"),
      isActive: integer("is_active").notNull().default(1),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      // Auto-delete services when salon is deleted
      category: varchar("category", { length: 50 }),
      // Hair Cut & Style, Hair Color, Makeup, etc
      subCategory: varchar("sub_category", { length: 100 }),
      // Male, Female, or specific sub-category
      imageUrl: text("image_url"),
      // Visual image for the service
      // Gender-based service differentiation (Billu Partner App style)
      gender: varchar("gender", { length: 10 }),
      // 'male', 'female', 'unisex'
      // Service approval workflow
      approvalStatus: varchar("approval_status", { length: 20 }).notNull().default("approved"),
      // 'approved', 'pending', 'rejected'
      // Custom service flag
      isCustomService: integer("is_custom_service").notNull().default(0),
      // 1 = salon created custom service, 0 = platform template
      // Flexible pricing structure
      priceType: varchar("price_type", { length: 20 }).notNull().default("fixed"),
      // 'fixed', 'variable', 'starting_from'
      productCostPaisa: integer("product_cost_paisa"),
      // Additional product cost if applicable
      specialPricePaisa: integer("special_price_paisa"),
      // Promotional/special pricing
      // Service combination/package support
      isComboService: integer("is_combo_service").notNull().default(0),
      // 1 if this is a combination service
      comboServiceIds: text("combo_service_ids").array(),
      // Array of service IDs if combo
      // Service template reference
      templateId: varchar("template_id"),
      // Reference to service template if created from template
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      // Composite unique constraint to enable composite foreign keys
      unique("services_id_salon_id_unique").on(table.id, table.salonId),
      // Index for gender-based filtering
      index("services_gender_idx").on(table.gender),
      // Index for category filtering
      index("services_category_idx").on(table.category),
      // Index for approval status
      index("services_approval_status_idx").on(table.approvalStatus)
    ]);
    insertServiceSchema = createInsertSchema(services).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    serviceTemplates = pgTable("service_templates", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      name: text("name").notNull(),
      description: text("description"),
      category: varchar("category", { length: 50 }).notNull(),
      // Hair Cut & Style, Hair Color, Makeup, etc
      subCategory: varchar("sub_category", { length: 100 }),
      // Male, Female, or specific sub-category
      gender: varchar("gender", { length: 10 }).notNull(),
      // 'male', 'female', 'unisex'
      // Suggested pricing and duration (salons can override)
      suggestedDurationMinutes: integer("suggested_duration_minutes").notNull(),
      suggestedPriceInPaisa: integer("suggested_price_in_paisa").notNull(),
      currency: varchar("currency", { length: 3 }).notNull().default("INR"),
      // Template metadata
      isPopular: integer("is_popular").notNull().default(0),
      // 1 if this is a popular service
      sortOrder: integer("sort_order").notNull().default(0),
      // For display ordering
      imageUrl: text("image_url"),
      // Visual image for the template
      // Tags for better categorization
      tags: text("tags").array(),
      // e.g., ['beard', 'fade', 'modern'], ['bridal', 'party'], etc
      isActive: integer("is_active").notNull().default(1),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      // Index for category filtering
      index("service_templates_category_idx").on(table.category),
      // Index for gender filtering
      index("service_templates_gender_idx").on(table.gender),
      // Index for popular services
      index("service_templates_popular_idx").on(table.isPopular),
      // Unique constraint on name + category + gender to prevent duplicates
      unique("service_templates_name_category_gender_unique").on(table.name, table.category, table.gender)
    ]);
    insertServiceTemplateSchema = createInsertSchema(serviceTemplates).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    servicesRelations = relations(services, ({ one, many }) => ({
      salon: one(salons, {
        fields: [services.salonId],
        references: [salons.id]
      }),
      bookings: many(bookings),
      packageServices: many(packageServices)
    }));
    staff = pgTable("staff", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      userId: varchar("user_id").references(() => users.id, { onDelete: "cascade" }),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      orgId: varchar("org_id").references(() => organizations.id, { onDelete: "cascade" }),
      name: text("name").notNull(),
      email: text("email"),
      phone: text("phone"),
      roles: text("roles").array(),
      // Staff roles (Stylist, Colorist, Nail Technician, etc.) - supports multiple roles
      gender: varchar("gender", { length: 10 }),
      // Staff gender (Male/Female)
      photoUrl: text("photo_url"),
      // Staff photo URL
      specialties: text("specialties").array(),
      // Array of service categories they specialize in
      isActive: integer("is_active").notNull().default(1),
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      // Composite unique constraint to enable composite foreign keys
      unique("staff_id_salon_id_unique").on(table.id, table.salonId)
    ]);
    insertStaffSchema = createInsertSchema(staff).omit({
      id: true,
      createdAt: true
    });
    availabilityPatterns = pgTable("availability_patterns", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      staffId: varchar("staff_id").references(() => staff.id, { onDelete: "cascade" }),
      patternName: text("pattern_name").notNull(),
      // e.g., "Weekday Morning Hours"
      dayOfWeek: integer("day_of_week").notNull(),
      // 0=Sunday, 1=Monday, etc.
      startTime: text("start_time").notNull(),
      // "09:00"
      endTime: text("end_time").notNull(),
      // "17:00"
      slotDurationMinutes: integer("slot_duration_minutes").notNull().default(30),
      isActive: integer("is_active").notNull().default(1),
      effectiveFrom: timestamp("effective_from").defaultNow(),
      effectiveUntil: timestamp("effective_until"),
      // null means indefinite
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      // Composite unique constraint to enable composite foreign keys
      unique("availability_patterns_id_salon_id_unique").on(table.id, table.salonId),
      // Composite foreign key to enforce same-salon staff membership
      foreignKey({
        columns: [table.staffId, table.salonId],
        foreignColumns: [staff.id, staff.salonId],
        name: "availability_patterns_staff_salon_fk"
      })
    ]);
    insertAvailabilityPatternSchema = createInsertSchema(availabilityPatterns).omit({
      id: true,
      createdAt: true
    });
    timeSlots = pgTable("time_slots", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      patternId: varchar("pattern_id").references(() => availabilityPatterns.id, { onDelete: "cascade" }),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      staffId: varchar("staff_id").references(() => staff.id, { onDelete: "cascade" }),
      startDateTime: timestamp("start_date_time").notNull(),
      endDateTime: timestamp("end_date_time").notNull(),
      isBooked: integer("is_booked").notNull().default(0),
      isBlocked: integer("is_blocked").notNull().default(0),
      // Manually blocked by salon
      bookingId: varchar("booking_id"),
      // Will be defined after bookings table
      generatedAt: timestamp("generated_at").defaultNow()
    }, (table) => [
      // Composite unique constraint to enable composite foreign keys
      unique("time_slots_id_salon_id_unique").on(table.id, table.salonId),
      // Composite foreign keys to enforce same-salon membership
      foreignKey({
        columns: [table.patternId, table.salonId],
        foreignColumns: [availabilityPatterns.id, availabilityPatterns.salonId],
        name: "time_slots_pattern_salon_fk"
      }),
      foreignKey({
        columns: [table.staffId, table.salonId],
        foreignColumns: [staff.id, staff.salonId],
        name: "time_slots_staff_salon_fk"
      })
    ]);
    insertTimeSlotSchema = createInsertSchema(timeSlots).omit({
      id: true,
      generatedAt: true
    });
    servicePackages = pgTable("service_packages", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      name: text("name").notNull(),
      // e.g., "Bridal Package", "Spa Day Special"
      description: text("description"),
      // Package details
      totalDurationMinutes: integer("total_duration_minutes").notNull(),
      // Sum of all services or custom
      packagePriceInPaisa: integer("package_price_in_paisa").notNull(),
      // Discounted package price
      regularPriceInPaisa: integer("regular_price_in_paisa").notNull(),
      // Total if booked separately
      discountPercentage: integer("discount_percentage"),
      // Calculated discount percentage
      currency: varchar("currency", { length: 3 }).notNull().default("INR"),
      // Category and visual
      category: varchar("category", { length: 50 }),
      // 'bridal', 'spa_day', 'grooming', 'seasonal', 'combo'
      imageUrl: text("image_url"),
      // Package promotional image
      // Availability constraints
      maxBookingsPerDay: integer("max_bookings_per_day"),
      // Limit daily package bookings (null = unlimited)
      validFrom: timestamp("valid_from"),
      // Start of validity period
      validUntil: timestamp("valid_until"),
      // End of validity period
      minAdvanceBookingHours: integer("min_advance_booking_hours"),
      // Required advance notice
      availableDays: text("available_days").array(),
      // Days available (e.g., ['Mon', 'Tue', 'Wed'])
      availableTimeStart: text("available_time_start"),
      // Earliest booking time (HH:MM)
      availableTimeEnd: text("available_time_end"),
      // Latest booking time (HH:MM)
      // Targeting
      gender: varchar("gender", { length: 10 }),
      // 'male', 'female', 'unisex'
      // Display and metrics
      isFeatured: integer("is_featured").notNull().default(0),
      // Featured on homepage
      bookingCount: integer("booking_count").notNull().default(0),
      // Times booked
      sortOrder: integer("sort_order").notNull().default(0),
      // Display order
      isActive: integer("is_active").notNull().default(1),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      unique("service_packages_id_salon_id_unique").on(table.id, table.salonId),
      index("service_packages_category_idx").on(table.category),
      index("service_packages_featured_idx").on(table.isFeatured),
      index("service_packages_salon_active_idx").on(table.salonId, table.isActive)
    ]);
    SERVICE_PACKAGE_CATEGORIES = [
      { value: "bridal", label: "Bridal" },
      { value: "spa_day", label: "Spa Day" },
      { value: "grooming", label: "Grooming" },
      { value: "seasonal", label: "Seasonal Special" },
      { value: "combo", label: "Combo Deal" },
      { value: "party", label: "Party & Events" },
      { value: "wellness", label: "Wellness" }
    ];
    insertServicePackageSchema = createInsertSchema(servicePackages).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    packageServices = pgTable("package_services", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      packageId: varchar("package_id").notNull().references(() => servicePackages.id, { onDelete: "cascade" }),
      serviceId: varchar("service_id").notNull().references(() => services.id, { onDelete: "cascade" }),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      sequenceOrder: integer("sequence_order").notNull().default(1),
      // Order in which services are performed
      quantity: integer("quantity").notNull().default(1),
      // Quantity of this service in package (for same-service-twice scenario)
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      // Ensure same package doesn't have duplicate services (with same sequence)
      unique("package_services_package_service_seq_unique").on(table.packageId, table.serviceId, table.sequenceOrder),
      // Foreign key constraints to enforce same-salon membership
      foreignKey({
        columns: [table.packageId, table.salonId],
        foreignColumns: [servicePackages.id, servicePackages.salonId],
        name: "package_services_package_salon_fk"
      }),
      foreignKey({
        columns: [table.serviceId, table.salonId],
        foreignColumns: [services.id, services.salonId],
        name: "package_services_service_salon_fk"
      })
    ]);
    insertPackageServiceSchema = createInsertSchema(packageServices).omit({
      id: true,
      createdAt: true
    });
    packageBookings = pgTable("package_bookings", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      bookingId: varchar("booking_id").notNull().references(() => bookings.id, { onDelete: "cascade" }),
      packageId: varchar("package_id").notNull().references(() => servicePackages.id, { onDelete: "cascade" }),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      packagePriceAtBooking: integer("package_price_at_booking").notNull(),
      // Price when booked (snapshot)
      regularPriceAtBooking: integer("regular_price_at_booking").notNull(),
      // Regular price when booked (snapshot)
      savingsPaisa: integer("savings_paisa").notNull(),
      // Amount saved
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      unique("package_bookings_booking_unique").on(table.bookingId),
      index("package_bookings_package_idx").on(table.packageId),
      index("package_bookings_salon_idx").on(table.salonId)
    ]);
    insertPackageBookingSchema = createInsertSchema(packageBookings).omit({
      id: true,
      createdAt: true
    });
    servicePackagesRelations = relations(servicePackages, ({ one, many }) => ({
      salon: one(salons, {
        fields: [servicePackages.salonId],
        references: [salons.id]
      }),
      packageServices: many(packageServices),
      packageBookings: many(packageBookings)
    }));
    packageBookingsRelations = relations(packageBookings, ({ one }) => ({
      booking: one(bookings, {
        fields: [packageBookings.bookingId],
        references: [bookings.id]
      }),
      package: one(servicePackages, {
        fields: [packageBookings.packageId],
        references: [servicePackages.id]
      }),
      salon: one(salons, {
        fields: [packageBookings.salonId],
        references: [salons.id]
      })
    }));
    packageServicesRelations = relations(packageServices, ({ one }) => ({
      package: one(servicePackages, {
        fields: [packageServices.packageId],
        references: [servicePackages.id]
      }),
      service: one(services, {
        fields: [packageServices.serviceId],
        references: [services.id]
      }),
      salon: one(salons, {
        fields: [packageServices.salonId],
        references: [salons.id]
      })
    }));
    packageServiceEntrySchema = z.object({
      serviceId: z.string().uuid("Invalid service ID"),
      quantity: z.number().int().min(1, "Quantity must be at least 1").max(10, "Quantity cannot exceed 10").default(1)
    });
    baseServicePackageSchema = z.object({
      name: z.string().min(3, "Package name must be at least 3 characters").max(100),
      description: z.string().max(1e3).optional(),
      serviceIds: z.array(z.string().uuid()).optional(),
      services: z.array(packageServiceEntrySchema).optional(),
      packagePriceInPaisa: z.number().int().positive("Package price must be positive"),
      category: z.enum(["bridal", "spa_day", "grooming", "seasonal", "combo", "party", "wellness"]).optional(),
      imageUrl: z.string().url().optional().nullable(),
      gender: z.enum(["male", "female", "unisex"]).optional(),
      maxBookingsPerDay: z.number().int().positive().optional().nullable(),
      validFrom: z.string().datetime().optional().nullable(),
      validUntil: z.string().datetime().optional().nullable(),
      minAdvanceBookingHours: z.number().int().min(0).optional().nullable(),
      availableDays: z.array(z.enum(["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"])).optional().nullable(),
      availableTimeStart: z.string().regex(/^([01]?[0-9]|2[0-3]):[0-5][0-9]$/, "Invalid time format").optional().nullable(),
      availableTimeEnd: z.string().regex(/^([01]?[0-9]|2[0-3]):[0-5][0-9]$/, "Invalid time format").optional().nullable(),
      isFeatured: z.boolean().optional(),
      sortOrder: z.number().int().min(0).optional()
    });
    createServicePackageSchema = baseServicePackageSchema.refine(
      (data) => data.serviceIds && data.serviceIds.length >= 2 || data.services && data.services.length >= 1 && data.services.reduce((sum4, s) => sum4 + s.quantity, 0) >= 2,
      { message: "Package must contain at least 2 service instances (either 2 different services or same service with quantity >= 2)", path: ["services"] }
    );
    updateServicePackageSchema = baseServicePackageSchema.partial().extend({
      isActive: z.boolean().optional()
    });
    bookPackageSchema = z.object({
      packageId: z.string().uuid("Invalid package ID"),
      salonId: z.string().uuid("Invalid salon ID"),
      date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Invalid date format (YYYY-MM-DD)"),
      time: z.string().regex(/^([01]?[0-9]|2[0-3]):[0-5][0-9]$/, "Invalid time format"),
      staffId: z.string().uuid().optional(),
      notes: z.string().max(500).optional()
    });
    bookings = pgTable("bookings", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      // Auto-delete bookings when salon is deleted
      serviceId: varchar("service_id").notNull().references(() => services.id, { onDelete: "cascade" }),
      // Auto-delete bookings when service is deleted
      staffId: varchar("staff_id").references(() => staff.id, { onDelete: "set null" }),
      timeSlotId: varchar("time_slot_id").references(() => timeSlots.id, { onDelete: "restrict" }),
      userId: varchar("user_id").references(() => users.id, { onDelete: "set null" }),
      // Link to authenticated user (null for guests)
      packageId: varchar("package_id").references(() => servicePackages.id, { onDelete: "set null" }),
      // If this is a package booking
      customerName: text("customer_name").notNull(),
      customerEmail: text("customer_email").notNull(),
      customerPhone: text("customer_phone").notNull(),
      salonName: text("salon_name"),
      // Missing column that exists in database
      bookingDate: text("booking_date").notNull(),
      // Store as ISO date string
      bookingTime: text("booking_time").notNull(),
      status: varchar("status", { length: 20 }).notNull().default("pending"),
      // pending, confirmed, cancelled, completed
      totalAmountPaisa: integer("total_amount_paisa").notNull(),
      currency: varchar("currency", { length: 3 }).notNull().default("USD"),
      paymentMethod: varchar("payment_method", { length: 20 }).notNull().default("pay_now"),
      // pay_now, pay_at_salon
      notes: text("notes"),
      // Special requests or notes
      guestSessionId: text("guest_session_id"),
      // For tracking guest user sessions (null for authenticated users)
      isPackageBooking: integer("is_package_booking").notNull().default(0),
      // 1 if this is a package booking
      // Offer-related fields (snapshot at booking time for audit trail)
      offerId: varchar("offer_id").references(() => platformOffers.id, { onDelete: "set null" }),
      // Applied offer (if any)
      offerTitle: text("offer_title"),
      // Snapshot of offer title at booking time
      offerDiscountType: varchar("offer_discount_type", { length: 20 }),
      // Snapshot: 'percentage' | 'fixed'
      offerDiscountValue: integer("offer_discount_value"),
      // Snapshot: percentage or paisa amount
      originalAmountPaisa: integer("original_amount_paisa"),
      // Original price before discount
      discountAmountPaisa: integer("discount_amount_paisa"),
      // Discount applied in paisa
      finalAmountPaisa: integer("final_amount_paisa"),
      // Final amount after discount
      // Membership-related fields
      membershipId: varchar("membership_id"),
      // Link to customer_memberships (null for non-member bookings)
      membershipDiscountInPaisa: integer("membership_discount_in_paisa").default(0),
      // Discount from membership
      membershipCreditsUsedInPaisa: integer("membership_credits_used_in_paisa").default(0),
      // Credits used for this booking
      isMembershipService: integer("is_membership_service").default(0),
      // 1 if included in packaged membership
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      // Unique constraint to enable composite FKs from booking_services
      unique("bookings_id_salon_id_unique").on(table.id, table.salonId),
      // Composite foreign keys to enforce same-salon membership
      foreignKey({
        columns: [table.serviceId, table.salonId],
        foreignColumns: [services.id, services.salonId],
        name: "bookings_service_salon_fk"
      }),
      // Handle nullable staffId - only enforce if staffId is not null
      foreignKey({
        columns: [table.staffId, table.salonId],
        foreignColumns: [staff.id, staff.salonId],
        name: "bookings_staff_salon_fk"
      }),
      // Handle nullable timeSlotId - only enforce if timeSlotId is not null  
      foreignKey({
        columns: [table.timeSlotId, table.salonId],
        foreignColumns: [timeSlots.id, timeSlots.salonId],
        name: "bookings_timeslot_salon_fk"
      })
    ]);
    insertBookingSchema = createInsertSchema(bookings).omit({
      id: true,
      createdAt: true
    });
    bookingServices = pgTable("booking_services", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      bookingId: varchar("booking_id").notNull(),
      serviceId: varchar("service_id").notNull(),
      salonId: varchar("salon_id").notNull(),
      priceInPaisa: integer("price_in_paisa").notNull(),
      // Captured at time of booking
      durationMinutes: integer("duration_minutes").notNull(),
      // Captured at time of booking
      sequence: integer("sequence").notNull(),
      // Order of services in the booking (required, no default)
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      // Composite foreign keys to enforce same-salon membership
      foreignKey({
        columns: [table.bookingId, table.salonId],
        foreignColumns: [bookings.id, bookings.salonId],
        name: "booking_services_booking_salon_fk"
      }).onDelete("cascade"),
      // Auto-delete when booking is deleted
      foreignKey({
        columns: [table.serviceId, table.salonId],
        foreignColumns: [services.id, services.salonId],
        name: "booking_services_service_salon_fk"
      }).onDelete("cascade"),
      // Auto-delete when service is deleted
      // Unique constraint: booking can't have duplicate sequence numbers
      unique().on(table.bookingId, table.sequence)
    ]);
    insertBookingServiceSchema = createInsertSchema(bookingServices).omit({
      id: true,
      createdAt: true
    });
    bookingServicesRelations = relations(bookingServices, ({ one }) => ({
      booking: one(bookings, {
        fields: [bookingServices.bookingId],
        references: [bookings.id]
      }),
      service: one(services, {
        fields: [bookingServices.serviceId],
        references: [services.id]
      }),
      salon: one(salons, {
        fields: [bookingServices.salonId],
        references: [salons.id]
      })
    }));
    bookingsRelations = relations(bookings, ({ one, many }) => ({
      salon: one(salons, {
        fields: [bookings.salonId],
        references: [salons.id]
      }),
      service: one(services, {
        fields: [bookings.serviceId],
        references: [services.id]
      }),
      staff: one(staff, {
        fields: [bookings.staffId],
        references: [staff.id]
      }),
      timeSlot: one(timeSlots, {
        fields: [bookings.timeSlotId],
        references: [timeSlots.id]
      }),
      payment: one(payments, {
        fields: [bookings.id],
        references: [payments.bookingId]
      }),
      bookingServices: many(bookingServices)
    }));
    payments = pgTable("payments", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      // Either bookingId (for service bookings) OR productOrderId (for product orders) must be set
      bookingId: varchar("booking_id").references(() => bookings.id, { onDelete: "cascade" }),
      productOrderId: varchar("product_order_id").references(() => productOrders.id, { onDelete: "cascade" }),
      userId: varchar("user_id").references(() => users.id, { onDelete: "set null" }),
      paymentMethod: varchar("payment_method", { length: 50 }),
      // online, cod, upi, wallet
      razorpayOrderId: text("razorpay_order_id"),
      razorpayPaymentId: text("razorpay_payment_id"),
      razorpaySignature: text("razorpay_signature"),
      amountPaisa: integer("amount_paisa").notNull(),
      currency: varchar("currency", { length: 3 }).notNull().default("INR"),
      status: varchar("status", { length: 20 }).notNull().default("pending"),
      // pending, completed, failed
      createdAt: timestamp("created_at").defaultNow(),
      completedAt: timestamp("completed_at")
    });
    insertPaymentSchema = createInsertSchema(payments).omit({
      id: true,
      createdAt: true,
      completedAt: true
    });
    bookingCancellations = pgTable("booking_cancellations", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      bookingId: varchar("booking_id").notNull().unique().references(() => bookings.id, { onDelete: "cascade" }),
      userId: varchar("user_id").references(() => users.id, { onDelete: "set null" }),
      cancelledBy: varchar("cancelled_by", { length: 20 }).notNull(),
      // 'customer', 'salon', 'system'
      reasonCode: varchar("reason_code", { length: 50 }).notNull(),
      reasonCategory: varchar("reason_category", { length: 30 }).notNull(),
      additionalComments: text("additional_comments"),
      wasRescheduled: integer("was_rescheduled").notNull().default(0),
      rescheduledBookingId: varchar("rescheduled_booking_id").references(() => bookings.id, { onDelete: "set null" }),
      refundRequested: integer("refund_requested").notNull().default(0),
      refundAmountPaisa: integer("refund_amount_paisa"),
      cancellationFeePaisa: integer("cancellation_fee_paisa"),
      hoursBeforeAppointment: integer("hours_before_appointment"),
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("booking_cancellations_booking_id_idx").on(table.bookingId),
      index("booking_cancellations_user_id_idx").on(table.userId),
      index("booking_cancellations_reason_code_idx").on(table.reasonCode),
      index("booking_cancellations_created_at_idx").on(table.createdAt)
    ]);
    insertBookingCancellationSchema = createInsertSchema(bookingCancellations).omit({
      id: true,
      createdAt: true
    });
    bookingCancellationsRelations = relations(bookingCancellations, ({ one }) => ({
      booking: one(bookings, {
        fields: [bookingCancellations.bookingId],
        references: [bookings.id]
      }),
      user: one(users, {
        fields: [bookingCancellations.userId],
        references: [users.id]
      }),
      rescheduledBooking: one(bookings, {
        fields: [bookingCancellations.rescheduledBookingId],
        references: [bookings.id]
      })
    }));
    CANCELLATION_REASON_CODES = {
      // Customer reasons
      schedule_conflict: { category: "scheduling", label: "I have a schedule conflict" },
      found_better_price: { category: "pricing", label: "Found a better price elsewhere" },
      service_not_needed: { category: "changed_mind", label: "No longer need the service" },
      health_issue: { category: "emergency", label: "Feeling unwell / health issue" },
      family_emergency: { category: "emergency", label: "Family emergency" },
      travel_plans: { category: "scheduling", label: "Travel plans changed" },
      staff_unavailable: { category: "salon_issue", label: "Preferred staff not available" },
      long_wait_time: { category: "salon_issue", label: "Expected long wait time" },
      poor_reviews: { category: "trust", label: "Read negative reviews" },
      booked_by_mistake: { category: "user_error", label: "Booked by mistake" },
      weather_conditions: { category: "external", label: "Bad weather conditions" },
      transportation_issue: { category: "external", label: "Transportation problems" },
      financial_reason: { category: "pricing", label: "Financial constraints" },
      other: { category: "other", label: "Other reason" },
      // Salon reasons
      staff_sick: { category: "staff", label: "Staff member is sick" },
      staff_emergency: { category: "staff", label: "Staff emergency" },
      equipment_issue: { category: "operations", label: "Equipment malfunction" },
      double_booking: { category: "operations", label: "Scheduling error - double booked" },
      salon_closed: { category: "operations", label: "Salon closed unexpectedly" },
      customer_no_show_history: { category: "policy", label: "Customer has no-show history" },
      // System reasons
      payment_failed: { category: "payment", label: "Payment authorization failed" },
      payment_timeout: { category: "payment", label: "Payment not completed in time" },
      slot_no_longer_available: { category: "system", label: "Time slot became unavailable" },
      service_discontinued: { category: "system", label: "Service no longer offered" }
    };
    lateArrivalNotifications = pgTable("late_arrival_notifications", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      bookingId: varchar("booking_id").notNull().references(() => bookings.id, { onDelete: "cascade" }),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      userId: varchar("user_id").references(() => users.id, { onDelete: "set null" }),
      // Delay information
      estimatedDelayMinutes: integer("estimated_delay_minutes").notNull(),
      // 5, 10, 15, 20, 30, 45, 60
      originalBookingTime: text("original_booking_time").notNull(),
      // HH:MM format
      estimatedArrivalTime: text("estimated_arrival_time").notNull(),
      // HH:MM format (calculated)
      // Customer message
      customerMessage: text("customer_message"),
      // Optional message from customer
      // Notification delivery status
      salonNotified: integer("salon_notified").notNull().default(0),
      // 0 = pending, 1 = sent
      salonNotifiedAt: timestamp("salon_notified_at"),
      notificationChannel: varchar("notification_channel", { length: 20 }),
      // 'sms', 'whatsapp', 'push', 'in_app'
      notificationMessageSid: varchar("notification_message_sid"),
      // Twilio message SID for tracking
      // Salon acknowledgment
      salonAcknowledged: integer("salon_acknowledged").notNull().default(0),
      salonAcknowledgedAt: timestamp("salon_acknowledged_at"),
      salonAcknowledgedBy: varchar("salon_acknowledged_by").references(() => users.id, { onDelete: "set null" }),
      salonResponse: varchar("salon_response", { length: 50 }),
      // 'acknowledged', 'rescheduled', 'cancelled'
      salonResponseNote: text("salon_response_note"),
      // Timestamps
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("late_arrival_notifications_booking_id_idx").on(table.bookingId),
      index("late_arrival_notifications_salon_id_idx").on(table.salonId),
      index("late_arrival_notifications_user_id_idx").on(table.userId),
      index("late_arrival_notifications_created_at_idx").on(table.createdAt)
    ]);
    insertLateArrivalNotificationSchema = createInsertSchema(lateArrivalNotifications).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    lateArrivalNotificationsRelations = relations(lateArrivalNotifications, ({ one }) => ({
      booking: one(bookings, {
        fields: [lateArrivalNotifications.bookingId],
        references: [bookings.id]
      }),
      salon: one(salons, {
        fields: [lateArrivalNotifications.salonId],
        references: [salons.id]
      }),
      user: one(users, {
        fields: [lateArrivalNotifications.userId],
        references: [users.id]
      }),
      acknowledgedBy: one(users, {
        fields: [lateArrivalNotifications.salonAcknowledgedBy],
        references: [users.id]
      })
    }));
    LATE_ARRIVAL_DELAY_OPTIONS = [
      { value: 5, label: "5 minutes" },
      { value: 10, label: "10 minutes" },
      { value: 15, label: "15 minutes" },
      { value: 20, label: "20 minutes" },
      { value: 30, label: "30 minutes" },
      { value: 45, label: "45 minutes" },
      { value: 60, label: "1 hour" }
    ];
    createLateArrivalNotificationSchema = z.object({
      bookingId: z.string().min(1, "Booking ID is required"),
      estimatedDelayMinutes: z.number().int().min(5).max(60),
      customerMessage: z.string().max(500).optional()
    });
    acknowledgeLateArrivalSchema = z.object({
      response: z.enum(["acknowledged", "rescheduled", "cancelled"]),
      responseNote: z.string().max(500).optional()
    });
    userRolesRelations = relations(userRoles, ({ one }) => ({
      user: one(users, {
        fields: [userRoles.userId],
        references: [users.id]
      }),
      role: one(roles, {
        fields: [userRoles.roleId],
        references: [roles.id]
      })
    }));
    organizationsRelations = relations(organizations, ({ one, many }) => ({
      owner: one(users, {
        fields: [organizations.ownerUserId],
        references: [users.id]
      }),
      salons: many(salons),
      members: many(orgUsers)
    }));
    orgUsersRelations = relations(orgUsers, ({ one }) => ({
      organization: one(organizations, {
        fields: [orgUsers.orgId],
        references: [organizations.id]
      }),
      user: one(users, {
        fields: [orgUsers.userId],
        references: [users.id]
      })
    }));
    paymentsRelations = relations(payments, ({ one }) => ({
      booking: one(bookings, {
        fields: [payments.bookingId],
        references: [bookings.id]
      })
    }));
    customerProfiles = pgTable("customer_profiles", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      customerEmail: varchar("customer_email").notNull(),
      customerName: varchar("customer_name").notNull(),
      customerPhone: varchar("customer_phone"),
      notes: text("notes"),
      // Customer-specific notes
      preferences: jsonb("preferences"),
      // Customer preferences as JSON
      isVip: integer("is_vip").notNull().default(0),
      tags: text("tags").array(),
      // Array of tags for customer categorization
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      // Unique constraint for customer per salon
      unique("customer_profiles_salon_email_unique").on(table.salonId, table.customerEmail)
    ]);
    insertCustomerProfileSchema = createInsertSchema(customerProfiles).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    customerProfilesRelations = relations(customerProfiles, ({ one }) => ({
      salon: one(salons, {
        fields: [customerProfiles.salonId],
        references: [salons.id]
      })
    }));
    createPaymentOrderSchema = z.object({
      salonId: z.string().uuid(),
      serviceId: z.string().uuid(),
      booking: z.object({
        date: z.string().min(1),
        time: z.string().min(1),
        customer: z.object({
          name: z.string().optional(),
          // Allow empty name for guest bookings
          email: z.string().email(),
          phone: z.string().optional()
          // Allow empty phone for guest bookings
        }),
        notes: z.string().optional(),
        guestSessionId: z.string().optional(),
        // For guest session tracking
        paymentMethod: z.enum(["pay_now", "pay_at_salon"]).default("pay_now"),
        // Payment method selection
        offerId: z.string().uuid().optional()
        // Optional offer to apply
      })
    });
    createSalonSchema = z.object({
      name: z.string().min(1),
      description: z.string().optional(),
      address: z.string().min(1),
      city: z.string().min(1),
      state: z.string().min(1),
      zipCode: z.string().min(1),
      phone: z.string().min(1),
      email: z.string().email(),
      website: z.string().url().optional(),
      category: z.string().min(1),
      priceRange: z.enum(["$", "$$", "$$$", "$$$$"]),
      imageUrl: z.string().url().optional(),
      openTime: z.string().optional(),
      closeTime: z.string().optional()
    });
    verifyPaymentSchema = z.object({
      razorpay_order_id: z.string(),
      razorpay_payment_id: z.string(),
      razorpay_signature: z.string()
    });
    bookingStatusEnum = z.enum(["pending", "confirmed", "arrived", "cancelled", "completed", "no_show"]);
    BOOKING_STATUSES = {
      PENDING: "pending",
      // Initial state when booking is created
      CONFIRMED: "confirmed",
      // Booking is confirmed but customer hasn't arrived
      ARRIVED: "arrived",
      // Customer has checked in, job card created
      COMPLETED: "completed",
      // Service done and booking closed
      CANCELLED: "cancelled",
      // Booking was cancelled
      NO_SHOW: "no_show"
      // Customer didn't show up
    };
    updateBookingSchema = z.object({
      status: bookingStatusEnum,
      notes: z.string().max(500, "Notes cannot exceed 500 characters").optional()
    });
    bulkUpdateBookingSchema = z.object({
      bookingIds: z.array(z.string().uuid()).min(1, "At least one booking ID is required"),
      status: bookingStatusEnum
    });
    rescheduleBookingInputSchema = z.object({
      bookingDate: z.string().min(1, "Booking date is required"),
      bookingTime: z.string().min(1, "Booking time is required"),
      staffId: z.string().uuid().optional()
    });
    createPackageSchema = z.object({
      name: z.string().min(1, "Package name is required").max(100, "Package name must be under 100 characters"),
      description: z.string().max(500, "Description must be under 500 characters").optional(),
      serviceIds: z.array(z.string().uuid()).min(2, "Package must include at least 2 services").max(10, "Package cannot have more than 10 services"),
      discountedPricePaisa: z.number().int("Price must be a whole number").positive("Price must be greater than 0").max(1e7, "Price cannot exceed \u20B9100,000")
      // Max 1 lakh
    });
    updatePackageSchema = z.object({
      name: z.string().min(1, "Package name is required").max(100, "Package name must be under 100 characters").optional(),
      description: z.string().max(500, "Description must be under 500 characters").optional(),
      serviceIds: z.array(z.string().uuid()).min(2, "Package must include at least 2 services").max(10, "Package cannot have more than 10 services").optional(),
      discountedPricePaisa: z.number().int("Price must be a whole number").positive("Price must be greater than 0").max(1e7, "Price cannot exceed \u20B9100,000").optional()
    });
    validateStatusTransition = (currentStatus, newStatus) => {
      const validTransitions = {
        pending: ["confirmed", "cancelled"],
        confirmed: ["arrived", "cancelled", "no_show"],
        // Must check in (arrived) before completing
        arrived: ["completed", "cancelled", "no_show"],
        // Customer has arrived and job card created
        completed: [],
        // Cannot transition from completed
        cancelled: [],
        // Cannot transition from cancelled
        no_show: []
        // Cannot transition from no_show
      };
      if (!validTransitions[currentStatus]) {
        return { isValid: false, error: `Invalid current status: ${currentStatus}` };
      }
      if (!validTransitions[currentStatus].includes(newStatus)) {
        return {
          isValid: false,
          error: `Invalid status transition: ${currentStatus} \u2192 ${newStatus}. Valid transitions are: ${validTransitions[currentStatus].join(", ") || "none"}`
        };
      }
      return { isValid: true };
    };
    staffRelations = relations(staff, ({ one, many }) => ({
      user: one(users, {
        fields: [staff.userId],
        references: [users.id]
      }),
      salon: one(salons, {
        fields: [staff.salonId],
        references: [salons.id]
      }),
      organization: one(organizations, {
        fields: [staff.orgId],
        references: [organizations.id]
      }),
      availabilityPatterns: many(availabilityPatterns),
      timeSlots: many(timeSlots)
    }));
    availabilityPatternsRelations = relations(availabilityPatterns, ({ one, many }) => ({
      salon: one(salons, {
        fields: [availabilityPatterns.salonId],
        references: [salons.id]
      }),
      staff: one(staff, {
        fields: [availabilityPatterns.staffId],
        references: [staff.id]
      }),
      timeSlots: many(timeSlots)
    }));
    timeSlotsRelations = relations(timeSlots, ({ one }) => ({
      pattern: one(availabilityPatterns, {
        fields: [timeSlots.patternId],
        references: [availabilityPatterns.id]
      }),
      salon: one(salons, {
        fields: [timeSlots.salonId],
        references: [salons.id]
      }),
      staff: one(staff, {
        fields: [timeSlots.staffId],
        references: [staff.id]
      }),
      booking: one(bookings, {
        fields: [timeSlots.bookingId],
        references: [bookings.id]
      })
    }));
    bookingSettings = pgTable("booking_settings", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }).unique(),
      timezone: varchar("timezone", { length: 50 }).notNull().default("America/New_York"),
      leadTimeMinutes: integer("lead_time_minutes").notNull().default(60),
      cancelWindowMinutes: integer("cancel_window_minutes").notNull().default(1440),
      bufferMinutes: integer("buffer_minutes").notNull().default(15),
      depositPercentage: integer("deposit_percentage").notNull().default(0),
      depositType: varchar("deposit_type", { length: 20 }).default("percentage"),
      depositAmountFixed: integer("deposit_amount_fixed").default(0),
      autoConfirm: integer("auto_confirm").notNull().default(1),
      allowCancellation: integer("allow_cancellation").notNull().default(1),
      allowRescheduling: integer("allow_reschedule").notNull().default(1),
      maxAdvanceBookingDays: integer("max_advance_booking_days").notNull().default(90),
      maxConcurrentBookings: integer("max_concurrent_bookings").default(1),
      allowGroupBookings: integer("allow_group_bookings").default(0),
      maxGroupSize: integer("max_group_size").default(1),
      sendAutomatedReminders: integer("send_automated_reminders").default(1),
      reminderHoursBefore: integer("reminder_hours_before").default(24),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      // Removed redundant index since unique constraint already creates one
      check("lead_time_positive", sql`lead_time_minutes > 0`),
      check("cancel_window_positive", sql`cancel_window_minutes > 0`),
      check("buffer_minutes_valid", sql`buffer_minutes >= 0`),
      check("deposit_percentage_valid", sql`deposit_percentage >= 0 AND deposit_percentage <= 100`),
      check("deposit_type_valid", sql`deposit_type IN ('fixed', 'percentage')`),
      check("deposit_amount_fixed_valid", sql`deposit_amount_fixed >= 0`),
      check("auto_confirm_valid", sql`auto_confirm IN (0,1)`),
      check("allow_cancellation_valid", sql`allow_cancellation IN (0,1)`),
      check("allow_reschedule_valid", sql`allow_reschedule IN (0,1)`),
      check("max_advance_days_positive", sql`max_advance_booking_days > 0`),
      check("max_concurrent_positive", sql`max_concurrent_bookings >= 1`),
      check("allow_group_bookings_valid", sql`allow_group_bookings IN (0,1)`),
      check("max_group_size_valid", sql`max_group_size >= 1 AND max_group_size <= 20`),
      check("send_reminders_valid", sql`send_automated_reminders IN (0,1)`),
      check("reminder_hours_valid", sql`reminder_hours_before >= 1`)
    ]);
    staffServices = pgTable("staff_services", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      staffId: varchar("staff_id").notNull().references(() => staff.id, { onDelete: "cascade" }),
      serviceId: varchar("service_id").notNull().references(() => services.id, { onDelete: "cascade" }),
      priceInPaisa: integer("price_in_paisa"),
      durationMinutes: integer("duration_minutes"),
      isActive: integer("is_active").notNull().default(1),
      commissionPercentage: integer("commission_percentage").default(0),
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("staff_service_salon_idx").on(table.salonId),
      index("staff_service_idx").on(table.staffId, table.serviceId),
      index("staff_service_service_idx").on(table.serviceId),
      unique("staff_services_salon_staff_service_unique").on(table.salonId, table.staffId, table.serviceId),
      check("price_positive", sql`price_in_paisa IS NULL OR price_in_paisa > 0`),
      check("duration_positive", sql`duration_minutes IS NULL OR duration_minutes > 0`),
      check("is_active_valid", sql`is_active IN (0,1)`),
      check("commission_valid", sql`commission_percentage >= 0 AND commission_percentage <= 100`),
      // Composite foreign keys to enforce same-salon membership
      foreignKey({
        columns: [table.staffId, table.salonId],
        foreignColumns: [staff.id, staff.salonId],
        name: "staff_services_staff_salon_fk"
      }),
      foreignKey({
        columns: [table.serviceId, table.salonId],
        foreignColumns: [services.id, services.salonId],
        name: "staff_services_service_salon_fk"
      })
    ]);
    resources = pgTable("resources", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      name: text("name").notNull(),
      resourceType: varchar("resource_type", { length: 50 }).notNull(),
      capacity: integer("capacity").notNull().default(1),
      description: text("description"),
      isActive: integer("is_active").notNull().default(1),
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("resources_salon_idx").on(table.salonId),
      // Composite unique constraint to enable composite foreign keys
      unique("resources_id_salon_id_unique").on(table.id, table.salonId),
      check("capacity_positive", sql`capacity > 0`),
      check("is_active_valid", sql`is_active IN (0,1)`),
      check("resource_type_valid", sql`resource_type IN ('chair', 'room', 'equipment', 'station', 'bed')`)
    ]);
    serviceResources = pgTable("service_resources", {
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      serviceId: varchar("service_id").notNull().references(() => services.id, { onDelete: "cascade" }),
      resourceId: varchar("resource_id").notNull().references(() => resources.id, { onDelete: "cascade" }),
      quantityRequired: integer("quantity_required").notNull().default(1)
    }, (table) => [
      index("service_resources_salon_idx").on(table.salonId),
      index("service_resources_resource_idx").on(table.resourceId),
      { pk: { columns: [table.salonId, table.serviceId, table.resourceId], primaryKey: true } },
      check("quantity_positive", sql`quantity_required > 0`),
      // Composite foreign keys to enforce same-salon membership
      foreignKey({
        columns: [table.serviceId, table.salonId],
        foreignColumns: [services.id, services.salonId],
        name: "service_resources_service_salon_fk"
      }),
      foreignKey({
        columns: [table.resourceId, table.salonId],
        foreignColumns: [resources.id, resources.salonId],
        name: "service_resources_resource_salon_fk"
      })
    ]);
    mediaAssets = pgTable("media_assets", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      assetType: varchar("asset_type", { length: 20 }).notNull(),
      url: text("url").notNull(),
      altText: text("alt_text"),
      displayOrder: integer("display_order").default(0),
      isPrimary: integer("is_primary").notNull().default(0),
      isActive: integer("is_active").notNull().default(1),
      uploadedAt: timestamp("uploaded_at").defaultNow()
    }, (table) => [
      index("media_assets_salon_idx").on(table.salonId),
      index("media_assets_salon_type_order_idx").on(table.salonId, table.assetType, table.displayOrder),
      // Only one primary media asset per salon
      uniqueIndex("media_assets_primary_unique").on(table.salonId).where(sql`is_primary = 1`),
      check("is_primary_valid", sql`is_primary IN (0,1)`),
      check("is_active_valid", sql`is_active IN (0,1)`),
      check("asset_type_valid", sql`asset_type IN ('logo', 'cover', 'gallery', 'video')`)
    ]);
    taxRates = pgTable("tax_rates", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      name: varchar("name", { length: 100 }).notNull(),
      rateBasisPoints: integer("rate_basis_points").notNull(),
      isDefault: integer("is_default").notNull().default(0),
      isActive: integer("is_active").notNull().default(1),
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("tax_rates_salon_idx").on(table.salonId),
      unique("tax_rates_salon_name_unique").on(table.salonId, table.name),
      // Only one default tax rate per salon - use uniqueIndex for partial constraints
      uniqueIndex("tax_rates_default_unique").on(table.salonId).where(sql`is_default = 1`),
      check("rate_valid", sql`rate_basis_points >= 0 AND rate_basis_points <= 10000`),
      // Max 100%
      check("is_default_valid", sql`is_default IN (0,1)`),
      check("is_active_valid", sql`is_active IN (0,1)`)
    ]);
    payoutAccounts = pgTable("payout_accounts", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      provider: varchar("provider", { length: 20 }).notNull(),
      onboardingStatus: varchar("onboarding_status", { length: 20 }).notNull().default("pending"),
      accountId: text("account_id"),
      requirementsMissing: jsonb("requirements_missing"),
      isDefault: integer("is_default").notNull().default(0),
      isActive: integer("is_active").notNull().default(1),
      lastUpdated: timestamp("last_updated").defaultNow(),
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("payout_accounts_salon_idx").on(table.salonId),
      unique("payout_accounts_salon_provider_unique").on(table.salonId, table.provider),
      // Only one default payout account per salon
      uniqueIndex("payout_accounts_default_unique").on(table.salonId).where(sql`is_default = 1`),
      check("provider_valid", sql`provider IN ('razorpay', 'stripe')`),
      check("onboarding_status_valid", sql`onboarding_status IN ('pending', 'incomplete', 'approved', 'rejected')`),
      check("is_default_valid", sql`is_default IN (0,1)`),
      check("is_active_valid", sql`is_active IN (0,1)`)
    ]);
    publishState = pgTable("publish_state", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }).unique(),
      canAcceptBookings: integer("can_accept_bookings").notNull().default(0),
      isPublished: integer("is_published").notNull().default(0),
      onboardingStep: integer("onboarding_step").notNull().default(1),
      completedSteps: jsonb("completed_steps").default(sql`'[]'::jsonb`),
      checklist: jsonb("checklist").default(sql`'{}'::jsonb`),
      publishedAt: timestamp("published_at"),
      lastUpdated: timestamp("last_updated").defaultNow()
    }, (table) => [
      // Removed redundant index since unique constraint already creates one
      check("can_accept_bookings_valid", sql`can_accept_bookings IN (0,1)`),
      check("is_published_valid", sql`is_published IN (0,1)`),
      check("onboarding_step_valid", sql`onboarding_step >= 1`)
    ]);
    insertBookingSettingsSchema = createInsertSchema(bookingSettings).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertStaffServiceSchema = createInsertSchema(staffServices).omit({
      id: true,
      createdAt: true
    });
    insertResourceSchema = createInsertSchema(resources).omit({
      id: true,
      createdAt: true
    });
    insertServiceResourceSchema = createInsertSchema(serviceResources);
    insertMediaAssetSchema = createInsertSchema(mediaAssets).omit({
      id: true,
      uploadedAt: true
    });
    insertTaxRateSchema = createInsertSchema(taxRates).omit({
      id: true,
      createdAt: true
    });
    insertPayoutAccountSchema = createInsertSchema(payoutAccounts).omit({
      id: true,
      createdAt: true,
      lastUpdated: true
    });
    insertPublishStateSchema = createInsertSchema(publishState).omit({
      id: true,
      lastUpdated: true
    }).extend({
      // Allow publishedAt to accept ISO string dates from frontend
      publishedAt: z.union([z.date(), z.string().datetime()]).optional().transform((val) => {
        if (typeof val === "string") {
          return new Date(val);
        }
        return val;
      })
    });
    updateCustomerNotesSchema = z.object({
      notes: z.string().max(1e3, "Notes cannot exceed 1000 characters").optional(),
      preferences: z.record(z.any()).optional(),
      // JSON object for preferences
      isVip: z.boolean().optional(),
      tags: z.array(z.string()).optional()
    });
    updateCustomerProfileSchema = z.object({
      firstName: z.string().min(1, "First name is required").max(50, "First name cannot exceed 50 characters").optional(),
      lastName: z.string().min(1, "Last name is required").max(50, "Last name cannot exceed 50 characters").optional(),
      phone: z.string().max(20, "Phone number cannot exceed 20 characters").optional().nullable(),
      preferences: z.object({
        emailNotifications: z.boolean().default(true),
        smsNotifications: z.boolean().default(false),
        marketingComms: z.boolean().default(false),
        preferredTimes: z.array(z.enum(["morning", "afternoon", "evening"])).default([]),
        preferredDays: z.array(z.enum(["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"])).default([]),
        preferredCommunicationMethod: z.enum(["email", "sms", "both"]).default("email")
      }).optional()
    });
    expenseCategories = pgTable("expense_categories", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      name: varchar("name", { length: 100 }).notNull(),
      description: text("description"),
      color: varchar("color", { length: 7 }).default("#6366f1"),
      // Hex color for UI
      isDefault: integer("is_default").notNull().default(0),
      // System default categories
      isActive: integer("is_active").notNull().default(1),
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("expense_categories_salon_idx").on(table.salonId),
      unique("expense_categories_salon_name_unique").on(table.salonId, table.name),
      check("is_default_valid", sql`is_default IN (0,1)`),
      check("is_active_valid", sql`is_active IN (0,1)`)
    ]);
    expenses = pgTable("expenses", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      categoryId: varchar("category_id").notNull().references(() => expenseCategories.id, { onDelete: "restrict" }),
      title: varchar("title", { length: 200 }).notNull(),
      description: text("description"),
      amountPaisa: integer("amount_paisa").notNull(),
      currency: varchar("currency", { length: 3 }).notNull().default("USD"),
      expenseDate: timestamp("expense_date").notNull(),
      receiptUrl: text("receipt_url"),
      // URL to uploaded receipt
      receiptNumber: varchar("receipt_number", { length: 100 }),
      vendor: varchar("vendor", { length: 200 }),
      isRecurring: integer("is_recurring").notNull().default(0),
      recurringFrequency: varchar("recurring_frequency", { length: 20 }),
      // monthly, quarterly, yearly
      taxDeductible: integer("tax_deductible").notNull().default(0),
      taxAmountPaisa: integer("tax_amount_paisa").default(0),
      status: varchar("status", { length: 20 }).notNull().default("pending"),
      // pending, approved, rejected
      approvedBy: varchar("approved_by").references(() => users.id),
      approvedAt: timestamp("approved_at"),
      tags: jsonb("tags").default(sql`'[]'::jsonb`),
      metadata: jsonb("metadata").default(sql`'{}'::jsonb`),
      createdBy: varchar("created_by").notNull().references(() => users.id),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("expenses_salon_idx").on(table.salonId),
      index("expenses_category_idx").on(table.categoryId),
      index("expenses_date_idx").on(table.expenseDate),
      index("expenses_status_idx").on(table.status),
      check("is_recurring_valid", sql`is_recurring IN (0,1)`),
      check("tax_deductible_valid", sql`tax_deductible IN (0,1)`),
      check("status_valid", sql`status IN ('pending', 'approved', 'rejected')`),
      check("recurring_frequency_valid", sql`recurring_frequency IS NULL OR recurring_frequency IN ('monthly', 'quarterly', 'yearly')`)
    ]);
    commissionRates = pgTable("commission_rates", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      staffId: varchar("staff_id").references(() => staff.id, { onDelete: "cascade" }),
      serviceId: varchar("service_id").references(() => services.id, { onDelete: "cascade" }),
      productId: varchar("product_id").references(() => products.id, { onDelete: "cascade" }),
      appliesTo: varchar("applies_to", { length: 20 }).notNull().default("service"),
      rateType: varchar("rate_type", { length: 20 }).notNull(),
      rateValue: decimal("rate_value", { precision: 10, scale: 4 }).notNull(),
      minAmount: integer("min_amount_paisa"),
      maxAmount: integer("max_amount_paisa"),
      isDefault: integer("is_default").notNull().default(0),
      isActive: integer("is_active").notNull().default(1),
      effectiveFrom: timestamp("effective_from").notNull().defaultNow(),
      effectiveTo: timestamp("effective_to"),
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("commission_rates_salon_idx").on(table.salonId),
      index("commission_rates_staff_idx").on(table.staffId),
      index("commission_rates_service_idx").on(table.serviceId),
      index("commission_rates_product_idx").on(table.productId),
      index("commission_rates_applies_to_idx").on(table.appliesTo),
      index("commission_rates_effective_idx").on(table.effectiveFrom, table.effectiveTo),
      check("rate_type_valid", sql`rate_type IN ('percentage', 'fixed_amount', 'tiered')`),
      check("is_default_valid", sql`is_default IN (0,1)`),
      check("is_active_valid", sql`is_active IN (0,1)`),
      check("applies_to_valid", sql`applies_to IN ('service', 'product')`)
    ]);
    commissions = pgTable("commissions", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      staffId: varchar("staff_id").notNull().references(() => staff.id, { onDelete: "cascade" }),
      bookingId: varchar("booking_id").references(() => bookings.id, { onDelete: "set null" }),
      serviceId: varchar("service_id").references(() => services.id, { onDelete: "set null" }),
      productId: varchar("product_id").references(() => products.id, { onDelete: "set null" }),
      jobCardId: varchar("job_card_id"),
      rateId: varchar("rate_id").references(() => commissionRates.id, { onDelete: "set null" }),
      sourceType: varchar("source_type", { length: 20 }).notNull().default("service"),
      baseAmountPaisa: integer("base_amount_paisa").notNull(),
      commissionAmountPaisa: integer("commission_amount_paisa").notNull(),
      commissionRate: decimal("commission_rate", { precision: 10, scale: 4 }).notNull(),
      serviceDate: timestamp("service_date").notNull(),
      periodYear: integer("period_year").notNull(),
      periodMonth: integer("period_month").notNull(),
      paymentStatus: varchar("payment_status", { length: 20 }).notNull().default("pending"),
      isReversed: integer("is_reversed").notNull().default(0),
      reversalId: varchar("reversal_id"),
      payoutId: varchar("payout_id"),
      paidAt: timestamp("paid_at"),
      paidBy: varchar("paid_by").references(() => users.id),
      paymentMethod: varchar("payment_method", { length: 50 }),
      paymentReference: varchar("payment_reference", { length: 100 }),
      notes: text("notes"),
      metadata: jsonb("metadata").default(sql`'{}'::jsonb`),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("commissions_salon_idx").on(table.salonId),
      index("commissions_staff_idx").on(table.staffId),
      index("commissions_booking_idx").on(table.bookingId),
      index("commissions_period_idx").on(table.periodYear, table.periodMonth),
      index("commissions_payment_status_idx").on(table.paymentStatus),
      index("commissions_service_date_idx").on(table.serviceDate),
      index("commissions_job_card_idx").on(table.jobCardId),
      index("commissions_source_type_idx").on(table.sourceType),
      check("payment_status_valid", sql`payment_status IN ('pending', 'paid', 'cancelled', 'reversed')`),
      check("period_month_valid", sql`period_month >= 1 AND period_month <= 12`),
      check("period_year_valid", sql`period_year >= 2020`),
      check("source_type_valid", sql`source_type IN ('service', 'product')`),
      check("is_reversed_valid", sql`is_reversed IN (0, 1)`)
    ]);
    staffPayouts = pgTable("staff_payouts", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      staffId: varchar("staff_id").notNull().references(() => staff.id, { onDelete: "cascade" }),
      totalAmountPaisa: integer("total_amount_paisa").notNull(),
      commissionAmountPaisa: integer("commission_amount_paisa").notNull().default(0),
      tipsAmountPaisa: integer("tips_amount_paisa").notNull().default(0),
      adjustmentsAmountPaisa: integer("adjustments_amount_paisa").notNull().default(0),
      periodStart: timestamp("period_start").notNull(),
      periodEnd: timestamp("period_end").notNull(),
      paymentMethod: varchar("payment_method", { length: 30 }).notNull(),
      paymentReference: varchar("payment_reference", { length: 100 }),
      paymentDate: timestamp("payment_date").notNull(),
      status: varchar("status", { length: 20 }).notNull().default("completed"),
      processedBy: varchar("processed_by").references(() => users.id),
      notes: text("notes"),
      metadata: jsonb("metadata").default(sql`'{}'::jsonb`),
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("staff_payouts_salon_idx").on(table.salonId),
      index("staff_payouts_staff_idx").on(table.staffId),
      index("staff_payouts_date_idx").on(table.paymentDate),
      index("staff_payouts_period_idx").on(table.periodStart, table.periodEnd),
      index("staff_payouts_status_idx").on(table.status),
      check("payout_status_valid", sql`status IN ('pending', 'completed', 'failed', 'cancelled')`),
      check("payout_method_valid", sql`payment_method IN ('cash', 'bank_transfer', 'upi', 'cheque', 'other')`)
    ]);
    staffAdjustments = pgTable("staff_adjustments", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      staffId: varchar("staff_id").notNull().references(() => staff.id, { onDelete: "cascade" }),
      adjustmentType: varchar("adjustment_type", { length: 20 }).notNull(),
      category: varchar("category", { length: 50 }).notNull(),
      amountPaisa: integer("amount_paisa").notNull(),
      reason: text("reason").notNull(),
      effectiveDate: timestamp("effective_date").notNull(),
      status: varchar("status", { length: 20 }).notNull().default("pending"),
      payoutId: varchar("payout_id"),
      createdBy: varchar("created_by").notNull().references(() => users.id),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("staff_adjustments_salon_idx").on(table.salonId),
      index("staff_adjustments_staff_idx").on(table.staffId),
      index("staff_adjustments_status_idx").on(table.status),
      index("staff_adjustments_date_idx").on(table.effectiveDate),
      check("adjustment_type_valid", sql`adjustment_type IN ('bonus', 'deduction')`),
      check("adjustment_status_valid", sql`status IN ('pending', 'applied', 'cancelled')`),
      check("adjustment_category_valid", sql`category IN ('performance_bonus', 'festival_bonus', 'referral_bonus', 'custom_bonus', 'advance_recovery', 'damage_recovery', 'uniform_deduction', 'custom_deduction', 'commission_reversal')`)
    ]);
    commissionReversals = pgTable("commission_reversals", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      originalCommissionId: varchar("original_commission_id").notNull().references(() => commissions.id, { onDelete: "cascade" }),
      reversalAmountPaisa: integer("reversal_amount_paisa").notNull(),
      reversalReason: varchar("reversal_reason", { length: 50 }).notNull(),
      alreadyPaid: integer("already_paid").notNull().default(0),
      recoveryAdjustmentId: varchar("recovery_adjustment_id"),
      reversedBy: varchar("reversed_by").references(() => users.id),
      reversedAt: timestamp("reversed_at").defaultNow(),
      notes: text("notes")
    }, (table) => [
      index("commission_reversals_salon_idx").on(table.salonId),
      index("commission_reversals_commission_idx").on(table.originalCommissionId),
      check("reversal_reason_valid", sql`reversal_reason IN ('job_card_cancelled', 'service_refunded', 'product_returned', 'manual_reversal')`),
      check("already_paid_valid", sql`already_paid IN (0, 1)`)
    ]);
    budgets = pgTable("budgets", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      categoryId: varchar("category_id").references(() => expenseCategories.id, { onDelete: "set null" }),
      name: varchar("name", { length: 200 }).notNull(),
      description: text("description"),
      budgetType: varchar("budget_type", { length: 20 }).notNull(),
      // category, overall, department
      budgetAmountPaisa: integer("budget_amount_paisa").notNull(),
      spentAmountPaisa: integer("spent_amount_paisa").notNull().default(0),
      currency: varchar("currency", { length: 3 }).notNull().default("USD"),
      budgetPeriod: varchar("budget_period", { length: 20 }).notNull(),
      // monthly, quarterly, yearly
      startDate: timestamp("start_date").notNull(),
      endDate: timestamp("end_date").notNull(),
      alertThreshold: integer("alert_threshold").default(80),
      // Alert when % of budget used
      isActive: integer("is_active").notNull().default(1),
      createdBy: varchar("created_by").notNull().references(() => users.id),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("budgets_salon_idx").on(table.salonId),
      index("budgets_category_idx").on(table.categoryId),
      index("budgets_period_idx").on(table.startDate, table.endDate),
      check("budget_type_valid", sql`budget_type IN ('category', 'overall', 'department')`),
      check("budget_period_valid", sql`budget_period IN ('monthly', 'quarterly', 'yearly')`),
      check("is_active_valid", sql`is_active IN (0,1)`),
      check("alert_threshold_valid", sql`alert_threshold >= 0 AND alert_threshold <= 100`)
    ]);
    financialReports = pgTable("financial_reports", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      reportType: varchar("report_type", { length: 50 }).notNull(),
      // pl_statement, cash_flow, commission_report, expense_report
      reportTitle: varchar("report_title", { length: 200 }).notNull(),
      reportPeriod: varchar("report_period", { length: 20 }).notNull(),
      // monthly, quarterly, yearly, custom
      startDate: timestamp("start_date").notNull(),
      endDate: timestamp("end_date").notNull(),
      reportData: jsonb("report_data").notNull(),
      // Structured report data
      summary: jsonb("summary").default(sql`'{}'::jsonb`),
      // Key metrics summary
      generatedBy: varchar("generated_by").notNull().references(() => users.id),
      exportedAt: timestamp("exported_at"),
      exportFormat: varchar("export_format", { length: 20 }),
      // pdf, excel, csv
      isScheduled: integer("is_scheduled").notNull().default(0),
      scheduleFrequency: varchar("schedule_frequency", { length: 20 }),
      nextScheduledAt: timestamp("next_scheduled_at"),
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("financial_reports_salon_idx").on(table.salonId),
      index("financial_reports_type_idx").on(table.reportType),
      index("financial_reports_period_idx").on(table.startDate, table.endDate),
      check("report_type_valid", sql`report_type IN ('pl_statement', 'cash_flow', 'commission_report', 'expense_report', 'tax_report', 'budget_report')`),
      check("report_period_valid", sql`report_period IN ('monthly', 'quarterly', 'yearly', 'custom')`),
      check("export_format_valid", sql`export_format IS NULL OR export_format IN ('pdf', 'excel', 'csv')`),
      check("is_scheduled_valid", sql`is_scheduled IN (0,1)`),
      check("schedule_frequency_valid", sql`schedule_frequency IS NULL OR schedule_frequency IN ('weekly', 'monthly', 'quarterly')`)
    ]);
    taxSettings = pgTable("tax_settings", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      taxType: varchar("tax_type", { length: 50 }).notNull(),
      // gst, vat, sales_tax, income_tax
      taxName: varchar("tax_name", { length: 100 }).notNull(),
      taxRate: decimal("tax_rate", { precision: 10, scale: 4 }).notNull(),
      // Tax percentage
      isInclusive: integer("is_inclusive").notNull().default(0),
      // Tax included in price or added
      isActive: integer("is_active").notNull().default(1),
      applicableFrom: timestamp("applicable_from").notNull().defaultNow(),
      applicableTo: timestamp("applicable_to"),
      taxAuthority: varchar("tax_authority", { length: 200 }),
      registrationNumber: varchar("registration_number", { length: 100 }),
      filingFrequency: varchar("filing_frequency", { length: 20 }),
      // monthly, quarterly, yearly
      nextFilingDate: timestamp("next_filing_date"),
      autoCalculate: integer("auto_calculate").notNull().default(1),
      metadata: jsonb("metadata").default(sql`'{}'::jsonb`),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("tax_settings_salon_idx").on(table.salonId),
      index("tax_settings_type_idx").on(table.taxType),
      unique("tax_settings_salon_type_unique").on(table.salonId, table.taxType),
      check("tax_type_valid", sql`tax_type IN ('gst', 'vat', 'sales_tax', 'income_tax', 'service_tax')`),
      check("is_inclusive_valid", sql`is_inclusive IN (0,1)`),
      check("is_active_valid", sql`is_active IN (0,1)`),
      check("auto_calculate_valid", sql`auto_calculate IN (0,1)`),
      check("filing_frequency_valid", sql`filing_frequency IS NULL OR filing_frequency IN ('monthly', 'quarterly', 'yearly')`)
    ]);
    expenseCategoriesRelations = relations(expenseCategories, ({ one, many }) => ({
      salon: one(salons, {
        fields: [expenseCategories.salonId],
        references: [salons.id]
      }),
      expenses: many(expenses),
      budgets: many(budgets)
    }));
    expensesRelations = relations(expenses, ({ one }) => ({
      salon: one(salons, {
        fields: [expenses.salonId],
        references: [salons.id]
      }),
      category: one(expenseCategories, {
        fields: [expenses.categoryId],
        references: [expenseCategories.id]
      }),
      createdByUser: one(users, {
        fields: [expenses.createdBy],
        references: [users.id]
      }),
      approvedByUser: one(users, {
        fields: [expenses.approvedBy],
        references: [users.id]
      })
    }));
    commissionRatesRelations = relations(commissionRates, ({ one, many }) => ({
      salon: one(salons, {
        fields: [commissionRates.salonId],
        references: [salons.id]
      }),
      staff: one(staff, {
        fields: [commissionRates.staffId],
        references: [staff.id]
      }),
      service: one(services, {
        fields: [commissionRates.serviceId],
        references: [services.id]
      }),
      product: one(products, {
        fields: [commissionRates.productId],
        references: [products.id]
      }),
      commissions: many(commissions)
    }));
    commissionsRelations = relations(commissions, ({ one }) => ({
      salon: one(salons, {
        fields: [commissions.salonId],
        references: [salons.id]
      }),
      staff: one(staff, {
        fields: [commissions.staffId],
        references: [staff.id]
      }),
      booking: one(bookings, {
        fields: [commissions.bookingId],
        references: [bookings.id]
      }),
      service: one(services, {
        fields: [commissions.serviceId],
        references: [services.id]
      }),
      product: one(products, {
        fields: [commissions.productId],
        references: [products.id]
      }),
      rate: one(commissionRates, {
        fields: [commissions.rateId],
        references: [commissionRates.id]
      }),
      paidByUser: one(users, {
        fields: [commissions.paidBy],
        references: [users.id]
      })
    }));
    staffPayoutsRelations = relations(staffPayouts, ({ one }) => ({
      salon: one(salons, {
        fields: [staffPayouts.salonId],
        references: [salons.id]
      }),
      staff: one(staff, {
        fields: [staffPayouts.staffId],
        references: [staff.id]
      }),
      processedByUser: one(users, {
        fields: [staffPayouts.processedBy],
        references: [users.id]
      })
    }));
    staffAdjustmentsRelations = relations(staffAdjustments, ({ one }) => ({
      salon: one(salons, {
        fields: [staffAdjustments.salonId],
        references: [salons.id]
      }),
      staff: one(staff, {
        fields: [staffAdjustments.staffId],
        references: [staff.id]
      }),
      createdByUser: one(users, {
        fields: [staffAdjustments.createdBy],
        references: [users.id]
      })
    }));
    commissionReversalsRelations = relations(commissionReversals, ({ one }) => ({
      salon: one(salons, {
        fields: [commissionReversals.salonId],
        references: [salons.id]
      }),
      originalCommission: one(commissions, {
        fields: [commissionReversals.originalCommissionId],
        references: [commissions.id]
      }),
      reversedByUser: one(users, {
        fields: [commissionReversals.reversedBy],
        references: [users.id]
      })
    }));
    budgetsRelations = relations(budgets, ({ one }) => ({
      salon: one(salons, {
        fields: [budgets.salonId],
        references: [salons.id]
      }),
      category: one(expenseCategories, {
        fields: [budgets.categoryId],
        references: [expenseCategories.id]
      }),
      createdByUser: one(users, {
        fields: [budgets.createdBy],
        references: [users.id]
      })
    }));
    financialReportsRelations = relations(financialReports, ({ one }) => ({
      salon: one(salons, {
        fields: [financialReports.salonId],
        references: [salons.id]
      }),
      generatedByUser: one(users, {
        fields: [financialReports.generatedBy],
        references: [users.id]
      })
    }));
    taxSettingsRelations = relations(taxSettings, ({ one }) => ({
      salon: one(salons, {
        fields: [taxSettings.salonId],
        references: [salons.id]
      })
    }));
    insertExpenseCategorySchema = createInsertSchema(expenseCategories).omit({
      id: true,
      createdAt: true
    });
    insertExpenseSchema = createInsertSchema(expenses).omit({
      id: true,
      createdAt: true,
      updatedAt: true,
      approvedAt: true
    }).extend({
      expenseDate: z.union([z.date(), z.string().datetime()]).transform((val) => {
        if (typeof val === "string") {
          return new Date(val);
        }
        return val;
      })
    });
    insertCommissionRateSchema = createInsertSchema(commissionRates).omit({
      id: true,
      createdAt: true
    }).extend({
      effectiveFrom: z.union([z.date(), z.string().datetime()]).transform((val) => {
        if (typeof val === "string") {
          return new Date(val);
        }
        return val;
      }),
      effectiveTo: z.union([z.date(), z.string().datetime()]).optional().transform((val) => {
        if (typeof val === "string") {
          return new Date(val);
        }
        return val;
      })
    });
    insertCommissionSchema = createInsertSchema(commissions).omit({
      id: true,
      createdAt: true,
      updatedAt: true,
      paidAt: true
    }).extend({
      serviceDate: z.union([z.date(), z.string().datetime()]).transform((val) => {
        if (typeof val === "string") {
          return new Date(val);
        }
        return val;
      })
    });
    insertStaffPayoutSchema = createInsertSchema(staffPayouts).omit({
      id: true,
      createdAt: true
    }).extend({
      periodStart: z.union([z.date(), z.string().datetime()]).transform((val) => {
        if (typeof val === "string") {
          return new Date(val);
        }
        return val;
      }),
      periodEnd: z.union([z.date(), z.string().datetime()]).transform((val) => {
        if (typeof val === "string") {
          return new Date(val);
        }
        return val;
      }),
      paymentDate: z.union([z.date(), z.string().datetime()]).transform((val) => {
        if (typeof val === "string") {
          return new Date(val);
        }
        return val;
      })
    });
    insertStaffAdjustmentSchema = createInsertSchema(staffAdjustments).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    }).extend({
      effectiveDate: z.union([z.date(), z.string().datetime()]).transform((val) => {
        if (typeof val === "string") {
          return new Date(val);
        }
        return val;
      })
    });
    insertCommissionReversalSchema = createInsertSchema(commissionReversals).omit({
      id: true,
      reversedAt: true
    });
    insertBudgetSchema = createInsertSchema(budgets).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    }).extend({
      startDate: z.union([z.date(), z.string().datetime()]).transform((val) => {
        if (typeof val === "string") {
          return new Date(val);
        }
        return val;
      }),
      endDate: z.union([z.date(), z.string().datetime()]).transform((val) => {
        if (typeof val === "string") {
          return new Date(val);
        }
        return val;
      })
    });
    insertFinancialReportSchema = createInsertSchema(financialReports).omit({
      id: true,
      createdAt: true,
      exportedAt: true,
      nextScheduledAt: true
    }).extend({
      startDate: z.union([z.date(), z.string().datetime()]).transform((val) => {
        if (typeof val === "string") {
          return new Date(val);
        }
        return val;
      }),
      endDate: z.union([z.date(), z.string().datetime()]).transform((val) => {
        if (typeof val === "string") {
          return new Date(val);
        }
        return val;
      })
    });
    insertTaxSettingSchema = createInsertSchema(taxSettings).omit({
      id: true,
      createdAt: true,
      updatedAt: true,
      nextFilingDate: true
    }).extend({
      applicableFrom: z.union([z.date(), z.string().datetime()]).transform((val) => {
        if (typeof val === "string") {
          return new Date(val);
        }
        return val;
      }),
      applicableTo: z.union([z.date(), z.string().datetime()]).optional().transform((val) => {
        if (typeof val === "string") {
          return new Date(val);
        }
        return val;
      })
    });
    messageTemplates = pgTable("message_templates", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      name: varchar("name", { length: 100 }).notNull(),
      // Template name
      type: varchar("type", { length: 50 }).notNull(),
      // booking_confirmation, booking_reminder, marketing, follow_up, birthday, etc.
      channel: varchar("channel", { length: 20 }).notNull(),
      // email, sms, both
      subject: varchar("subject", { length: 200 }),
      // For emails
      content: text("content").notNull(),
      // Template content with placeholders
      variables: jsonb("variables").default("[]"),
      // Available variables like {{customerName}}, {{appointmentTime}}
      isActive: integer("is_active").notNull().default(1),
      isDefault: integer("is_default").notNull().default(0),
      // System default templates
      createdBy: varchar("created_by").references(() => users.id),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("message_templates_salon_id_idx").on(table.salonId),
      index("message_templates_type_idx").on(table.type)
    ]);
    insertMessageTemplateSchema = createInsertSchema(messageTemplates).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    customerSegments = pgTable("customer_segments", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      name: varchar("name", { length: 100 }).notNull(),
      description: text("description"),
      criteria: jsonb("criteria").notNull(),
      // Segment criteria (booking count, last visit, services, etc.)
      customerCount: integer("customer_count").notNull().default(0),
      isActive: integer("is_active").notNull().default(1),
      createdBy: varchar("created_by").references(() => users.id),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("customer_segments_salon_id_idx").on(table.salonId)
    ]);
    insertCustomerSegmentSchema = createInsertSchema(customerSegments).omit({
      id: true,
      customerCount: true,
      createdAt: true,
      updatedAt: true
    });
    communicationCampaigns = pgTable("communication_campaigns", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      name: varchar("name", { length: 100 }).notNull(),
      description: text("description"),
      type: varchar("type", { length: 50 }).notNull(),
      // marketing, automated, birthday, re_engagement
      status: varchar("status", { length: 20 }).notNull().default("draft"),
      // draft, scheduled, running, paused, completed, cancelled
      templateId: varchar("template_id").references(() => messageTemplates.id),
      segmentId: varchar("segment_id").references(() => customerSegments.id),
      // Target segment
      scheduledAt: timestamp("scheduled_at"),
      startedAt: timestamp("started_at"),
      completedAt: timestamp("completed_at"),
      totalRecipients: integer("total_recipients").notNull().default(0),
      messagesSent: integer("messages_sent").notNull().default(0),
      messagesDelivered: integer("messages_delivered").notNull().default(0),
      messagesOpened: integer("messages_opened").notNull().default(0),
      messagesClicked: integer("messages_clicked").notNull().default(0),
      messagesFailed: integer("messages_failed").notNull().default(0),
      unsubscribes: integer("unsubscribes").notNull().default(0),
      createdBy: varchar("created_by").references(() => users.id),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("communication_campaigns_salon_id_idx").on(table.salonId),
      index("communication_campaigns_status_idx").on(table.status),
      index("communication_campaigns_scheduled_at_idx").on(table.scheduledAt)
    ]);
    insertCommunicationCampaignSchema = createInsertSchema(communicationCampaigns).omit({
      id: true,
      totalRecipients: true,
      messagesSent: true,
      messagesDelivered: true,
      messagesOpened: true,
      messagesClicked: true,
      messagesFailed: true,
      unsubscribes: true,
      startedAt: true,
      completedAt: true,
      createdAt: true,
      updatedAt: true
    });
    communicationHistory = pgTable("communication_history", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      customerId: varchar("customer_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      campaignId: varchar("campaign_id").references(() => communicationCampaigns.id, { onDelete: "set null" }),
      templateId: varchar("template_id").references(() => messageTemplates.id, { onDelete: "set null" }),
      bookingId: varchar("booking_id").references(() => bookings.id, { onDelete: "set null" }),
      // For booking-related messages
      type: varchar("type", { length: 50 }).notNull(),
      // booking_confirmation, reminder, marketing, etc.
      channel: varchar("channel", { length: 20 }).notNull(),
      // email, sms
      recipient: varchar("recipient", { length: 255 }).notNull(),
      // email address or phone number
      subject: varchar("subject", { length: 200 }),
      content: text("content").notNull(),
      status: varchar("status", { length: 20 }).notNull().default("pending"),
      // pending, sent, delivered, failed, bounced
      providerId: varchar("provider_id"),
      // External provider message ID (SendGrid, Twilio)
      sentAt: timestamp("sent_at"),
      deliveredAt: timestamp("delivered_at"),
      openedAt: timestamp("opened_at"),
      clickedAt: timestamp("clicked_at"),
      failureReason: text("failure_reason"),
      metadata: jsonb("metadata").default("{}"),
      // Additional tracking data
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("communication_history_salon_id_idx").on(table.salonId),
      index("communication_history_customer_id_idx").on(table.customerId),
      index("communication_history_campaign_id_idx").on(table.campaignId),
      index("communication_history_booking_id_idx").on(table.bookingId),
      index("communication_history_status_idx").on(table.status),
      index("communication_history_sent_at_idx").on(table.sentAt)
    ]);
    insertCommunicationHistorySchema = createInsertSchema(communicationHistory).omit({
      id: true,
      sentAt: true,
      deliveredAt: true,
      openedAt: true,
      clickedAt: true,
      createdAt: true
    });
    communicationPreferences = pgTable("communication_preferences", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      customerId: varchar("customer_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      emailOptIn: integer("email_opt_in").notNull().default(1),
      // 1 = opted in, 0 = opted out
      smsOptIn: integer("sms_opt_in").notNull().default(1),
      marketingOptIn: integer("marketing_opt_in").notNull().default(1),
      // Marketing communications
      bookingNotifications: integer("booking_notifications").notNull().default(1),
      // Booking confirmations/reminders
      promotionalOffers: integer("promotional_offers").notNull().default(1),
      birthdayOffers: integer("birthday_offers").notNull().default(1),
      preferredChannel: varchar("preferred_channel", { length: 20 }).default("email"),
      // email, sms, both
      unsubscribedAt: timestamp("unsubscribed_at"),
      unsubscribeReason: text("unsubscribe_reason"),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("communication_preferences_customer_id_idx").on(table.customerId),
      index("communication_preferences_salon_id_idx").on(table.salonId),
      unique("communication_preferences_customer_salon_unique").on(table.customerId, table.salonId)
    ]);
    insertCommunicationPreferencesSchema = createInsertSchema(communicationPreferences).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    scheduledMessages = pgTable("scheduled_messages", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      customerId: varchar("customer_id").references(() => users.id, { onDelete: "cascade" }),
      bookingId: varchar("booking_id").references(() => bookings.id, { onDelete: "cascade" }),
      campaignId: varchar("campaign_id").references(() => communicationCampaigns.id, { onDelete: "cascade" }),
      templateId: varchar("template_id").references(() => messageTemplates.id, { onDelete: "set null" }),
      type: varchar("type", { length: 50 }).notNull(),
      // booking_reminder, follow_up, birthday, etc.
      channel: varchar("channel", { length: 20 }).notNull(),
      // email, sms
      recipient: varchar("recipient", { length: 255 }).notNull(),
      subject: varchar("subject", { length: 200 }),
      content: text("content").notNull(),
      scheduledFor: timestamp("scheduled_for").notNull(),
      status: varchar("status", { length: 20 }).notNull().default("pending"),
      // pending, sent, failed, cancelled
      attempts: integer("attempts").notNull().default(0),
      maxAttempts: integer("max_attempts").notNull().default(3),
      lastAttemptAt: timestamp("last_attempt_at"),
      sentAt: timestamp("sent_at"),
      failureReason: text("failure_reason"),
      metadata: jsonb("metadata").default("{}"),
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("scheduled_messages_salon_id_idx").on(table.salonId),
      index("scheduled_messages_scheduled_for_idx").on(table.scheduledFor),
      index("scheduled_messages_status_idx").on(table.status),
      index("scheduled_messages_booking_id_idx").on(table.bookingId)
    ]);
    insertScheduledMessageSchema = createInsertSchema(scheduledMessages).omit({
      id: true,
      attempts: true,
      lastAttemptAt: true,
      sentAt: true,
      createdAt: true
    });
    communicationAnalytics = pgTable("communication_analytics", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      campaignId: varchar("campaign_id").references(() => communicationCampaigns.id, { onDelete: "cascade" }),
      date: timestamp("date").notNull(),
      // Analytics for specific date
      channel: varchar("channel", { length: 20 }).notNull(),
      // email, sms
      messagesSent: integer("messages_sent").notNull().default(0),
      messagesDelivered: integer("messages_delivered").notNull().default(0),
      messagesOpened: integer("messages_opened").notNull().default(0),
      messagesClicked: integer("messages_clicked").notNull().default(0),
      messagesFailed: integer("messages_failed").notNull().default(0),
      unsubscribes: integer("unsubscribes").notNull().default(0),
      bounces: integer("bounces").notNull().default(0),
      complaints: integer("complaints").notNull().default(0),
      revenue: integer("revenue").notNull().default(0),
      // Revenue attributed to communications in paisa
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("communication_analytics_salon_id_idx").on(table.salonId),
      index("communication_analytics_date_idx").on(table.date),
      index("communication_analytics_campaign_id_idx").on(table.campaignId),
      unique("communication_analytics_salon_campaign_date_channel_unique").on(table.salonId, table.campaignId, table.date, table.channel)
    ]);
    insertCommunicationAnalyticsSchema = createInsertSchema(communicationAnalytics).omit({
      id: true,
      createdAt: true
    });
    messageTemplatesRelations = relations(messageTemplates, ({ one, many }) => ({
      salon: one(salons, {
        fields: [messageTemplates.salonId],
        references: [salons.id]
      }),
      createdByUser: one(users, {
        fields: [messageTemplates.createdBy],
        references: [users.id]
      }),
      campaigns: many(communicationCampaigns),
      history: many(communicationHistory),
      scheduledMessages: many(scheduledMessages),
      abTestCampaigns: many(abTestCampaigns)
    }));
    customerSegmentsRelations = relations(customerSegments, ({ one, many }) => ({
      salon: one(salons, {
        fields: [customerSegments.salonId],
        references: [salons.id]
      }),
      createdByUser: one(users, {
        fields: [customerSegments.createdBy],
        references: [users.id]
      }),
      campaigns: many(communicationCampaigns),
      abTestCampaigns: many(abTestCampaigns)
    }));
    communicationCampaignsRelations = relations(communicationCampaigns, ({ one, many }) => ({
      salon: one(salons, {
        fields: [communicationCampaigns.salonId],
        references: [salons.id]
      }),
      template: one(messageTemplates, {
        fields: [communicationCampaigns.templateId],
        references: [messageTemplates.id]
      }),
      segment: one(customerSegments, {
        fields: [communicationCampaigns.segmentId],
        references: [customerSegments.id]
      }),
      createdByUser: one(users, {
        fields: [communicationCampaigns.createdBy],
        references: [users.id]
      }),
      history: many(communicationHistory),
      analytics: many(communicationAnalytics),
      scheduledMessages: many(scheduledMessages)
    }));
    communicationHistoryRelations = relations(communicationHistory, ({ one }) => ({
      salon: one(salons, {
        fields: [communicationHistory.salonId],
        references: [salons.id]
      }),
      customer: one(users, {
        fields: [communicationHistory.customerId],
        references: [users.id]
      }),
      campaign: one(communicationCampaigns, {
        fields: [communicationHistory.campaignId],
        references: [communicationCampaigns.id]
      }),
      template: one(messageTemplates, {
        fields: [communicationHistory.templateId],
        references: [messageTemplates.id]
      }),
      booking: one(bookings, {
        fields: [communicationHistory.bookingId],
        references: [bookings.id]
      })
    }));
    communicationPreferencesRelations = relations(communicationPreferences, ({ one }) => ({
      customer: one(users, {
        fields: [communicationPreferences.customerId],
        references: [users.id]
      }),
      salon: one(salons, {
        fields: [communicationPreferences.salonId],
        references: [salons.id]
      })
    }));
    scheduledMessagesRelations = relations(scheduledMessages, ({ one }) => ({
      salon: one(salons, {
        fields: [scheduledMessages.salonId],
        references: [salons.id]
      }),
      customer: one(users, {
        fields: [scheduledMessages.customerId],
        references: [users.id]
      }),
      booking: one(bookings, {
        fields: [scheduledMessages.bookingId],
        references: [bookings.id]
      }),
      campaign: one(communicationCampaigns, {
        fields: [scheduledMessages.campaignId],
        references: [communicationCampaigns.id]
      }),
      template: one(messageTemplates, {
        fields: [scheduledMessages.templateId],
        references: [messageTemplates.id]
      })
    }));
    communicationAnalyticsRelations = relations(communicationAnalytics, ({ one }) => ({
      salon: one(salons, {
        fields: [communicationAnalytics.salonId],
        references: [salons.id]
      }),
      campaign: one(communicationCampaigns, {
        fields: [communicationAnalytics.campaignId],
        references: [communicationCampaigns.id]
      })
    }));
    abTestCampaigns = pgTable("ab_test_campaigns", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      campaignName: varchar("campaign_name", { length: 200 }).notNull(),
      description: text("description"),
      status: varchar("status", { length: 20 }).notNull().default("draft"),
      // draft, active, completed, paused
      baseTemplateId: varchar("base_template_id").notNull().references(() => messageTemplates.id, { onDelete: "restrict" }),
      testType: varchar("test_type", { length: 50 }).notNull(),
      // subject, content, timing, channel, multivariate
      targetSegmentId: varchar("target_segment_id").references(() => customerSegments.id, { onDelete: "set null" }),
      sampleSizePercentage: integer("sample_size_percentage").notNull().default(100),
      // 1-100
      testDuration: integer("test_duration").notNull().default(7),
      // Duration in days
      confidenceLevel: integer("confidence_level").notNull().default(95),
      // 90, 95, 99
      successMetric: varchar("success_metric", { length: 50 }).notNull().default("open_rate"),
      // open_rate, click_rate, conversion_rate, booking_rate
      winnerSelectionCriteria: varchar("winner_selection_criteria", { length: 50 }).notNull().default("statistical_significance"),
      // statistical_significance, business_rules
      autoOptimization: integer("auto_optimization").notNull().default(0),
      // Boolean: auto-select winner
      createdAt: timestamp("created_at").defaultNow(),
      startedAt: timestamp("started_at"),
      completedAt: timestamp("completed_at"),
      createdBy: varchar("created_by").references(() => users.id)
    }, (table) => [
      index("ab_test_campaigns_salon_id_idx").on(table.salonId),
      index("ab_test_campaigns_status_idx").on(table.status),
      index("ab_test_campaigns_test_type_idx").on(table.testType),
      index("ab_test_campaigns_started_at_idx").on(table.startedAt),
      index("ab_test_campaigns_completed_at_idx").on(table.completedAt),
      check("sample_size_valid", sql`sample_size_percentage >= 1 AND sample_size_percentage <= 100`),
      check("test_duration_valid", sql`test_duration >= 1`),
      check("confidence_level_valid", sql`confidence_level IN (90, 95, 99)`),
      check("auto_optimization_valid", sql`auto_optimization IN (0,1)`)
    ]);
    insertAbTestCampaignSchema = createInsertSchema(abTestCampaigns).omit({
      id: true,
      createdAt: true,
      startedAt: true,
      completedAt: true
    });
    testVariants = pgTable("test_variants", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      testCampaignId: varchar("test_campaign_id").notNull().references(() => abTestCampaigns.id, { onDelete: "cascade" }),
      variantName: varchar("variant_name", { length: 100 }).notNull(),
      isControl: integer("is_control").notNull().default(0),
      // Boolean: control variant
      templateOverrides: jsonb("template_overrides").default("{}"),
      // JSON: subject, content, timing modifications
      channelOverride: varchar("channel_override", { length: 20 }),
      // email, sms, both - overrides base template channel
      priority: integer("priority").notNull().default(0),
      // For ordering variants
      audiencePercentage: integer("audience_percentage").notNull(),
      // Percentage of test audience for this variant
      status: varchar("status", { length: 20 }).notNull().default("active"),
      // active, paused, winner, loser
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("test_variants_campaign_id_idx").on(table.testCampaignId),
      index("test_variants_status_idx").on(table.status),
      index("test_variants_priority_idx").on(table.priority),
      unique("test_variants_campaign_name_unique").on(table.testCampaignId, table.variantName),
      check("is_control_valid", sql`is_control IN (0,1)`),
      check("audience_percentage_valid", sql`audience_percentage >= 1 AND audience_percentage <= 100`),
      check("priority_valid", sql`priority >= 0`)
    ]);
    insertTestVariantSchema = createInsertSchema(testVariants).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    testMetrics = pgTable("test_metrics", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      testCampaignId: varchar("test_campaign_id").notNull().references(() => abTestCampaigns.id, { onDelete: "cascade" }),
      variantId: varchar("variant_id").notNull().references(() => testVariants.id, { onDelete: "cascade" }),
      metricDate: timestamp("metric_date").notNull(),
      // Date for daily aggregated metrics
      participantCount: integer("participant_count").notNull().default(0),
      // Number of users in this variant
      sentCount: integer("sent_count").notNull().default(0),
      deliveredCount: integer("delivered_count").notNull().default(0),
      openCount: integer("open_count").notNull().default(0),
      clickCount: integer("click_count").notNull().default(0),
      replyCount: integer("reply_count").notNull().default(0),
      bookingCount: integer("booking_count").notNull().default(0),
      conversionCount: integer("conversion_count").notNull().default(0),
      bounceCount: integer("bounce_count").notNull().default(0),
      unsubscribeCount: integer("unsubscribe_count").notNull().default(0),
      openRate: decimal("open_rate", { precision: 5, scale: 4 }).default("0.0000"),
      // Calculated: openCount/deliveredCount
      clickRate: decimal("click_rate", { precision: 5, scale: 4 }).default("0.0000"),
      // Calculated: clickCount/deliveredCount
      conversionRate: decimal("conversion_rate", { precision: 5, scale: 4 }).default("0.0000"),
      // Calculated: conversionCount/deliveredCount
      bookingRate: decimal("booking_rate", { precision: 5, scale: 4 }).default("0.0000"),
      // Calculated: bookingCount/deliveredCount
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("test_metrics_campaign_id_idx").on(table.testCampaignId),
      index("test_metrics_variant_id_idx").on(table.variantId),
      index("test_metrics_date_idx").on(table.metricDate),
      unique("test_metrics_variant_date_unique").on(table.variantId, table.metricDate),
      check("participant_count_valid", sql`participant_count >= 0`),
      check("sent_count_valid", sql`sent_count >= 0`),
      check("delivered_count_valid", sql`delivered_count >= 0`),
      check("open_count_valid", sql`open_count >= 0`),
      check("click_count_valid", sql`click_count >= 0`),
      check("reply_count_valid", sql`reply_count >= 0`),
      check("booking_count_valid", sql`booking_count >= 0`),
      check("conversion_count_valid", sql`conversion_count >= 0`),
      check("bounce_count_valid", sql`bounce_count >= 0`),
      check("unsubscribe_count_valid", sql`unsubscribe_count >= 0`),
      check("rates_valid", sql`open_rate >= 0 AND click_rate >= 0 AND conversion_rate >= 0 AND booking_rate >= 0`)
    ]);
    insertTestMetricSchema = createInsertSchema(testMetrics).omit({
      id: true,
      openRate: true,
      // Calculated field
      clickRate: true,
      // Calculated field
      conversionRate: true,
      // Calculated field
      bookingRate: true,
      // Calculated field
      updatedAt: true
    });
    testResults = pgTable("test_results", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      testCampaignId: varchar("test_campaign_id").notNull().references(() => abTestCampaigns.id, { onDelete: "cascade" }).unique(),
      winnerVariantId: varchar("winner_variant_id").references(() => testVariants.id, { onDelete: "set null" }),
      completedAt: timestamp("completed_at").notNull(),
      statisticalSignificance: decimal("statistical_significance", { precision: 5, scale: 4 }),
      // P-value or confidence level achieved
      confidenceLevel: integer("confidence_level"),
      // Actual confidence level achieved
      pValue: decimal("p_value", { precision: 10, scale: 9 }),
      // Statistical p-value
      performanceImprovement: decimal("performance_improvement", { precision: 5, scale: 4 }),
      // % improvement of winner over control
      resultSummary: jsonb("result_summary").default("{}"),
      // JSON: detailed results, variant performance comparison
      actionTaken: varchar("action_taken", { length: 50 }).notNull(),
      // manual_selection, auto_winner, inconclusive
      implementedAt: timestamp("implemented_at"),
      // When the winning variant was implemented
      notes: text("notes")
      // Additional notes about the test conclusion
    }, (table) => [
      index("test_results_campaign_id_idx").on(table.testCampaignId),
      index("test_results_winner_variant_idx").on(table.winnerVariantId),
      index("test_results_completed_at_idx").on(table.completedAt),
      index("test_results_implemented_at_idx").on(table.implementedAt),
      check("confidence_level_valid", sql`confidence_level IS NULL OR confidence_level IN (90, 95, 99)`),
      check("statistical_significance_valid", sql`statistical_significance IS NULL OR (statistical_significance >= 0 AND statistical_significance <= 1)`),
      check("p_value_valid", sql`p_value IS NULL OR (p_value >= 0 AND p_value <= 1)`)
    ]);
    insertTestResultSchema = createInsertSchema(testResults).omit({
      id: true
    });
    abTestCampaignsRelations = relations(abTestCampaigns, ({ one, many }) => ({
      salon: one(salons, {
        fields: [abTestCampaigns.salonId],
        references: [salons.id]
      }),
      baseTemplate: one(messageTemplates, {
        fields: [abTestCampaigns.baseTemplateId],
        references: [messageTemplates.id]
      }),
      targetSegment: one(customerSegments, {
        fields: [abTestCampaigns.targetSegmentId],
        references: [customerSegments.id]
      }),
      createdByUser: one(users, {
        fields: [abTestCampaigns.createdBy],
        references: [users.id]
      }),
      variants: many(testVariants),
      metrics: many(testMetrics),
      result: one(testResults, {
        fields: [abTestCampaigns.id],
        references: [testResults.testCampaignId]
      })
    }));
    testVariantsRelations = relations(testVariants, ({ one, many }) => ({
      testCampaign: one(abTestCampaigns, {
        fields: [testVariants.testCampaignId],
        references: [abTestCampaigns.id]
      }),
      metrics: many(testMetrics),
      winnerResults: many(testResults)
    }));
    testMetricsRelations = relations(testMetrics, ({ one }) => ({
      testCampaign: one(abTestCampaigns, {
        fields: [testMetrics.testCampaignId],
        references: [abTestCampaigns.id]
      }),
      variant: one(testVariants, {
        fields: [testMetrics.variantId],
        references: [testVariants.id]
      })
    }));
    testResultsRelations = relations(testResults, ({ one }) => ({
      testCampaign: one(abTestCampaigns, {
        fields: [testResults.testCampaignId],
        references: [abTestCampaigns.id]
      }),
      winnerVariant: one(testVariants, {
        fields: [testResults.winnerVariantId],
        references: [testVariants.id]
      })
    }));
    automationConfigurations = pgTable("automation_configurations", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      configurationName: varchar("configuration_name", { length: 100 }).notNull(),
      isEnabled: integer("is_enabled").notNull().default(1),
      // Variant generation settings
      enableVariantGeneration: integer("enable_variant_generation").notNull().default(1),
      maxVariantsPerTest: integer("max_variants_per_test").notNull().default(4),
      variantGenerationTypes: jsonb("variant_generation_types").default('["subject_line", "content", "send_time"]'),
      // Types of variants to auto-generate
      // Performance monitoring settings
      enablePerformanceMonitoring: integer("enable_performance_monitoring").notNull().default(1),
      monitoringIntervalMinutes: integer("monitoring_interval_minutes").notNull().default(15),
      performanceAlertThreshold: decimal("performance_alert_threshold", { precision: 5, scale: 4 }).default("0.0500"),
      // 5% performance change threshold
      // Winner selection settings
      enableAutoWinnerSelection: integer("enable_auto_winner_selection").notNull().default(0),
      autoWinnerConfidenceLevel: integer("auto_winner_confidence_level").notNull().default(95),
      // 90, 95, 99
      minimumTestDurationHours: integer("minimum_test_duration_hours").notNull().default(24),
      minimumSampleSize: integer("minimum_sample_size").notNull().default(100),
      // Campaign optimization settings
      enableCampaignOptimization: integer("enable_campaign_optimization").notNull().default(1),
      optimizationTypes: jsonb("optimization_types").default('["send_time", "frequency", "channel"]'),
      // Types of optimizations to suggest
      learningDataDays: integer("learning_data_days").notNull().default(30),
      // Days of historical data to use for learning
      // Business rules for automation
      businessRules: jsonb("business_rules").default("{}"),
      // Custom business rules as JSON
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("automation_configurations_salon_id_idx").on(table.salonId),
      index("automation_configurations_enabled_idx").on(table.isEnabled),
      unique("automation_configurations_salon_name_unique").on(table.salonId, table.configurationName),
      check("max_variants_valid", sql`max_variants_per_test >= 2 AND max_variants_per_test <= 10`),
      check("monitoring_interval_valid", sql`monitoring_interval_minutes >= 5 AND monitoring_interval_minutes <= 1440`),
      check("confidence_level_valid", sql`auto_winner_confidence_level IN (90, 95, 99)`),
      check("duration_valid", sql`minimum_test_duration_hours >= 1 AND minimum_test_duration_hours <= 168`),
      check("sample_size_valid", sql`minimum_sample_size >= 10`)
    ]);
    insertAutomationConfigurationSchema = createInsertSchema(automationConfigurations).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    variantGenerationRules = pgTable("variant_generation_rules", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      configurationId: varchar("configuration_id").notNull().references(() => automationConfigurations.id, { onDelete: "cascade" }),
      ruleName: varchar("rule_name", { length: 100 }).notNull(),
      ruleType: varchar("rule_type", { length: 50 }).notNull(),
      // subject_line, content, timing, channel, personalization
      isActive: integer("is_active").notNull().default(1),
      priority: integer("priority").notNull().default(0),
      // Higher priority rules are applied first
      // Rule conditions
      conditions: jsonb("conditions").default("{}"),
      // JSON: audience criteria, performance thresholds, etc.
      // Rule actions
      actions: jsonb("actions").default("{}"),
      // JSON: variant modifications to apply
      // Performance tracking
      timesApplied: integer("times_applied").notNull().default(0),
      successRate: decimal("success_rate", { precision: 5, scale: 4 }).default("0.0000"),
      // % of times this rule improved performance
      averageImprovement: decimal("average_improvement", { precision: 5, scale: 4 }).default("0.0000"),
      // Average performance improvement
      // Best practice templates
      bestPracticeTemplates: jsonb("best_practice_templates").default("[]"),
      // Proven effective patterns
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("variant_generation_rules_salon_id_idx").on(table.salonId),
      index("variant_generation_rules_config_id_idx").on(table.configurationId),
      index("variant_generation_rules_type_idx").on(table.ruleType),
      index("variant_generation_rules_active_idx").on(table.isActive),
      index("variant_generation_rules_priority_idx").on(table.priority),
      unique("variant_generation_rules_config_name_unique").on(table.configurationId, table.ruleName)
    ]);
    insertVariantGenerationRuleSchema = createInsertSchema(variantGenerationRules).omit({
      id: true,
      timesApplied: true,
      successRate: true,
      averageImprovement: true,
      createdAt: true,
      updatedAt: true
    });
    performanceMonitoringSettings = pgTable("performance_monitoring_settings", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      configurationId: varchar("configuration_id").notNull().references(() => automationConfigurations.id, { onDelete: "cascade" }),
      monitoringName: varchar("monitoring_name", { length: 100 }).notNull(),
      isActive: integer("is_active").notNull().default(1),
      // Monitoring targets
      targetMetrics: jsonb("target_metrics").default('["open_rate", "click_rate", "conversion_rate"]'),
      // Metrics to monitor
      metricThresholds: jsonb("metric_thresholds").default("{}"),
      // Alert thresholds for each metric
      // Monitoring frequency
      checkIntervalMinutes: integer("check_interval_minutes").notNull().default(15),
      alertCooldownMinutes: integer("alert_cooldown_minutes").notNull().default(60),
      // Prevent spam alerts
      // Alert settings
      enableEmailAlerts: integer("enable_email_alerts").notNull().default(1),
      enableSmsAlerts: integer("enable_sms_alerts").notNull().default(0),
      alertRecipients: jsonb("alert_recipients").default("[]"),
      // Email/phone list for alerts
      // Early detection settings
      enableEarlyWinnerDetection: integer("enable_early_winner_detection").notNull().default(1),
      earlyDetectionMinimumSamples: integer("early_detection_minimum_samples").notNull().default(50),
      earlyDetectionSignificanceLevel: decimal("early_detection_significance_level", { precision: 5, scale: 4 }).default("0.0500"),
      // 5% significance level
      // Data collection settings
      enableProviderIntegration: integer("enable_provider_integration").notNull().default(1),
      providerSettings: jsonb("provider_settings").default("{}"),
      // SendGrid, Twilio integration settings
      lastMonitoredAt: timestamp("last_monitored_at"),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("performance_monitoring_settings_salon_id_idx").on(table.salonId),
      index("performance_monitoring_settings_config_id_idx").on(table.configurationId),
      index("performance_monitoring_settings_active_idx").on(table.isActive),
      index("performance_monitoring_settings_last_monitored_idx").on(table.lastMonitoredAt),
      unique("performance_monitoring_settings_config_name_unique").on(table.configurationId, table.monitoringName),
      check("check_interval_valid", sql`check_interval_minutes >= 5 AND check_interval_minutes <= 1440`),
      check("cooldown_valid", sql`alert_cooldown_minutes >= 5 AND alert_cooldown_minutes <= 1440`)
    ]);
    insertPerformanceMonitoringSettingSchema = createInsertSchema(performanceMonitoringSettings).omit({
      id: true,
      lastMonitoredAt: true,
      createdAt: true,
      updatedAt: true
    });
    optimizationRecommendations = pgTable("optimization_recommendations", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      campaignId: varchar("campaign_id").references(() => communicationCampaigns.id, { onDelete: "cascade" }),
      testCampaignId: varchar("test_campaign_id").references(() => abTestCampaigns.id, { onDelete: "cascade" }),
      recommendationType: varchar("recommendation_type", { length: 50 }).notNull(),
      // send_time, audience, content, frequency, channel
      recommendationTitle: varchar("recommendation_title", { length: 200 }).notNull(),
      recommendationDescription: text("recommendation_description").notNull(),
      // Confidence and impact metrics
      confidenceScore: decimal("confidence_score", { precision: 5, scale: 4 }).notNull(),
      // 0-1 confidence in recommendation
      expectedImprovement: decimal("expected_improvement", { precision: 5, scale: 4 }).notNull(),
      // % improvement expected
      impactScore: decimal("impact_score", { precision: 5, scale: 4 }).notNull(),
      // Business impact score
      // Implementation details
      implementationData: jsonb("implementation_data").default("{}"),
      // JSON: specific changes to make
      implementationComplexity: varchar("implementation_complexity", { length: 20 }).notNull().default("low"),
      // low, medium, high
      estimatedEffortHours: decimal("estimated_effort_hours", { precision: 4, scale: 2 }).default("0.25"),
      // ML model details
      modelVersion: varchar("model_version", { length: 50 }),
      modelFeatures: jsonb("model_features").default("{}"),
      // Features used for this recommendation
      basedOnDataPoints: integer("based_on_data_points").default(0),
      // Number of data points used
      // Status and feedback
      status: varchar("status", { length: 20 }).notNull().default("pending"),
      // pending, implemented, rejected, expired
      implementedAt: timestamp("implemented_at"),
      implementedBy: varchar("implemented_by").references(() => users.id),
      actualImprovement: decimal("actual_improvement", { precision: 5, scale: 4 }),
      // Measured improvement after implementation
      feedbackScore: integer("feedback_score"),
      // User feedback 1-5
      feedbackNotes: text("feedback_notes"),
      // Expiration and priority
      expiresAt: timestamp("expires_at"),
      priority: integer("priority").notNull().default(5),
      // 1-10 priority scale
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("optimization_recommendations_salon_id_idx").on(table.salonId),
      index("optimization_recommendations_campaign_id_idx").on(table.campaignId),
      index("optimization_recommendations_test_campaign_id_idx").on(table.testCampaignId),
      index("optimization_recommendations_type_idx").on(table.recommendationType),
      index("optimization_recommendations_status_idx").on(table.status),
      index("optimization_recommendations_priority_idx").on(table.priority),
      index("optimization_recommendations_expires_at_idx").on(table.expiresAt),
      check("confidence_score_valid", sql`confidence_score >= 0 AND confidence_score <= 1`),
      check("impact_score_valid", sql`impact_score >= 0 AND impact_score <= 1`),
      check("priority_valid", sql`priority >= 1 AND priority <= 10`),
      check("feedback_score_valid", sql`feedback_score IS NULL OR (feedback_score >= 1 AND feedback_score <= 5)`)
    ]);
    insertOptimizationRecommendationSchema = createInsertSchema(optimizationRecommendations).omit({
      id: true,
      implementedAt: true,
      actualImprovement: true,
      feedbackScore: true,
      feedbackNotes: true,
      createdAt: true,
      updatedAt: true
    });
    automatedActionLogs = pgTable("automated_action_logs", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      configurationId: varchar("configuration_id").references(() => automationConfigurations.id, { onDelete: "set null" }),
      campaignId: varchar("campaign_id").references(() => communicationCampaigns.id, { onDelete: "set null" }),
      testCampaignId: varchar("test_campaign_id").references(() => abTestCampaigns.id, { onDelete: "set null" }),
      recommendationId: varchar("recommendation_id").references(() => optimizationRecommendations.id, { onDelete: "set null" }),
      actionType: varchar("action_type", { length: 50 }).notNull(),
      // variant_generated, winner_selected, optimization_applied, alert_sent, etc.
      actionDescription: text("action_description").notNull(),
      // Action details
      actionData: jsonb("action_data").default("{}"),
      // JSON: specific action parameters and results
      triggeredBy: varchar("triggered_by", { length: 50 }).notNull(),
      // system, user, schedule, webhook
      triggerData: jsonb("trigger_data").default("{}"),
      // What triggered this action
      // Results
      status: varchar("status", { length: 20 }).notNull().default("completed"),
      // pending, completed, failed, cancelled
      resultData: jsonb("result_data").default("{}"),
      // Action results and metrics
      errorMessage: text("error_message"),
      // Error details if failed
      // Performance impact
      performanceImpact: jsonb("performance_impact").default("{}"),
      // Measured impact of this action
      // Timing
      executionTimeMs: integer("execution_time_ms"),
      // How long the action took
      createdAt: timestamp("created_at").defaultNow(),
      completedAt: timestamp("completed_at")
    }, (table) => [
      index("automated_action_logs_salon_id_idx").on(table.salonId),
      index("automated_action_logs_config_id_idx").on(table.configurationId),
      index("automated_action_logs_campaign_id_idx").on(table.campaignId),
      index("automated_action_logs_test_campaign_id_idx").on(table.testCampaignId),
      index("automated_action_logs_action_type_idx").on(table.actionType),
      index("automated_action_logs_status_idx").on(table.status),
      index("automated_action_logs_triggered_by_idx").on(table.triggeredBy),
      index("automated_action_logs_created_at_idx").on(table.createdAt)
    ]);
    insertAutomatedActionLogSchema = createInsertSchema(automatedActionLogs).omit({
      id: true,
      executionTimeMs: true,
      createdAt: true,
      completedAt: true
    });
    campaignOptimizationInsights = pgTable("campaign_optimization_insights", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      insightType: varchar("insight_type", { length: 50 }).notNull(),
      // send_time_patterns, audience_preferences, content_performance, channel_effectiveness
      insightTitle: varchar("insight_title", { length: 200 }).notNull(),
      insightDescription: text("insight_description").notNull(),
      // Insight data
      insightData: jsonb("insight_data").default("{}"),
      // JSON: detailed insight findings
      supportingMetrics: jsonb("supporting_metrics").default("{}"),
      // Metrics that support this insight
      // Confidence and validity
      confidenceScore: decimal("confidence_score", { precision: 5, scale: 4 }).notNull(),
      // 0-1 confidence in insight
      sampleSize: integer("sample_size").notNull(),
      // Number of data points used
      dataDateRange: jsonb("data_date_range").default("{}"),
      // Start and end dates of analyzed data
      // Actionability
      isActionable: integer("is_actionable").notNull().default(1),
      recommendedActions: jsonb("recommended_actions").default("[]"),
      // List of recommended actions
      // Performance tracking
      timesActedUpon: integer("times_acted_upon").notNull().default(0),
      averageImpactWhenActedUpon: decimal("average_impact_when_acted_upon", { precision: 5, scale: 4 }).default("0.0000"),
      // Lifecycle
      status: varchar("status", { length: 20 }).notNull().default("active"),
      // active, implemented, expired, superseded
      validUntil: timestamp("valid_until"),
      // When this insight expires
      supersededBy: varchar("superseded_by"),
      // Self-reference will be added after table definition
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("campaign_optimization_insights_salon_id_idx").on(table.salonId),
      index("campaign_optimization_insights_type_idx").on(table.insightType),
      index("campaign_optimization_insights_status_idx").on(table.status),
      index("campaign_optimization_insights_actionable_idx").on(table.isActionable),
      index("campaign_optimization_insights_valid_until_idx").on(table.validUntil),
      check("confidence_score_valid", sql`confidence_score >= 0 AND confidence_score <= 1`),
      check("sample_size_valid", sql`sample_size > 0`)
    ]);
    insertCampaignOptimizationInsightSchema = createInsertSchema(campaignOptimizationInsights).omit({
      id: true,
      timesActedUpon: true,
      averageImpactWhenActedUpon: true,
      createdAt: true,
      updatedAt: true
    });
    automationConfigurationsRelations = relations(automationConfigurations, ({ one, many }) => ({
      salon: one(salons, {
        fields: [automationConfigurations.salonId],
        references: [salons.id]
      }),
      variantRules: many(variantGenerationRules),
      monitoringSettings: many(performanceMonitoringSettings),
      actionLogs: many(automatedActionLogs)
    }));
    variantGenerationRulesRelations = relations(variantGenerationRules, ({ one }) => ({
      salon: one(salons, {
        fields: [variantGenerationRules.salonId],
        references: [salons.id]
      }),
      configuration: one(automationConfigurations, {
        fields: [variantGenerationRules.configurationId],
        references: [automationConfigurations.id]
      })
    }));
    performanceMonitoringSettingsRelations = relations(performanceMonitoringSettings, ({ one }) => ({
      salon: one(salons, {
        fields: [performanceMonitoringSettings.salonId],
        references: [salons.id]
      }),
      configuration: one(automationConfigurations, {
        fields: [performanceMonitoringSettings.configurationId],
        references: [automationConfigurations.id]
      })
    }));
    optimizationRecommendationsRelations = relations(optimizationRecommendations, ({ one }) => ({
      salon: one(salons, {
        fields: [optimizationRecommendations.salonId],
        references: [salons.id]
      }),
      campaign: one(communicationCampaigns, {
        fields: [optimizationRecommendations.campaignId],
        references: [communicationCampaigns.id]
      }),
      testCampaign: one(abTestCampaigns, {
        fields: [optimizationRecommendations.testCampaignId],
        references: [abTestCampaigns.id]
      }),
      implementedBy: one(users, {
        fields: [optimizationRecommendations.implementedBy],
        references: [users.id]
      })
    }));
    automatedActionLogsRelations = relations(automatedActionLogs, ({ one }) => ({
      salon: one(salons, {
        fields: [automatedActionLogs.salonId],
        references: [salons.id]
      }),
      configuration: one(automationConfigurations, {
        fields: [automatedActionLogs.configurationId],
        references: [automationConfigurations.id]
      }),
      campaign: one(communicationCampaigns, {
        fields: [automatedActionLogs.campaignId],
        references: [communicationCampaigns.id]
      }),
      testCampaign: one(abTestCampaigns, {
        fields: [automatedActionLogs.testCampaignId],
        references: [abTestCampaigns.id]
      }),
      recommendation: one(optimizationRecommendations, {
        fields: [automatedActionLogs.recommendationId],
        references: [optimizationRecommendations.id]
      })
    }));
    campaignOptimizationInsightsRelations = relations(campaignOptimizationInsights, ({ one }) => ({
      salon: one(salons, {
        fields: [campaignOptimizationInsights.salonId],
        references: [salons.id]
      }),
      supersededBy: one(campaignOptimizationInsights, {
        fields: [campaignOptimizationInsights.supersededBy],
        references: [campaignOptimizationInsights.id]
      })
    }));
    vendors = pgTable("vendors", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      name: varchar("name", { length: 200 }).notNull(),
      contactPerson: varchar("contact_person", { length: 200 }),
      email: varchar("email", { length: 200 }),
      phone: varchar("phone", { length: 50 }),
      address: text("address"),
      city: varchar("city", { length: 100 }),
      state: varchar("state", { length: 100 }),
      zipCode: varchar("zip_code", { length: 20 }),
      country: varchar("country", { length: 100 }).default("India"),
      website: varchar("website", { length: 200 }),
      taxId: varchar("tax_id", { length: 50 }),
      // GST number in India
      paymentTerms: varchar("payment_terms", { length: 100 }),
      // Net 30, COD, etc.
      notes: text("notes"),
      status: varchar("status", { length: 20 }).notNull().default("active"),
      // active, inactive, suspended
      rating: decimal("rating", { precision: 3, scale: 2 }).default("0.00"),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("vendors_salon_id_idx").on(table.salonId),
      index("vendors_status_idx").on(table.status)
    ]);
    insertVendorSchema = createInsertSchema(vendors).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    productCategories = pgTable("product_categories", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      name: varchar("name", { length: 100 }).notNull(),
      description: text("description"),
      parentCategoryId: varchar("parent_category_id"),
      // Self-reference will be added after table definition
      isActive: integer("is_active").notNull().default(1),
      sortOrder: integer("sort_order").default(0),
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("product_categories_salon_id_idx").on(table.salonId),
      index("product_categories_parent_idx").on(table.parentCategoryId),
      unique("product_categories_salon_name_unique").on(table.salonId, table.name)
    ]);
    insertProductCategorySchema = createInsertSchema(productCategories).omit({
      id: true,
      createdAt: true
    });
    products = pgTable("products", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      categoryId: varchar("category_id").references(() => productCategories.id, { onDelete: "set null" }),
      vendorId: varchar("vendor_id").references(() => vendors.id, { onDelete: "set null" }),
      sku: varchar("sku", { length: 100 }).notNull(),
      name: varchar("name", { length: 200 }).notNull(),
      description: text("description"),
      brand: varchar("brand", { length: 100 }),
      size: varchar("size", { length: 50 }),
      // 500ml, 1L, etc.
      unit: varchar("unit", { length: 20 }).notNull().default("piece"),
      // piece, ml, g, kg, etc.
      costPriceInPaisa: integer("cost_price_in_paisa").notNull(),
      // Purchase cost
      sellingPriceInPaisa: integer("selling_price_in_paisa"),
      // Retail price for resale items
      currency: varchar("currency", { length: 3 }).notNull().default("USD"),
      currentStock: decimal("current_stock", { precision: 10, scale: 3 }).notNull().default("0"),
      minimumStock: decimal("minimum_stock", { precision: 10, scale: 3 }).notNull().default("0"),
      maximumStock: decimal("maximum_stock", { precision: 10, scale: 3 }),
      reorderPoint: decimal("reorder_point", { precision: 10, scale: 3 }),
      reorderQuantity: decimal("reorder_quantity", { precision: 10, scale: 3 }),
      leadTimeDays: integer("lead_time_days").default(7),
      expiryDate: timestamp("expiry_date"),
      batchNumber: varchar("batch_number", { length: 100 }),
      barcode: varchar("barcode", { length: 100 }),
      location: varchar("location", { length: 100 }),
      // Storage location in salon
      isActive: integer("is_active").notNull().default(1),
      isRetailItem: integer("is_retail_item").notNull().default(0),
      // Can be sold to customers
      trackStock: integer("track_stock").notNull().default(1),
      // Enable stock tracking
      lowStockAlert: integer("low_stock_alert").notNull().default(1),
      // E-commerce retail fields
      availableForRetail: integer("available_for_retail").notNull().default(0),
      // Enable retail sales for this product
      retailPriceInPaisa: integer("retail_price_in_paisa"),
      // Customer-facing price (separate from cost_price_in_paisa)
      notes: text("notes"),
      tags: jsonb("tags").default("[]"),
      // Flexible tagging system
      metadata: jsonb("metadata").default("{}"),
      // Additional custom fields
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("products_salon_id_idx").on(table.salonId),
      index("products_category_id_idx").on(table.categoryId),
      index("products_vendor_id_idx").on(table.vendorId),
      index("products_sku_idx").on(table.sku),
      index("products_barcode_idx").on(table.barcode),
      index("products_current_stock_idx").on(table.currentStock),
      index("products_low_stock_idx").on(table.currentStock, table.minimumStock),
      index("products_retail_idx").on(table.salonId, table.availableForRetail, table.isActive),
      // E-commerce: Efficient retail product filtering
      unique("products_salon_sku_unique").on(table.salonId, table.sku)
    ]);
    insertProductSchema = createInsertSchema(products).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    stockMovements = pgTable("stock_movements", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      productId: varchar("product_id").notNull().references(() => products.id, { onDelete: "cascade" }),
      type: varchar("type", { length: 50 }).notNull(),
      // purchase, usage, adjustment, waste, transfer, return
      quantity: decimal("quantity", { precision: 10, scale: 3 }).notNull(),
      unit: varchar("unit", { length: 20 }).notNull(),
      unitCostInPaisa: integer("unit_cost_in_paisa"),
      // Cost per unit for this movement
      totalCostInPaisa: integer("total_cost_in_paisa"),
      // Total cost of movement
      previousStock: decimal("previous_stock", { precision: 10, scale: 3 }).notNull(),
      newStock: decimal("new_stock", { precision: 10, scale: 3 }).notNull(),
      reason: varchar("reason", { length: 100 }),
      // Why the movement happened
      reference: varchar("reference", { length: 100 }),
      // PO number, booking ID, etc.
      referenceId: varchar("reference_id"),
      // Foreign key to related record
      referenceType: varchar("reference_type", { length: 50 }),
      // purchase_order, booking, adjustment, etc.
      staffId: varchar("staff_id").references(() => staff.id, { onDelete: "set null" }),
      // Who performed the movement
      notes: text("notes"),
      batchNumber: varchar("batch_number", { length: 100 }),
      expiryDate: timestamp("expiry_date"),
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("stock_movements_salon_id_idx").on(table.salonId),
      index("stock_movements_product_id_idx").on(table.productId),
      index("stock_movements_type_idx").on(table.type),
      index("stock_movements_created_at_idx").on(table.createdAt),
      index("stock_movements_reference_idx").on(table.referenceType, table.referenceId)
    ]);
    insertStockMovementSchema = createInsertSchema(stockMovements).omit({
      id: true,
      createdAt: true
    });
    purchaseOrders = pgTable("purchase_orders", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      vendorId: varchar("vendor_id").notNull().references(() => vendors.id, { onDelete: "restrict" }),
      orderNumber: varchar("order_number", { length: 100 }).notNull(),
      status: varchar("status", { length: 20 }).notNull().default("draft"),
      // draft, sent, confirmed, received, cancelled
      orderDate: timestamp("order_date").notNull().defaultNow(),
      expectedDeliveryDate: timestamp("expected_delivery_date"),
      actualDeliveryDate: timestamp("actual_delivery_date"),
      subtotalInPaisa: integer("subtotal_in_paisa").notNull().default(0),
      taxInPaisa: integer("tax_in_paisa").notNull().default(0),
      shippingInPaisa: integer("shipping_in_paisa").notNull().default(0),
      discountInPaisa: integer("discount_in_paisa").notNull().default(0),
      totalInPaisa: integer("total_in_paisa").notNull().default(0),
      currency: varchar("currency", { length: 3 }).notNull().default("USD"),
      paymentTerms: varchar("payment_terms", { length: 100 }),
      paymentStatus: varchar("payment_status", { length: 20 }).default("pending"),
      // pending, partial, paid
      createdBy: varchar("created_by").notNull().references(() => users.id, { onDelete: "restrict" }),
      approvedBy: varchar("approved_by").references(() => users.id, { onDelete: "set null" }),
      receivedBy: varchar("received_by").references(() => users.id, { onDelete: "set null" }),
      notes: text("notes"),
      internalNotes: text("internal_notes"),
      // Private notes not visible to vendor
      metadata: jsonb("metadata").default("{}"),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("purchase_orders_salon_id_idx").on(table.salonId),
      index("purchase_orders_vendor_id_idx").on(table.vendorId),
      index("purchase_orders_status_idx").on(table.status),
      index("purchase_orders_order_date_idx").on(table.orderDate),
      unique("purchase_orders_salon_order_number_unique").on(table.salonId, table.orderNumber)
    ]);
    insertPurchaseOrderSchema = createInsertSchema(purchaseOrders).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    purchaseOrderItems = pgTable("purchase_order_items", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      purchaseOrderId: varchar("purchase_order_id").notNull().references(() => purchaseOrders.id, { onDelete: "cascade" }),
      productId: varchar("product_id").notNull().references(() => products.id, { onDelete: "restrict" }),
      quantity: decimal("quantity", { precision: 10, scale: 3 }).notNull(),
      unit: varchar("unit", { length: 20 }).notNull(),
      unitCostInPaisa: integer("unit_cost_in_paisa").notNull(),
      totalCostInPaisa: integer("total_cost_in_paisa").notNull(),
      receivedQuantity: decimal("received_quantity", { precision: 10, scale: 3 }).default("0"),
      notes: text("notes"),
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("purchase_order_items_po_id_idx").on(table.purchaseOrderId),
      index("purchase_order_items_product_id_idx").on(table.productId)
    ]);
    insertPurchaseOrderItemSchema = createInsertSchema(purchaseOrderItems).omit({
      id: true,
      createdAt: true
    });
    productUsage = pgTable("product_usage", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      serviceId: varchar("service_id").notNull().references(() => services.id, { onDelete: "cascade" }),
      productId: varchar("product_id").notNull().references(() => products.id, { onDelete: "cascade" }),
      quantityPerService: decimal("quantity_per_service", { precision: 10, scale: 3 }).notNull(),
      unit: varchar("unit", { length: 20 }).notNull(),
      costPerServiceInPaisa: integer("cost_per_service_in_paisa"),
      // Calculated cost per service
      isActive: integer("is_active").notNull().default(1),
      notes: text("notes"),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("product_usage_salon_id_idx").on(table.salonId),
      index("product_usage_service_id_idx").on(table.serviceId),
      index("product_usage_product_id_idx").on(table.productId),
      unique("product_usage_service_product_unique").on(table.serviceId, table.productId)
    ]);
    insertProductUsageSchema = createInsertSchema(productUsage).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    reorderRules = pgTable("reorder_rules", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      productId: varchar("product_id").notNull().references(() => products.id, { onDelete: "cascade" }),
      vendorId: varchar("vendor_id").references(() => vendors.id, { onDelete: "set null" }),
      isActive: integer("is_active").notNull().default(1),
      reorderPoint: decimal("reorder_point", { precision: 10, scale: 3 }).notNull(),
      reorderQuantity: decimal("reorder_quantity", { precision: 10, scale: 3 }).notNull(),
      leadTimeDays: integer("lead_time_days").notNull().default(7),
      safetyStockDays: integer("safety_stock_days").default(3),
      autoCreatePO: integer("auto_create_po").notNull().default(0),
      // Automatically create purchase orders
      lastTriggered: timestamp("last_triggered"),
      nextReviewDate: timestamp("next_review_date"),
      seasonalFactor: decimal("seasonal_factor", { precision: 5, scale: 2 }).default("1.00"),
      // Seasonal adjustment
      notes: text("notes"),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("reorder_rules_salon_id_idx").on(table.salonId),
      index("reorder_rules_product_id_idx").on(table.productId),
      index("reorder_rules_vendor_id_idx").on(table.vendorId),
      index("reorder_rules_next_review_idx").on(table.nextReviewDate),
      unique("reorder_rules_salon_product_unique").on(table.salonId, table.productId)
    ]);
    insertReorderRuleSchema = createInsertSchema(reorderRules).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    inventoryAdjustments = pgTable("inventory_adjustments", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      adjustmentNumber: varchar("adjustment_number", { length: 100 }).notNull(),
      type: varchar("type", { length: 50 }).notNull(),
      // physical_count, shrinkage, damage, expired, correction
      status: varchar("status", { length: 20 }).notNull().default("draft"),
      // draft, submitted, approved
      adjustmentDate: timestamp("adjustment_date").notNull().defaultNow(),
      reason: varchar("reason", { length: 200 }).notNull(),
      description: text("description"),
      totalValueInPaisa: integer("total_value_in_paisa").default(0),
      // Total value of adjustment
      createdBy: varchar("created_by").notNull().references(() => users.id, { onDelete: "restrict" }),
      approvedBy: varchar("approved_by").references(() => users.id, { onDelete: "set null" }),
      approvedAt: timestamp("approved_at"),
      notes: text("notes"),
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("inventory_adjustments_salon_id_idx").on(table.salonId),
      index("inventory_adjustments_type_idx").on(table.type),
      index("inventory_adjustments_status_idx").on(table.status),
      index("inventory_adjustments_date_idx").on(table.adjustmentDate),
      unique("inventory_adjustments_salon_number_unique").on(table.salonId, table.adjustmentNumber)
    ]);
    insertInventoryAdjustmentSchema = createInsertSchema(inventoryAdjustments).omit({
      id: true,
      createdAt: true
    });
    inventoryAdjustmentItems = pgTable("inventory_adjustment_items", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      adjustmentId: varchar("adjustment_id").notNull().references(() => inventoryAdjustments.id, { onDelete: "cascade" }),
      productId: varchar("product_id").notNull().references(() => products.id, { onDelete: "restrict" }),
      expectedQuantity: decimal("expected_quantity", { precision: 10, scale: 3 }).notNull(),
      actualQuantity: decimal("actual_quantity", { precision: 10, scale: 3 }).notNull(),
      adjustmentQuantity: decimal("adjustment_quantity", { precision: 10, scale: 3 }).notNull(),
      unit: varchar("unit", { length: 20 }).notNull(),
      unitCostInPaisa: integer("unit_cost_in_paisa"),
      totalCostInPaisa: integer("total_cost_in_paisa"),
      reason: varchar("reason", { length: 200 }),
      notes: text("notes"),
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("inventory_adjustment_items_adjustment_id_idx").on(table.adjustmentId),
      index("inventory_adjustment_items_product_id_idx").on(table.productId)
    ]);
    insertInventoryAdjustmentItemSchema = createInsertSchema(inventoryAdjustmentItems).omit({
      id: true,
      createdAt: true
    });
    vendorsRelations = relations(vendors, ({ one, many }) => ({
      salon: one(salons, {
        fields: [vendors.salonId],
        references: [salons.id]
      }),
      products: many(products),
      purchaseOrders: many(purchaseOrders),
      reorderRules: many(reorderRules)
    }));
    productCategoriesRelations = relations(productCategories, ({ one, many }) => ({
      salon: one(salons, {
        fields: [productCategories.salonId],
        references: [salons.id]
      }),
      parentCategory: one(productCategories, {
        fields: [productCategories.parentCategoryId],
        references: [productCategories.id]
      }),
      subcategories: many(productCategories),
      products: many(products)
    }));
    productsRelations = relations(products, ({ one, many }) => ({
      salon: one(salons, {
        fields: [products.salonId],
        references: [salons.id]
      }),
      category: one(productCategories, {
        fields: [products.categoryId],
        references: [productCategories.id]
      }),
      vendor: one(vendors, {
        fields: [products.vendorId],
        references: [vendors.id]
      }),
      stockMovements: many(stockMovements),
      purchaseOrderItems: many(purchaseOrderItems),
      productUsage: many(productUsage),
      reorderRule: one(reorderRules),
      adjustmentItems: many(inventoryAdjustmentItems)
    }));
    stockMovementsRelations = relations(stockMovements, ({ one }) => ({
      salon: one(salons, {
        fields: [stockMovements.salonId],
        references: [salons.id]
      }),
      product: one(products, {
        fields: [stockMovements.productId],
        references: [products.id]
      }),
      staff: one(staff, {
        fields: [stockMovements.staffId],
        references: [staff.id]
      })
    }));
    purchaseOrdersRelations = relations(purchaseOrders, ({ one, many }) => ({
      salon: one(salons, {
        fields: [purchaseOrders.salonId],
        references: [salons.id]
      }),
      vendor: one(vendors, {
        fields: [purchaseOrders.vendorId],
        references: [vendors.id]
      }),
      createdByUser: one(users, {
        fields: [purchaseOrders.createdBy],
        references: [users.id]
      }),
      approvedByUser: one(users, {
        fields: [purchaseOrders.approvedBy],
        references: [users.id]
      }),
      receivedByUser: one(users, {
        fields: [purchaseOrders.receivedBy],
        references: [users.id]
      }),
      items: many(purchaseOrderItems)
    }));
    purchaseOrderItemsRelations = relations(purchaseOrderItems, ({ one }) => ({
      purchaseOrder: one(purchaseOrders, {
        fields: [purchaseOrderItems.purchaseOrderId],
        references: [purchaseOrders.id]
      }),
      product: one(products, {
        fields: [purchaseOrderItems.productId],
        references: [products.id]
      })
    }));
    productUsageRelations = relations(productUsage, ({ one }) => ({
      salon: one(salons, {
        fields: [productUsage.salonId],
        references: [salons.id]
      }),
      service: one(services, {
        fields: [productUsage.serviceId],
        references: [services.id]
      }),
      product: one(products, {
        fields: [productUsage.productId],
        references: [products.id]
      })
    }));
    reorderRulesRelations = relations(reorderRules, ({ one }) => ({
      salon: one(salons, {
        fields: [reorderRules.salonId],
        references: [salons.id]
      }),
      product: one(products, {
        fields: [reorderRules.productId],
        references: [products.id]
      }),
      vendor: one(vendors, {
        fields: [reorderRules.vendorId],
        references: [vendors.id]
      })
    }));
    inventoryAdjustmentsRelations = relations(inventoryAdjustments, ({ one, many }) => ({
      salon: one(salons, {
        fields: [inventoryAdjustments.salonId],
        references: [salons.id]
      }),
      createdByUser: one(users, {
        fields: [inventoryAdjustments.createdBy],
        references: [users.id]
      }),
      approvedByUser: one(users, {
        fields: [inventoryAdjustments.approvedBy],
        references: [users.id]
      }),
      items: many(inventoryAdjustmentItems)
    }));
    inventoryAdjustmentItemsRelations = relations(inventoryAdjustmentItems, ({ one }) => ({
      adjustment: one(inventoryAdjustments, {
        fields: [inventoryAdjustmentItems.adjustmentId],
        references: [inventoryAdjustments.id]
      }),
      product: one(products, {
        fields: [inventoryAdjustmentItems.productId],
        references: [products.id]
      })
    }));
    salonSearchSchema = z.object({
      lat: z.number().min(-90).max(90, "Latitude must be between -90 and 90 degrees"),
      lng: z.number().min(-180).max(180, "Longitude must be between -180 and 180 degrees"),
      radiusKm: z.number().min(0.1).max(50, "Radius must be between 0.1 and 50 kilometers").default(1),
      category: z.string().optional(),
      q: z.string().optional(),
      sort: z.enum(["distance", "rating", "name", "recommended", "top-rated", "nearest"]).default("distance"),
      page: z.number().min(1).default(1),
      pageSize: z.number().min(1).max(50).default(20),
      time: z.string().optional(),
      date: z.string().optional(),
      maxPrice: z.number().optional(),
      venueType: z.string().optional(),
      availableToday: z.boolean().optional(),
      instantBooking: z.boolean().optional(),
      offerDeals: z.boolean().optional(),
      acceptGroup: z.boolean().optional()
    });
    salonSearchResultSchema = z.object({
      salons: z.array(z.object({
        id: z.string(),
        name: z.string(),
        description: z.string().nullable(),
        address: z.string(),
        city: z.string(),
        state: z.string(),
        zipCode: z.string(),
        latitude: z.string().nullable(),
        longitude: z.string().nullable(),
        phone: z.string(),
        email: z.string(),
        website: z.string().nullable(),
        category: z.string(),
        priceRange: z.string(),
        rating: z.string(),
        reviewCount: z.number(),
        imageUrl: z.string().nullable(),
        openTime: z.string().nullable(),
        closeTime: z.string().nullable(),
        distance_km: z.number(),
        createdAt: z.date().nullable()
      })),
      pagination: z.object({
        page: z.number(),
        pageSize: z.number(),
        total: z.number(),
        totalPages: z.number(),
        hasMore: z.boolean()
      }),
      searchParams: z.object({
        lat: z.number(),
        lng: z.number(),
        radiusKm: z.number(),
        category: z.string().optional(),
        q: z.string().optional(),
        sort: z.string()
      })
    });
    placesAutocompleteSchema = z.object({
      q: z.string().min(1, "Query must not be empty").max(200, "Query too long"),
      lat: z.number().min(-90).max(90, "Latitude must be between -90 and 90 degrees").optional(),
      lng: z.number().min(-180).max(180, "Longitude must be between -180 and 180 degrees").optional(),
      limit: z.number().min(1).max(20, "Limit must be between 1 and 20").default(10).optional(),
      countrycode: z.string().length(2, "Country code must be 2 characters").optional()
    });
    placesDetailsSchema = z.object({
      placeId: z.string().min(1, "Place ID is required").max(500, "Place ID too long")
    });
    placesGeocodeSchema = z.union([
      // Forward geocoding: address -> coordinates
      z.object({
        address: z.string().min(1, "Address is required").max(500, "Address too long"),
        countrycode: z.string().length(2, "Country code must be 2 characters").optional()
      }),
      // Reverse geocoding: coordinates -> address  
      z.object({
        lat: z.number().min(-90, "Latitude must be between -90 and 90 degrees").max(90, "Latitude must be between -90 and 90 degrees"),
        lng: z.number().min(-180, "Longitude must be between -180 and 180 degrees").max(180, "Longitude must be between -180 and 180 degrees"),
        countrycode: z.string().length(2, "Country code must be 2 characters").optional()
      })
    ]);
    placesAutocompleteResponseSchema = z.object({
      suggestions: z.array(z.object({
        id: z.string(),
        title: z.string(),
        subtitle: z.string(),
        lat: z.number().optional(),
        lng: z.number().optional()
      })),
      query: z.string()
    });
    placesDetailsResponseSchema = z.object({
      address: z.string(),
      lat: z.number(),
      lng: z.number(),
      placeId: z.string().optional(),
      components: z.object({
        city: z.string().optional(),
        state: z.string().optional(),
        country: z.string().optional(),
        postcode: z.string().optional(),
        street: z.string().optional(),
        housenumber: z.string().optional()
      })
    });
    placesGeocodeResponseSchema = z.object({
      address: z.string(),
      lat: z.number(),
      lng: z.number(),
      confidence: z.number()
    });
    platformOffers = pgTable("platform_offers", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").references(() => salons.id, { onDelete: "cascade" }),
      // null for platform-wide offers
      ownedBySalonId: varchar("owned_by_salon_id").references(() => salons.id, { onDelete: "cascade" }),
      // Track salon ownership (null = super admin created)
      title: text("title").notNull(),
      description: text("description"),
      discountType: varchar("discount_type", { length: 20 }).notNull(),
      // 'percentage' | 'fixed'
      discountValue: integer("discount_value").notNull(),
      // percentage (1-100) or paisa amount
      minimumPurchase: integer("minimum_purchase"),
      // minimum purchase in paisa
      maxDiscount: integer("max_discount"),
      // maximum discount cap in paisa (for percentage discounts)
      validFrom: timestamp("valid_from").notNull(),
      validUntil: timestamp("valid_until").notNull(),
      isActive: integer("is_active").notNull().default(1),
      isPlatformWide: integer("is_platform_wide").notNull().default(0),
      // 1 for all salons, 0 for specific salon
      usageLimit: integer("usage_limit"),
      // null for unlimited
      usageCount: integer("usage_count").notNull().default(0),
      approvalStatus: varchar("approval_status", { length: 20 }).notNull().default("pending"),
      // 'pending' | 'approved' | 'rejected'
      approvalNotes: text("approval_notes"),
      approvedBy: varchar("approved_by").references(() => users.id),
      approvedAt: timestamp("approved_at"),
      rejectedBy: varchar("rejected_by").references(() => users.id),
      rejectedAt: timestamp("rejected_at"),
      createdBy: varchar("created_by").references(() => users.id),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow(),
      // Approval workflow tracking (Migration: All existing offers default to manually approved state)
      autoApproved: integer("auto_approved").notNull().default(0),
      // 1 if auto-approved by system, 0 if manually created/approved by admin
      requiresApprovalOnEdit: integer("requires_approval_on_edit").notNull().default(0),
      // 1 if future edits need re-approval (set when auto-approve is disabled)
      lastEditedBy: varchar("last_edited_by").references(() => users.id),
      lastEditedAt: timestamp("last_edited_at"),
      imageUrl: text("image_url")
      // Promotional image for the offer card
    }, (table) => ({
      // Index for salon-scoped offer queries (performance optimization)
      ownedBySalonIdIdx: index("platform_offers_owned_by_salon_id_idx").on(table.ownedBySalonId)
    }));
    insertPlatformOfferSchema = createInsertSchema(platformOffers).omit({
      id: true,
      createdAt: true,
      updatedAt: true,
      usageCount: true,
      approvedBy: true,
      approvedAt: true,
      rejectedBy: true,
      rejectedAt: true,
      autoApproved: true,
      requiresApprovalOnEdit: true,
      lastEditedBy: true,
      lastEditedAt: true
    });
    createOfferSchema = insertPlatformOfferSchema.extend({
      validFrom: z.string().or(z.date()),
      validUntil: z.string().or(z.date()),
      discountType: z.enum(["percentage", "fixed"]),
      discountValue: z.number().positive(),
      isPlatformWide: z.number().int().min(0).max(1),
      isActive: z.number().int().min(0).max(1).default(1),
      imageUrl: z.string().url().optional()
    });
    updateOfferSchema = createOfferSchema.partial().omit({
      createdBy: true
    });
    approveRejectOfferSchema = z.object({
      reason: z.string().optional()
    });
    toggleOfferStatusSchema = z.object({
      isActive: z.number().int().min(0).max(1)
    });
    salonOfferSchema = z.object({
      salonId: z.string(),
      title: z.string().min(3, "Title must be at least 3 characters"),
      description: z.string().optional(),
      discountType: z.enum(["percentage", "fixed"]),
      discountValue: z.number().positive("Discount value must be positive"),
      minimumPurchase: z.number().int().nonnegative().optional(),
      maxDiscount: z.number().int().nonnegative().optional(),
      validFrom: z.string().or(z.date()),
      validUntil: z.string().or(z.date()),
      usageLimit: z.number().int().positive().optional(),
      isActive: z.number().int().min(0).max(1).default(1),
      imageUrl: z.string().url().optional()
    });
    platformSettingsSchema = z.object({
      autoApproveSalonOffers: z.boolean(),
      commissionRate: z.number().min(0).max(100).optional()
    });
    userWallets = pgTable("user_wallets", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      balanceInPaisa: integer("balance_in_paisa").notNull().default(0),
      lifetimeEarnedInPaisa: integer("lifetime_earned_in_paisa").notNull().default(0),
      lifetimeSpentInPaisa: integer("lifetime_spent_in_paisa").notNull().default(0),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    });
    walletTransactions = pgTable("wallet_transactions", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      walletId: varchar("wallet_id").notNull().references(() => userWallets.id, { onDelete: "cascade" }),
      userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      type: varchar("type", { length: 20 }).notNull(),
      // 'credit' | 'debit'
      amountInPaisa: integer("amount_in_paisa").notNull(),
      reason: text("reason").notNull(),
      // 'signup_bonus' | 'cashback' | 'booking_payment' | 'referral_reward' etc
      bookingId: varchar("booking_id"),
      offerId: varchar("offer_id").references(() => platformOffers.id, { onDelete: "set null" }),
      createdAt: timestamp("created_at").defaultNow()
    });
    userOfferUsage = pgTable("user_offer_usage", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      offerId: varchar("offer_id").notNull().references(() => platformOffers.id, { onDelete: "cascade" }),
      bookingId: varchar("booking_id").notNull(),
      discountAppliedInPaisa: integer("discount_applied_in_paisa").notNull(),
      usageNumber: integer("usage_number").notNull(),
      // 1st, 2nd, 3rd booking etc
      createdAt: timestamp("created_at").defaultNow()
    });
    launchOffers = pgTable("launch_offers", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      offerType: varchar("offer_type", { length: 50 }).notNull(),
      // 'first_booking' | 'signup_bonus' | 'referral'
      title: text("title").notNull(),
      description: text("description"),
      instantDiscountPercent: integer("instant_discount_percent"),
      // e.g., 15%
      walletCashbackPercent: integer("wallet_cashback_percent"),
      // e.g., 10%
      walletBonusInPaisa: integer("wallet_bonus_in_paisa"),
      // Fixed amount bonus
      maxUsagePerUser: integer("max_usage_per_user"),
      // e.g., 3 for "first 3 bookings"
      minimumPurchaseInPaisa: integer("minimum_purchase_in_paisa"),
      validFrom: timestamp("valid_from").notNull(),
      validUntil: timestamp("valid_until").notNull(),
      isActive: integer("is_active").notNull().default(1),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    });
    insertUserWalletSchema = createInsertSchema(userWallets).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertWalletTransactionSchema = createInsertSchema(walletTransactions).omit({
      id: true,
      createdAt: true
    });
    insertUserOfferUsageSchema = createInsertSchema(userOfferUsage).omit({
      id: true,
      createdAt: true
    });
    insertLaunchOfferSchema = createInsertSchema(launchOffers).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    passwordResetOtps = pgTable("password_reset_otps", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      phoneNumber: varchar("phone_number", { length: 20 }).notNull(),
      otp: varchar("otp", { length: 6 }).notNull(),
      expiresAt: timestamp("expires_at").notNull(),
      verified: integer("verified").notNull().default(0),
      // 0 = not verified, 1 = verified
      attempts: integer("attempts").notNull().default(0),
      // Track OTP verification attempts
      createdAt: timestamp("created_at").defaultNow()
    });
    insertPasswordResetOtpSchema = createInsertSchema(passwordResetOtps).omit({
      id: true,
      createdAt: true
    });
    geocodeLocations = pgTable("geocode_locations", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      placeId: varchar("place_id", { length: 255 }).unique(),
      // Google Place ID - unique identifier
      formattedAddress: text("formatted_address").notNull(),
      // Official address from Google
      normalizedHash: varchar("normalized_hash", { length: 64 }),
      // MD5 hash for deduplication
      latitude: decimal("latitude", { precision: 10, scale: 8 }).notNull(),
      // 10.8 decimals = 1.1mm precision
      longitude: decimal("longitude", { precision: 11, scale: 8 }).notNull(),
      // 11.8 decimals = 1.1mm precision
      viewport: jsonb("viewport"),
      // Bounding box for map display
      locationType: varchar("location_type", { length: 30 }),
      // ROOFTOP, RANGE_INTERPOLATED, GEOMETRIC_CENTER, APPROXIMATE
      confidence: varchar("confidence", { length: 20 }).notNull().default("medium"),
      // high, medium, low
      source: varchar("source", { length: 50 }).notNull().default("google_places"),
      // google_places, geoapify, nominatim, hardcoded
      rawResponse: jsonb("raw_response"),
      // Full API response for debugging
      verifiedAt: timestamp("verified_at").defaultNow(),
      // Last validation timestamp
      expiresAt: timestamp("expires_at").notNull(),
      // TTL for cache - 60-90 days
      needsReview: integer("needs_review").notNull().default(0),
      // Flag for manual verification
      usageCount: integer("usage_count").notNull().default(0),
      // Track how often this location is used
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("geocode_locations_place_id_idx").on(table.placeId),
      index("geocode_locations_hash_idx").on(table.normalizedHash),
      index("geocode_locations_expires_idx").on(table.expiresAt),
      index("geocode_locations_coords_idx").on(table.latitude, table.longitude)
    ]);
    locationAliases = pgTable("location_aliases", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      normalizedQuery: varchar("normalized_query", { length: 255 }).notNull(),
      // "dlf mall of india noida" (lowercase, trimmed)
      originalQuery: varchar("original_query", { length: 255 }).notNull(),
      // "DLF Mall of India, Noida" (as user typed)
      placeId: varchar("place_id", { length: 255 }).notNull(),
      // Foreign key to geocode_locations
      matchType: varchar("match_type", { length: 20 }).notNull().default("exact"),
      // exact, partial, alias
      usageCount: integer("usage_count").notNull().default(0),
      // Track popular search terms
      locale: varchar("locale", { length: 10 }).default("en"),
      // Language/region code
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("location_aliases_normalized_idx").on(table.normalizedQuery),
      index("location_aliases_place_id_idx").on(table.placeId),
      uniqueIndex("location_aliases_query_unique").on(table.normalizedQuery, table.placeId)
    ]);
    insertGeocodeLocationSchema = createInsertSchema(geocodeLocations).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertLocationAliasSchema = createInsertSchema(locationAliases).omit({
      id: true,
      createdAt: true
    });
    beautyProducts = pgTable("beauty_products", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      brand: text("brand").notNull(),
      productLine: text("product_line"),
      name: text("name").notNull(),
      category: varchar("category", { length: 50 }).notNull(),
      // foundation, lipstick, eyeshadow, etc
      shade: text("shade"),
      sku: text("sku").notNull(),
      finishType: text("finish_type"),
      // matte, satin, shimmer, etc
      skinToneCompatibility: text("skin_tone_compatibility"),
      // fair, medium, deep, etc
      price: integer("price").notNull(),
      // Price in paisa
      imageUrl: text("image_url"),
      description: text("description"),
      gender: varchar("gender", { length: 20 }).default("unisex"),
      // male, female, unisex
      createdAt: timestamp("created_at", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`)
    }, (table) => [
      unique("beauty_products_sku_unique").on(table.sku)
    ]);
    effectPresets = pgTable("effect_presets", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      slug: varchar("slug", { length: 100 }).notNull().unique(),
      // Canonical slug matching Gemini categories
      name: text("name").notNull(),
      category: varchar("category", { length: 50 }).notNull(),
      // makeup, hair, beard
      deeparEffectFile: text("deepar_effect_file"),
      lookTags: text("look_tags"),
      // glamorous, natural, bold, etc
      associatedProducts: text("associated_products"),
      // Product IDs as JSON array
      createdAt: timestamp("created_at", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`)
    });
    salonInventory = pgTable("salon_inventory", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id),
      productId: varchar("product_id").notNull().references(() => beautyProducts.id),
      quantity: integer("quantity").notNull().default(0),
      lowStockThreshold: integer("low_stock_threshold").default(5),
      lastRestockedAt: timestamp("last_restocked_at", { mode: "string" }),
      createdAt: timestamp("created_at", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`)
    }, (table) => [
      unique("salon_inventory_salon_product_unique").on(table.salonId, table.productId)
    ]);
    aiLookSessions = pgTable("ai_look_sessions", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id),
      customerName: text("customer_name").notNull(),
      customerPhotoUrl: text("customer_photo_url"),
      gender: varchar("gender", { length: 20 }),
      // male, female, prefer_not_to_say
      eventType: varchar("event_type", { length: 50 }),
      // wedding, party, casual, etc
      weather: varchar("weather", { length: 50 }),
      location: varchar("location", { length: 50 }),
      skinTone: varchar("skin_tone", { length: 50 }),
      hairType: varchar("hair_type", { length: 50 }),
      staffUserId: varchar("staff_user_id").references(() => users.id),
      createdAt: timestamp("created_at", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`)
    });
    aiLookOptions = pgTable("ai_look_options", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      sessionId: varchar("session_id").notNull().references(() => aiLookSessions.id),
      lookName: text("look_name").notNull(),
      description: text("description"),
      presetIds: text("preset_ids"),
      // JSON array of preset IDs
      aiConfidenceScore: decimal("ai_confidence_score", { precision: 5, scale: 2 }),
      isSelected: integer("is_selected").notNull().default(0),
      previewImageUrl: text("preview_image_url"),
      createdAt: timestamp("created_at", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`)
    });
    aiLookProducts = pgTable("ai_look_products", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      lookOptionId: varchar("look_option_id").notNull().references(() => aiLookOptions.id),
      productId: varchar("product_id").notNull().references(() => beautyProducts.id),
      applicationArea: text("application_area"),
      // face, eyes, lips, etc
      applicationInstructions: text("application_instructions"),
      quantityNeeded: text("quantity_needed"),
      // "1 pump", "2 dots", etc
      isInStock: integer("is_in_stock").notNull().default(1),
      substituteProductId: varchar("substitute_product_id").references(() => beautyProducts.id),
      createdAt: timestamp("created_at", { mode: "string" }).default(sql`CURRENT_TIMESTAMP`)
    });
    insertBeautyProductSchema = createInsertSchema(beautyProducts).omit({
      id: true,
      createdAt: true
    });
    insertEffectPresetSchema = createInsertSchema(effectPresets).omit({
      id: true,
      createdAt: true
    });
    insertSalonInventorySchema = createInsertSchema(salonInventory).omit({
      id: true,
      createdAt: true
    });
    insertAiLookSessionSchema = createInsertSchema(aiLookSessions).omit({
      id: true,
      createdAt: true
    });
    insertAiLookOptionSchema = createInsertSchema(aiLookOptions).omit({
      id: true,
      createdAt: true
    });
    insertAiLookProductSchema = createInsertSchema(aiLookProducts).omit({
      id: true,
      createdAt: true
    });
    productRetailConfig = pgTable("product_retail_config", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      productId: varchar("product_id").notNull().references(() => products.id, { onDelete: "cascade" }),
      // Retail settings
      availableForRetail: integer("available_for_retail").notNull().default(0),
      retailPriceInPaisa: integer("retail_price_in_paisa"),
      // Overrides products.retailPriceInPaisa if set
      // Display settings
      featured: integer("featured").default(0),
      displayOrder: integer("display_order").default(0),
      // Stock allocation (separate from main inventory)
      retailStockAllocated: decimal("retail_stock_allocated", { precision: 10, scale: 3 }).default("0"),
      useAllocatedStock: integer("use_allocated_stock").notNull().default(1),
      // Hybrid model: 1=use allocated stock, 0=use warehouse stock
      lowStockThreshold: decimal("low_stock_threshold", { precision: 10, scale: 3 }).default("5"),
      // Alert when retail stock falls below this
      // Images & Media
      retailImages: text("retail_images").array(),
      // Retail-specific images
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("product_retail_config_salon_id_idx").on(table.salonId, table.availableForRetail),
      index("product_retail_config_featured_idx").on(table.salonId, table.featured).where(sql`${table.featured} = 1`),
      index("product_retail_config_product_id_idx").on(table.productId),
      unique("retail_config_unique").on(table.salonId, table.productId)
    ]);
    insertProductRetailConfigSchema = createInsertSchema(productRetailConfig).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    productVariants = pgTable("product_variants", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      productId: varchar("product_id").notNull().references(() => products.id, { onDelete: "cascade" }),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      // Variant details
      variantType: varchar("variant_type", { length: 50 }).notNull(),
      // size, color, scent, etc.
      variantValue: varchar("variant_value", { length: 100 }).notNull(),
      // 100ml, Red, Lavender, etc.
      skuSuffix: varchar("sku_suffix", { length: 20 }),
      // -100ML, -RED
      // Pricing override (if different from base product)
      priceAdjustmentPaisa: integer("price_adjustment_paisa").default(0),
      // +/- from base price
      // Stock
      stockQuantity: integer("stock_quantity").notNull().default(0),
      // Display
      displayOrder: integer("display_order").default(0),
      colorHex: varchar("color_hex", { length: 7 }),
      // For color variants: #FF5733
      imageUrl: text("image_url"),
      // Availability
      isActive: integer("is_active").notNull().default(1),
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("product_variants_product_id_idx").on(table.productId),
      index("product_variants_salon_id_idx").on(table.salonId),
      index("product_variants_active_idx").on(table.productId, table.isActive),
      unique("product_variants_salon_unique").on(table.salonId, table.productId, table.variantType, table.variantValue)
    ]);
    insertProductVariantSchema = createInsertSchema(productVariants).omit({
      id: true,
      createdAt: true
    });
    shoppingCarts = pgTable("shopping_carts", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      userId: varchar("user_id").references(() => users.id, { onDelete: "cascade" }),
      sessionId: varchar("session_id"),
      // For guest users
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      // Status
      status: varchar("status", { length: 20 }).notNull().default("active"),
      // active, abandoned, converted, expired
      // Timestamps
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow(),
      expiresAt: timestamp("expires_at").default(sql`NOW() + INTERVAL '30 days'`)
    }, (table) => [
      index("shopping_carts_user_id_idx").on(table.userId, table.status),
      index("shopping_carts_session_id_idx").on(table.sessionId, table.status),
      index("shopping_carts_expires_idx").on(table.expiresAt),
      check("shopping_carts_user_or_session", sql`${table.userId} IS NOT NULL OR ${table.sessionId} IS NOT NULL`)
    ]);
    insertShoppingCartSchema = createInsertSchema(shoppingCarts).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    cartItems = pgTable("cart_items", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      cartId: varchar("cart_id").notNull().references(() => shoppingCarts.id, { onDelete: "cascade" }),
      productId: varchar("product_id").notNull().references(() => products.id, { onDelete: "cascade" }),
      variantId: varchar("variant_id").references(() => productVariants.id, { onDelete: "set null" }),
      // Pricing (locked at time of adding to cart)
      priceAtAddPaisa: integer("price_at_add_paisa").notNull(),
      currentPricePaisa: integer("current_price_paisa").notNull(),
      // Updated when cart is loaded
      // Quantity
      quantity: integer("quantity").notNull().default(1),
      // Timestamps
      addedAt: timestamp("added_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("cart_items_cart_id_idx").on(table.cartId),
      index("cart_items_product_id_idx").on(table.productId),
      unique("cart_items_unique").on(table.cartId, table.productId, table.variantId),
      check("cart_items_quantity_positive", sql`${table.quantity} > 0`)
    ]);
    insertCartItemSchema = createInsertSchema(cartItems).omit({
      id: true,
      addedAt: true,
      updatedAt: true
    });
    productOrders = pgTable("product_orders", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      orderNumber: varchar("order_number", { length: 20 }).notNull().unique(),
      // Relationships
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "restrict" }),
      customerId: varchar("customer_id").notNull().references(() => users.id, { onDelete: "restrict" }),
      // Order details
      status: varchar("status", { length: 20 }).notNull().default("pending"),
      // pending, confirmed, packed, shipped, delivered, cancelled, refunded
      // Fulfillment
      fulfillmentType: varchar("fulfillment_type", { length: 20 }).notNull(),
      // delivery, salon_pickup
      deliveryAddressId: varchar("delivery_address_id").references(() => userSavedLocations.id),
      deliveryAddress: text("delivery_address"),
      // Snapshot of address at order time
      pickupCode: varchar("pickup_code", { length: 10 }),
      // For salon pickup: 6-digit code
      // Pricing (all in paisa)
      subtotalPaisa: integer("subtotal_paisa").notNull(),
      discountPaisa: integer("discount_paisa").default(0),
      deliveryChargePaisa: integer("delivery_charge_paisa").default(0),
      taxPaisa: integer("tax_paisa").notNull(),
      totalPaisa: integer("total_paisa").notNull(),
      currency: varchar("currency", { length: 3 }).notNull().default("INR"),
      // Payment
      paymentMethod: varchar("payment_method", { length: 50 }),
      // online, cod, wallet, pay_at_salon
      paymentStatus: varchar("payment_status", { length: 20 }).notNull().default("pending"),
      // pending, paid, failed, refunded
      paymentId: varchar("payment_id"),
      // Razorpay payment ID
      razorpayOrderId: varchar("razorpay_order_id"),
      walletAmountUsedPaisa: integer("wallet_amount_used_paisa").default(0),
      // Offers (offer system to be implemented separately)
      offerId: varchar("offer_id"),
      offerCode: varchar("offer_code", { length: 20 }),
      // Tracking
      trackingNumber: varchar("tracking_number", { length: 100 }),
      courierPartner: varchar("courier_partner", { length: 100 }),
      estimatedDeliveryDate: timestamp("estimated_delivery_date"),
      // Cancellation/Return
      cancellationReason: text("cancellation_reason"),
      cancelledAt: timestamp("cancelled_at"),
      cancelledBy: varchar("cancelled_by").references(() => users.id),
      // Platform commission
      commissionRate: decimal("commission_rate", { precision: 5, scale: 2 }).default("10.00"),
      commissionPaisa: integer("commission_paisa"),
      // Notes
      customerNotes: text("customer_notes"),
      adminNotes: text("admin_notes"),
      // Timestamps
      createdAt: timestamp("created_at").defaultNow(),
      confirmedAt: timestamp("confirmed_at"),
      packedAt: timestamp("packed_at"),
      shippedAt: timestamp("shipped_at"),
      deliveredAt: timestamp("delivered_at")
    }, (table) => [
      index("product_orders_salon_id_idx").on(table.salonId, table.status),
      index("product_orders_customer_id_idx").on(table.customerId, table.status),
      index("product_orders_status_idx").on(table.status, table.createdAt),
      index("product_orders_number_idx").on(table.orderNumber),
      check("product_orders_total_check", sql`${table.totalPaisa} = ${table.subtotalPaisa} - ${table.discountPaisa} + ${table.deliveryChargePaisa} + ${table.taxPaisa}`)
    ]);
    insertProductOrderSchema = createInsertSchema(productOrders).omit({
      id: true,
      createdAt: true,
      confirmedAt: true,
      packedAt: true,
      shippedAt: true,
      deliveredAt: true
    });
    productOrderItems = pgTable("product_order_items", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      orderId: varchar("order_id").notNull().references(() => productOrders.id, { onDelete: "cascade" }),
      productId: varchar("product_id").notNull().references(() => products.id, { onDelete: "restrict" }),
      variantId: varchar("variant_id").references(() => productVariants.id, { onDelete: "set null" }),
      // Snapshot at time of order (in case product is deleted/updated)
      productName: varchar("product_name", { length: 255 }).notNull(),
      productSku: varchar("product_sku", { length: 100 }),
      variantInfo: jsonb("variant_info"),
      // {type: "size", value: "100ml"}
      productImageUrl: text("product_image_url"),
      // Pricing
      unitPricePaisa: integer("unit_price_paisa").notNull(),
      quantity: integer("quantity").notNull(),
      discountPerItemPaisa: integer("discount_per_item_paisa").default(0),
      subtotalPaisa: integer("subtotal_paisa").notNull(),
      // Review
      reviewSubmitted: integer("review_submitted").notNull().default(0),
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("product_order_items_order_id_idx").on(table.orderId),
      index("product_order_items_product_id_idx").on(table.productId),
      check("product_order_items_quantity_positive", sql`${table.quantity} > 0`)
    ]);
    insertProductOrderItemSchema = createInsertSchema(productOrderItems).omit({
      id: true,
      createdAt: true
    });
    wishlists = pgTable("wishlists", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      productId: varchar("product_id").notNull().references(() => products.id, { onDelete: "cascade" }),
      variantId: varchar("variant_id").references(() => productVariants.id, { onDelete: "cascade" }),
      // Price tracking
      priceAtAddPaisa: integer("price_at_add_paisa").notNull(),
      // Notifications
      notifyOnPriceDrop: integer("notify_on_price_drop").notNull().default(1),
      notifyOnBackInStock: integer("notify_on_back_in_stock").notNull().default(1),
      addedAt: timestamp("added_at").defaultNow()
    }, (table) => [
      index("wishlists_user_id_idx").on(table.userId, table.addedAt),
      index("wishlists_product_id_idx").on(table.productId),
      unique("wishlists_unique").on(table.userId, table.productId, table.variantId)
    ]);
    insertWishlistSchema = createInsertSchema(wishlists).omit({
      id: true,
      addedAt: true
    });
    productReviews = pgTable("product_reviews", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      productId: varchar("product_id").notNull().references(() => products.id, { onDelete: "cascade" }),
      orderId: varchar("order_id").notNull().references(() => productOrders.id, { onDelete: "cascade" }),
      userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      // Review content
      rating: integer("rating").notNull(),
      // 1-5
      title: varchar("title", { length: 200 }),
      comment: text("comment"),
      // Media
      imageUrls: text("image_urls").array(),
      // Array of review images
      // Verification
      verifiedPurchase: integer("verified_purchase").notNull().default(1),
      // Moderation
      isVisible: integer("is_visible").notNull().default(1),
      moderationStatus: varchar("moderation_status", { length: 20 }).notNull().default("approved"),
      // pending, approved, rejected
      moderationReason: text("moderation_reason"),
      // Salon response
      salonResponse: text("salon_response"),
      salonRespondedAt: timestamp("salon_responded_at"),
      // Helpfulness
      helpfulCount: integer("helpful_count").default(0),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("product_reviews_product_id_idx").on(table.productId, table.isVisible, table.createdAt),
      index("product_reviews_user_id_idx").on(table.userId),
      index("product_reviews_salon_id_idx").on(table.salonId, table.moderationStatus),
      index("product_reviews_rating_idx").on(table.productId, table.rating),
      unique("product_reviews_unique").on(table.orderId, table.productId, table.userId),
      check("product_reviews_rating_range", sql`${table.rating} >= 1 AND ${table.rating} <= 5`)
    ]);
    insertProductReviewSchema = createInsertSchema(productReviews).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    deliverySettings = pgTable("delivery_settings", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().unique().references(() => salons.id, { onDelete: "cascade" }),
      // Delivery options
      enableHomeDelivery: integer("enable_home_delivery").notNull().default(0),
      enableSalonPickup: integer("enable_salon_pickup").notNull().default(1),
      // Delivery charges
      deliveryChargePaisa: integer("delivery_charge_paisa").default(5e3),
      // 50
      freeDeliveryAbovePaisa: integer("free_delivery_above_paisa").default(5e4),
      // 500
      // Delivery area
      deliveryRadiusKm: integer("delivery_radius_km").default(10),
      serviceablePincodes: text("serviceable_pincodes").array(),
      // Array of pincodes
      // Timing
      estimatedDeliveryDays: integer("estimated_delivery_days").default(3),
      pickupReadyHours: integer("pickup_ready_hours").default(24),
      // Return policy
      acceptReturns: integer("accept_returns").notNull().default(1),
      returnWindowDays: integer("return_window_days").default(7),
      returnConditions: text("return_conditions"),
      // Packaging
      packagingChargePaisa: integer("packaging_charge_paisa").default(0),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("delivery_settings_salon_id_idx").on(table.salonId)
    ]);
    insertDeliverySettingsSchema = createInsertSchema(deliverySettings).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    productViews = pgTable("product_views", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      productId: varchar("product_id").notNull().references(() => products.id, { onDelete: "cascade" }),
      userId: varchar("user_id").references(() => users.id, { onDelete: "set null" }),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      sessionId: varchar("session_id"),
      // For anonymous users
      viewedAt: timestamp("viewed_at").defaultNow()
    }, (table) => [
      index("product_views_product_id_idx").on(table.productId, table.viewedAt),
      index("product_views_user_id_idx").on(table.userId),
      index("product_views_salon_id_idx").on(table.salonId, table.viewedAt)
    ]);
    insertProductViewSchema = createInsertSchema(productViews).omit({
      id: true,
      viewedAt: true
    });
    addToCartSchema = z.object({
      salonId: z.string().uuid(),
      productId: z.string().uuid(),
      variantId: z.string().uuid().optional(),
      quantity: z.number().int().min(1).max(100)
    });
    updateCartItemSchema = z.object({
      quantity: z.number().int().min(0).max(100)
    });
    createProductOrderSchema = z.object({
      salonId: z.string().uuid().optional(),
      // Optional - will be derived from cart items
      cartId: z.string().optional(),
      // Optional - supports virtual "combined" cart
      addressId: z.string().uuid().optional(),
      // For existing saved addresses
      fulfillmentType: z.enum(["delivery", "pickup"]),
      deliveryAddress: z.union([z.string(), z.object({
        fullName: z.string(),
        phone: z.string(),
        addressLine1: z.string(),
        addressLine2: z.string().optional(),
        city: z.string(),
        state: z.string(),
        pincode: z.string()
      })]).optional(),
      paymentMethod: z.enum(["cod", "online", "upi", "razorpay", "pay_at_salon"]).default("cod"),
      razorpayPaymentId: z.string().optional(),
      razorpayOrderId: z.string().optional(),
      razorpaySignature: z.string().optional()
    });
    cancelOrderSchema = z.object({
      reason: z.string().max(500).optional()
    });
    addToWishlistSchema = z.object({
      productId: z.string().uuid(),
      variantId: z.string().uuid().optional()
    });
    createReviewSchema = z.object({
      orderId: z.string().uuid().optional(),
      rating: z.number().int().min(1).max(5),
      title: z.string().max(200).optional(),
      reviewText: z.string().max(2e3).optional(),
      images: z.array(z.string().url()).max(5).optional()
    });
    trackProductViewSchema = z.object({
      sessionId: z.string().max(100).optional()
    });
    configureRetailSchema = z.object({
      availableForRetail: z.boolean(),
      retailPriceInPaisa: z.number().int().positive().optional(),
      retailStockAllocated: z.number().int().min(0).optional(),
      retailDescription: z.string().optional(),
      retailImageUrls: z.array(z.string().url()).optional(),
      featured: z.boolean().optional(),
      metaTitle: z.string().max(200).optional(),
      metaDescription: z.string().max(500).optional(),
      searchKeywords: z.array(z.string()).optional()
    });
    updateOrderStatusSchema = z.object({
      status: z.enum(["pending", "confirmed", "processing", "shipped", "out_for_delivery", "delivered", "cancelled", "refunded"]),
      trackingNumber: z.string().max(100).optional(),
      courierPartner: z.string().max(100).optional(),
      estimatedDeliveryDate: z.string().optional(),
      // ISO date string
      notes: z.string().optional()
    });
    cancelOrderAdminSchema = z.object({
      reason: z.string().min(1, "Cancellation reason is required"),
      refundAmountPaisa: z.number().int().positive().optional()
    });
    updateDeliverySettingsSchema = z.object({
      salonPickupEnabled: z.number().int().min(0).max(1).optional(),
      homeDeliveryEnabled: z.number().int().min(0).max(1).optional(),
      freeDeliveryThresholdPaisa: z.number().int().min(0).optional(),
      baseDeliveryChargePaisa: z.number().int().min(0).optional(),
      maxDeliveryRadiusKm: z.number().min(0).optional(),
      estimatedPickupMinutes: z.number().int().min(0).optional(),
      estimatedDeliveryMinutes: z.number().int().min(0).optional(),
      deliveryInstructions: z.string().optional()
    });
    eventTypes = pgTable("event_types", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      name: varchar("name", { length: 50 }).notNull(),
      description: text("description"),
      icon: varchar("icon", { length: 50 }),
      color: varchar("color", { length: 20 }),
      isActive: integer("is_active").notNull().default(1),
      orderIndex: integer("order_index").default(0),
      createdAt: timestamp("created_at").defaultNow()
    });
    insertEventTypeSchema = createInsertSchema(eventTypes).omit({
      id: true,
      createdAt: true
    });
    events = pgTable("events", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      organizationId: varchar("organization_id").references(() => organizations.id),
      createdBy: varchar("created_by").notNull().references(() => users.id),
      title: varchar("title", { length: 200 }).notNull(),
      slug: varchar("slug", { length: 200 }).unique(),
      description: text("description"),
      shortDescription: varchar("short_description", { length: 500 }),
      eventTypeId: varchar("event_type_id").references(() => eventTypes.id),
      startDate: varchar("start_date", { length: 10 }).notNull(),
      endDate: varchar("end_date", { length: 10 }),
      startTime: varchar("start_time", { length: 8 }).notNull(),
      endTime: varchar("end_time", { length: 8 }).notNull(),
      timezone: varchar("timezone", { length: 50 }).default("Asia/Kolkata"),
      durationMinutes: integer("duration_minutes"),
      venueType: varchar("venue_type", { length: 20 }).default("salon"),
      venueName: varchar("venue_name", { length: 200 }),
      venueAddress: text("venue_address"),
      venueCity: varchar("venue_city", { length: 100 }),
      venueState: varchar("venue_state", { length: 100 }),
      venuePincode: varchar("venue_pincode", { length: 10 }),
      venueLatitude: decimal("venue_latitude", { precision: 9, scale: 6 }),
      venueLongitude: decimal("venue_longitude", { precision: 9, scale: 6 }),
      venueInstructions: text("venue_instructions"),
      maxCapacity: integer("max_capacity").notNull().default(20),
      currentRegistrations: integer("current_registrations").default(0),
      minCapacity: integer("min_capacity").default(1),
      registrationStartDate: varchar("registration_start_date", { length: 10 }),
      registrationEndDate: varchar("registration_end_date", { length: 10 }),
      status: varchar("status", { length: 20 }).default("draft"),
      visibility: varchar("visibility", { length: 20 }).default("public"),
      isFeatured: integer("is_featured").default(0),
      coverImageUrl: text("cover_image_url"),
      galleryImages: jsonb("gallery_images").default(sql`'[]'::jsonb`),
      videoUrl: text("video_url"),
      metaTitle: varchar("meta_title", { length: 200 }),
      metaDescription: varchar("meta_description", { length: 500 }),
      socialLinks: jsonb("social_links").default(sql`'{}'::jsonb`),
      cancellationPolicy: jsonb("cancellation_policy").default(sql`'{"7_plus_days": 100, "3_to_6_days": 75, "1_to_2_days": 50, "same_day": 0}'::jsonb`),
      termsConditions: text("terms_conditions"),
      publishedAt: timestamp("published_at"),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("events_salon_id_idx").on(table.salonId),
      index("events_status_idx").on(table.status),
      index("events_start_date_idx").on(table.startDate)
    ]);
    insertEventSchema = createInsertSchema(events).omit({
      id: true,
      currentRegistrations: true,
      publishedAt: true,
      createdAt: true,
      updatedAt: true
    });
    eventSpeakers = pgTable("event_speakers", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      eventId: varchar("event_id").notNull().references(() => events.id, { onDelete: "cascade" }),
      userId: varchar("user_id").references(() => users.id),
      name: varchar("name", { length: 200 }).notNull(),
      title: varchar("title", { length: 200 }),
      bio: text("bio"),
      photoUrl: text("photo_url"),
      credentials: text("credentials"),
      socialLinks: jsonb("social_links").default(sql`'{}'::jsonb`),
      orderIndex: integer("order_index").default(0),
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("event_speakers_event_id_idx").on(table.eventId)
    ]);
    insertEventSpeakerSchema = createInsertSchema(eventSpeakers).omit({
      id: true,
      createdAt: true
    });
    eventSchedules = pgTable("event_schedules", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      eventId: varchar("event_id").notNull().references(() => events.id, { onDelete: "cascade" }),
      title: varchar("title", { length: 200 }).notNull(),
      description: text("description"),
      startTime: varchar("start_time", { length: 8 }).notNull(),
      endTime: varchar("end_time", { length: 8 }).notNull(),
      speakerId: varchar("speaker_id").references(() => eventSpeakers.id),
      orderIndex: integer("order_index").default(0),
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("event_schedules_event_id_idx").on(table.eventId)
    ]);
    insertEventScheduleSchema = createInsertSchema(eventSchedules).omit({
      id: true,
      createdAt: true
    });
    eventTicketTypes = pgTable("event_ticket_types", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      eventId: varchar("event_id").notNull().references(() => events.id, { onDelete: "cascade" }),
      name: varchar("name", { length: 100 }).notNull(),
      description: text("description"),
      basePricePaisa: integer("base_price_paisa").notNull(),
      gstPercentage: decimal("gst_percentage", { precision: 5, scale: 2 }).default("18.00"),
      quantityAvailable: integer("quantity_available"),
      quantitySold: integer("quantity_sold").default(0),
      saleStartDate: timestamp("sale_start_date"),
      saleEndDate: timestamp("sale_end_date"),
      discountPercentage: decimal("discount_percentage", { precision: 5, scale: 2 }).default("0"),
      discountLabel: varchar("discount_label", { length: 50 }),
      includes: jsonb("includes").default(sql`'[]'::jsonb`),
      isActive: integer("is_active").default(1),
      orderIndex: integer("order_index").default(0),
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("event_ticket_types_event_id_idx").on(table.eventId)
    ]);
    insertEventTicketTypeSchema = createInsertSchema(eventTicketTypes).omit({
      id: true,
      quantitySold: true,
      createdAt: true
    });
    eventGroupDiscounts = pgTable("event_group_discounts", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      eventId: varchar("event_id").notNull().references(() => events.id, { onDelete: "cascade" }),
      minGroupSize: integer("min_group_size").notNull(),
      maxGroupSize: integer("max_group_size"),
      discountPercentage: decimal("discount_percentage", { precision: 5, scale: 2 }).notNull(),
      isActive: integer("is_active").default(1),
      createdAt: timestamp("created_at").defaultNow()
    });
    insertEventGroupDiscountSchema = createInsertSchema(eventGroupDiscounts).omit({
      id: true,
      createdAt: true
    });
    eventPromoCodes = pgTable("event_promo_codes", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      eventId: varchar("event_id").references(() => events.id, { onDelete: "cascade" }),
      code: varchar("code", { length: 50 }).notNull().unique(),
      discountType: varchar("discount_type", { length: 20 }).notNull(),
      discountValue: decimal("discount_value", { precision: 10, scale: 2 }).notNull(),
      maxUses: integer("max_uses"),
      currentUses: integer("current_uses").default(0),
      minOrderAmountPaisa: integer("min_order_amount_paisa"),
      validFrom: timestamp("valid_from"),
      validUntil: timestamp("valid_until"),
      isActive: integer("is_active").default(1),
      createdAt: timestamp("created_at").defaultNow()
    });
    insertEventPromoCodeSchema = createInsertSchema(eventPromoCodes).omit({
      id: true,
      currentUses: true,
      createdAt: true
    });
    eventRegistrations = pgTable("event_registrations", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      eventId: varchar("event_id").notNull().references(() => events.id),
      userId: varchar("user_id").references(() => users.id),
      ticketTypeId: varchar("ticket_type_id").notNull().references(() => eventTicketTypes.id),
      bookingId: varchar("booking_id", { length: 20 }).notNull().unique(),
      attendeeName: varchar("attendee_name", { length: 200 }).notNull(),
      attendeeEmail: varchar("attendee_email", { length: 255 }).notNull(),
      attendeePhone: varchar("attendee_phone", { length: 20 }).notNull(),
      attendeeAgeGroup: varchar("attendee_age_group", { length: 20 }),
      experienceLevel: varchar("experience_level", { length: 20 }),
      dietaryPreference: varchar("dietary_preference", { length: 50 }),
      specialRequirements: text("special_requirements"),
      ticketPricePaisa: integer("ticket_price_paisa").notNull(),
      discountAmountPaisa: integer("discount_amount_paisa").default(0),
      promoCodeId: varchar("promo_code_id").references(() => eventPromoCodes.id),
      gstAmountPaisa: integer("gst_amount_paisa").notNull(),
      totalAmountPaisa: integer("total_amount_paisa").notNull(),
      status: varchar("status", { length: 20 }).default("pending"),
      paymentStatus: varchar("payment_status", { length: 20 }).default("pending"),
      paymentOrderId: varchar("payment_order_id", { length: 100 }),
      paymentTransactionId: varchar("payment_transaction_id", { length: 100 }),
      qrCodeData: varchar("qr_code_data", { length: 255 }).unique(),
      checkedInAt: timestamp("checked_in_at"),
      checkedInBy: varchar("checked_in_by").references(() => users.id),
      cancelledAt: timestamp("cancelled_at"),
      cancellationReason: text("cancellation_reason"),
      refundAmountPaisa: integer("refund_amount_paisa"),
      refundStatus: varchar("refund_status", { length: 20 }),
      refundProcessedAt: timestamp("refund_processed_at"),
      expiresAt: timestamp("expires_at"),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("event_registrations_event_id_idx").on(table.eventId),
      index("event_registrations_user_id_idx").on(table.userId),
      index("event_registrations_booking_id_idx").on(table.bookingId),
      index("event_registrations_status_idx").on(table.status),
      index("event_registrations_expires_at_idx").on(table.expiresAt)
    ]);
    insertEventRegistrationSchema = createInsertSchema(eventRegistrations).omit({
      id: true,
      qrCodeData: true,
      checkedInAt: true,
      checkedInBy: true,
      cancelledAt: true,
      cancellationReason: true,
      refundAmountPaisa: true,
      refundStatus: true,
      refundProcessedAt: true,
      createdAt: true,
      updatedAt: true
    });
    eventRegistrationPayments = pgTable("event_registration_payments", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      registrationId: varchar("registration_id").notNull().references(() => eventRegistrations.id),
      amountPaisa: integer("amount_paisa").notNull(),
      paymentMethod: varchar("payment_method", { length: 50 }),
      paymentProvider: varchar("payment_provider", { length: 50 }),
      providerOrderId: varchar("provider_order_id", { length: 100 }),
      providerPaymentId: varchar("provider_payment_id", { length: 100 }),
      providerSignature: varchar("provider_signature", { length: 255 }),
      status: varchar("status", { length: 20 }).default("pending"),
      paymentMetadata: jsonb("payment_metadata").default(sql`'{}'::jsonb`),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("event_registration_payments_registration_id_idx").on(table.registrationId)
    ]);
    insertEventRegistrationPaymentSchema = createInsertSchema(eventRegistrationPayments).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    eventReviews = pgTable("event_reviews", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      eventId: varchar("event_id").notNull().references(() => events.id),
      registrationId: varchar("registration_id").notNull().references(() => eventRegistrations.id),
      userId: varchar("user_id").notNull().references(() => users.id),
      overallRating: integer("overall_rating").notNull(),
      instructorRating: integer("instructor_rating"),
      contentRating: integer("content_rating"),
      venueRating: integer("venue_rating"),
      valueRating: integer("value_rating"),
      organizationRating: integer("organization_rating"),
      likedAspects: jsonb("liked_aspects").default(sql`'[]'::jsonb`),
      reviewText: text("review_text"),
      reviewPhotos: jsonb("review_photos").default(sql`'[]'::jsonb`),
      status: varchar("status", { length: 20 }).default("pending"),
      moderatedBy: varchar("moderated_by").references(() => users.id),
      moderatedAt: timestamp("moderated_at"),
      isFeatured: integer("is_featured").default(0),
      helpfulCount: integer("helpful_count").default(0),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("event_reviews_event_id_idx").on(table.eventId),
      index("event_reviews_user_id_idx").on(table.userId)
    ]);
    insertEventReviewSchema = createInsertSchema(eventReviews).omit({
      id: true,
      status: true,
      moderatedBy: true,
      moderatedAt: true,
      isFeatured: true,
      helpfulCount: true,
      createdAt: true,
      updatedAt: true
    });
    eventNotifications = pgTable("event_notifications", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      userId: varchar("user_id").notNull().references(() => users.id),
      eventId: varchar("event_id").references(() => events.id),
      registrationId: varchar("registration_id").references(() => eventRegistrations.id),
      type: varchar("type", { length: 50 }).notNull(),
      category: varchar("category", { length: 30 }).notNull(),
      priority: varchar("priority", { length: 10 }).default("normal"),
      title: varchar("title", { length: 200 }).notNull(),
      message: text("message").notNull(),
      actionUrl: varchar("action_url", { length: 500 }),
      isRead: integer("is_read").default(0),
      readAt: timestamp("read_at"),
      channels: jsonb("channels").default(sql`'["in_app"]'::jsonb`),
      deliveredAt: timestamp("delivered_at"),
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("event_notifications_user_id_idx").on(table.userId),
      index("event_notifications_event_id_idx").on(table.eventId)
    ]);
    insertEventNotificationSchema = createInsertSchema(eventNotifications).omit({
      id: true,
      isRead: true,
      readAt: true,
      deliveredAt: true,
      createdAt: true
    });
    eventNotificationPreferences = pgTable("event_notification_preferences", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      userId: varchar("user_id").notNull().references(() => users.id).unique(),
      emailNewRegistration: integer("email_new_registration").default(1),
      emailEventReminder: integer("email_event_reminder").default(1),
      emailLowAttendance: integer("email_low_attendance").default(1),
      emailCancellation: integer("email_cancellation").default(1),
      pushNewRegistration: integer("push_new_registration").default(1),
      pushEventReminder: integer("push_event_reminder").default(1),
      pushLowAttendance: integer("push_low_attendance").default(1),
      pushCancellation: integer("push_cancellation").default(1),
      smsEventReminder: integer("sms_event_reminder").default(0),
      smsCancellation: integer("sms_cancellation").default(0),
      updatedAt: timestamp("updated_at").defaultNow()
    });
    insertEventNotificationPreferencesSchema = createInsertSchema(eventNotificationPreferences).omit({
      id: true,
      updatedAt: true
    });
    eventAnalyticsDaily = pgTable("event_analytics_daily", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      eventId: varchar("event_id").notNull().references(() => events.id),
      date: varchar("date", { length: 10 }).notNull(),
      totalRegistrations: integer("total_registrations").default(0),
      newRegistrations: integer("new_registrations").default(0),
      cancellations: integer("cancellations").default(0),
      totalRevenuePaisa: integer("total_revenue_paisa").default(0),
      refundsPaisa: integer("refunds_paisa").default(0),
      pageViews: integer("page_views").default(0),
      uniqueVisitors: integer("unique_visitors").default(0),
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("event_analytics_daily_event_id_idx").on(table.eventId),
      uniqueIndex("event_analytics_daily_event_date_unique").on(table.eventId, table.date)
    ]);
    insertEventAnalyticsDailySchema = createInsertSchema(eventAnalyticsDaily).omit({
      id: true,
      createdAt: true
    });
    eventViews = pgTable("event_views", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      eventId: varchar("event_id").notNull().references(() => events.id),
      userId: varchar("user_id").references(() => users.id),
      sessionId: varchar("session_id", { length: 100 }),
      source: varchar("source", { length: 50 }),
      platform: varchar("platform", { length: 20 }),
      referrer: text("referrer"),
      deviceType: varchar("device_type", { length: 20 }),
      browser: varchar("browser", { length: 50 }),
      os: varchar("os", { length: 50 }),
      viewedAt: timestamp("viewed_at").defaultNow()
    }, (table) => [
      index("event_views_event_id_idx").on(table.eventId),
      index("event_views_viewed_at_idx").on(table.viewedAt)
    ]);
    insertEventViewSchema = createInsertSchema(eventViews).omit({
      id: true,
      viewedAt: true
    });
    eventTypesRelations = relations(eventTypes, ({ many }) => ({
      events: many(events)
    }));
    eventsRelations = relations(events, ({ one, many }) => ({
      salon: one(salons, {
        fields: [events.salonId],
        references: [salons.id]
      }),
      organization: one(organizations, {
        fields: [events.organizationId],
        references: [organizations.id]
      }),
      creator: one(users, {
        fields: [events.createdBy],
        references: [users.id]
      }),
      eventType: one(eventTypes, {
        fields: [events.eventTypeId],
        references: [eventTypes.id]
      }),
      speakers: many(eventSpeakers),
      schedules: many(eventSchedules),
      ticketTypes: many(eventTicketTypes),
      groupDiscounts: many(eventGroupDiscounts),
      registrations: many(eventRegistrations),
      reviews: many(eventReviews),
      notifications: many(eventNotifications),
      analyticsDaily: many(eventAnalyticsDaily),
      views: many(eventViews)
    }));
    eventSpeakersRelations = relations(eventSpeakers, ({ one, many }) => ({
      event: one(events, {
        fields: [eventSpeakers.eventId],
        references: [events.id]
      }),
      user: one(users, {
        fields: [eventSpeakers.userId],
        references: [users.id]
      }),
      schedules: many(eventSchedules)
    }));
    eventSchedulesRelations = relations(eventSchedules, ({ one }) => ({
      event: one(events, {
        fields: [eventSchedules.eventId],
        references: [events.id]
      }),
      speaker: one(eventSpeakers, {
        fields: [eventSchedules.speakerId],
        references: [eventSpeakers.id]
      })
    }));
    eventTicketTypesRelations = relations(eventTicketTypes, ({ one, many }) => ({
      event: one(events, {
        fields: [eventTicketTypes.eventId],
        references: [events.id]
      }),
      registrations: many(eventRegistrations)
    }));
    eventRegistrationsRelations = relations(eventRegistrations, ({ one, many }) => ({
      event: one(events, {
        fields: [eventRegistrations.eventId],
        references: [events.id]
      }),
      user: one(users, {
        fields: [eventRegistrations.userId],
        references: [users.id]
      }),
      ticketType: one(eventTicketTypes, {
        fields: [eventRegistrations.ticketTypeId],
        references: [eventTicketTypes.id]
      }),
      promoCode: one(eventPromoCodes, {
        fields: [eventRegistrations.promoCodeId],
        references: [eventPromoCodes.id]
      }),
      payments: many(eventRegistrationPayments),
      reviews: many(eventReviews)
    }));
    eventRegistrationPaymentsRelations = relations(eventRegistrationPayments, ({ one }) => ({
      registration: one(eventRegistrations, {
        fields: [eventRegistrationPayments.registrationId],
        references: [eventRegistrations.id]
      })
    }));
    eventReviewsRelations = relations(eventReviews, ({ one }) => ({
      event: one(events, {
        fields: [eventReviews.eventId],
        references: [events.id]
      }),
      registration: one(eventRegistrations, {
        fields: [eventReviews.registrationId],
        references: [eventRegistrations.id]
      }),
      user: one(users, {
        fields: [eventReviews.userId],
        references: [users.id]
      })
    }));
    createEventSchema = z.object({
      salonId: z.string().uuid(),
      title: z.string().min(1).max(200),
      description: z.string().optional(),
      shortDescription: z.string().max(500).optional(),
      eventTypeId: z.string().uuid().optional(),
      startDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/),
      endDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/).optional(),
      startTime: z.string().regex(/^\d{2}:\d{2}(:\d{2})?$/),
      endTime: z.string().regex(/^\d{2}:\d{2}(:\d{2})?$/),
      venueType: z.enum(["salon", "external", "online"]).default("salon"),
      venueName: z.string().max(200).optional(),
      venueAddress: z.string().optional(),
      venueCity: z.string().max(100).optional(),
      venueState: z.string().max(100).optional(),
      venuePincode: z.string().max(10).optional(),
      venueLatitude: z.number().optional(),
      venueLongitude: z.number().optional(),
      maxCapacity: z.number().int().min(1).default(20),
      minCapacity: z.number().int().min(1).default(1),
      visibility: z.enum(["public", "private", "invite_only"]).default("public"),
      coverImageUrl: z.string().url().optional(),
      galleryImages: z.array(z.string().url()).optional(),
      cancellationPolicy: z.object({
        "7_plus_days": z.number().min(0).max(100),
        "3_to_6_days": z.number().min(0).max(100),
        "1_to_2_days": z.number().min(0).max(100),
        "same_day": z.number().min(0).max(100)
      }).optional()
    });
    updateEventSchema = createEventSchema.partial();
    createTicketTypeSchema = z.object({
      eventId: z.string().uuid(),
      name: z.string().min(1).max(100),
      description: z.string().optional(),
      basePricePaisa: z.number().int().min(0),
      gstPercentage: z.number().min(0).max(100).default(18),
      quantityAvailable: z.number().int().min(1).optional(),
      saleStartDate: z.string().optional(),
      saleEndDate: z.string().optional(),
      discountPercentage: z.number().min(0).max(100).default(0),
      discountLabel: z.string().max(50).optional(),
      includes: z.array(z.string()).optional()
    });
    eventRegistrationSchema = z.object({
      eventId: z.string().uuid(),
      ticketTypeId: z.string().uuid(),
      attendeeName: z.string().min(1).max(200),
      attendeeEmail: z.string().email(),
      attendeePhone: z.string().min(10).max(20),
      attendeeAgeGroup: z.string().max(20).optional(),
      experienceLevel: z.enum(["beginner", "intermediate", "advanced"]).optional(),
      dietaryPreference: z.string().max(50).optional(),
      specialRequirements: z.string().max(500).optional(),
      promoCode: z.string().max(50).optional()
    });
    eventReviewSchema = z.object({
      eventId: z.string().uuid(),
      registrationId: z.string().uuid(),
      overallRating: z.number().int().min(1).max(5),
      instructorRating: z.number().int().min(1).max(5).optional(),
      contentRating: z.number().int().min(1).max(5).optional(),
      venueRating: z.number().int().min(1).max(5).optional(),
      valueRating: z.number().int().min(1).max(5).optional(),
      organizationRating: z.number().int().min(1).max(5).optional(),
      likedAspects: z.array(z.string()).optional(),
      reviewText: z.string().max(2e3).optional(),
      reviewPhotos: z.array(z.string().url()).max(5).optional()
    });
    cancelRegistrationSchema = z.object({
      reason: z.string().max(500).optional()
    });
    userNotifications = pgTable("user_notifications", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      title: text("title").notNull(),
      message: text("message").notNull(),
      type: varchar("type", { length: 50 }).notNull(),
      // booking, payment, wallet, promo, system
      referenceId: varchar("reference_id"),
      // bookingId, orderId, etc.
      referenceType: varchar("reference_type", { length: 50 }),
      // booking, order, wallet, etc.
      isRead: integer("is_read").notNull().default(0),
      readAt: timestamp("read_at"),
      imageUrl: varchar("image_url"),
      actionUrl: varchar("action_url"),
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("user_notifications_user_id_idx").on(table.userId),
      index("user_notifications_created_at_idx").on(table.createdAt)
    ]);
    insertUserNotificationSchema = createInsertSchema(userNotifications).omit({
      id: true,
      createdAt: true
    });
    userPushTokens = pgTable("user_push_tokens", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      token: text("token").notNull(),
      platform: varchar("platform", { length: 20 }).notNull().default("unknown"),
      // ios, android, web
      deviceId: varchar("device_id", { length: 255 }),
      deviceName: varchar("device_name", { length: 255 }),
      isActive: integer("is_active").notNull().default(1),
      lastUsedAt: timestamp("last_used_at").defaultNow(),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("user_push_tokens_user_id_idx").on(table.userId),
      index("user_push_tokens_token_idx").on(table.token)
    ]);
    loyaltyTiers = pgTable("loyalty_tiers", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      name: varchar("name", { length: 50 }).notNull().unique(),
      // bronze, silver, gold, platinum
      displayName: varchar("display_name", { length: 100 }).notNull(),
      // Bronze, Silver, Gold, Platinum
      minPoints: integer("min_points").notNull().default(0),
      // Minimum points to reach this tier
      maxPoints: integer("max_points"),
      // Maximum points for this tier (null for highest tier)
      pointsMultiplier: decimal("points_multiplier", { precision: 3, scale: 2 }).notNull().default("1.00"),
      // Points earned multiplier
      discountPercentage: decimal("discount_percentage", { precision: 5, scale: 2 }).notNull().default("0.00"),
      // Discount on bookings
      benefits: jsonb("benefits").default("[]"),
      // Array of benefit descriptions
      iconUrl: varchar("icon_url"),
      // Tier badge icon
      colorHex: varchar("color_hex", { length: 7 }).default("#CD7F32"),
      // Bronze color by default
      sortOrder: integer("sort_order").notNull().default(0),
      isActive: integer("is_active").notNull().default(1),
      createdAt: timestamp("created_at").defaultNow()
    });
    userPoints = pgTable("user_points", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }).unique(),
      currentPoints: integer("current_points").notNull().default(0),
      // Redeemable points
      lifetimePoints: integer("lifetime_points").notNull().default(0),
      // Total points ever earned (for tier calculation)
      currentTierId: varchar("current_tier_id").references(() => loyaltyTiers.id),
      tierExpiresAt: timestamp("tier_expires_at"),
      // When current tier status expires
      lastPointsEarnedAt: timestamp("last_points_earned_at"),
      lastPointsRedeemedAt: timestamp("last_points_redeemed_at"),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("user_points_user_id_idx").on(table.userId),
      index("user_points_lifetime_points_idx").on(table.lifetimePoints)
    ]);
    pointTransactions = pgTable("point_transactions", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      type: varchar("type", { length: 20 }).notNull(),
      // earn, redeem, expire, bonus, referral
      points: integer("points").notNull(),
      // Positive for earn, negative for redeem/expire
      balanceAfter: integer("balance_after").notNull(),
      // Points balance after this transaction
      source: varchar("source", { length: 50 }).notNull(),
      // booking, review, referral, promotion, birthday, signup
      referenceId: varchar("reference_id"),
      // bookingId, reviewId, etc.
      referenceType: varchar("reference_type", { length: 50 }),
      // booking, review, referral, reward
      description: text("description").notNull(),
      // Human readable description
      expiresAt: timestamp("expires_at"),
      // When these points expire (for earned points)
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("point_transactions_user_id_idx").on(table.userId),
      index("point_transactions_created_at_idx").on(table.createdAt),
      index("point_transactions_type_idx").on(table.type)
    ]);
    rewards = pgTable("rewards", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      name: varchar("name", { length: 200 }).notNull(),
      description: text("description"),
      shortDescription: varchar("short_description", { length: 200 }),
      pointsCost: integer("points_cost").notNull(),
      // Points required to redeem
      rewardType: varchar("reward_type", { length: 50 }).notNull(),
      // discount, free_service, product, voucher, experience
      rewardValue: integer("reward_value"),
      // Value in paisa for discounts/vouchers
      rewardPercentage: decimal("reward_percentage", { precision: 5, scale: 2 }),
      // Percentage discount
      category: varchar("category", { length: 50 }),
      // hair, spa, nails, makeup, products
      imageUrl: varchar("image_url"),
      termsConditions: text("terms_conditions"),
      validityDays: integer("validity_days").default(30),
      // Days until reward expires after redemption
      minTierRequired: varchar("min_tier_required").references(() => loyaltyTiers.id),
      // Minimum tier to redeem
      maxRedemptionsPerUser: integer("max_redemptions_per_user"),
      // Limit per user
      totalQuantity: integer("total_quantity"),
      // Total available (null = unlimited)
      redeemedCount: integer("redeemed_count").notNull().default(0),
      isActive: integer("is_active").notNull().default(1),
      startDate: timestamp("start_date"),
      endDate: timestamp("end_date"),
      sortOrder: integer("sort_order").notNull().default(0),
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("rewards_points_cost_idx").on(table.pointsCost),
      index("rewards_reward_type_idx").on(table.rewardType),
      index("rewards_is_active_idx").on(table.isActive)
    ]);
    userRedeemedRewards = pgTable("user_redeemed_rewards", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      rewardId: varchar("reward_id").notNull().references(() => rewards.id, { onDelete: "cascade" }),
      pointsSpent: integer("points_spent").notNull(),
      redemptionCode: varchar("redemption_code", { length: 20 }).notNull().unique(),
      // Unique code for this redemption
      status: varchar("status", { length: 20 }).notNull().default("active"),
      // active, used, expired, cancelled
      usedAt: timestamp("used_at"),
      usedAtSalonId: varchar("used_at_salon_id").references(() => salons.id),
      usedAtBookingId: varchar("used_at_booking_id"),
      expiresAt: timestamp("expires_at").notNull(),
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("user_redeemed_rewards_user_id_idx").on(table.userId),
      index("user_redeemed_rewards_status_idx").on(table.status),
      index("user_redeemed_rewards_expires_at_idx").on(table.expiresAt)
    ]);
    favoriteSalons = pgTable("favorite_salons", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("favorite_salons_user_id_idx").on(table.userId),
      index("favorite_salons_salon_id_idx").on(table.salonId),
      uniqueIndex("favorite_salons_user_salon_unique").on(table.userId, table.salonId)
    ]);
    favoriteStylists = pgTable("favorite_stylists", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      staffId: varchar("staff_id").notNull().references(() => staff.id, { onDelete: "cascade" }),
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("favorite_stylists_user_id_idx").on(table.userId),
      index("favorite_stylists_staff_id_idx").on(table.staffId),
      uniqueIndex("favorite_stylists_user_staff_unique").on(table.userId, table.staffId)
    ]);
    referralCodes = pgTable("referral_codes", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }).unique(),
      code: varchar("code", { length: 20 }).notNull().unique(),
      // e.g., JOHN2024, BEAUTY123
      referrerRewardPoints: integer("referrer_reward_points").notNull().default(200),
      // Points for referrer
      refereeRewardPoints: integer("referee_reward_points").notNull().default(100),
      // Points for new user
      refereeDiscountPercentage: decimal("referee_discount_percentage", { precision: 5, scale: 2 }).default("10.00"),
      // Discount for first booking
      maxUses: integer("max_uses"),
      // Maximum times this code can be used (null = unlimited)
      usedCount: integer("used_count").notNull().default(0),
      isActive: integer("is_active").notNull().default(1),
      expiresAt: timestamp("expires_at"),
      // Optional expiry date
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("referral_codes_code_idx").on(table.code),
      index("referral_codes_user_id_idx").on(table.userId)
    ]);
    referrals = pgTable("referrals", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      referrerId: varchar("referrer_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      // User who referred
      refereeId: varchar("referee_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      // New user who signed up
      referralCodeId: varchar("referral_code_id").notNull().references(() => referralCodes.id, { onDelete: "cascade" }),
      status: varchar("status", { length: 20 }).notNull().default("pending"),
      // pending, completed, rewarded, expired
      referrerPointsAwarded: integer("referrer_points_awarded").default(0),
      // Points given to referrer
      refereePointsAwarded: integer("referee_points_awarded").default(0),
      // Points given to referee
      refereeFirstBookingId: varchar("referee_first_booking_id"),
      // First booking by referred user
      refereeFirstBookingAt: timestamp("referee_first_booking_at"),
      rewardedAt: timestamp("rewarded_at"),
      // When both parties were rewarded
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("referrals_referrer_id_idx").on(table.referrerId),
      index("referrals_referee_id_idx").on(table.refereeId),
      index("referrals_status_idx").on(table.status),
      uniqueIndex("referrals_referee_unique").on(table.refereeId)
      // Each user can only be referred once
    ]);
    referralCodesRelations = relations(referralCodes, ({ one, many }) => ({
      user: one(users, {
        fields: [referralCodes.userId],
        references: [users.id]
      }),
      referrals: many(referrals)
    }));
    referralsRelations = relations(referrals, ({ one }) => ({
      referrer: one(users, {
        fields: [referrals.referrerId],
        references: [users.id],
        relationName: "referrer"
      }),
      referee: one(users, {
        fields: [referrals.refereeId],
        references: [users.id],
        relationName: "referee"
      }),
      referralCode: one(referralCodes, {
        fields: [referrals.referralCodeId],
        references: [referralCodes.id]
      })
    }));
    userPointsRelations = relations(userPoints, ({ one }) => ({
      user: one(users, {
        fields: [userPoints.userId],
        references: [users.id]
      }),
      currentTier: one(loyaltyTiers, {
        fields: [userPoints.currentTierId],
        references: [loyaltyTiers.id]
      })
    }));
    pointTransactionsRelations = relations(pointTransactions, ({ one }) => ({
      user: one(users, {
        fields: [pointTransactions.userId],
        references: [users.id]
      })
    }));
    userRedeemedRewardsRelations = relations(userRedeemedRewards, ({ one }) => ({
      user: one(users, {
        fields: [userRedeemedRewards.userId],
        references: [users.id]
      }),
      reward: one(rewards, {
        fields: [userRedeemedRewards.rewardId],
        references: [rewards.id]
      }),
      salon: one(salons, {
        fields: [userRedeemedRewards.usedAtSalonId],
        references: [salons.id]
      })
    }));
    favoriteSalonsRelations = relations(favoriteSalons, ({ one }) => ({
      user: one(users, {
        fields: [favoriteSalons.userId],
        references: [users.id]
      }),
      salon: one(salons, {
        fields: [favoriteSalons.salonId],
        references: [salons.id]
      })
    }));
    favoriteStylistsRelations = relations(favoriteStylists, ({ one }) => ({
      user: one(users, {
        fields: [favoriteStylists.userId],
        references: [users.id]
      }),
      stylist: one(staff, {
        fields: [favoriteStylists.staffId],
        references: [staff.id]
      })
    }));
    chatConversations = pgTable("chat_conversations", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      customerId: varchar("customer_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      status: varchar("status", { length: 20 }).notNull().default("active"),
      // active, archived, closed
      context: varchar("context", { length: 50 }).default("pre_booking"),
      // pre_booking, booking_inquiry, support
      relatedBookingId: varchar("related_booking_id"),
      // Optional: if conversation relates to a specific booking
      relatedServiceId: varchar("related_service_id"),
      // Optional: if discussing a specific service
      assignedStaffId: varchar("assigned_staff_id").references(() => staff.id, { onDelete: "set null" }),
      // Staff handling this chat
      lastMessageAt: timestamp("last_message_at"),
      lastMessagePreview: text("last_message_preview"),
      // First 100 chars of last message for list view
      customerUnreadCount: integer("customer_unread_count").notNull().default(0),
      staffUnreadCount: integer("staff_unread_count").notNull().default(0),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("chat_conversations_salon_id_idx").on(table.salonId),
      index("chat_conversations_customer_id_idx").on(table.customerId),
      index("chat_conversations_assigned_staff_idx").on(table.assignedStaffId),
      index("chat_conversations_status_idx").on(table.status),
      index("chat_conversations_last_message_at_idx").on(table.lastMessageAt),
      uniqueIndex("chat_conversations_salon_customer_unique").on(table.salonId, table.customerId)
    ]);
    chatParticipants = pgTable("chat_participants", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      conversationId: varchar("conversation_id").notNull().references(() => chatConversations.id, { onDelete: "cascade" }),
      userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      role: varchar("role", { length: 20 }).notNull(),
      // customer, staff, admin
      staffId: varchar("staff_id").references(() => staff.id, { onDelete: "cascade" }),
      // Only if role is 'staff'
      joinedAt: timestamp("joined_at").defaultNow(),
      lastReadAt: timestamp("last_read_at"),
      isActive: integer("is_active").notNull().default(1)
      // 0 if left the conversation
    }, (table) => [
      index("chat_participants_conversation_id_idx").on(table.conversationId),
      index("chat_participants_user_id_idx").on(table.userId),
      uniqueIndex("chat_participants_conversation_user_unique").on(table.conversationId, table.userId)
    ]);
    chatMessages = pgTable("chat_messages", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      conversationId: varchar("conversation_id").notNull().references(() => chatConversations.id, { onDelete: "cascade" }),
      senderId: varchar("sender_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      senderRole: varchar("sender_role", { length: 20 }).notNull(),
      // customer, staff
      senderName: text("sender_name"),
      // Cached sender name for display
      senderAvatar: text("sender_avatar"),
      // Cached sender avatar URL
      messageType: varchar("message_type", { length: 20 }).notNull().default("text"),
      // text, image, file, system
      body: text("body"),
      // Message text content
      attachmentUrl: text("attachment_url"),
      // URL for image/file attachments
      attachmentType: varchar("attachment_type", { length: 50 }),
      // image/jpeg, application/pdf, etc.
      attachmentName: text("attachment_name"),
      // Original filename
      attachmentSize: integer("attachment_size"),
      // File size in bytes
      metadata: jsonb("metadata"),
      // Additional data (e.g., service details, booking info)
      isEdited: integer("is_edited").notNull().default(0),
      editedAt: timestamp("edited_at"),
      isDeleted: integer("is_deleted").notNull().default(0),
      deletedAt: timestamp("deleted_at"),
      sentAt: timestamp("sent_at").defaultNow(),
      deliveredAt: timestamp("delivered_at")
    }, (table) => [
      index("chat_messages_conversation_id_idx").on(table.conversationId),
      index("chat_messages_sender_id_idx").on(table.senderId),
      index("chat_messages_sent_at_idx").on(table.sentAt),
      index("chat_messages_conversation_sent_idx").on(table.conversationId, table.sentAt)
    ]);
    chatMessageReads = pgTable("chat_message_reads", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      messageId: varchar("message_id").notNull().references(() => chatMessages.id, { onDelete: "cascade" }),
      userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      readAt: timestamp("read_at").defaultNow()
    }, (table) => [
      index("chat_message_reads_message_id_idx").on(table.messageId),
      index("chat_message_reads_user_id_idx").on(table.userId),
      uniqueIndex("chat_message_reads_message_user_unique").on(table.messageId, table.userId)
    ]);
    chatConversationsRelations = relations(chatConversations, ({ one, many }) => ({
      salon: one(salons, {
        fields: [chatConversations.salonId],
        references: [salons.id]
      }),
      customer: one(users, {
        fields: [chatConversations.customerId],
        references: [users.id]
      }),
      assignedStaff: one(staff, {
        fields: [chatConversations.assignedStaffId],
        references: [staff.id]
      }),
      participants: many(chatParticipants),
      messages: many(chatMessages)
    }));
    chatParticipantsRelations = relations(chatParticipants, ({ one }) => ({
      conversation: one(chatConversations, {
        fields: [chatParticipants.conversationId],
        references: [chatConversations.id]
      }),
      user: one(users, {
        fields: [chatParticipants.userId],
        references: [users.id]
      }),
      staffMember: one(staff, {
        fields: [chatParticipants.staffId],
        references: [staff.id]
      })
    }));
    chatMessagesRelations = relations(chatMessages, ({ one, many }) => ({
      conversation: one(chatConversations, {
        fields: [chatMessages.conversationId],
        references: [chatConversations.id]
      }),
      sender: one(users, {
        fields: [chatMessages.senderId],
        references: [users.id]
      }),
      readReceipts: many(chatMessageReads)
    }));
    chatMessageReadsRelations = relations(chatMessageReads, ({ one }) => ({
      message: one(chatMessages, {
        fields: [chatMessageReads.messageId],
        references: [chatMessages.id]
      }),
      user: one(users, {
        fields: [chatMessageReads.userId],
        references: [users.id]
      })
    }));
    insertChatConversationSchema = createInsertSchema(chatConversations).pick({
      salonId: true,
      customerId: true,
      context: true,
      relatedBookingId: true,
      relatedServiceId: true
    });
    insertChatMessageSchema = createInsertSchema(chatMessages).pick({
      conversationId: true,
      body: true,
      messageType: true,
      attachmentUrl: true,
      attachmentType: true,
      attachmentName: true,
      attachmentSize: true,
      metadata: true
    });
    clientProfiles = pgTable("client_profiles", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      customerId: varchar("customer_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      // Hair-specific structured fields
      hairType: varchar("hair_type", { length: 50 }),
      // straight, wavy, curly, coily
      hairCondition: varchar("hair_condition", { length: 50 }),
      // healthy, damaged, color-treated
      hairLength: varchar("hair_length", { length: 50 }),
      // short, medium, long
      hairDensity: varchar("hair_density", { length: 50 }),
      // thin, medium, thick
      scalpCondition: varchar("scalp_condition", { length: 50 }),
      // normal, oily, dry, sensitive
      // Skin-specific structured fields
      skinType: varchar("skin_type", { length: 50 }),
      // oily, dry, combination, sensitive, normal
      skinConcerns: text("skin_concerns").array(),
      // Array of concerns: acne, aging, hyperpigmentation, etc
      // Allergy & sensitivity information (critical for safety)
      allergies: text("allergies").array(),
      // Array of known allergies
      sensitivities: text("sensitivities").array(),
      // Array of sensitivities
      contraindications: text("contraindications"),
      // Free text for medical contraindications
      // Preference fields
      preferredStylistId: varchar("preferred_stylist_id").references(() => staff.id, { onDelete: "set null" }),
      communicationStyle: varchar("communication_style", { length: 50 }),
      // chatty, quiet, professional
      beveragePreference: varchar("beverage_preference", { length: 100 }),
      // tea, coffee, water, none
      musicPreference: varchar("music_preference", { length: 100 }),
      // pop, classical, ambient, none
      specialRequirements: text("special_requirements"),
      // Free text for any special needs
      // Customer-provided preferences
      preferredProducts: text("preferred_products").array(),
      // Products customer likes
      dislikedProducts: text("disliked_products").array(),
      // Products customer dislikes
      // Tracking fields
      lastVisitDate: timestamp("last_visit_date"),
      totalVisits: integer("total_visits").notNull().default(0),
      lifetimeSpendPaisa: integer("lifetime_spend_paisa").notNull().default(0),
      // VIP/loyalty status for this salon
      isVip: integer("is_vip").notNull().default(0),
      vipNotes: text("vip_notes"),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow(),
      createdBy: varchar("created_by").references(() => users.id, { onDelete: "set null" }),
      updatedBy: varchar("updated_by").references(() => users.id, { onDelete: "set null" })
    }, (table) => [
      index("client_profiles_salon_id_idx").on(table.salonId),
      index("client_profiles_customer_id_idx").on(table.customerId),
      index("client_profiles_preferred_stylist_idx").on(table.preferredStylistId),
      uniqueIndex("client_profiles_salon_customer_unique").on(table.salonId, table.customerId)
    ]);
    clientNotes = pgTable("client_notes", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      clientProfileId: varchar("client_profile_id").notNull().references(() => clientProfiles.id, { onDelete: "cascade" }),
      bookingId: varchar("booking_id").references(() => bookings.id, { onDelete: "set null" }),
      // Optional link to specific appointment
      serviceId: varchar("service_id").references(() => services.id, { onDelete: "set null" }),
      // Optional link to specific service
      noteType: varchar("note_type", { length: 50 }).notNull().default("general"),
      // general, appointment, formula, complaint, compliment
      title: varchar("title", { length: 200 }),
      // Optional title for the note
      content: text("content").notNull(),
      // The actual note content
      // Priority/visibility flags
      isPinned: integer("is_pinned").notNull().default(0),
      // Pinned notes show first
      isAlertNote: integer("is_alert_note").notNull().default(0),
      // Alert notes show as popups
      isVisibleToCustomer: integer("is_visible_to_customer").notNull().default(0),
      // Can customer see this note
      // Author tracking
      authorId: varchar("author_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      authorStaffId: varchar("author_staff_id").references(() => staff.id, { onDelete: "set null" }),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("client_notes_client_profile_id_idx").on(table.clientProfileId),
      index("client_notes_booking_id_idx").on(table.bookingId),
      index("client_notes_author_id_idx").on(table.authorId),
      index("client_notes_note_type_idx").on(table.noteType),
      index("client_notes_is_pinned_idx").on(table.isPinned)
    ]);
    clientFormulas = pgTable("client_formulas", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      clientProfileId: varchar("client_profile_id").notNull().references(() => clientProfiles.id, { onDelete: "cascade" }),
      bookingId: varchar("booking_id").references(() => bookings.id, { onDelete: "set null" }),
      // Link to appointment when formula was used
      formulaType: varchar("formula_type", { length: 50 }).notNull(),
      // hair_color, highlights, treatment, perm, relaxer
      formulaName: varchar("formula_name", { length: 200 }).notNull(),
      // User-friendly name for this formula
      // Hair color specific fields
      baseColor: varchar("base_color", { length: 100 }),
      // Base color used
      targetColor: varchar("target_color", { length: 100 }),
      // Desired result color
      developer: varchar("developer", { length: 50 }),
      // Developer volume (10, 20, 30, 40)
      mixingRatio: varchar("mixing_ratio", { length: 50 }),
      // e.g., "1:1", "1:2"
      processingTime: integer("processing_time"),
      // Time in minutes
      heatUsed: integer("heat_used").notNull().default(0),
      // 1 if heat was used
      // Product details (flexible JSON for various products)
      products: jsonb("products"),
      // Array of { brand, name, shade, amount }
      // Additional formula notes
      applicationTechnique: text("application_technique"),
      // How formula was applied
      sectioning: text("sectioning"),
      // How hair was sectioned
      specialInstructions: text("special_instructions"),
      // Any special instructions
      // Result tracking
      resultNotes: text("result_notes"),
      // How the result turned out
      resultRating: integer("result_rating"),
      // 1-5 rating of the result
      // Flags
      isActiveFormula: integer("is_active_formula").notNull().default(1),
      // Current formula vs historical
      isCustomerFavorite: integer("is_customer_favorite").notNull().default(0),
      // Customer marked as favorite
      // Author tracking
      createdBy: varchar("created_by").notNull().references(() => users.id, { onDelete: "cascade" }),
      updatedBy: varchar("updated_by").references(() => users.id, { onDelete: "set null" }),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("client_formulas_client_profile_id_idx").on(table.clientProfileId),
      index("client_formulas_formula_type_idx").on(table.formulaType),
      index("client_formulas_booking_id_idx").on(table.bookingId),
      index("client_formulas_is_active_idx").on(table.isActiveFormula)
    ]);
    clientPhotos = pgTable("client_photos", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      clientProfileId: varchar("client_profile_id").notNull().references(() => clientProfiles.id, { onDelete: "cascade" }),
      bookingId: varchar("booking_id").references(() => bookings.id, { onDelete: "set null" }),
      // Link to appointment
      formulaId: varchar("formula_id").references(() => clientFormulas.id, { onDelete: "set null" }),
      // Optional link to formula used
      photoType: varchar("photo_type", { length: 20 }).notNull(),
      // before, after, reference, inspiration
      photoUrl: text("photo_url").notNull(),
      // URL to stored photo
      thumbnailUrl: text("thumbnail_url"),
      // Compressed thumbnail URL
      caption: varchar("caption", { length: 500 }),
      // Optional caption/description
      serviceType: varchar("service_type", { length: 100 }),
      // What service this photo relates to
      // Visibility flags
      isVisibleToCustomer: integer("is_visible_to_customer").notNull().default(1),
      // Customer can view
      isPortfolioPhoto: integer("is_portfolio_photo").notNull().default(0),
      // Can be used in salon portfolio (with consent)
      consentGiven: integer("consent_given").notNull().default(0),
      // Customer gave consent for portfolio use
      // Metadata
      takenAt: timestamp("taken_at"),
      // When photo was taken (can differ from upload)
      uploadedBy: varchar("uploaded_by").notNull().references(() => users.id, { onDelete: "cascade" }),
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("client_photos_client_profile_id_idx").on(table.clientProfileId),
      index("client_photos_booking_id_idx").on(table.bookingId),
      index("client_photos_formula_id_idx").on(table.formulaId),
      index("client_photos_photo_type_idx").on(table.photoType),
      index("client_photos_is_portfolio_idx").on(table.isPortfolioPhoto)
    ]);
    profileVisibilitySettings = pgTable("profile_visibility_settings", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      // Visibility mode: 'all', 'preferences_only', 'none'
      visibilityMode: varchar("visibility_mode", { length: 20 }).notNull().default("preferences_only"),
      // Fine-grained field visibility (when mode is 'custom')
      showHairProfile: integer("show_hair_profile").notNull().default(1),
      showSkinProfile: integer("show_skin_profile").notNull().default(1),
      showAllergies: integer("show_allergies").notNull().default(1),
      showPreferences: integer("show_preferences").notNull().default(1),
      showPhotos: integer("show_photos").notNull().default(1),
      showNotes: integer("show_notes").notNull().default(0),
      // Staff notes hidden by default
      showFormulas: integer("show_formulas").notNull().default(0),
      // Formulas hidden by default
      showVisitHistory: integer("show_visit_history").notNull().default(1),
      // Auto-popup settings
      showProfileOnBooking: integer("show_profile_on_booking").notNull().default(1),
      // Auto-popup for staff
      highlightAllergies: integer("highlight_allergies").notNull().default(1),
      // Red highlight for allergies
      highlightVip: integer("highlight_vip").notNull().default(1),
      // VIP badge highlight
      updatedAt: timestamp("updated_at").defaultNow(),
      updatedBy: varchar("updated_by").references(() => users.id, { onDelete: "set null" })
    }, (table) => [
      uniqueIndex("profile_visibility_settings_salon_unique").on(table.salonId)
    ]);
    clientProfilesRelations = relations(clientProfiles, ({ one, many }) => ({
      salon: one(salons, {
        fields: [clientProfiles.salonId],
        references: [salons.id]
      }),
      customer: one(users, {
        fields: [clientProfiles.customerId],
        references: [users.id]
      }),
      preferredStylist: one(staff, {
        fields: [clientProfiles.preferredStylistId],
        references: [staff.id]
      }),
      notes: many(clientNotes),
      formulas: many(clientFormulas),
      photos: many(clientPhotos)
    }));
    clientNotesRelations = relations(clientNotes, ({ one }) => ({
      clientProfile: one(clientProfiles, {
        fields: [clientNotes.clientProfileId],
        references: [clientProfiles.id]
      }),
      booking: one(bookings, {
        fields: [clientNotes.bookingId],
        references: [bookings.id]
      }),
      service: one(services, {
        fields: [clientNotes.serviceId],
        references: [services.id]
      }),
      author: one(users, {
        fields: [clientNotes.authorId],
        references: [users.id]
      }),
      authorStaff: one(staff, {
        fields: [clientNotes.authorStaffId],
        references: [staff.id]
      })
    }));
    clientFormulasRelations = relations(clientFormulas, ({ one, many }) => ({
      clientProfile: one(clientProfiles, {
        fields: [clientFormulas.clientProfileId],
        references: [clientProfiles.id]
      }),
      booking: one(bookings, {
        fields: [clientFormulas.bookingId],
        references: [bookings.id]
      }),
      photos: many(clientPhotos)
    }));
    clientPhotosRelations = relations(clientPhotos, ({ one }) => ({
      clientProfile: one(clientProfiles, {
        fields: [clientPhotos.clientProfileId],
        references: [clientProfiles.id]
      }),
      booking: one(bookings, {
        fields: [clientPhotos.bookingId],
        references: [bookings.id]
      }),
      formula: one(clientFormulas, {
        fields: [clientPhotos.formulaId],
        references: [clientFormulas.id]
      }),
      uploader: one(users, {
        fields: [clientPhotos.uploadedBy],
        references: [users.id]
      })
    }));
    profileVisibilitySettingsRelations = relations(profileVisibilitySettings, ({ one }) => ({
      salon: one(salons, {
        fields: [profileVisibilitySettings.salonId],
        references: [salons.id]
      })
    }));
    insertClientProfileSchema = createInsertSchema(clientProfiles).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    updateClientProfileSchema = createInsertSchema(clientProfiles).omit({
      id: true,
      salonId: true,
      customerId: true,
      createdAt: true,
      createdBy: true
    }).partial();
    insertClientNoteSchema = createInsertSchema(clientNotes).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertClientFormulaSchema = createInsertSchema(clientFormulas).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertClientPhotoSchema = createInsertSchema(clientPhotos).omit({
      id: true,
      createdAt: true
    });
    insertProfileVisibilitySettingsSchema = createInsertSchema(profileVisibilitySettings).omit({
      id: true,
      updatedAt: true
    });
    depositSettings = pgTable("deposit_settings", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      // Master toggle
      isEnabled: integer("is_enabled").notNull().default(0),
      // 1 = deposits enabled
      // Deposit amount configuration
      depositPercentage: integer("deposit_percentage").notNull().default(25),
      // 20, 25, 50, etc.
      // Trigger methods (salon owner chooses which to use)
      usePriceThreshold: integer("use_price_threshold").notNull().default(0),
      // 1 = enabled
      priceThresholdPaisa: integer("price_threshold_paisa"),
      // e.g., 100000 = 1000
      useCategoryBased: integer("use_category_based").notNull().default(0),
      // 1 = enabled
      protectedCategories: text("protected_categories").array(),
      // e.g., ['Bridal', 'Premium']
      useManualToggle: integer("use_manual_toggle").notNull().default(1),
      // 1 = enabled (default)
      // Trusted customer settings
      allowTrustedCustomerBypass: integer("allow_trusted_customer_bypass").notNull().default(1),
      // 1 = trusted can skip deposit
      requireCardOnFile: integer("require_card_on_file").notNull().default(1),
      // 1 = card required for bypass
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow(),
      updatedBy: varchar("updated_by").references(() => users.id, { onDelete: "set null" })
    }, (table) => [
      uniqueIndex("deposit_settings_salon_unique").on(table.salonId)
    ]);
    serviceDepositRules = pgTable("service_deposit_rules", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      serviceId: varchar("service_id").notNull().references(() => services.id, { onDelete: "cascade" }),
      // Manual override for this specific service
      requiresDeposit: integer("requires_deposit").notNull().default(0),
      // 1 = deposit required
      // Optional custom percentage (overrides salon default)
      customPercentage: integer("custom_percentage"),
      // null = use salon default
      // Optional custom minimum deposit amount
      minimumDepositPaisa: integer("minimum_deposit_paisa"),
      // e.g., 50000 = 500 minimum
      // Optional maximum deposit cap
      maximumDepositPaisa: integer("maximum_deposit_paisa"),
      // Cap the deposit amount
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      uniqueIndex("service_deposit_rules_unique").on(table.salonId, table.serviceId),
      index("service_deposit_rules_salon_idx").on(table.salonId),
      index("service_deposit_rules_service_idx").on(table.serviceId)
    ]);
    cancellationPolicies = pgTable("cancellation_policies", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      // Cancellation window in hours (12, 24, 48, 72)
      cancellationWindowHours: integer("cancellation_window_hours").notNull().default(24),
      // What happens if cancelled within window
      withinWindowAction: varchar("within_window_action", { length: 30 }).notNull().default("forfeit_full"),
      // Options: 'forfeit_full', 'forfeit_partial', 'no_penalty'
      partialForfeitPercentage: integer("partial_forfeit_percentage").default(50),
      // % of deposit to forfeit if partial
      // No-show handling
      noShowAction: varchar("no_show_action", { length: 30 }).notNull().default("forfeit_full"),
      // Options: 'forfeit_full', 'forfeit_partial', 'charge_full_service'
      noShowChargeFull: integer("no_show_charge_full").notNull().default(0),
      // 1 = charge full service price on no-show
      // Grace period (extra minutes before marking as no-show)
      noShowGraceMinutes: integer("no_show_grace_minutes").notNull().default(15),
      // Policy text (shown to customers)
      policyText: text("policy_text"),
      // Custom policy description
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow(),
      updatedBy: varchar("updated_by").references(() => users.id, { onDelete: "set null" })
    }, (table) => [
      uniqueIndex("cancellation_policies_salon_unique").on(table.salonId)
    ]);
    trustedCustomers = pgTable("trusted_customers", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      customerId: varchar("customer_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      // Trust status
      trustLevel: varchar("trust_level", { length: 20 }).notNull().default("trusted"),
      // Options: 'trusted', 'vip', 'blacklisted'
      // Reason for trust status
      reason: text("reason"),
      // Why customer was marked as trusted/blacklisted
      // Bypass settings
      canBypassDeposit: integer("can_bypass_deposit").notNull().default(1),
      // 1 = can skip deposit
      hasCardOnFile: integer("has_card_on_file").notNull().default(0),
      // 1 = card saved
      cardTokenId: varchar("card_token_id", { length: 100 }),
      // Razorpay token reference
      cardLast4: varchar("card_last_4", { length: 4 }),
      // Last 4 digits for display
      cardBrand: varchar("card_brand", { length: 20 }),
      // visa, mastercard, etc.
      cardExpiryMonth: integer("card_expiry_month"),
      cardExpiryYear: integer("card_expiry_year"),
      // Stats for trust calculation
      totalBookings: integer("total_bookings").notNull().default(0),
      completedBookings: integer("completed_bookings").notNull().default(0),
      noShowCount: integer("no_show_count").notNull().default(0),
      lateCancellationCount: integer("late_cancellation_count").notNull().default(0),
      // Tracking
      addedBy: varchar("added_by").references(() => users.id, { onDelete: "set null" }),
      addedAt: timestamp("added_at").defaultNow(),
      lastUpdatedAt: timestamp("last_updated_at").defaultNow(),
      lastUpdatedBy: varchar("last_updated_by").references(() => users.id, { onDelete: "set null" })
    }, (table) => [
      uniqueIndex("trusted_customers_unique").on(table.salonId, table.customerId),
      index("trusted_customers_salon_idx").on(table.salonId),
      index("trusted_customers_customer_idx").on(table.customerId),
      index("trusted_customers_trust_level_idx").on(table.trustLevel)
    ]);
    depositTransactions = pgTable("deposit_transactions", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      customerId: varchar("customer_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      bookingId: varchar("booking_id").notNull().references(() => bookings.id, { onDelete: "cascade" }),
      // Transaction details
      transactionType: varchar("transaction_type", { length: 30 }).notNull(),
      // Options: 'deposit_collected', 'deposit_refunded', 'deposit_forfeited', 'no_show_charged', 'deposit_applied'
      amountPaisa: integer("amount_paisa").notNull(),
      // Transaction amount
      currency: varchar("currency", { length: 3 }).notNull().default("INR"),
      // Service details snapshot
      serviceAmountPaisa: integer("service_amount_paisa").notNull(),
      // Original service price
      depositPercentage: integer("deposit_percentage").notNull(),
      // % used to calculate
      // Payment gateway details
      razorpayPaymentId: varchar("razorpay_payment_id", { length: 100 }),
      // For deposits/charges
      razorpayRefundId: varchar("razorpay_refund_id", { length: 100 }),
      // For refunds
      razorpayOrderId: varchar("razorpay_order_id", { length: 100 }),
      // Status tracking
      status: varchar("status", { length: 20 }).notNull().default("pending"),
      // Options: 'pending', 'completed', 'failed', 'refund_pending', 'refunded'
      // Reason/notes
      reason: text("reason"),
      // Why refund/forfeit happened
      notes: text("notes"),
      // Staff notes
      // Related to cancellation/no-show
      cancellationWindowHours: integer("cancellation_window_hours"),
      // Policy at time of booking
      cancelledWithinWindow: integer("cancelled_within_window"),
      // 1 = within penalty window
      wasNoShow: integer("was_no_show").notNull().default(0),
      // 1 = no-show
      // Processing timestamps
      collectedAt: timestamp("collected_at"),
      // When deposit was collected
      processedAt: timestamp("processed_at"),
      // When transaction completed
      refundedAt: timestamp("refunded_at"),
      // When refund was processed
      forfeitedAt: timestamp("forfeited_at"),
      // When deposit was forfeited
      // Tracking
      processedBy: varchar("processed_by").references(() => users.id, { onDelete: "set null" }),
      // Staff who processed
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("deposit_transactions_salon_idx").on(table.salonId),
      index("deposit_transactions_customer_idx").on(table.customerId),
      index("deposit_transactions_booking_idx").on(table.bookingId),
      index("deposit_transactions_type_idx").on(table.transactionType),
      index("deposit_transactions_status_idx").on(table.status),
      index("deposit_transactions_created_at_idx").on(table.createdAt)
    ]);
    customerSavedCards = pgTable("customer_saved_cards", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      customerId: varchar("customer_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      // Razorpay token reference
      razorpayTokenId: varchar("razorpay_token_id", { length: 100 }).notNull(),
      razorpayCustomerId: varchar("razorpay_customer_id", { length: 100 }),
      // Card display info (masked)
      cardNetwork: varchar("card_network", { length: 50 }),
      // visa, mastercard, rupay, etc.
      cardType: varchar("card_type", { length: 20 }),
      // credit, debit
      cardLast4: varchar("card_last_4", { length: 4 }),
      cardIssuer: varchar("card_issuer", { length: 100 }),
      // Bank name
      cardBrand: varchar("card_brand", { length: 50 }),
      expiryMonth: integer("expiry_month"),
      expiryYear: integer("expiry_year"),
      // Card nickname for easy identification
      nickname: varchar("nickname", { length: 50 }),
      // Status
      isDefault: integer("is_default").notNull().default(0),
      // 1 = default card
      isActive: integer("is_active").notNull().default(1),
      // 0 = deactivated
      // Compliance fields
      consentGiven: integer("consent_given").notNull().default(1),
      // RBI compliance
      consentTimestamp: timestamp("consent_timestamp"),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow(),
      lastUsedAt: timestamp("last_used_at")
    }, (table) => [
      index("customer_saved_cards_customer_idx").on(table.customerId),
      index("customer_saved_cards_token_idx").on(table.razorpayTokenId),
      index("customer_saved_cards_active_idx").on(table.isActive),
      unique("customer_saved_cards_token_unique").on(table.razorpayTokenId)
    ]);
    customerSavedCardsRelations = relations(customerSavedCards, ({ one }) => ({
      customer: one(users, {
        fields: [customerSavedCards.customerId],
        references: [users.id]
      })
    }));
    depositSettingsRelations = relations(depositSettings, ({ one }) => ({
      salon: one(salons, {
        fields: [depositSettings.salonId],
        references: [salons.id]
      })
    }));
    serviceDepositRulesRelations = relations(serviceDepositRules, ({ one }) => ({
      salon: one(salons, {
        fields: [serviceDepositRules.salonId],
        references: [salons.id]
      }),
      service: one(services, {
        fields: [serviceDepositRules.serviceId],
        references: [services.id]
      })
    }));
    cancellationPoliciesRelations = relations(cancellationPolicies, ({ one }) => ({
      salon: one(salons, {
        fields: [cancellationPolicies.salonId],
        references: [salons.id]
      })
    }));
    trustedCustomersRelations = relations(trustedCustomers, ({ one }) => ({
      salon: one(salons, {
        fields: [trustedCustomers.salonId],
        references: [salons.id]
      }),
      customer: one(users, {
        fields: [trustedCustomers.customerId],
        references: [users.id]
      })
    }));
    depositTransactionsRelations = relations(depositTransactions, ({ one }) => ({
      salon: one(salons, {
        fields: [depositTransactions.salonId],
        references: [salons.id]
      }),
      customer: one(users, {
        fields: [depositTransactions.customerId],
        references: [users.id]
      }),
      booking: one(bookings, {
        fields: [depositTransactions.bookingId],
        references: [bookings.id]
      })
    }));
    insertDepositSettingsSchema = createInsertSchema(depositSettings).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    updateDepositSettingsSchema = createInsertSchema(depositSettings).omit({
      id: true,
      salonId: true,
      createdAt: true
    }).partial();
    insertServiceDepositRuleSchema = createInsertSchema(serviceDepositRules).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertCancellationPolicySchema = createInsertSchema(cancellationPolicies).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    updateCancellationPolicySchema = createInsertSchema(cancellationPolicies).omit({
      id: true,
      salonId: true,
      createdAt: true
    }).partial();
    insertTrustedCustomerSchema = createInsertSchema(trustedCustomers).omit({
      id: true,
      addedAt: true,
      lastUpdatedAt: true
    });
    insertDepositTransactionSchema = createInsertSchema(depositTransactions).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    giftCardTemplates = pgTable("gift_card_templates", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      // Template details
      name: varchar("name", { length: 100 }).notNull(),
      // e.g., "Birthday Special", "Holiday Gift"
      description: text("description"),
      designUrl: text("design_url"),
      // URL to the design image
      designData: jsonb("design_data"),
      // Custom design configuration (colors, fonts, etc.)
      // Preset values (optional)
      presetValuesPaisa: text("preset_values_paisa").array(),
      // e.g., ['100000', '200000', '500000'] for 1000, 2000, 5000
      allowCustomValue: integer("allow_custom_value").notNull().default(1),
      // 1 = allow custom amounts
      minValuePaisa: integer("min_value_paisa").notNull().default(5e4),
      // Minimum gift card value (500)
      maxValuePaisa: integer("max_value_paisa").notNull().default(25e5),
      // Maximum gift card value (25000)
      // Display settings
      sortOrder: integer("sort_order").notNull().default(0),
      isActive: integer("is_active").notNull().default(1),
      isDefault: integer("is_default").notNull().default(0),
      // 1 = default template
      // Category for organization
      category: varchar("category", { length: 50 }),
      // 'birthday', 'holiday', 'occasion', 'general'
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow(),
      createdBy: varchar("created_by").references(() => users.id, { onDelete: "set null" })
    }, (table) => [
      index("gift_card_templates_salon_idx").on(table.salonId),
      index("gift_card_templates_active_idx").on(table.isActive),
      index("gift_card_templates_category_idx").on(table.category)
    ]);
    giftCards = pgTable("gift_cards", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      // Gift card code - unique identifier for redemption
      code: varchar("code", { length: 20 }).notNull().unique(),
      // e.g., "GIFT-ABCD-1234"
      // Value tracking
      originalValuePaisa: integer("original_value_paisa").notNull(),
      // Original purchased amount
      balancePaisa: integer("balance_paisa").notNull(),
      // Current remaining balance
      currency: varchar("currency", { length: 3 }).notNull().default("INR"),
      // Status
      status: varchar("status", { length: 20 }).notNull().default("active"),
      // Options: 'pending_payment', 'active', 'partially_used', 'fully_redeemed', 'expired', 'cancelled', 'refunded'
      // Purchase details
      purchasedBy: varchar("purchased_by").references(() => users.id, { onDelete: "set null" }),
      // Customer who bought
      purchasedAt: timestamp("purchased_at"),
      // Recipient details
      recipientName: varchar("recipient_name", { length: 100 }),
      recipientEmail: varchar("recipient_email", { length: 255 }),
      recipientPhone: varchar("recipient_phone", { length: 20 }),
      personalMessage: text("personal_message"),
      // Gift message from purchaser
      // Template used
      templateId: varchar("template_id").references(() => giftCardTemplates.id, { onDelete: "set null" }),
      // Scheduling for future delivery
      scheduledDeliveryAt: timestamp("scheduled_delivery_at"),
      // When to send the gift card
      deliveredAt: timestamp("delivered_at"),
      // When actually delivered
      // Expiry
      expiresAt: timestamp("expires_at"),
      // Null = never expires
      // Payment details
      razorpayOrderId: varchar("razorpay_order_id", { length: 100 }),
      razorpayPaymentId: varchar("razorpay_payment_id", { length: 100 }),
      // For tracking last usage
      lastUsedAt: timestamp("last_used_at"),
      lastUsedBookingId: varchar("last_used_booking_id"),
      // Redemption tracking
      totalRedemptionsPaisa: integer("total_redemptions_paisa").notNull().default(0),
      redemptionCount: integer("redemption_count").notNull().default(0),
      // QR Code for easy scanning
      qrCodeUrl: text("qr_code_url"),
      // Internal notes
      internalNotes: text("internal_notes"),
      // Audit trail
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow(),
      cancelledAt: timestamp("cancelled_at"),
      cancelledBy: varchar("cancelled_by").references(() => users.id, { onDelete: "set null" }),
      cancellationReason: text("cancellation_reason")
    }, (table) => [
      index("gift_cards_salon_idx").on(table.salonId),
      index("gift_cards_code_idx").on(table.code),
      index("gift_cards_status_idx").on(table.status),
      index("gift_cards_purchased_by_idx").on(table.purchasedBy),
      index("gift_cards_recipient_email_idx").on(table.recipientEmail),
      index("gift_cards_expires_at_idx").on(table.expiresAt),
      index("gift_cards_created_at_idx").on(table.createdAt)
    ]);
    giftCardTransactions = pgTable("gift_card_transactions", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      giftCardId: varchar("gift_card_id").notNull().references(() => giftCards.id, { onDelete: "cascade" }),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      // Transaction type
      transactionType: varchar("transaction_type", { length: 30 }).notNull(),
      // Options: 'purchase', 'redemption', 'partial_redemption', 'refund', 'adjustment', 'expiry', 'cancellation'
      // Amount details
      amountPaisa: integer("amount_paisa").notNull(),
      // Transaction amount (positive for purchase/refund, negative for redemption)
      balanceBeforePaisa: integer("balance_before_paisa").notNull(),
      // Balance before this transaction
      balanceAfterPaisa: integer("balance_after_paisa").notNull(),
      // Balance after this transaction
      currency: varchar("currency", { length: 3 }).notNull().default("INR"),
      // Reference to booking (for redemptions)
      bookingId: varchar("booking_id").references(() => bookings.id, { onDelete: "set null" }),
      // Payment details (for purchases/refunds)
      razorpayPaymentId: varchar("razorpay_payment_id", { length: 100 }),
      razorpayRefundId: varchar("razorpay_refund_id", { length: 100 }),
      // User who performed the transaction
      performedBy: varchar("performed_by").references(() => users.id, { onDelete: "set null" }),
      // Staff or customer
      performedByType: varchar("performed_by_type", { length: 20 }),
      // 'customer', 'staff', 'system'
      // Notes
      notes: text("notes"),
      // Status
      status: varchar("status", { length: 20 }).notNull().default("completed"),
      // Options: 'pending', 'completed', 'failed', 'reversed'
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("gift_card_transactions_gift_card_idx").on(table.giftCardId),
      index("gift_card_transactions_salon_idx").on(table.salonId),
      index("gift_card_transactions_booking_idx").on(table.bookingId),
      index("gift_card_transactions_type_idx").on(table.transactionType),
      index("gift_card_transactions_created_at_idx").on(table.createdAt)
    ]);
    giftCardDeliveries = pgTable("gift_card_deliveries", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      giftCardId: varchar("gift_card_id").notNull().references(() => giftCards.id, { onDelete: "cascade" }),
      // Delivery method
      deliveryMethod: varchar("delivery_method", { length: 20 }).notNull(),
      // Options: 'email', 'sms', 'whatsapp', 'print', 'in_app'
      // Recipient details
      recipientEmail: varchar("recipient_email", { length: 255 }),
      recipientPhone: varchar("recipient_phone", { length: 20 }),
      // Delivery status
      status: varchar("status", { length: 20 }).notNull().default("pending"),
      // Options: 'pending', 'scheduled', 'sent', 'delivered', 'failed', 'bounced'
      // Scheduling
      scheduledAt: timestamp("scheduled_at"),
      // When to send
      sentAt: timestamp("sent_at"),
      // When actually sent
      deliveredAt: timestamp("delivered_at"),
      // When confirmed delivered (email open, etc.)
      // Error tracking
      failedAt: timestamp("failed_at"),
      failureReason: text("failure_reason"),
      retryCount: integer("retry_count").notNull().default(0),
      maxRetries: integer("max_retries").notNull().default(3),
      // External service references
      externalMessageId: varchar("external_message_id", { length: 100 }),
      // SendGrid message ID, Twilio SID, etc.
      // Content tracking
      emailSubject: varchar("email_subject", { length: 255 }),
      emailTemplateId: varchar("email_template_id", { length: 100 }),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("gift_card_deliveries_gift_card_idx").on(table.giftCardId),
      index("gift_card_deliveries_status_idx").on(table.status),
      index("gift_card_deliveries_method_idx").on(table.deliveryMethod),
      index("gift_card_deliveries_scheduled_idx").on(table.scheduledAt)
    ]);
    giftCardTemplatesRelations = relations(giftCardTemplates, ({ one, many }) => ({
      salon: one(salons, {
        fields: [giftCardTemplates.salonId],
        references: [salons.id]
      }),
      giftCards: many(giftCards)
    }));
    giftCardsRelations = relations(giftCards, ({ one, many }) => ({
      salon: one(salons, {
        fields: [giftCards.salonId],
        references: [salons.id]
      }),
      purchaser: one(users, {
        fields: [giftCards.purchasedBy],
        references: [users.id]
      }),
      template: one(giftCardTemplates, {
        fields: [giftCards.templateId],
        references: [giftCardTemplates.id]
      }),
      transactions: many(giftCardTransactions),
      deliveries: many(giftCardDeliveries)
    }));
    giftCardTransactionsRelations = relations(giftCardTransactions, ({ one }) => ({
      giftCard: one(giftCards, {
        fields: [giftCardTransactions.giftCardId],
        references: [giftCards.id]
      }),
      salon: one(salons, {
        fields: [giftCardTransactions.salonId],
        references: [salons.id]
      }),
      booking: one(bookings, {
        fields: [giftCardTransactions.bookingId],
        references: [bookings.id]
      }),
      performer: one(users, {
        fields: [giftCardTransactions.performedBy],
        references: [users.id]
      })
    }));
    giftCardDeliveriesRelations = relations(giftCardDeliveries, ({ one }) => ({
      giftCard: one(giftCards, {
        fields: [giftCardDeliveries.giftCardId],
        references: [giftCards.id]
      })
    }));
    insertGiftCardTemplateSchema = createInsertSchema(giftCardTemplates).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    updateGiftCardTemplateSchema = createInsertSchema(giftCardTemplates).omit({
      id: true,
      salonId: true,
      createdAt: true,
      createdBy: true
    }).partial();
    insertGiftCardSchema = createInsertSchema(giftCards).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    updateGiftCardSchema = createInsertSchema(giftCards).omit({
      id: true,
      salonId: true,
      code: true,
      originalValuePaisa: true,
      createdAt: true
    }).partial();
    insertGiftCardTransactionSchema = createInsertSchema(giftCardTransactions).omit({
      id: true,
      createdAt: true
    });
    insertGiftCardDeliverySchema = createInsertSchema(giftCardDeliveries).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    purchaseGiftCardSchema = z.object({
      salonId: z.string(),
      templateId: z.string().optional(),
      valuePaisa: z.number().int().positive(),
      recipientName: z.string().max(100).optional(),
      recipientEmail: z.string().email().optional(),
      recipientPhone: z.string().max(20).optional(),
      personalMessage: z.string().max(500).optional(),
      deliveryMethod: z.enum(["email", "sms", "whatsapp", "print", "in_app"]).default("email"),
      scheduledDeliveryAt: z.string().datetime().optional()
      // ISO date string for scheduling
    });
    redeemGiftCardSchema = z.object({
      code: z.string().max(20),
      bookingId: z.string(),
      amountPaisa: z.number().int().positive().optional()
      // Optional for partial redemption
    });
    validateGiftCardSchema = z.object({
      code: z.string().max(20),
      salonId: z.string().optional()
      // Optional - to check if card is valid for specific salon
    });
    serviceRebookingCycles = pgTable("service_rebooking_cycles", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      serviceId: varchar("service_id").notNull().references(() => services.id, { onDelete: "cascade" }),
      // Rebooking cycle configuration
      recommendedDays: integer("recommended_days").notNull().default(30),
      // Days until next rebooking recommended
      minDays: integer("min_days").notNull().default(14),
      // Minimum days before suggesting rebooking
      maxDays: integer("max_days").notNull().default(60),
      // Maximum days before urgent rebooking needed
      // Reminder settings
      reminderEnabled: integer("reminder_enabled").notNull().default(1),
      // 1 = send reminders
      firstReminderDays: integer("first_reminder_days").notNull().default(3),
      // Days before due date to send first reminder
      secondReminderDays: integer("second_reminder_days"),
      // Days after due date to send second reminder (optional)
      // Reminder channels
      reminderChannels: text("reminder_channels").array().default(sql`ARRAY['email']::text[]`),
      // 'email', 'sms', 'push', 'whatsapp'
      // Customization
      customMessage: text("custom_message"),
      // Custom reminder message template
      // Analytics
      avgCompletionRate: decimal("avg_completion_rate", { precision: 5, scale: 2 }).default("0.00"),
      // Percentage of customers who rebook
      avgDaysBetweenBookings: decimal("avg_days_between_bookings", { precision: 6, scale: 2 }),
      // Actual average days between bookings
      // Status
      isActive: integer("is_active").notNull().default(1),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow(),
      createdBy: varchar("created_by").references(() => users.id, { onDelete: "set null" })
    }, (table) => [
      index("service_rebooking_cycles_salon_idx").on(table.salonId),
      index("service_rebooking_cycles_service_idx").on(table.serviceId),
      index("service_rebooking_cycles_active_idx").on(table.isActive),
      unique("service_rebooking_cycles_salon_service_unique").on(table.salonId, table.serviceId)
    ]);
    customerRebookingStats = pgTable("customer_rebooking_stats", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      customerId: varchar("customer_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      serviceId: varchar("service_id").notNull().references(() => services.id, { onDelete: "cascade" }),
      // Booking history
      totalBookings: integer("total_bookings").notNull().default(0),
      // Total times booked this service
      lastBookingId: varchar("last_booking_id").references(() => bookings.id, { onDelete: "set null" }),
      lastBookingDate: timestamp("last_booking_date"),
      // Next rebooking
      nextRebookingDue: timestamp("next_rebooking_due"),
      // Calculated date when rebooking is recommended
      rebookingStatus: varchar("rebooking_status", { length: 20 }).notNull().default("not_due"),
      // Options: 'not_due', 'approaching', 'due', 'overdue', 'booked', 'dismissed'
      // Customer behavior tracking
      avgDaysBetweenBookings: decimal("avg_days_between_bookings", { precision: 6, scale: 2 }),
      // Customer's actual average
      preferredDayOfWeek: integer("preferred_day_of_week"),
      // 0-6 (Sunday-Saturday)
      preferredTimeSlot: varchar("preferred_time_slot", { length: 20 }),
      // 'morning', 'afternoon', 'evening'
      preferredStaffId: varchar("preferred_staff_id").references(() => staff.id, { onDelete: "set null" }),
      // Engagement
      remindersReceived: integer("reminders_received").notNull().default(0),
      remindersDismissed: integer("reminders_dismissed").notNull().default(0),
      rebookingsFromReminders: integer("rebookings_from_reminders").notNull().default(0),
      // Conversions
      // Last interaction
      lastReminderSentAt: timestamp("last_reminder_sent_at"),
      lastDismissedAt: timestamp("last_dismissed_at"),
      dismissUntil: timestamp("dismiss_until"),
      // Customer can snooze reminders
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("customer_rebooking_stats_salon_idx").on(table.salonId),
      index("customer_rebooking_stats_customer_idx").on(table.customerId),
      index("customer_rebooking_stats_service_idx").on(table.serviceId),
      index("customer_rebooking_stats_next_due_idx").on(table.nextRebookingDue),
      index("customer_rebooking_stats_status_idx").on(table.rebookingStatus),
      unique("customer_rebooking_stats_unique").on(table.salonId, table.customerId, table.serviceId)
    ]);
    rebookingReminders = pgTable("rebooking_reminders", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      customerId: varchar("customer_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      serviceId: varchar("service_id").notNull().references(() => services.id, { onDelete: "cascade" }),
      customerStatId: varchar("customer_stat_id").references(() => customerRebookingStats.id, { onDelete: "cascade" }),
      // Reminder details
      reminderType: varchar("reminder_type", { length: 20 }).notNull().default("first"),
      // Options: 'first', 'second', 'final', 'custom'
      channel: varchar("channel", { length: 20 }).notNull(),
      // 'email', 'sms', 'push', 'whatsapp'
      // Message content
      subject: varchar("subject", { length: 255 }),
      messageBody: text("message_body"),
      // Scheduling
      scheduledAt: timestamp("scheduled_at"),
      sentAt: timestamp("sent_at"),
      // Status
      status: varchar("status", { length: 20 }).notNull().default("pending"),
      // Options: 'pending', 'scheduled', 'sent', 'delivered', 'failed', 'opened', 'clicked', 'dismissed', 'converted'
      // Delivery tracking
      externalMessageId: varchar("external_message_id", { length: 100 }),
      // SendGrid/Twilio ID
      deliveredAt: timestamp("delivered_at"),
      openedAt: timestamp("opened_at"),
      clickedAt: timestamp("clicked_at"),
      // Conversion tracking
      convertedBookingId: varchar("converted_booking_id").references(() => bookings.id, { onDelete: "set null" }),
      convertedAt: timestamp("converted_at"),
      // Error handling
      failedAt: timestamp("failed_at"),
      failureReason: text("failure_reason"),
      retryCount: integer("retry_count").notNull().default(0),
      maxRetries: integer("max_retries").notNull().default(3),
      // Customer action
      dismissedAt: timestamp("dismissed_at"),
      dismissReason: varchar("dismiss_reason", { length: 50 }),
      // 'not_interested', 'already_booked', 'snooze', 'unsubscribe'
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("rebooking_reminders_salon_idx").on(table.salonId),
      index("rebooking_reminders_customer_idx").on(table.customerId),
      index("rebooking_reminders_service_idx").on(table.serviceId),
      index("rebooking_reminders_scheduled_idx").on(table.scheduledAt),
      index("rebooking_reminders_status_idx").on(table.status),
      index("rebooking_reminders_sent_at_idx").on(table.sentAt)
    ]);
    rebookingSettings = pgTable("rebooking_settings", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }).unique(),
      // Global enable/disable
      isEnabled: integer("is_enabled").notNull().default(1),
      // Default cycle settings (used when service doesn't have specific settings)
      defaultRecommendedDays: integer("default_recommended_days").notNull().default(30),
      defaultMinDays: integer("default_min_days").notNull().default(14),
      defaultMaxDays: integer("default_max_days").notNull().default(60),
      // Default reminder settings
      defaultReminderEnabled: integer("default_reminder_enabled").notNull().default(1),
      defaultFirstReminderDays: integer("default_first_reminder_days").notNull().default(3),
      defaultSecondReminderDays: integer("default_second_reminder_days"),
      defaultReminderChannels: text("default_reminder_channels").array().default(sql`ARRAY['email']::text[]`),
      // Incentive settings
      enableRebookingDiscount: integer("enable_rebooking_discount").notNull().default(0),
      rebookingDiscountPercent: decimal("rebooking_discount_percent", { precision: 5, scale: 2 }).default("0.00"),
      discountValidDays: integer("discount_valid_days").notNull().default(7),
      // Days after due date discount is valid
      // Communication preferences
      maxRemindersPerService: integer("max_reminders_per_service").notNull().default(2),
      quietHoursStart: varchar("quiet_hours_start", { length: 5 }),
      // e.g., "21:00"
      quietHoursEnd: varchar("quiet_hours_end", { length: 5 }),
      // e.g., "09:00"
      // Opt-out management
      respectCustomerOptOut: integer("respect_customer_opt_out").notNull().default(1),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("rebooking_settings_salon_idx").on(table.salonId)
    ]);
    userBookingPreferences = pgTable("user_booking_preferences", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      preferredStaffId: varchar("preferred_staff_id").references(() => staff.id, { onDelete: "set null" }),
      preferredServiceIds: text("preferred_service_ids").array(),
      preferredDayOfWeek: integer("preferred_day_of_week"),
      preferredTimeSlot: varchar("preferred_time_slot", { length: 20 }),
      preferredTimeExact: text("preferred_time_exact"),
      averageBookingIntervalDays: integer("average_booking_interval_days"),
      lastBookingId: varchar("last_booking_id").references(() => bookings.id, { onDelete: "set null" }),
      lastBookingDate: text("last_booking_date"),
      totalCompletedBookings: integer("total_completed_bookings").notNull().default(0),
      totalSpentPaisa: integer("total_spent_paisa").notNull().default(0),
      updatedAt: timestamp("updated_at").defaultNow(),
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("user_booking_preferences_user_id_idx").on(table.userId),
      index("user_booking_preferences_salon_id_idx").on(table.salonId),
      uniqueIndex("user_booking_preferences_user_salon_unique").on(table.userId, table.salonId)
    ]);
    rebookSuggestions = pgTable("rebook_suggestions", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      suggestedDate: text("suggested_date").notNull(),
      suggestedTime: text("suggested_time").notNull(),
      suggestedServiceIds: text("suggested_service_ids").array().notNull(),
      suggestedStaffId: varchar("suggested_staff_id").references(() => staff.id, { onDelete: "set null" }),
      confidenceScore: integer("confidence_score").notNull(),
      reason: varchar("reason", { length: 255 }).notNull(),
      status: varchar("status", { length: 20 }).notNull().default("pending"),
      shownAt: timestamp("shown_at"),
      respondedAt: timestamp("responded_at"),
      resultingBookingId: varchar("resulting_booking_id").references(() => bookings.id, { onDelete: "set null" }),
      expiresAt: timestamp("expires_at").notNull(),
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("rebook_suggestions_user_id_idx").on(table.userId),
      index("rebook_suggestions_salon_id_idx").on(table.salonId),
      index("rebook_suggestions_status_idx").on(table.status),
      index("rebook_suggestions_expires_at_idx").on(table.expiresAt)
    ]);
    userBookingPreferencesRelations = relations(userBookingPreferences, ({ one }) => ({
      user: one(users, {
        fields: [userBookingPreferences.userId],
        references: [users.id]
      }),
      salon: one(salons, {
        fields: [userBookingPreferences.salonId],
        references: [salons.id]
      }),
      preferredStaff: one(staff, {
        fields: [userBookingPreferences.preferredStaffId],
        references: [staff.id]
      }),
      lastBooking: one(bookings, {
        fields: [userBookingPreferences.lastBookingId],
        references: [bookings.id]
      })
    }));
    rebookSuggestionsRelations = relations(rebookSuggestions, ({ one }) => ({
      user: one(users, {
        fields: [rebookSuggestions.userId],
        references: [users.id]
      }),
      salon: one(salons, {
        fields: [rebookSuggestions.salonId],
        references: [salons.id]
      }),
      suggestedStaff: one(staff, {
        fields: [rebookSuggestions.suggestedStaffId],
        references: [staff.id]
      }),
      resultingBooking: one(bookings, {
        fields: [rebookSuggestions.resultingBookingId],
        references: [bookings.id]
      })
    }));
    serviceRebookingCyclesRelations = relations(serviceRebookingCycles, ({ one }) => ({
      salon: one(salons, {
        fields: [serviceRebookingCycles.salonId],
        references: [salons.id]
      }),
      service: one(services, {
        fields: [serviceRebookingCycles.serviceId],
        references: [services.id]
      })
    }));
    customerRebookingStatsRelations = relations(customerRebookingStats, ({ one }) => ({
      salon: one(salons, {
        fields: [customerRebookingStats.salonId],
        references: [salons.id]
      }),
      customer: one(users, {
        fields: [customerRebookingStats.customerId],
        references: [users.id]
      }),
      service: one(services, {
        fields: [customerRebookingStats.serviceId],
        references: [services.id]
      }),
      lastBooking: one(bookings, {
        fields: [customerRebookingStats.lastBookingId],
        references: [bookings.id]
      }),
      preferredStaff: one(staff, {
        fields: [customerRebookingStats.preferredStaffId],
        references: [staff.id]
      })
    }));
    rebookingRemindersRelations = relations(rebookingReminders, ({ one }) => ({
      salon: one(salons, {
        fields: [rebookingReminders.salonId],
        references: [salons.id]
      }),
      customer: one(users, {
        fields: [rebookingReminders.customerId],
        references: [users.id]
      }),
      service: one(services, {
        fields: [rebookingReminders.serviceId],
        references: [services.id]
      }),
      customerStat: one(customerRebookingStats, {
        fields: [rebookingReminders.customerStatId],
        references: [customerRebookingStats.id]
      }),
      convertedBooking: one(bookings, {
        fields: [rebookingReminders.convertedBookingId],
        references: [bookings.id]
      })
    }));
    rebookingSettingsRelations = relations(rebookingSettings, ({ one }) => ({
      salon: one(salons, {
        fields: [rebookingSettings.salonId],
        references: [salons.id]
      })
    }));
    insertServiceRebookingCycleSchema = createInsertSchema(serviceRebookingCycles).omit({
      id: true,
      createdAt: true,
      updatedAt: true,
      avgCompletionRate: true,
      avgDaysBetweenBookings: true
    });
    updateServiceRebookingCycleSchema = createInsertSchema(serviceRebookingCycles).omit({
      id: true,
      salonId: true,
      serviceId: true,
      createdAt: true,
      createdBy: true
    }).partial();
    insertCustomerRebookingStatSchema = createInsertSchema(customerRebookingStats).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    updateCustomerRebookingStatSchema = createInsertSchema(customerRebookingStats).omit({
      id: true,
      salonId: true,
      customerId: true,
      serviceId: true,
      createdAt: true
    }).partial();
    insertRebookingReminderSchema = createInsertSchema(rebookingReminders).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    insertRebookingSettingsSchema = createInsertSchema(rebookingSettings).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    updateRebookingSettingsSchema = createInsertSchema(rebookingSettings).omit({
      id: true,
      salonId: true,
      createdAt: true
    }).partial();
    createRebookingCycleSchema = z.object({
      serviceId: z.string(),
      recommendedDays: z.number().int().positive().default(30),
      minDays: z.number().int().positive().default(14),
      maxDays: z.number().int().positive().default(60),
      reminderEnabled: z.boolean().default(true),
      firstReminderDays: z.number().int().positive().default(3),
      secondReminderDays: z.number().int().positive().optional(),
      reminderChannels: z.array(z.enum(["email", "sms", "push", "whatsapp"])).default(["email"]),
      customMessage: z.string().max(500).optional()
    });
    updateRebookingCycleSchema = createRebookingCycleSchema.partial();
    updateRebookingSettingsRequestSchema = z.object({
      isEnabled: z.boolean().optional(),
      defaultRecommendedDays: z.number().int().positive().optional(),
      defaultMinDays: z.number().int().positive().optional(),
      defaultMaxDays: z.number().int().positive().optional(),
      defaultReminderEnabled: z.boolean().optional(),
      defaultFirstReminderDays: z.number().int().positive().optional(),
      defaultSecondReminderDays: z.number().int().positive().optional(),
      defaultReminderChannels: z.array(z.enum(["email", "sms", "push", "whatsapp"])).optional(),
      enableRebookingDiscount: z.boolean().optional(),
      rebookingDiscountPercent: z.number().min(0).max(100).optional(),
      discountValidDays: z.number().int().positive().optional(),
      maxRemindersPerService: z.number().int().positive().max(5).optional(),
      quietHoursStart: z.string().regex(/^\d{2}:\d{2}$/).optional(),
      quietHoursEnd: z.string().regex(/^\d{2}:\d{2}$/).optional(),
      respectCustomerOptOut: z.boolean().optional()
    });
    rebookingSuggestionSchema = z.object({
      serviceId: z.string(),
      serviceName: z.string(),
      salonId: z.string(),
      salonName: z.string(),
      lastBookingDate: z.string(),
      dueDate: z.string(),
      daysOverdue: z.number(),
      status: z.enum(["approaching", "due", "overdue"]),
      preferredStaffId: z.string().optional(),
      preferredStaffName: z.string().optional(),
      preferredDayOfWeek: z.number().optional(),
      preferredTimeSlot: z.string().optional(),
      discountAvailable: z.boolean().default(false),
      discountPercent: z.number().optional()
    });
    quickRebookSchema = z.object({
      suggestionId: z.string()
    });
    customizeRebookSchema = z.object({
      suggestionId: z.string(),
      modifications: z.object({
        date: z.string().optional(),
        time: z.string().optional(),
        addServiceIds: z.array(z.string()).optional(),
        removeServiceIds: z.array(z.string()).optional(),
        staffId: z.string().optional()
      })
    });
    dismissRebookSuggestionSchema = z.object({
      suggestionId: z.string(),
      reason: z.enum(["not_now", "wrong_service", "wrong_time", "changed_salon", "other"]).optional()
    });
    dismissRebookingSchema = z.object({
      serviceId: z.string(),
      salonId: z.string(),
      reason: z.enum(["not_interested", "already_booked", "snooze", "unsubscribe"]),
      snoozeDays: z.number().int().positive().max(90).optional()
      // Only for snooze reason
    });
    shopRoleTypes = ["business_owner", "shop_admin", "staff"];
    permissionCategories = [
      "shop_management",
      "staff_management",
      "services_products",
      "bookings",
      "events",
      "analytics",
      "settings",
      "gift_cards",
      "chat"
    ];
    permissions = pgTable("permissions", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      code: varchar("code", { length: 100 }).notNull().unique(),
      // e.g., 'shop.edit', 'staff.create', 'booking.manage'
      name: varchar("name", { length: 100 }).notNull(),
      // Human-readable name
      description: text("description"),
      category: varchar("category", { length: 50 }).notNull(),
      // shop_management, staff_management, etc.
      isActive: integer("is_active").notNull().default(1),
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("permissions_category_idx").on(table.category),
      index("permissions_code_idx").on(table.code)
    ]);
    insertPermissionSchema = createInsertSchema(permissions).omit({
      id: true,
      createdAt: true
    });
    shopRolePermissions = pgTable("shop_role_permissions", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      role: varchar("role", { length: 50 }).notNull(),
      // 'business_owner', 'shop_admin', 'staff'
      permissionId: varchar("permission_id").notNull().references(() => permissions.id, { onDelete: "cascade" }),
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("shop_role_permissions_role_idx").on(table.role),
      uniqueIndex("shop_role_permissions_unique").on(table.role, table.permissionId)
    ]);
    insertShopRolePermissionSchema = createInsertSchema(shopRolePermissions).omit({
      id: true,
      createdAt: true
    });
    shopRoleAssignments = pgTable("shop_role_assignments", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      role: varchar("role", { length: 50 }).notNull(),
      // 'shop_admin', 'staff'
      assignedBy: varchar("assigned_by").references(() => users.id, { onDelete: "set null" }),
      // Who assigned this role
      isActive: integer("is_active").notNull().default(1),
      assignedAt: timestamp("assigned_at").defaultNow(),
      revokedAt: timestamp("revoked_at"),
      revokedBy: varchar("revoked_by").references(() => users.id, { onDelete: "set null" }),
      notes: text("notes")
      // Optional notes about the assignment
    }, (table) => [
      index("shop_role_assignments_user_idx").on(table.userId),
      index("shop_role_assignments_salon_idx").on(table.salonId),
      index("shop_role_assignments_role_idx").on(table.role),
      // Unique active assignment per user per salon (user can only have one active role per salon)
      uniqueIndex("shop_role_assignments_active_unique").on(table.userId, table.salonId).where(sql`${table.isActive} = 1`)
    ]);
    insertShopRoleAssignmentSchema = createInsertSchema(shopRoleAssignments).omit({
      id: true,
      assignedAt: true,
      revokedAt: true
    });
    adminAuditLogs = pgTable("admin_audit_logs", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      // Who performed the action
      salonId: varchar("salon_id").references(() => salons.id, { onDelete: "cascade" }),
      // Which salon (null for org-level)
      action: varchar("action", { length: 100 }).notNull(),
      // 'role_assigned', 'role_revoked', 'permission_changed', etc.
      targetUserId: varchar("target_user_id").references(() => users.id, { onDelete: "set null" }),
      // User affected by action
      previousValue: jsonb("previous_value"),
      // Previous state before change
      newValue: jsonb("new_value"),
      // New state after change
      ipAddress: varchar("ip_address", { length: 45 }),
      userAgent: text("user_agent"),
      metadata: jsonb("metadata"),
      // Additional context
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("admin_audit_logs_user_idx").on(table.userId),
      index("admin_audit_logs_salon_idx").on(table.salonId),
      index("admin_audit_logs_action_idx").on(table.action),
      index("admin_audit_logs_created_at_idx").on(table.createdAt)
    ]);
    insertAdminAuditLogSchema = createInsertSchema(adminAuditLogs).omit({
      id: true,
      createdAt: true
    });
    shopRoleAssignmentsRelations = relations(shopRoleAssignments, ({ one }) => ({
      user: one(users, {
        fields: [shopRoleAssignments.userId],
        references: [users.id]
      }),
      salon: one(salons, {
        fields: [shopRoleAssignments.salonId],
        references: [salons.id]
      }),
      assignedByUser: one(users, {
        fields: [shopRoleAssignments.assignedBy],
        references: [users.id],
        relationName: "assignedBy"
      })
    }));
    shopRolePermissionsRelations = relations(shopRolePermissions, ({ one }) => ({
      permission: one(permissions, {
        fields: [shopRolePermissions.permissionId],
        references: [permissions.id]
      })
    }));
    adminAuditLogsRelations = relations(adminAuditLogs, ({ one }) => ({
      user: one(users, {
        fields: [adminAuditLogs.userId],
        references: [users.id],
        relationName: "performer"
      }),
      salon: one(salons, {
        fields: [adminAuditLogs.salonId],
        references: [salons.id]
      }),
      targetUser: one(users, {
        fields: [adminAuditLogs.targetUserId],
        references: [users.id],
        relationName: "target"
      })
    }));
    assignShopRoleSchema = z.object({
      userId: z.string(),
      salonId: z.string(),
      role: z.enum(["shop_admin", "staff"]),
      notes: z.string().max(500).optional()
    });
    revokeShopRoleSchema = z.object({
      userId: z.string(),
      salonId: z.string()
    });
    updateShopRoleSchema = z.object({
      userId: z.string(),
      salonId: z.string(),
      newRole: z.enum(["shop_admin", "staff"]),
      notes: z.string().max(500).optional()
    });
    userSalonPermissionsSchema = z.object({
      userId: z.string(),
      salonId: z.string(),
      role: z.enum(["business_owner", "shop_admin", "staff"]),
      permissions: z.array(z.string()),
      // Array of permission codes
      isBusinessOwner: z.boolean()
    });
    shopAdminListItemSchema = z.object({
      userId: z.string(),
      userName: z.string(),
      userEmail: z.string().nullable(),
      userPhone: z.string().nullable(),
      userProfileImage: z.string().nullable(),
      role: z.enum(["shop_admin", "staff"]),
      assignedAt: z.string(),
      assignedByName: z.string().nullable(),
      isActive: z.boolean()
    });
    jobCards = pgTable("job_cards", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      // Core References
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      bookingId: varchar("booking_id").references(() => bookings.id, { onDelete: "set null" }),
      customerId: varchar("customer_id").references(() => users.id, { onDelete: "set null" }),
      // Job Card Number - Sequential per salon per day (e.g., "JC-20251207-001")
      jobCardNumber: varchar("job_card_number", { length: 30 }).notNull(),
      // Customer Info (snapshot - may differ from booking for walk-ins)
      customerName: text("customer_name").notNull(),
      customerEmail: text("customer_email"),
      customerPhone: text("customer_phone"),
      // Check-in Details
      checkInMethod: varchar("check_in_method", { length: 20 }).notNull().default("manual"),
      checkInAt: timestamp("check_in_at").notNull().defaultNow(),
      checkInBy: varchar("check_in_by").references(() => users.id, { onDelete: "set null" }),
      // Assigned Staff (primary stylist/therapist)
      assignedStaffId: varchar("assigned_staff_id").references(() => staff.id, { onDelete: "set null" }),
      // Service Timing
      serviceStartAt: timestamp("service_start_at"),
      serviceEndAt: timestamp("service_end_at"),
      estimatedDurationMinutes: integer("estimated_duration_minutes"),
      actualDurationMinutes: integer("actual_duration_minutes"),
      // Status Workflow
      status: varchar("status", { length: 20 }).notNull().default("open"),
      // Billing Summary (all amounts in paisa)
      subtotalPaisa: integer("subtotal_paisa").notNull().default(0),
      discountAmountPaisa: integer("discount_amount_paisa").notNull().default(0),
      discountType: varchar("discount_type", { length: 20 }),
      discountValue: decimal("discount_value", { precision: 10, scale: 2 }),
      discountReason: text("discount_reason"),
      taxAmountPaisa: integer("tax_amount_paisa").notNull().default(0),
      tipAmountPaisa: integer("tip_amount_paisa").notNull().default(0),
      totalAmountPaisa: integer("total_amount_paisa").notNull().default(0),
      paidAmountPaisa: integer("paid_amount_paisa").notNull().default(0),
      balancePaisa: integer("balance_paisa").notNull().default(0),
      currency: varchar("currency", { length: 3 }).notNull().default("INR"),
      // Payment Status
      paymentStatus: varchar("payment_status", { length: 20 }).notNull().default("unpaid"),
      // Checkout Details
      checkoutAt: timestamp("checkout_at"),
      checkoutBy: varchar("checkout_by").references(() => users.id, { onDelete: "set null" }),
      receiptNumber: varchar("receipt_number", { length: 50 }),
      receiptUrl: text("receipt_url"),
      // Notes
      internalNotes: text("internal_notes"),
      customerNotes: text("customer_notes"),
      // Walk-in vs Booking
      isWalkIn: integer("is_walk_in").notNull().default(0),
      // Cancellation Details
      cancellationReason: text("cancellation_reason"),
      cancelledAt: timestamp("cancelled_at"),
      cancelledBy: varchar("cancelled_by").references(() => users.id, { onDelete: "set null" }),
      // Feedback
      feedbackRequested: integer("feedback_requested").notNull().default(0),
      feedbackRequestedAt: timestamp("feedback_requested_at"),
      // Metadata
      metadata: jsonb("metadata").default(sql`'{}'::jsonb`),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("job_cards_salon_idx").on(table.salonId),
      index("job_cards_booking_idx").on(table.bookingId),
      index("job_cards_customer_idx").on(table.customerId),
      index("job_cards_status_idx").on(table.status),
      index("job_cards_check_in_at_idx").on(table.checkInAt),
      index("job_cards_assigned_staff_idx").on(table.assignedStaffId),
      unique("job_cards_number_salon_unique").on(table.salonId, table.jobCardNumber),
      check("job_card_status_valid", sql`status IN ('open', 'in_service', 'pending_checkout', 'completed', 'cancelled', 'no_show')`),
      check("check_in_method_valid", sql`check_in_method IN ('manual', 'qr_code', 'self_checkin', 'booking_auto')`),
      check("payment_status_valid", sql`payment_status IN ('unpaid', 'partial', 'paid', 'refunded')`),
      check("is_walk_in_valid", sql`is_walk_in IN (0, 1)`),
      check("feedback_requested_valid", sql`feedback_requested IN (0, 1)`)
    ]);
    jobCardServices = pgTable("job_card_services", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      jobCardId: varchar("job_card_id").notNull().references(() => jobCards.id, { onDelete: "cascade" }),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      serviceId: varchar("service_id").notNull().references(() => services.id, { onDelete: "restrict" }),
      staffId: varchar("staff_id").references(() => staff.id, { onDelete: "set null" }),
      // Service Details (snapshot at time of addition)
      serviceName: text("service_name").notNull(),
      serviceCategory: varchar("service_category", { length: 100 }),
      // Pricing
      originalPricePaisa: integer("original_price_paisa").notNull(),
      discountPaisa: integer("discount_paisa").notNull().default(0),
      finalPricePaisa: integer("final_price_paisa").notNull(),
      // Duration
      estimatedDurationMinutes: integer("estimated_duration_minutes").notNull(),
      actualDurationMinutes: integer("actual_duration_minutes"),
      // Status
      status: varchar("status", { length: 20 }).notNull().default("pending"),
      startedAt: timestamp("started_at"),
      completedAt: timestamp("completed_at"),
      // Sequence/Order
      sequence: integer("sequence").notNull().default(1),
      // Notes
      notes: text("notes"),
      // Commission tracking
      commissionCalculated: integer("commission_calculated").notNull().default(0),
      commissionId: varchar("commission_id").references(() => commissions.id, { onDelete: "set null" }),
      // Source tracking
      source: varchar("source", { length: 20 }).notNull().default("booking"),
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("job_card_services_job_card_idx").on(table.jobCardId),
      index("job_card_services_salon_idx").on(table.salonId),
      index("job_card_services_service_idx").on(table.serviceId),
      index("job_card_services_staff_idx").on(table.staffId),
      check("jcs_status_valid", sql`status IN ('pending', 'in_progress', 'completed', 'cancelled')`),
      check("jcs_source_valid", sql`source IN ('booking', 'addon', 'walk_in')`),
      check("jcs_commission_calculated_valid", sql`commission_calculated IN (0, 1)`)
    ]);
    jobCardProducts = pgTable("job_card_products", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      jobCardId: varchar("job_card_id").notNull().references(() => jobCards.id, { onDelete: "cascade" }),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      productId: varchar("product_id").notNull().references(() => products.id, { onDelete: "restrict" }),
      staffId: varchar("staff_id").references(() => staff.id, { onDelete: "set null" }),
      // Product Details (snapshot at time of sale)
      productName: text("product_name").notNull(),
      productSku: varchar("product_sku", { length: 100 }),
      productCategory: varchar("product_category", { length: 100 }),
      // Quantity and Pricing
      quantity: integer("quantity").notNull().default(1),
      unitPricePaisa: integer("unit_price_paisa").notNull(),
      discountPaisa: integer("discount_paisa").notNull().default(0),
      totalPricePaisa: integer("total_price_paisa").notNull(),
      // Tax (products may have different GST than services)
      taxRatePercent: decimal("tax_rate_percent", { precision: 5, scale: 2 }),
      taxAmountPaisa: integer("tax_amount_paisa").notNull().default(0),
      // Inventory tracking
      inventoryDeducted: integer("inventory_deducted").notNull().default(0),
      inventoryTransactionId: varchar("inventory_transaction_id"),
      // Final price after discounts
      finalPricePaisa: integer("final_price_paisa"),
      // Commission tracking
      commissionCalculated: integer("commission_calculated").notNull().default(0),
      commissionId: varchar("commission_id"),
      // Notes
      notes: text("notes"),
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("job_card_products_job_card_idx").on(table.jobCardId),
      index("job_card_products_salon_idx").on(table.salonId),
      index("job_card_products_product_idx").on(table.productId),
      index("job_card_products_staff_idx").on(table.staffId),
      check("jcp_inventory_deducted_valid", sql`inventory_deducted IN (0, 1)`)
    ]);
    jobCardPayments = pgTable("job_card_payments", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      jobCardId: varchar("job_card_id").notNull().references(() => jobCards.id, { onDelete: "cascade" }),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      // Payment Details
      paymentMethod: varchar("payment_method", { length: 30 }).notNull(),
      amountPaisa: integer("amount_paisa").notNull(),
      currency: varchar("currency", { length: 3 }).notNull().default("INR"),
      // Status
      status: varchar("status", { length: 20 }).notNull().default("pending"),
      // Payment Gateway Details (if online)
      razorpayOrderId: text("razorpay_order_id"),
      razorpayPaymentId: text("razorpay_payment_id"),
      razorpaySignature: text("razorpay_signature"),
      transactionId: varchar("transaction_id", { length: 100 }),
      // For card payments
      cardLast4: varchar("card_last_4", { length: 4 }),
      cardNetwork: varchar("card_network", { length: 20 }),
      // For UPI payments
      upiId: varchar("upi_id", { length: 100 }),
      // Refund tracking
      isRefund: integer("is_refund").notNull().default(0),
      refundedFromPaymentId: varchar("refunded_from_payment_id"),
      refundReason: text("refund_reason"),
      // Notes
      notes: text("notes"),
      // Collected by
      collectedBy: varchar("collected_by").references(() => users.id, { onDelete: "set null" }),
      createdAt: timestamp("created_at").defaultNow(),
      completedAt: timestamp("completed_at")
    }, (table) => [
      index("job_card_payments_job_card_idx").on(table.jobCardId),
      index("job_card_payments_salon_idx").on(table.salonId),
      index("job_card_payments_method_idx").on(table.paymentMethod),
      index("job_card_payments_status_idx").on(table.status),
      check("jcpay_method_valid", sql`payment_method IN ('cash', 'card', 'upi', 'wallet', 'razorpay', 'bank_transfer', 'other')`),
      check("jcpay_status_valid", sql`status IN ('pending', 'completed', 'failed', 'refunded')`),
      check("jcpay_is_refund_valid", sql`is_refund IN (0, 1)`)
    ]);
    jobCardTips = pgTable("job_card_tips", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      jobCardId: varchar("job_card_id").notNull().references(() => jobCards.id, { onDelete: "cascade" }),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      staffId: varchar("staff_id").notNull().references(() => staff.id, { onDelete: "cascade" }),
      // Tip Amount
      amountPaisa: integer("amount_paisa").notNull(),
      currency: varchar("currency", { length: 3 }).notNull().default("INR"),
      // Payment Method (may differ from main payment)
      paymentMethod: varchar("payment_method", { length: 30 }).notNull().default("cash"),
      // Notes
      notes: text("notes"),
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("job_card_tips_job_card_idx").on(table.jobCardId),
      index("job_card_tips_salon_idx").on(table.salonId),
      index("job_card_tips_staff_idx").on(table.staffId),
      check("jct_payment_method_valid", sql`payment_method IN ('cash', 'card', 'upi', 'wallet', 'included_in_payment')`)
    ]);
    jobCardActivityLog = pgTable("job_card_activity_log", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      jobCardId: varchar("job_card_id").notNull().references(() => jobCards.id, { onDelete: "cascade" }),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      // Activity Details
      activityType: varchar("activity_type", { length: 50 }).notNull(),
      description: text("description").notNull(),
      // Before/After state (for auditing)
      previousValue: jsonb("previous_value"),
      newValue: jsonb("new_value"),
      // Who performed the action
      performedBy: varchar("performed_by").references(() => users.id, { onDelete: "set null" }),
      performedByName: text("performed_by_name"),
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("job_card_activity_job_card_idx").on(table.jobCardId),
      index("job_card_activity_salon_idx").on(table.salonId),
      index("job_card_activity_type_idx").on(table.activityType),
      index("job_card_activity_created_idx").on(table.createdAt)
    ]);
    jobCardsRelations = relations(jobCards, ({ one, many }) => ({
      salon: one(salons, {
        fields: [jobCards.salonId],
        references: [salons.id]
      }),
      booking: one(bookings, {
        fields: [jobCards.bookingId],
        references: [bookings.id]
      }),
      customer: one(users, {
        fields: [jobCards.customerId],
        references: [users.id]
      }),
      assignedStaff: one(staff, {
        fields: [jobCards.assignedStaffId],
        references: [staff.id]
      }),
      checkInByUser: one(users, {
        fields: [jobCards.checkInBy],
        references: [users.id],
        relationName: "checkInBy"
      }),
      checkoutByUser: one(users, {
        fields: [jobCards.checkoutBy],
        references: [users.id],
        relationName: "checkoutBy"
      }),
      services: many(jobCardServices),
      products: many(jobCardProducts),
      payments: many(jobCardPayments),
      tips: many(jobCardTips),
      activityLog: many(jobCardActivityLog)
    }));
    jobCardServicesRelations = relations(jobCardServices, ({ one }) => ({
      jobCard: one(jobCards, {
        fields: [jobCardServices.jobCardId],
        references: [jobCards.id]
      }),
      salon: one(salons, {
        fields: [jobCardServices.salonId],
        references: [salons.id]
      }),
      service: one(services, {
        fields: [jobCardServices.serviceId],
        references: [services.id]
      }),
      staff: one(staff, {
        fields: [jobCardServices.staffId],
        references: [staff.id]
      }),
      commission: one(commissions, {
        fields: [jobCardServices.commissionId],
        references: [commissions.id]
      })
    }));
    jobCardProductsRelations = relations(jobCardProducts, ({ one }) => ({
      jobCard: one(jobCards, {
        fields: [jobCardProducts.jobCardId],
        references: [jobCards.id]
      }),
      salon: one(salons, {
        fields: [jobCardProducts.salonId],
        references: [salons.id]
      }),
      product: one(products, {
        fields: [jobCardProducts.productId],
        references: [products.id]
      }),
      staff: one(staff, {
        fields: [jobCardProducts.staffId],
        references: [staff.id]
      })
    }));
    jobCardPaymentsRelations = relations(jobCardPayments, ({ one }) => ({
      jobCard: one(jobCards, {
        fields: [jobCardPayments.jobCardId],
        references: [jobCards.id]
      }),
      salon: one(salons, {
        fields: [jobCardPayments.salonId],
        references: [salons.id]
      }),
      collectedByUser: one(users, {
        fields: [jobCardPayments.collectedBy],
        references: [users.id]
      })
    }));
    jobCardTipsRelations = relations(jobCardTips, ({ one }) => ({
      jobCard: one(jobCards, {
        fields: [jobCardTips.jobCardId],
        references: [jobCards.id]
      }),
      salon: one(salons, {
        fields: [jobCardTips.salonId],
        references: [salons.id]
      }),
      staff: one(staff, {
        fields: [jobCardTips.staffId],
        references: [staff.id]
      })
    }));
    jobCardActivityLogRelations = relations(jobCardActivityLog, ({ one }) => ({
      jobCard: one(jobCards, {
        fields: [jobCardActivityLog.jobCardId],
        references: [jobCards.id]
      }),
      salon: one(salons, {
        fields: [jobCardActivityLog.salonId],
        references: [salons.id]
      }),
      performedByUser: one(users, {
        fields: [jobCardActivityLog.performedBy],
        references: [users.id]
      })
    }));
    insertJobCardSchema = createInsertSchema(jobCards).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    }).extend({
      checkInAt: z.union([z.date(), z.string().datetime()]).optional().transform((val) => {
        if (!val) return /* @__PURE__ */ new Date();
        if (typeof val === "string") return new Date(val);
        return val;
      })
    });
    insertJobCardServiceSchema = createInsertSchema(jobCardServices).omit({
      id: true,
      createdAt: true
    });
    insertJobCardProductSchema = createInsertSchema(jobCardProducts).omit({
      id: true,
      createdAt: true
    });
    insertJobCardPaymentSchema = createInsertSchema(jobCardPayments).omit({
      id: true,
      createdAt: true,
      completedAt: true
    });
    insertJobCardTipSchema = createInsertSchema(jobCardTips).omit({
      id: true,
      createdAt: true
    });
    insertJobCardActivityLogSchema = createInsertSchema(jobCardActivityLog).omit({
      id: true,
      createdAt: true
    });
    checkInCustomerSchema = z.object({
      bookingId: z.string().optional(),
      customerName: z.string().min(1, "Customer name is required"),
      customerEmail: z.string().email().optional(),
      customerPhone: z.string().optional(),
      assignedStaffId: z.string().optional(),
      checkInMethod: z.enum(["manual", "qr_code", "self_checkin", "booking_auto", "walk_in"]).default("manual"),
      isWalkIn: z.boolean().default(false),
      serviceIds: z.array(z.string()).optional(),
      staffId: z.string().optional(),
      notes: z.string().optional(),
      verificationSessionId: z.string().optional()
    });
    addJobCardServiceSchema = z.object({
      serviceId: z.string(),
      staffId: z.string().optional(),
      discountPaisa: z.number().min(0, "Discount cannot be negative").optional().default(0),
      notes: z.string().optional()
    });
    addJobCardProductSchema = z.object({
      productId: z.string(),
      staffId: z.string().optional(),
      quantity: z.number().min(1).default(1),
      discountPaisa: z.number().min(0, "Discount cannot be negative").optional().default(0),
      notes: z.string().optional()
    });
    processJobCardPaymentSchema = z.object({
      paymentMethod: z.enum(["cash", "card", "upi", "wallet", "razorpay", "bank_transfer", "other"]),
      amountPaisa: z.number().min(1),
      transactionId: z.string().optional(),
      cardLast4: z.string().max(4).optional(),
      cardNetwork: z.string().optional(),
      upiId: z.string().optional(),
      notes: z.string().optional()
    });
    addJobCardTipSchema = z.object({
      staffId: z.string(),
      amountPaisa: z.number().min(1),
      paymentMethod: z.enum(["cash", "card", "upi", "wallet", "included_in_payment"]).default("cash"),
      notes: z.string().optional()
    });
    applyJobCardDiscountSchema = z.object({
      discountType: z.enum(["percentage", "fixed"]),
      discountValue: z.number().min(0),
      discountReason: z.string().optional()
    }).refine(
      (data) => !(data.discountType === "percentage" && data.discountValue > 100),
      { message: "Percentage discount cannot exceed 100%", path: ["discountValue"] }
    );
    updateJobCardStatusSchema = z.object({
      status: z.enum(["open", "in_service", "pending_checkout", "completed", "cancelled", "no_show"]),
      notes: z.string().optional()
    });
    JOB_CARD_STATUSES = {
      OPEN: "open",
      IN_SERVICE: "in_service",
      PENDING_CHECKOUT: "pending_checkout",
      COMPLETED: "completed",
      CANCELLED: "cancelled",
      NO_SHOW: "no_show"
    };
    JOB_CARD_STATUS_TRANSITIONS = {
      [JOB_CARD_STATUSES.OPEN]: [JOB_CARD_STATUSES.IN_SERVICE, JOB_CARD_STATUSES.CANCELLED, JOB_CARD_STATUSES.NO_SHOW],
      [JOB_CARD_STATUSES.IN_SERVICE]: [JOB_CARD_STATUSES.PENDING_CHECKOUT, JOB_CARD_STATUSES.CANCELLED],
      [JOB_CARD_STATUSES.PENDING_CHECKOUT]: [JOB_CARD_STATUSES.IN_SERVICE, JOB_CARD_STATUSES.COMPLETED, JOB_CARD_STATUSES.CANCELLED],
      [JOB_CARD_STATUSES.COMPLETED]: [],
      // Terminal state - no transitions allowed
      [JOB_CARD_STATUSES.CANCELLED]: [],
      // Terminal state - no transitions allowed
      [JOB_CARD_STATUSES.NO_SHOW]: [JOB_CARD_STATUSES.OPEN]
      // Can reopen if customer arrives late
    };
    JOB_CARD_PAYMENT_STATUSES = {
      UNPAID: "unpaid",
      PARTIAL: "partial",
      PAID: "paid",
      REFUNDED: "refunded"
    };
    CHECK_IN_METHODS = {
      MANUAL: "manual",
      QR_CODE: "qr_code",
      SELF_CHECKIN: "self_checkin",
      BOOKING_AUTO: "booking_auto"
    };
    PAYMENT_METHODS = {
      CASH: "cash",
      CARD: "card",
      UPI: "upi",
      WALLET: "wallet",
      RAZORPAY: "razorpay",
      BANK_TRANSFER: "bank_transfer",
      OTHER: "other"
    };
    customerImportBatches = pgTable("customer_import_batches", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      importedBy: varchar("imported_by").notNull().references(() => users.id),
      fileName: varchar("file_name", { length: 255 }),
      totalRecords: integer("total_records").notNull().default(0),
      successfulImports: integer("successful_imports").notNull().default(0),
      failedImports: integer("failed_imports").notNull().default(0),
      duplicateSkipped: integer("duplicate_skipped").notNull().default(0),
      status: varchar("status", { length: 20 }).notNull().default("processing"),
      errorLog: jsonb("error_log"),
      createdAt: timestamp("created_at").defaultNow(),
      completedAt: timestamp("completed_at")
    }, (table) => [
      index("customer_import_batches_salon_id_idx").on(table.salonId),
      index("customer_import_batches_status_idx").on(table.status)
    ]);
    insertCustomerImportBatchSchema = createInsertSchema(customerImportBatches).omit({
      id: true,
      createdAt: true,
      completedAt: true
    });
    importedCustomers = pgTable("imported_customers", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      importBatchId: varchar("import_batch_id").references(() => customerImportBatches.id, { onDelete: "set null" }),
      customerName: varchar("customer_name", { length: 255 }).notNull(),
      phone: varchar("phone", { length: 20 }).notNull(),
      email: varchar("email", { length: 255 }),
      normalizedPhone: varchar("normalized_phone", { length: 20 }).notNull(),
      status: varchar("status", { length: 20 }).notNull().default("pending"),
      invitedAt: timestamp("invited_at"),
      registeredAt: timestamp("registered_at"),
      linkedUserId: varchar("linked_user_id").references(() => users.id, { onDelete: "set null" }),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      unique("imported_customers_salon_phone_unique").on(table.salonId, table.normalizedPhone),
      index("imported_customers_normalized_phone_idx").on(table.normalizedPhone),
      index("imported_customers_salon_id_idx").on(table.salonId),
      index("imported_customers_status_idx").on(table.status)
    ]);
    insertImportedCustomerSchema = createInsertSchema(importedCustomers).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    welcomeOffers = pgTable("welcome_offers", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      name: varchar("name", { length: 255 }).notNull(),
      discountType: varchar("discount_type", { length: 20 }).notNull(),
      discountValue: integer("discount_value").notNull(),
      maxDiscountInPaisa: integer("max_discount_in_paisa"),
      minimumPurchaseInPaisa: integer("minimum_purchase_in_paisa"),
      validityDays: integer("validity_days").notNull().default(30),
      usageLimit: integer("usage_limit").notNull().default(1),
      isActive: integer("is_active").notNull().default(1),
      totalRedemptions: integer("total_redemptions").notNull().default(0),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("welcome_offers_salon_id_idx").on(table.salonId),
      index("welcome_offers_is_active_idx").on(table.isActive)
    ]);
    insertWelcomeOfferSchema = createInsertSchema(welcomeOffers).omit({
      id: true,
      createdAt: true,
      updatedAt: true,
      totalRedemptions: true
    });
    invitationCampaigns = pgTable("invitation_campaigns", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      name: varchar("name", { length: 255 }).notNull(),
      channel: varchar("channel", { length: 20 }).notNull().default("whatsapp"),
      messageTemplate: text("message_template").notNull(),
      welcomeOfferId: varchar("welcome_offer_id").references(() => welcomeOffers.id, { onDelete: "set null" }),
      status: varchar("status", { length: 20 }).notNull().default("draft"),
      scheduledFor: timestamp("scheduled_for"),
      targetCustomerCount: integer("target_customer_count").notNull().default(0),
      messagesSent: integer("messages_sent").notNull().default(0),
      messagesDelivered: integer("messages_delivered").notNull().default(0),
      messagesFailed: integer("messages_failed").notNull().default(0),
      createdBy: varchar("created_by").notNull().references(() => users.id),
      createdAt: timestamp("created_at").defaultNow(),
      startedAt: timestamp("started_at"),
      completedAt: timestamp("completed_at")
    }, (table) => [
      index("invitation_campaigns_salon_id_idx").on(table.salonId),
      index("invitation_campaigns_status_idx").on(table.status)
    ]);
    insertInvitationCampaignSchema = createInsertSchema(invitationCampaigns).omit({
      id: true,
      createdAt: true,
      startedAt: true,
      completedAt: true,
      messagesSent: true,
      messagesDelivered: true,
      messagesFailed: true
    });
    invitationMessages = pgTable("invitation_messages", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      campaignId: varchar("campaign_id").notNull().references(() => invitationCampaigns.id, { onDelete: "cascade" }),
      importedCustomerId: varchar("imported_customer_id").notNull().references(() => importedCustomers.id, { onDelete: "cascade" }),
      channel: varchar("channel", { length: 20 }).notNull(),
      twilioMessageSid: varchar("twilio_message_sid", { length: 50 }),
      status: varchar("status", { length: 20 }).notNull().default("pending"),
      errorMessage: text("error_message"),
      sentAt: timestamp("sent_at"),
      deliveredAt: timestamp("delivered_at"),
      readAt: timestamp("read_at"),
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("invitation_messages_campaign_id_idx").on(table.campaignId),
      index("invitation_messages_customer_id_idx").on(table.importedCustomerId),
      index("invitation_messages_status_idx").on(table.status),
      index("invitation_messages_twilio_sid_idx").on(table.twilioMessageSid)
    ]);
    insertInvitationMessageSchema = createInsertSchema(invitationMessages).omit({
      id: true,
      createdAt: true,
      sentAt: true,
      deliveredAt: true,
      readAt: true
    });
    welcomeOfferRedemptions = pgTable("welcome_offer_redemptions", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      welcomeOfferId: varchar("welcome_offer_id").notNull().references(() => welcomeOffers.id, { onDelete: "cascade" }),
      userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      importedCustomerId: varchar("imported_customer_id").references(() => importedCustomers.id, { onDelete: "set null" }),
      bookingId: varchar("booking_id"),
      discountAppliedInPaisa: integer("discount_applied_in_paisa").notNull(),
      expiresAt: timestamp("expires_at").notNull(),
      redeemedAt: timestamp("redeemed_at"),
      status: varchar("status", { length: 20 }).notNull().default("active"),
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("welcome_offer_redemptions_offer_id_idx").on(table.welcomeOfferId),
      index("welcome_offer_redemptions_user_id_idx").on(table.userId),
      index("welcome_offer_redemptions_status_idx").on(table.status)
    ]);
    insertWelcomeOfferRedemptionSchema = createInsertSchema(welcomeOfferRedemptions).omit({
      id: true,
      createdAt: true,
      redeemedAt: true
    });
    customerImportBatchesRelations = relations(customerImportBatches, ({ one, many }) => ({
      salon: one(salons, {
        fields: [customerImportBatches.salonId],
        references: [salons.id]
      }),
      importedBy: one(users, {
        fields: [customerImportBatches.importedBy],
        references: [users.id]
      }),
      customers: many(importedCustomers)
    }));
    importedCustomersRelations = relations(importedCustomers, ({ one, many }) => ({
      salon: one(salons, {
        fields: [importedCustomers.salonId],
        references: [salons.id]
      }),
      importBatch: one(customerImportBatches, {
        fields: [importedCustomers.importBatchId],
        references: [customerImportBatches.id]
      }),
      linkedUser: one(users, {
        fields: [importedCustomers.linkedUserId],
        references: [users.id]
      }),
      messages: many(invitationMessages)
    }));
    welcomeOffersRelations = relations(welcomeOffers, ({ one, many }) => ({
      salon: one(salons, {
        fields: [welcomeOffers.salonId],
        references: [salons.id]
      }),
      campaigns: many(invitationCampaigns),
      redemptions: many(welcomeOfferRedemptions)
    }));
    invitationCampaignsRelations = relations(invitationCampaigns, ({ one, many }) => ({
      salon: one(salons, {
        fields: [invitationCampaigns.salonId],
        references: [salons.id]
      }),
      welcomeOffer: one(welcomeOffers, {
        fields: [invitationCampaigns.welcomeOfferId],
        references: [welcomeOffers.id]
      }),
      createdByUser: one(users, {
        fields: [invitationCampaigns.createdBy],
        references: [users.id]
      }),
      messages: many(invitationMessages)
    }));
    invitationMessagesRelations = relations(invitationMessages, ({ one }) => ({
      campaign: one(invitationCampaigns, {
        fields: [invitationMessages.campaignId],
        references: [invitationCampaigns.id]
      }),
      importedCustomer: one(importedCustomers, {
        fields: [invitationMessages.importedCustomerId],
        references: [importedCustomers.id]
      })
    }));
    welcomeOfferRedemptionsRelations = relations(welcomeOfferRedemptions, ({ one }) => ({
      welcomeOffer: one(welcomeOffers, {
        fields: [welcomeOfferRedemptions.welcomeOfferId],
        references: [welcomeOffers.id]
      }),
      user: one(users, {
        fields: [welcomeOfferRedemptions.userId],
        references: [users.id]
      }),
      importedCustomer: one(importedCustomers, {
        fields: [welcomeOfferRedemptions.importedCustomerId],
        references: [importedCustomers.id]
      })
    }));
    IMPORT_BATCH_STATUSES = {
      PROCESSING: "processing",
      COMPLETED: "completed",
      FAILED: "failed"
    };
    IMPORTED_CUSTOMER_STATUSES = {
      PENDING: "pending",
      INVITED: "invited",
      REGISTERED: "registered",
      EXPIRED: "expired"
    };
    CAMPAIGN_STATUSES = {
      DRAFT: "draft",
      SCHEDULED: "scheduled",
      SENDING: "sending",
      COMPLETED: "completed",
      PAUSED: "paused"
    };
    MESSAGE_STATUSES = {
      PENDING: "pending",
      SENT: "sent",
      DELIVERED: "delivered",
      FAILED: "failed",
      READ: "read"
    };
    CHANNEL_TYPES = {
      WHATSAPP: "whatsapp",
      SMS: "sms",
      BOTH: "both"
    };
    DISCOUNT_TYPES = {
      PERCENTAGE: "percentage",
      FIXED: "fixed"
    };
    REDEMPTION_STATUSES = {
      ACTIVE: "active",
      REDEEMED: "redeemed",
      EXPIRED: "expired"
    };
    SUBSCRIPTION_TIERS = {
      FREE: "free",
      GROWTH: "growth",
      ELITE: "elite"
    };
    SUBSCRIPTION_STATUSES = {
      ACTIVE: "active",
      TRIALING: "trialing",
      PAST_DUE: "past_due",
      CANCELLED: "cancelled",
      EXPIRED: "expired"
    };
    subscriptionTiers = pgTable("subscription_tiers", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      name: varchar("name", { length: 50 }).notNull().unique(),
      displayName: varchar("display_name", { length: 100 }).notNull(),
      description: text("description"),
      monthlyPricePaisa: integer("monthly_price_paisa").notNull().default(0),
      yearlyPricePaisa: integer("yearly_price_paisa").notNull().default(0),
      features: jsonb("features").notNull().default("[]"),
      limits: jsonb("limits").notNull().default("{}"),
      isActive: integer("is_active").notNull().default(1),
      sortOrder: integer("sort_order").notNull().default(0),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    });
    salonSubscriptions = pgTable("salon_subscriptions", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      tierId: varchar("tier_id").notNull().references(() => subscriptionTiers.id),
      status: varchar("status", { length: 20 }).notNull().default("active"),
      billingCycle: varchar("billing_cycle", { length: 20 }).notNull().default("monthly"),
      currentPeriodStart: timestamp("current_period_start").notNull(),
      currentPeriodEnd: timestamp("current_period_end").notNull(),
      trialEndsAt: timestamp("trial_ends_at"),
      cancelledAt: timestamp("cancelled_at"),
      cancelReason: text("cancel_reason"),
      razorpaySubscriptionId: varchar("razorpay_subscription_id", { length: 100 }),
      razorpayCustomerId: varchar("razorpay_customer_id", { length: 100 }),
      razorpayPlanId: varchar("razorpay_plan_id", { length: 100 }),
      lastPaymentAt: timestamp("last_payment_at"),
      nextPaymentAt: timestamp("next_payment_at"),
      failedPaymentCount: integer("failed_payment_count").notNull().default(0),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("salon_subscriptions_salon_id_idx").on(table.salonId),
      index("salon_subscriptions_status_idx").on(table.status)
    ]);
    subscriptionPayments = pgTable("subscription_payments", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      subscriptionId: varchar("subscription_id").notNull().references(() => salonSubscriptions.id, { onDelete: "cascade" }),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      amountPaisa: integer("amount_paisa").notNull(),
      currency: varchar("currency", { length: 3 }).notNull().default("INR"),
      status: varchar("status", { length: 20 }).notNull(),
      razorpayPaymentId: varchar("razorpay_payment_id", { length: 100 }),
      razorpayOrderId: varchar("razorpay_order_id", { length: 100 }),
      razorpaySignature: varchar("razorpay_signature", { length: 255 }),
      paymentMethod: varchar("payment_method", { length: 50 }),
      failureReason: text("failure_reason"),
      invoiceUrl: text("invoice_url"),
      periodStart: timestamp("period_start"),
      periodEnd: timestamp("period_end"),
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("subscription_payments_subscription_id_idx").on(table.subscriptionId),
      index("subscription_payments_salon_id_idx").on(table.salonId)
    ]);
    subscriptionRefunds = pgTable("subscription_refunds", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      paymentId: varchar("payment_id").notNull().references(() => subscriptionPayments.id, { onDelete: "cascade" }),
      subscriptionId: varchar("subscription_id").notNull().references(() => salonSubscriptions.id, { onDelete: "cascade" }),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      originalAmountPaisa: integer("original_amount_paisa").notNull(),
      refundAmountPaisa: integer("refund_amount_paisa").notNull(),
      refundType: varchar("refund_type", { length: 20 }).notNull().default("prorated"),
      reason: text("reason"),
      status: varchar("status", { length: 20 }).notNull().default("pending"),
      razorpayRefundId: varchar("razorpay_refund_id", { length: 100 }),
      razorpayPaymentId: varchar("razorpay_payment_id", { length: 100 }),
      processedAt: timestamp("processed_at"),
      failureReason: text("failure_reason"),
      daysUsed: integer("days_used"),
      totalDays: integer("total_days"),
      requestedBy: varchar("requested_by").references(() => users.id),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("subscription_refunds_payment_id_idx").on(table.paymentId),
      index("subscription_refunds_subscription_id_idx").on(table.subscriptionId),
      index("subscription_refunds_salon_id_idx").on(table.salonId),
      index("subscription_refunds_status_idx").on(table.status)
    ]);
    razorpayWebhookEvents = pgTable("razorpay_webhook_events", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      eventId: varchar("event_id", { length: 100 }).notNull().unique(),
      eventType: varchar("event_type", { length: 100 }).notNull(),
      payload: jsonb("payload").notNull(),
      status: varchar("status", { length: 20 }).notNull().default("received"),
      processedAt: timestamp("processed_at"),
      errorMessage: text("error_message"),
      retryCount: integer("retry_count").notNull().default(0),
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("razorpay_webhook_events_event_id_idx").on(table.eventId),
      index("razorpay_webhook_events_event_type_idx").on(table.eventType),
      index("razorpay_webhook_events_status_idx").on(table.status)
    ]);
    metaIntegrations = pgTable("meta_integrations", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      fbPageId: varchar("fb_page_id", { length: 50 }),
      fbPageName: varchar("fb_page_name", { length: 255 }),
      fbPageAccessToken: text("fb_page_access_token"),
      fbPageTokenExpiresAt: timestamp("fb_page_token_expires_at"),
      igAccountId: varchar("ig_account_id", { length: 50 }),
      igUsername: varchar("ig_username", { length: 100 }),
      igAccessToken: text("ig_access_token"),
      igTokenExpiresAt: timestamp("ig_token_expires_at"),
      metaUserId: varchar("meta_user_id", { length: 50 }),
      metaUserAccessToken: text("meta_user_access_token"),
      metaUserTokenExpiresAt: timestamp("meta_user_token_expires_at"),
      status: varchar("status", { length: 20 }).notNull().default("pending"),
      lastSyncAt: timestamp("last_sync_at"),
      syncError: text("sync_error"),
      bookingLeadTimeHours: integer("booking_lead_time_hours").notNull().default(2),
      cancellationPolicy: text("cancellation_policy"),
      autoConfirmBookings: integer("auto_confirm_bookings").notNull().default(1),
      sendDmReminders: integer("send_dm_reminders").notNull().default(1),
      webhookVerifyToken: varchar("webhook_verify_token", { length: 100 }),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("meta_integrations_salon_id_idx").on(table.salonId),
      unique("meta_integrations_fb_page_unique").on(table.fbPageId),
      unique("meta_integrations_ig_account_unique").on(table.igAccountId)
    ]);
    metaBookingRefs = pgTable("meta_booking_refs", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      bookingId: varchar("booking_id").notNull().references(() => bookings.id, { onDelete: "cascade" }),
      metaIntegrationId: varchar("meta_integration_id").notNull().references(() => metaIntegrations.id, { onDelete: "cascade" }),
      source: varchar("source", { length: 20 }).notNull(),
      metaAppointmentId: varchar("meta_appointment_id", { length: 100 }),
      metaUserId: varchar("meta_user_id", { length: 50 }),
      confirmationDmSent: integer("confirmation_dm_sent").notNull().default(0),
      confirmationDmId: varchar("confirmation_dm_id", { length: 100 }),
      reminder24hSent: integer("reminder_24h_sent").notNull().default(0),
      reminder2hSent: integer("reminder_2h_sent").notNull().default(0),
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("meta_booking_refs_booking_id_idx").on(table.bookingId),
      index("meta_booking_refs_meta_integration_id_idx").on(table.metaIntegrationId)
    ]);
    metaWebhookEvents = pgTable("meta_webhook_events", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      eventType: varchar("event_type", { length: 50 }).notNull(),
      payload: jsonb("payload").notNull(),
      signature: varchar("signature", { length: 255 }),
      processed: integer("processed").notNull().default(0),
      processedAt: timestamp("processed_at"),
      error: text("error"),
      receivedAt: timestamp("received_at").defaultNow()
    }, (table) => [
      index("meta_webhook_events_event_type_idx").on(table.eventType),
      index("meta_webhook_events_processed_idx").on(table.processed)
    ]);
    socialBookingAnalytics = pgTable("social_booking_analytics", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      date: timestamp("date").notNull(),
      source: varchar("source", { length: 20 }).notNull(),
      buttonClicks: integer("button_clicks").notNull().default(0),
      bookingStarted: integer("booking_started").notNull().default(0),
      bookingsCompleted: integer("bookings_completed").notNull().default(0),
      bookingsCancelled: integer("bookings_cancelled").notNull().default(0),
      revenuePaisa: integer("revenue_paisa").notNull().default(0),
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("social_booking_analytics_salon_id_idx").on(table.salonId),
      index("social_booking_analytics_date_idx").on(table.date)
    ]);
    subscriptionTiersRelations = relations(subscriptionTiers, ({ many }) => ({
      subscriptions: many(salonSubscriptions)
    }));
    salonSubscriptionsRelations = relations(salonSubscriptions, ({ one, many }) => ({
      salon: one(salons, {
        fields: [salonSubscriptions.salonId],
        references: [salons.id]
      }),
      tier: one(subscriptionTiers, {
        fields: [salonSubscriptions.tierId],
        references: [subscriptionTiers.id]
      }),
      payments: many(subscriptionPayments)
    }));
    subscriptionPaymentsRelations = relations(subscriptionPayments, ({ one }) => ({
      subscription: one(salonSubscriptions, {
        fields: [subscriptionPayments.subscriptionId],
        references: [salonSubscriptions.id]
      }),
      salon: one(salons, {
        fields: [subscriptionPayments.salonId],
        references: [salons.id]
      })
    }));
    metaIntegrationsRelations = relations(metaIntegrations, ({ one, many }) => ({
      salon: one(salons, {
        fields: [metaIntegrations.salonId],
        references: [salons.id]
      }),
      bookingRefs: many(metaBookingRefs)
    }));
    metaBookingRefsRelations = relations(metaBookingRefs, ({ one }) => ({
      booking: one(bookings, {
        fields: [metaBookingRefs.bookingId],
        references: [bookings.id]
      }),
      metaIntegration: one(metaIntegrations, {
        fields: [metaBookingRefs.metaIntegrationId],
        references: [metaIntegrations.id]
      })
    }));
    savedOffers = pgTable("saved_offers", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      offerId: varchar("offer_id").notNull().references(() => platformOffers.id, { onDelete: "cascade" }),
      savedAt: timestamp("saved_at").defaultNow()
    }, (table) => [
      uniqueIndex("saved_offers_user_offer_unique").on(table.userId, table.offerId),
      index("saved_offers_user_id_idx").on(table.userId)
    ]);
    savedOffersRelations = relations(savedOffers, ({ one }) => ({
      user: one(users, {
        fields: [savedOffers.userId],
        references: [users.id]
      }),
      offer: one(platformOffers, {
        fields: [savedOffers.offerId],
        references: [platformOffers.id]
      })
    }));
    WAITLIST_STATUS = {
      waiting: "waiting",
      notified: "notified",
      booked: "booked",
      expired: "expired",
      cancelled: "cancelled"
    };
    WAITLIST_PRIORITY = {
      regular: 1,
      gold: 2,
      elite: 3
    };
    WAITLIST_NOTIFICATION_TYPE = {
      push: "push",
      sms: "sms",
      email: "email"
    };
    WAITLIST_RESPONSE = {
      accepted: "accepted",
      declined: "declined",
      expired: "expired"
    };
    slotWaitlist = pgTable("slot_waitlist", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      serviceId: varchar("service_id").notNull().references(() => services.id, { onDelete: "cascade" }),
      staffId: varchar("staff_id").references(() => staff.id, { onDelete: "set null" }),
      requestedDate: text("requested_date").notNull(),
      timeWindowStart: text("time_window_start").notNull(),
      timeWindowEnd: text("time_window_end").notNull(),
      flexibilityDays: integer("flexibility_days").notNull().default(0),
      priority: integer("priority").notNull().default(1),
      status: varchar("status", { length: 20 }).notNull().default("waiting"),
      notifiedAt: timestamp("notified_at"),
      notifiedSlotId: varchar("notified_slot_id").references(() => timeSlots.id, { onDelete: "set null" }),
      responseDeadline: timestamp("response_deadline"),
      bookedAt: timestamp("booked_at"),
      expiresAt: timestamp("expires_at").notNull(),
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("slot_waitlist_user_id_idx").on(table.userId),
      index("slot_waitlist_salon_date_idx").on(table.salonId, table.requestedDate),
      index("slot_waitlist_status_idx").on(table.status),
      index("slot_waitlist_expires_at_idx").on(table.expiresAt),
      index("slot_waitlist_priority_created_idx").on(table.priority, table.createdAt),
      uniqueIndex("slot_waitlist_user_salon_service_date_unique").on(table.userId, table.salonId, table.serviceId, table.requestedDate),
      foreignKey({
        columns: [table.serviceId, table.salonId],
        foreignColumns: [services.id, services.salonId],
        name: "slot_waitlist_service_salon_fk"
      })
    ]);
    insertSlotWaitlistSchema = createInsertSchema(slotWaitlist).omit({
      id: true,
      createdAt: true
    });
    waitlistNotifications = pgTable("waitlist_notifications", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      waitlistId: varchar("waitlist_id").notNull().references(() => slotWaitlist.id, { onDelete: "cascade" }),
      slotId: varchar("slot_id").notNull().references(() => timeSlots.id, { onDelete: "cascade" }),
      notificationType: varchar("notification_type", { length: 20 }).notNull(),
      sentAt: timestamp("sent_at").notNull().defaultNow(),
      openedAt: timestamp("opened_at"),
      response: varchar("response", { length: 20 }),
      respondedAt: timestamp("responded_at"),
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("waitlist_notifications_waitlist_id_idx").on(table.waitlistId),
      index("waitlist_notifications_slot_id_idx").on(table.slotId),
      index("waitlist_notifications_sent_at_idx").on(table.sentAt)
    ]);
    insertWaitlistNotificationSchema = createInsertSchema(waitlistNotifications).omit({
      id: true,
      createdAt: true
    });
    slotWaitlistRelations = relations(slotWaitlist, ({ one, many }) => ({
      user: one(users, {
        fields: [slotWaitlist.userId],
        references: [users.id]
      }),
      salon: one(salons, {
        fields: [slotWaitlist.salonId],
        references: [salons.id]
      }),
      service: one(services, {
        fields: [slotWaitlist.serviceId],
        references: [services.id]
      }),
      staff: one(staff, {
        fields: [slotWaitlist.staffId],
        references: [staff.id]
      }),
      notifiedSlot: one(timeSlots, {
        fields: [slotWaitlist.notifiedSlotId],
        references: [timeSlots.id]
      }),
      notifications: many(waitlistNotifications)
    }));
    waitlistNotificationsRelations = relations(waitlistNotifications, ({ one }) => ({
      waitlistEntry: one(slotWaitlist, {
        fields: [waitlistNotifications.waitlistId],
        references: [slotWaitlist.id]
      }),
      slot: one(timeSlots, {
        fields: [waitlistNotifications.slotId],
        references: [timeSlots.id]
      })
    }));
    joinWaitlistSchema = z.object({
      salonId: z.string().uuid(),
      serviceId: z.string().uuid(),
      staffId: z.string().uuid().optional().nullable(),
      requestedDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Date must be YYYY-MM-DD format"),
      timeWindowStart: z.string().regex(/^\d{2}:\d{2}$/, "Time must be HH:MM format"),
      timeWindowEnd: z.string().regex(/^\d{2}:\d{2}$/, "Time must be HH:MM format"),
      flexibilityDays: z.number().int().min(0).max(7).default(0)
    });
    respondWaitlistSchema = z.object({
      response: z.enum(["accepted", "declined"])
    });
    DEMAND_LEVELS = {
      low: "low",
      medium: "medium",
      high: "high",
      peak: "peak"
    };
    PRICING_RULE_TYPES = {
      off_peak_discount: "off_peak_discount",
      peak_surcharge: "peak_surcharge",
      happy_hour: "happy_hour",
      seasonal: "seasonal"
    };
    ADJUSTMENT_TYPES = {
      percentage: "percentage",
      fixed: "fixed"
    };
    timeSlotDemand = pgTable("time_slot_demand", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      dayOfWeek: integer("day_of_week").notNull(),
      // 0-6 (Sunday-Saturday)
      hourOfDay: integer("hour_of_day").notNull(),
      // 0-23
      demandLevel: varchar("demand_level", { length: 20 }).notNull(),
      // 'low', 'medium', 'high', 'peak'
      bookingCount30d: integer("booking_count_30d").notNull().default(0),
      // Bookings in last 30 days
      avgUtilizationPercent: integer("avg_utilization_percent").notNull().default(0),
      // Slot fill rate 0-100
      generatedAt: timestamp("generated_at").defaultNow()
    }, (table) => [
      index("time_slot_demand_salon_day_idx").on(table.salonId, table.dayOfWeek),
      uniqueIndex("time_slot_demand_salon_day_hour_unique").on(table.salonId, table.dayOfWeek, table.hourOfDay)
    ]);
    insertTimeSlotDemandSchema = createInsertSchema(timeSlotDemand).omit({
      id: true,
      generatedAt: true
    });
    dynamicPricingRules = pgTable("dynamic_pricing_rules", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      name: text("name").notNull(),
      ruleType: varchar("rule_type", { length: 30 }).notNull(),
      // 'off_peak_discount', 'peak_surcharge', 'happy_hour', 'seasonal'
      dayOfWeek: integer("day_of_week"),
      // Specific day or NULL for all days
      startHour: integer("start_hour").notNull(),
      // 0-23
      endHour: integer("end_hour").notNull(),
      // 0-23
      adjustmentType: varchar("adjustment_type", { length: 20 }).notNull(),
      // 'percentage', 'fixed'
      adjustmentValue: integer("adjustment_value").notNull(),
      // Negative = discount, positive = surcharge (paisa for fixed, percent for percentage)
      maxDiscountPaisa: integer("max_discount_paisa"),
      // Cap on discount amount
      minBookingValuePaisa: integer("min_booking_value_paisa"),
      // Minimum booking value for rule to apply
      applicableServiceIds: text("applicable_service_ids").array(),
      // NULL = all services
      isActive: integer("is_active").notNull().default(1),
      validFrom: timestamp("valid_from"),
      validUntil: timestamp("valid_until"),
      priority: integer("priority").notNull().default(0),
      // Higher priority rules applied first when overlapping
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("dynamic_pricing_rules_salon_idx").on(table.salonId),
      index("dynamic_pricing_rules_active_idx").on(table.isActive),
      index("dynamic_pricing_rules_valid_idx").on(table.validFrom, table.validUntil)
    ]);
    insertDynamicPricingRuleSchema = createInsertSchema(dynamicPricingRules).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    pricingAdjustmentsLog = pgTable("pricing_adjustments_log", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      bookingId: varchar("booking_id").notNull().references(() => bookings.id, { onDelete: "cascade" }),
      ruleId: varchar("rule_id").notNull().references(() => dynamicPricingRules.id, { onDelete: "cascade" }),
      originalPricePaisa: integer("original_price_paisa").notNull(),
      adjustedPricePaisa: integer("adjusted_price_paisa").notNull(),
      adjustmentAmountPaisa: integer("adjustment_amount_paisa").notNull(),
      // Negative = discount, positive = surcharge
      adjustmentPercent: integer("adjustment_percent"),
      // Store the percentage if applicable
      ruleName: text("rule_name").notNull(),
      // Denormalized for historical reference
      ruleType: varchar("rule_type", { length: 30 }).notNull(),
      appliedAt: timestamp("applied_at").defaultNow()
    }, (table) => [
      index("pricing_adjustments_log_booking_idx").on(table.bookingId),
      index("pricing_adjustments_log_rule_idx").on(table.ruleId),
      index("pricing_adjustments_log_applied_at_idx").on(table.appliedAt)
    ]);
    insertPricingAdjustmentLogSchema = createInsertSchema(pricingAdjustmentsLog).omit({
      id: true,
      appliedAt: true
    });
    demandDateOverrides = pgTable("demand_date_overrides", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      overrideDate: text("override_date").notNull(),
      // YYYY-MM-DD format
      demandLevel: varchar("demand_level", { length: 20 }).notNull(),
      // Override demand for the whole day
      reason: text("reason"),
      // e.g., "National Holiday", "Valentine's Day"
      createdBy: varchar("created_by").references(() => users.id, { onDelete: "set null" }),
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("demand_date_overrides_salon_idx").on(table.salonId),
      uniqueIndex("demand_date_overrides_salon_date_unique").on(table.salonId, table.overrideDate)
    ]);
    insertDemandDateOverrideSchema = createInsertSchema(demandDateOverrides).omit({
      id: true,
      createdAt: true
    });
    timeSlotDemandRelations = relations(timeSlotDemand, ({ one }) => ({
      salon: one(salons, {
        fields: [timeSlotDemand.salonId],
        references: [salons.id]
      })
    }));
    dynamicPricingRulesRelations = relations(dynamicPricingRules, ({ one, many }) => ({
      salon: one(salons, {
        fields: [dynamicPricingRules.salonId],
        references: [salons.id]
      }),
      adjustments: many(pricingAdjustmentsLog)
    }));
    pricingAdjustmentsLogRelations = relations(pricingAdjustmentsLog, ({ one }) => ({
      booking: one(bookings, {
        fields: [pricingAdjustmentsLog.bookingId],
        references: [bookings.id]
      }),
      rule: one(dynamicPricingRules, {
        fields: [pricingAdjustmentsLog.ruleId],
        references: [dynamicPricingRules.id]
      })
    }));
    demandDateOverridesRelations = relations(demandDateOverrides, ({ one }) => ({
      salon: one(salons, {
        fields: [demandDateOverrides.salonId],
        references: [salons.id]
      }),
      createdByUser: one(users, {
        fields: [demandDateOverrides.createdBy],
        references: [users.id]
      })
    }));
    createPricingRuleSchema = z.object({
      name: z.string().min(1).max(100),
      ruleType: z.enum(["off_peak_discount", "peak_surcharge", "happy_hour", "seasonal"]),
      dayOfWeek: z.number().int().min(0).max(6).optional().nullable(),
      startHour: z.number().int().min(0).max(23),
      endHour: z.number().int().min(0).max(23),
      adjustmentType: z.enum(["percentage", "fixed"]),
      adjustmentValue: z.number().int().min(-50).max(25),
      // Max 50% discount, max 25% surcharge
      maxDiscountPaisa: z.number().int().positive().optional().nullable(),
      minBookingValuePaisa: z.number().int().positive().optional().nullable(),
      applicableServiceIds: z.array(z.string().uuid()).optional().nullable(),
      validFrom: z.string().datetime().optional().nullable(),
      validUntil: z.string().datetime().optional().nullable(),
      priority: z.number().int().min(0).max(100).default(0)
    });
    updatePricingRuleSchema = createPricingRuleSchema.partial().extend({
      isActive: z.boolean().optional()
    });
    createDemandOverrideSchema = z.object({
      overrideDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, "Date must be YYYY-MM-DD format"),
      demandLevel: z.enum(["low", "medium", "high", "peak"]),
      reason: z.string().max(200).optional()
    });
    staffQueueStatus = pgTable("staff_queue_status", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      staffId: varchar("staff_id").notNull().references(() => staff.id, { onDelete: "cascade" }),
      currentDate: text("current_date").notNull(),
      // YYYY-MM-DD
      currentJobCardId: varchar("current_job_card_id").references(() => jobCards.id, { onDelete: "set null" }),
      currentStatus: varchar("current_status", { length: 20 }).notNull().default("available"),
      // 'available', 'busy', 'break', 'offline'
      appointmentsAhead: integer("appointments_ahead").notNull().default(0),
      estimatedDelayMinutes: integer("estimated_delay_minutes").notNull().default(0),
      lastServiceEndAt: timestamp("last_service_end_at"),
      nextAvailableAt: timestamp("next_available_at"),
      avgServiceOverrunPercent: decimal("avg_service_overrun_percent", { precision: 5, scale: 2 }).default("0.00"),
      calculatedAt: timestamp("calculated_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("staff_queue_status_salon_idx").on(table.salonId),
      index("staff_queue_status_staff_idx").on(table.staffId),
      index("staff_queue_status_date_idx").on(table.currentDate),
      unique("staff_queue_status_staff_date_unique").on(table.staffId, table.currentDate)
    ]);
    insertStaffQueueStatusSchema = createInsertSchema(staffQueueStatus).omit({
      id: true,
      calculatedAt: true,
      updatedAt: true
    });
    staffQueueStatusRelations = relations(staffQueueStatus, ({ one }) => ({
      salon: one(salons, {
        fields: [staffQueueStatus.salonId],
        references: [salons.id]
      }),
      staff: one(staff, {
        fields: [staffQueueStatus.staffId],
        references: [staff.id]
      }),
      currentJobCard: one(jobCards, {
        fields: [staffQueueStatus.currentJobCardId],
        references: [jobCards.id]
      })
    }));
    departureAlerts = pgTable("departure_alerts", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      bookingId: varchar("booking_id").notNull().references(() => bookings.id, { onDelete: "cascade" }),
      userId: varchar("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      staffId: varchar("staff_id").references(() => staff.id, { onDelete: "set null" }),
      originalBookingTime: text("original_booking_time").notNull(),
      // HH:MM
      bookingDate: text("booking_date").notNull(),
      // YYYY-MM-DD
      predictedStartTime: text("predicted_start_time").notNull(),
      // HH:MM
      delayMinutes: integer("delay_minutes").notNull().default(0),
      delayReason: varchar("delay_reason", { length: 50 }),
      // 'queue_behind', 'previous_late', 'service_overrun', 'staff_break'
      suggestedDepartureTime: text("suggested_departure_time").notNull(),
      // HH:MM
      estimatedTravelMinutes: integer("estimated_travel_minutes"),
      bufferMinutes: integer("buffer_minutes").notNull().default(10),
      departureLocationLabel: varchar("departure_location_label", { length: 20 }),
      departureLatitude: decimal("departure_latitude", { precision: 9, scale: 6 }),
      departureLongitude: decimal("departure_longitude", { precision: 9, scale: 6 }),
      alertType: varchar("alert_type", { length: 30 }).notNull(),
      // 'initial_reminder', 'delay_update', 'earlier_available', 'staff_change', 'on_time'
      priority: varchar("priority", { length: 10 }).notNull().default("normal"),
      // 'low', 'normal', 'high', 'urgent'
      notificationSent: integer("notification_sent").notNull().default(0),
      sentAt: timestamp("sent_at"),
      sentVia: varchar("sent_via", { length: 20 }),
      messageId: varchar("message_id"),
      customerAcknowledged: integer("customer_acknowledged").notNull().default(0),
      acknowledgedAt: timestamp("acknowledged_at"),
      customerResponse: varchar("customer_response", { length: 30 }),
      // 'acknowledged', 'will_be_late', 'reschedule', 'cancel'
      actualDepartureTime: text("actual_departure_time"),
      actualArrivalTime: text("actual_arrival_time"),
      actualServiceStartTime: text("actual_service_start_time"),
      predictionAccuracyMinutes: integer("prediction_accuracy_minutes"),
      calculationDetails: jsonb("calculation_details").default("{}"),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("departure_alerts_booking_idx").on(table.bookingId),
      index("departure_alerts_user_idx").on(table.userId),
      index("departure_alerts_salon_idx").on(table.salonId),
      index("departure_alerts_date_idx").on(table.bookingDate),
      index("departure_alerts_created_at_idx").on(table.createdAt)
    ]);
    insertDepartureAlertSchema = createInsertSchema(departureAlerts).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    departureAlertsRelations = relations(departureAlerts, ({ one }) => ({
      booking: one(bookings, {
        fields: [departureAlerts.bookingId],
        references: [bookings.id]
      }),
      user: one(users, {
        fields: [departureAlerts.userId],
        references: [users.id]
      }),
      salon: one(salons, {
        fields: [departureAlerts.salonId],
        references: [salons.id]
      }),
      staff: one(staff, {
        fields: [departureAlerts.staffId],
        references: [staff.id]
      })
    }));
    departureAlertSettings = pgTable("departure_alert_settings", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().unique().references(() => salons.id, { onDelete: "cascade" }),
      isEnabled: integer("is_enabled").notNull().default(1),
      firstAlertMinutesBefore: integer("first_alert_minutes_before").notNull().default(60),
      updateIntervalMinutes: integer("update_interval_minutes").notNull().default(15),
      minDelayToNotify: integer("min_delay_to_notify").notNull().default(10),
      defaultBufferMinutes: integer("default_buffer_minutes").notNull().default(10),
      enablePushNotifications: integer("enable_push_notifications").notNull().default(1),
      enableSmsNotifications: integer("enable_sms_notifications").notNull().default(0),
      enableWhatsappNotifications: integer("enable_whatsapp_notifications").notNull().default(0),
      useTrafficData: integer("use_traffic_data").notNull().default(0),
      considerHistoricalOverrun: integer("consider_historical_overrun").notNull().default(1),
      autoReassignStaff: integer("auto_reassign_staff").notNull().default(0),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    });
    insertDepartureAlertSettingsSchema = createInsertSchema(departureAlertSettings).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    departureAlertSettingsRelations = relations(departureAlertSettings, ({ one }) => ({
      salon: one(salons, {
        fields: [departureAlertSettings.salonId],
        references: [salons.id]
      })
    }));
    customerDeparturePreferences = pgTable("customer_departure_preferences", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      userId: varchar("user_id").notNull().unique().references(() => users.id, { onDelete: "cascade" }),
      receiveAlerts: integer("receive_alerts").notNull().default(1),
      defaultLocationLabel: varchar("default_location_label", { length: 20 }).default("home"),
      // 'home', 'office', 'ask_each_time'
      preferredBufferMinutes: integer("preferred_buffer_minutes").default(15),
      reminderTimingPreference: varchar("reminder_timing_preference", { length: 20 }).default("60_minutes"),
      // '30_minutes', '60_minutes', '90_minutes', '2_hours'
      preferredChannel: varchar("preferred_channel", { length: 20 }).default("push"),
      // 'push', 'sms', 'whatsapp', 'all'
      quietHoursStart: text("quiet_hours_start"),
      // HH:MM
      quietHoursEnd: text("quiet_hours_end"),
      // HH:MM
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    });
    insertCustomerDeparturePreferencesSchema = createInsertSchema(customerDeparturePreferences).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    customerDeparturePreferencesRelations = relations(customerDeparturePreferences, ({ one }) => ({
      user: one(users, {
        fields: [customerDeparturePreferences.userId],
        references: [users.id]
      })
    }));
    updateDeparturePreferencesSchema = z.object({
      receiveAlerts: z.boolean().optional(),
      defaultLocationLabel: z.enum(["home", "office", "ask_each_time"]).optional(),
      preferredBufferMinutes: z.number().int().min(5).max(60).optional(),
      reminderTimingPreference: z.enum(["30_minutes", "60_minutes", "90_minutes", "2_hours"]).optional(),
      preferredChannel: z.enum(["push", "sms", "whatsapp", "all"]).optional(),
      quietHoursStart: z.string().regex(/^([01]?[0-9]|2[0-3]):[0-5][0-9]$/).optional().nullable(),
      quietHoursEnd: z.string().regex(/^([01]?[0-9]|2[0-3]):[0-5][0-9]$/).optional().nullable()
    });
    acknowledgeDepartureAlertSchema = z.object({
      response: z.enum(["acknowledged", "will_be_late", "reschedule", "cancel"]),
      actualDepartureTime: z.string().regex(/^([01]?[0-9]|2[0-3]):[0-5][0-9]$/).optional()
    });
    updateSalonDepartureSettingsSchema = z.object({
      isEnabled: z.boolean().optional(),
      firstAlertMinutesBefore: z.number().int().min(30).max(180).optional(),
      updateIntervalMinutes: z.number().int().min(5).max(60).optional(),
      minDelayToNotify: z.number().int().min(5).max(30).optional(),
      defaultBufferMinutes: z.number().int().min(5).max(30).optional(),
      enablePushNotifications: z.boolean().optional(),
      enableSmsNotifications: z.boolean().optional(),
      enableWhatsappNotifications: z.boolean().optional(),
      useTrafficData: z.boolean().optional(),
      considerHistoricalOverrun: z.boolean().optional(),
      autoReassignStaff: z.boolean().optional()
    });
    serviceTimingAnalytics = pgTable("service_timing_analytics", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      serviceId: varchar("service_id").notNull().references(() => services.id, { onDelete: "cascade" }),
      // Time period for aggregation
      dayOfWeek: integer("day_of_week").notNull(),
      // 0=Sunday, 6=Saturday
      hourBlock: integer("hour_block").notNull(),
      // 0-23 (hour of day)
      // Aggregated metrics
      sampleCount: integer("sample_count").notNull().default(0),
      avgDurationMinutes: decimal("avg_duration_minutes", { precision: 6, scale: 2 }).notNull().default("0.00"),
      stdDevMinutes: decimal("std_dev_minutes", { precision: 6, scale: 2 }).default("0.00"),
      minDurationMinutes: integer("min_duration_minutes"),
      maxDurationMinutes: integer("max_duration_minutes"),
      // Overrun analysis
      avgOverrunMinutes: decimal("avg_overrun_minutes", { precision: 6, scale: 2 }).default("0.00"),
      overrunRate: decimal("overrun_rate", { precision: 5, scale: 4 }).default("0.0000"),
      // % of services that run over
      // Confidence score based on sample size
      confidenceScore: decimal("confidence_score", { precision: 3, scale: 2 }).default("0.00"),
      // 0-1
      lastCalculatedAt: timestamp("last_calculated_at").defaultNow(),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("service_timing_salon_idx").on(table.salonId),
      index("service_timing_service_idx").on(table.serviceId),
      unique("service_timing_unique").on(table.salonId, table.serviceId, table.dayOfWeek, table.hourBlock)
    ]);
    staffPerformancePatterns = pgTable("staff_performance_patterns", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      staffId: varchar("staff_id").notNull().references(() => staff.id, { onDelete: "cascade" }),
      serviceId: varchar("service_id").references(() => services.id, { onDelete: "cascade" }),
      // null = all services
      // Time period
      dayOfWeek: integer("day_of_week"),
      // null = all days
      // Performance metrics
      sampleCount: integer("sample_count").notNull().default(0),
      avgDurationMinutes: decimal("avg_duration_minutes", { precision: 6, scale: 2 }).notNull().default("0.00"),
      speedFactor: decimal("speed_factor", { precision: 4, scale: 2 }).default("1.00"),
      // <1 = faster, >1 = slower
      // Reliability metrics
      consistencyScore: decimal("consistency_score", { precision: 3, scale: 2 }).default("0.00"),
      // 0-1, higher = more predictable
      lateStartRate: decimal("late_start_rate", { precision: 5, scale: 4 }).default("0.0000"),
      // % of late starts
      avgLateStartMinutes: decimal("avg_late_start_minutes", { precision: 5, scale: 2 }).default("0.00"),
      // Morning vs afternoon performance
      morningSpeedFactor: decimal("morning_speed_factor", { precision: 4, scale: 2 }).default("1.00"),
      // Before 12 PM
      afternoonSpeedFactor: decimal("afternoon_speed_factor", { precision: 4, scale: 2 }).default("1.00"),
      // 12-5 PM
      eveningSpeedFactor: decimal("evening_speed_factor", { precision: 4, scale: 2 }).default("1.00"),
      // After 5 PM
      confidenceScore: decimal("confidence_score", { precision: 3, scale: 2 }).default("0.00"),
      lastCalculatedAt: timestamp("last_calculated_at").defaultNow(),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("staff_performance_salon_idx").on(table.salonId),
      index("staff_performance_staff_idx").on(table.staffId),
      unique("staff_performance_unique").on(table.staffId, table.serviceId, table.dayOfWeek)
    ]);
    predictionAccuracyLogs = pgTable("prediction_accuracy_logs", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      bookingId: varchar("booking_id").notNull().references(() => bookings.id, { onDelete: "cascade" }),
      departureAlertId: varchar("departure_alert_id").references(() => departureAlerts.id, { onDelete: "set null" }),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      staffId: varchar("staff_id").references(() => staff.id, { onDelete: "set null" }),
      // Prediction details
      predictionType: varchar("prediction_type", { length: 30 }).notNull(),
      // 'basic', 'ml_enhanced', 'staff_adjusted'
      predictedStartTime: text("predicted_start_time").notNull(),
      // HH:MM
      predictedDelayMinutes: integer("predicted_delay_minutes").notNull().default(0),
      predictedDurationMinutes: integer("predicted_duration_minutes"),
      // Actual results
      actualStartTime: text("actual_start_time"),
      // HH:MM
      actualDelayMinutes: integer("actual_delay_minutes"),
      actualDurationMinutes: integer("actual_duration_minutes"),
      // Accuracy metrics
      startTimeErrorMinutes: integer("start_time_error_minutes"),
      // predicted - actual
      delayErrorMinutes: integer("delay_error_minutes"),
      durationErrorMinutes: integer("duration_error_minutes"),
      // Factors used in prediction
      factorsUsed: jsonb("factors_used").default("{}"),
      // { staffSpeedFactor, dayOfWeekAdjustment, historicalOverrun, queuePosition, etc. }
      // Was ML prediction better than basic?
      mlImprovedAccuracy: integer("ml_improved_accuracy"),
      // 1 = yes, 0 = no, null = not compared
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("prediction_accuracy_booking_idx").on(table.bookingId),
      index("prediction_accuracy_salon_idx").on(table.salonId),
      index("prediction_accuracy_type_idx").on(table.predictionType),
      index("prediction_accuracy_created_idx").on(table.createdAt)
    ]);
    customerTimingPreferences = pgTable("customer_timing_preferences", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      userId: varchar("user_id").notNull().unique().references(() => users.id, { onDelete: "cascade" }),
      // Historical behavior
      visitCount: integer("visit_count").notNull().default(0),
      avgArrivalMinutesBeforeAppt: decimal("avg_arrival_minutes_before_appt", { precision: 5, scale: 2 }).default("0.00"),
      lateArrivalRate: decimal("late_arrival_rate", { precision: 5, scale: 4 }).default("0.0000"),
      avgLateMinutes: decimal("avg_late_minutes", { precision: 5, scale: 2 }).default("0.00"),
      // Personalized recommendations
      recommendedBufferMinutes: integer("recommended_buffer_minutes").default(15),
      bufferConfidenceScore: decimal("buffer_confidence_score", { precision: 3, scale: 2 }).default("0.00"),
      // Departure behavior
      avgDepartureAccuracyMinutes: decimal("avg_departure_accuracy_minutes", { precision: 5, scale: 2 }).default("0.00"),
      // Positive = left early, Negative = left late
      // Notification responsiveness
      alertAcknowledgmentRate: decimal("alert_acknowledgment_rate", { precision: 5, scale: 4 }).default("0.0000"),
      avgResponseTimeMinutes: decimal("avg_response_time_minutes", { precision: 5, scale: 2 }),
      lastCalculatedAt: timestamp("last_calculated_at").defaultNow(),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("customer_timing_user_idx").on(table.userId)
    ]);
    membershipPlans = pgTable("membership_plans", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      // Basic Info
      name: text("name").notNull(),
      description: text("description"),
      imageUrl: text("image_url"),
      // Plan Type: 'discount' | 'credit' | 'packaged'
      planType: varchar("plan_type", { length: 20 }).notNull(),
      // Duration
      durationMonths: integer("duration_months").notNull(),
      // 6, 12, etc.
      // Pricing
      priceInPaisa: integer("price_in_paisa").notNull(),
      // Total membership price
      billingType: varchar("billing_type", { length: 20 }).notNull().default("one_time"),
      // 'one_time', 'monthly'
      monthlyPriceInPaisa: integer("monthly_price_in_paisa"),
      // If monthly billing
      // Discount Benefits (for 'discount' type)
      discountPercentage: integer("discount_percentage"),
      // e.g., 15 for 15%
      discountAppliesTo: varchar("discount_applies_to", { length: 20 }).default("all"),
      // 'all', 'services', 'products'
      // Credit Benefits (for 'credit' type)
      creditAmountInPaisa: integer("credit_amount_in_paisa"),
      // Monthly credit value
      bonusPercentage: integer("bonus_percentage"),
      // e.g., 20 for 20% bonus credits
      creditsRollover: integer("credits_rollover").default(1),
      // Can unused credits roll over? 1=yes, 0=no
      // Perks
      priorityBooking: integer("priority_booking").default(0),
      freeCancellation: integer("free_cancellation").default(0),
      birthdayBonusInPaisa: integer("birthday_bonus_in_paisa"),
      referralBonusInPaisa: integer("referral_bonus_in_paisa"),
      additionalPerks: jsonb("additional_perks"),
      // JSON array of custom perks
      // Limits
      maxMembers: integer("max_members"),
      // NULL = unlimited
      maxUsesPerMonth: integer("max_uses_per_month"),
      // For packaged plans
      // Availability
      isActive: integer("is_active").notNull().default(1),
      validFrom: timestamp("valid_from"),
      validUntil: timestamp("valid_until"),
      // Metadata
      sortOrder: integer("sort_order").default(0),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("membership_plans_salon_idx").on(table.salonId),
      index("membership_plans_active_idx").on(table.isActive),
      check("membership_plans_type_check", sql`${table.planType} IN ('discount', 'credit', 'packaged')`),
      check("membership_plans_billing_check", sql`${table.billingType} IN ('one_time', 'monthly')`)
    ]);
    insertMembershipPlanSchema = createInsertSchema(membershipPlans).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    membershipPlanServices = pgTable("membership_plan_services", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      planId: varchar("plan_id").notNull().references(() => membershipPlans.id, { onDelete: "cascade" }),
      serviceId: varchar("service_id").notNull().references(() => services.id, { onDelete: "cascade" }),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      quantityPerMonth: integer("quantity_per_month").notNull().default(1),
      // How many times per month
      isUnlimited: integer("is_unlimited").default(0),
      // Unlimited usage
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("membership_plan_services_plan_idx").on(table.planId),
      index("membership_plan_services_service_idx").on(table.serviceId)
    ]);
    insertMembershipPlanServiceSchema = createInsertSchema(membershipPlanServices).omit({
      id: true,
      createdAt: true
    });
    customerMemberships = pgTable("customer_memberships", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      customerId: varchar("customer_id").notNull().references(() => users.id, { onDelete: "cascade" }),
      salonId: varchar("salon_id").notNull().references(() => salons.id, { onDelete: "cascade" }),
      planId: varchar("plan_id").notNull().references(() => membershipPlans.id),
      // Status: 'active', 'paused', 'cancelled', 'expired', 'pending_payment'
      status: varchar("status", { length: 20 }).notNull().default("active"),
      // Dates
      startDate: timestamp("start_date").notNull(),
      endDate: timestamp("end_date").notNull(),
      nextBillingDate: timestamp("next_billing_date"),
      // For monthly billing
      pausedAt: timestamp("paused_at"),
      cancelledAt: timestamp("cancelled_at"),
      // Credit Balance (for credit-based plans)
      creditBalanceInPaisa: integer("credit_balance_in_paisa").default(0),
      totalCreditsEarnedInPaisa: integer("total_credits_earned_in_paisa").default(0),
      totalCreditsUsedInPaisa: integer("total_credits_used_in_paisa").default(0),
      // Payment
      totalPaidInPaisa: integer("total_paid_in_paisa").notNull(),
      razorpaySubscriptionId: varchar("razorpay_subscription_id"),
      // Renewal
      autoRenew: integer("auto_renew").default(0),
      renewalReminderSent: integer("renewal_reminder_sent").default(0),
      // Metadata
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => [
      index("customer_memberships_customer_idx").on(table.customerId),
      index("customer_memberships_salon_idx").on(table.salonId),
      index("customer_memberships_plan_idx").on(table.planId),
      index("customer_memberships_status_idx").on(table.status),
      check("customer_memberships_status_check", sql`${table.status} IN ('active', 'paused', 'cancelled', 'expired', 'pending_payment')`)
    ]);
    insertCustomerMembershipSchema = createInsertSchema(customerMemberships).omit({
      id: true,
      createdAt: true,
      updatedAt: true
    });
    membershipServiceUsage = pgTable("membership_service_usage", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      membershipId: varchar("membership_id").notNull().references(() => customerMemberships.id, { onDelete: "cascade" }),
      serviceId: varchar("service_id").notNull().references(() => services.id),
      salonId: varchar("salon_id").notNull().references(() => salons.id),
      bookingId: varchar("booking_id").references(() => bookings.id),
      // Usage tracking
      usageMonth: timestamp("usage_month").notNull(),
      // First day of the month
      quantityUsed: integer("quantity_used").notNull().default(1),
      usedAt: timestamp("used_at").defaultNow()
    }, (table) => [
      index("membership_service_usage_membership_idx").on(table.membershipId),
      index("membership_service_usage_service_idx").on(table.serviceId),
      index("membership_service_usage_month_idx").on(table.usageMonth)
    ]);
    insertMembershipServiceUsageSchema = createInsertSchema(membershipServiceUsage).omit({
      id: true,
      usedAt: true
    });
    membershipCreditTransactions = pgTable("membership_credit_transactions", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      membershipId: varchar("membership_id").notNull().references(() => customerMemberships.id, { onDelete: "cascade" }),
      // Transaction type: 'credit_added', 'credit_used', 'credit_expired', 'bonus_added', 'refund'
      transactionType: varchar("transaction_type", { length: 20 }).notNull(),
      amountInPaisa: integer("amount_in_paisa").notNull(),
      balanceAfterInPaisa: integer("balance_after_in_paisa").notNull(),
      // Reference
      bookingId: varchar("booking_id").references(() => bookings.id),
      description: text("description"),
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("membership_credit_tx_membership_idx").on(table.membershipId),
      index("membership_credit_tx_type_idx").on(table.transactionType),
      check("membership_credit_tx_type_check", sql`${table.transactionType} IN ('credit_added', 'credit_used', 'credit_expired', 'bonus_added', 'refund')`)
    ]);
    insertMembershipCreditTransactionSchema = createInsertSchema(membershipCreditTransactions).omit({
      id: true,
      createdAt: true
    });
    membershipPayments = pgTable("membership_payments", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      membershipId: varchar("membership_id").notNull().references(() => customerMemberships.id, { onDelete: "cascade" }),
      customerId: varchar("customer_id").notNull().references(() => users.id),
      salonId: varchar("salon_id").notNull().references(() => salons.id),
      // Payment details
      amountInPaisa: integer("amount_in_paisa").notNull(),
      paymentType: varchar("payment_type", { length: 20 }).notNull(),
      // 'initial', 'renewal', 'monthly'
      // Payment gateway
      razorpayPaymentId: varchar("razorpay_payment_id"),
      razorpayOrderId: varchar("razorpay_order_id"),
      paymentStatus: varchar("payment_status", { length: 20 }).notNull(),
      // 'pending', 'completed', 'failed', 'refunded'
      // Dates
      paidAt: timestamp("paid_at"),
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => [
      index("membership_payments_membership_idx").on(table.membershipId),
      index("membership_payments_customer_idx").on(table.customerId),
      index("membership_payments_salon_idx").on(table.salonId),
      index("membership_payments_status_idx").on(table.paymentStatus),
      check("membership_payments_type_check", sql`${table.paymentType} IN ('initial', 'renewal', 'monthly')`),
      check("membership_payments_status_check", sql`${table.paymentStatus} IN ('pending', 'completed', 'failed', 'refunded')`)
    ]);
    insertMembershipPaymentSchema = createInsertSchema(membershipPayments).omit({
      id: true,
      createdAt: true
    });
    membershipPlansRelations = relations(membershipPlans, ({ one, many }) => ({
      salon: one(salons, {
        fields: [membershipPlans.salonId],
        references: [salons.id]
      }),
      includedServices: many(membershipPlanServices),
      customerMemberships: many(customerMemberships)
    }));
    membershipPlanServicesRelations = relations(membershipPlanServices, ({ one }) => ({
      plan: one(membershipPlans, {
        fields: [membershipPlanServices.planId],
        references: [membershipPlans.id]
      }),
      service: one(services, {
        fields: [membershipPlanServices.serviceId],
        references: [services.id]
      }),
      salon: one(salons, {
        fields: [membershipPlanServices.salonId],
        references: [salons.id]
      })
    }));
    customerMembershipsRelations = relations(customerMemberships, ({ one, many }) => ({
      customer: one(users, {
        fields: [customerMemberships.customerId],
        references: [users.id]
      }),
      salon: one(salons, {
        fields: [customerMemberships.salonId],
        references: [salons.id]
      }),
      plan: one(membershipPlans, {
        fields: [customerMemberships.planId],
        references: [membershipPlans.id]
      }),
      serviceUsage: many(membershipServiceUsage),
      creditTransactions: many(membershipCreditTransactions),
      payments: many(membershipPayments)
    }));
    membershipServiceUsageRelations = relations(membershipServiceUsage, ({ one }) => ({
      membership: one(customerMemberships, {
        fields: [membershipServiceUsage.membershipId],
        references: [customerMemberships.id]
      }),
      service: one(services, {
        fields: [membershipServiceUsage.serviceId],
        references: [services.id]
      }),
      salon: one(salons, {
        fields: [membershipServiceUsage.salonId],
        references: [salons.id]
      }),
      booking: one(bookings, {
        fields: [membershipServiceUsage.bookingId],
        references: [bookings.id]
      })
    }));
    membershipCreditTransactionsRelations = relations(membershipCreditTransactions, ({ one }) => ({
      membership: one(customerMemberships, {
        fields: [membershipCreditTransactions.membershipId],
        references: [customerMemberships.id]
      }),
      booking: one(bookings, {
        fields: [membershipCreditTransactions.bookingId],
        references: [bookings.id]
      })
    }));
    membershipPaymentsRelations = relations(membershipPayments, ({ one }) => ({
      membership: one(customerMemberships, {
        fields: [membershipPayments.membershipId],
        references: [customerMemberships.id]
      }),
      customer: one(users, {
        fields: [membershipPayments.customerId],
        references: [users.id]
      }),
      salon: one(salons, {
        fields: [membershipPayments.salonId],
        references: [salons.id]
      })
    }));
  }
});

// server/db.ts
import { Pool, neonConfig } from "@neondatabase/serverless";
import { drizzle } from "drizzle-orm/neon-serverless";
import ws from "ws";
var databaseUrl, pool, db;
var init_db = __esm({
  "server/db.ts"() {
    "use strict";
    init_schema();
    neonConfig.webSocketConstructor = ws;
    databaseUrl = process.env.DATABASE_URL;
    if (!databaseUrl) {
      throw new Error(
        "DATABASE_URL must be set. Please add your database connection string."
      );
    }
    pool = new Pool({
      connectionString: databaseUrl,
      // Tighten timeouts to fail fast instead of hanging when cold
      connectionTimeoutMillis: 5e3,
      idleTimeoutMillis: 1e4,
      max: 30
    });
    db = drizzle({ client: pool, schema: schema_exports });
    (async () => {
      try {
        await pool.query(`CREATE INDEX IF NOT EXISTS services_salon_active_idx ON services (salon_id, is_active)`);
        await pool.query(`CREATE INDEX IF NOT EXISTS bookings_salon_time_idx ON bookings (salon_id, booking_date, booking_time)`);
        await pool.query(`CREATE INDEX IF NOT EXISTS payments_order_id_idx ON payments (razorpay_order_id)`);
        await pool.query(`CREATE INDEX IF NOT EXISTS bookings_service_idx ON bookings (service_id)`);
      } catch (e) {
        console.warn("Index ensure failed (non-fatal):", e);
      }
    })();
  }
});

// shared/service-images.ts
var service_images_exports = {};
__export(service_images_exports, {
  SERVICE_IMAGES: () => SERVICE_IMAGES,
  getDefaultImageByCategory: () => getDefaultImageByCategory,
  getServiceImage: () => getServiceImage
});
function getServiceImage(serviceName) {
  if (!serviceName) return null;
  const normalized = serviceName.toLowerCase().trim();
  if (SERVICE_IMAGES[normalized]) {
    return SERVICE_IMAGES[normalized];
  }
  for (const [key, image] of Object.entries(SERVICE_IMAGES)) {
    if (normalized.includes(key) || key.includes(normalized)) {
      return image;
    }
  }
  return null;
}
function getDefaultImageByCategory(category) {
  const categoryLower = category?.toLowerCase() || "";
  const categoryDefaults = {
    "hair": "https://images.unsplash.com/photo-1560066984-138dadb4c035?w=500",
    "nails": "https://images.unsplash.com/photo-1604654894610-df63bc536371?w=500",
    "facial": "https://images.unsplash.com/photo-1570172619644-dfd03ed5d881?w=500",
    "skincare": "https://images.unsplash.com/photo-1570172619644-dfd03ed5d881?w=500",
    "massage": "https://images.unsplash.com/photo-1544161515-4ab6ce6db874?w=500",
    "spa": "https://images.unsplash.com/photo-1540555700478-4be289fbecef?w=500",
    "makeup": "https://images.unsplash.com/photo-1487412947147-5cebf100ffc2?w=500",
    "piercing": "https://images.unsplash.com/photo-1535632066927-ab7c9ab60908?w=500",
    "tattoo": "https://images.unsplash.com/photo-1565058379802-bbe93b2f703f?w=500",
    "wax": "https://images.unsplash.com/photo-1556228578-0d85b1a4d571?w=500",
    "eyebrow": "https://images.unsplash.com/photo-1634926878768-2a5b3c42f139?w=500",
    "lash": "https://images.unsplash.com/photo-1583001931096-959e9a1a6223?w=500"
  };
  for (const [key, image] of Object.entries(categoryDefaults)) {
    if (categoryLower.includes(key)) {
      return image;
    }
  }
  return "https://images.unsplash.com/photo-1487412947147-5cebf100ffc2?w=500";
}
var SERVICE_IMAGES;
var init_service_images = __esm({
  "shared/service-images.ts"() {
    "use strict";
    SERVICE_IMAGES = {
      // Hair & Styling Services
      "haircut": "https://images.unsplash.com/photo-1560066984-138dadb4c035?w=500",
      "haircut & styling": "https://images.unsplash.com/photo-1560066984-138dadb4c035?w=500",
      "hair color": "https://images.unsplash.com/photo-1562322140-8baeececf3df?w=500",
      "hair coloring": "https://images.unsplash.com/photo-1562322140-8baeececf3df?w=500",
      "hair treatment": "https://images.unsplash.com/photo-1522337360788-8b13dee7a37e?w=500",
      "hair treatment & spa": "https://images.unsplash.com/photo-1522337360788-8b13dee7a37e?w=500",
      "balayage": "https://images.unsplash.com/photo-1487412947147-5cebf100ffc2?w=500",
      "balayage & highlights": "https://images.unsplash.com/photo-1487412947147-5cebf100ffc2?w=500",
      "keratin": "https://images.unsplash.com/photo-1580618672591-eb180b1a973f?w=500",
      "keratin treatment": "https://images.unsplash.com/photo-1580618672591-eb180b1a973f?w=500",
      "hair extensions": "https://images.unsplash.com/photo-1492106087820-71f1a00d2b11?w=500",
      "hair patch": "https://images.unsplash.com/photo-1605497788044-5a32c7078486?w=500",
      "hair weaving": "https://images.unsplash.com/photo-1521590832167-7bcbfaa6381f?w=500",
      "hair bonding": "https://images.unsplash.com/photo-1516975080664-ed2fc6a32937?w=500",
      // Nails Services
      "manicure": "https://images.unsplash.com/photo-1604654894610-df63bc536371?w=500",
      "pedicure": "https://images.unsplash.com/photo-1519014816548-bf5fe059798b?w=500",
      "nail art": "https://images.unsplash.com/photo-1610992015732-2449b76344bc?w=500",
      "nail art & design": "https://images.unsplash.com/photo-1610992015732-2449b76344bc?w=500",
      "gel nails": "https://images.unsplash.com/photo-1632345031435-8727f6897d53?w=500",
      "acrylic nails": "https://images.unsplash.com/photo-1604654894564-80ed46c4f939?w=500",
      "nail extensions": "https://images.unsplash.com/photo-1607779097040-26e80aa78e66?w=500",
      // Skincare & Facials
      "facial": "https://images.unsplash.com/photo-1570172619644-dfd03ed5d881?w=500",
      "classic facial": "https://images.unsplash.com/photo-1570172619644-dfd03ed5d881?w=500",
      "anti-aging": "https://images.unsplash.com/photo-1616394584738-fc6e612e71b9?w=500",
      "anti-aging treatment": "https://images.unsplash.com/photo-1616394584738-fc6e612e71b9?w=500",
      "acne treatment": "https://images.unsplash.com/photo-1531299204812-e6d44d9a185c?w=500",
      "hydrafacial": "https://images.unsplash.com/photo-1596755389378-c31d21fd1273?w=500",
      "cleanup": "https://images.unsplash.com/photo-1512290923902-8a9f81dc236c?w=500",
      "cleanup & bleach": "https://images.unsplash.com/photo-1512290923902-8a9f81dc236c?w=500",
      "chemical peel": "https://images.unsplash.com/photo-1515377905703-c4788e51af15?w=500",
      // Massage & Spa
      "massage": "https://images.unsplash.com/photo-1544161515-4ab6ce6db874?w=500",
      "body massage": "https://images.unsplash.com/photo-1544161515-4ab6ce6db874?w=500",
      "full body massage": "https://images.unsplash.com/photo-1544161515-4ab6ce6db874?w=500",
      "aromatherapy": "https://images.unsplash.com/photo-1600334129128-685c5582fd35?w=500",
      "deep tissue": "https://images.unsplash.com/photo-1519824145371-296894a0daa9?w=500",
      "deep tissue massage": "https://images.unsplash.com/photo-1519824145371-296894a0daa9?w=500",
      "thai massage": "https://images.unsplash.com/photo-1540555700478-4be289fbecef?w=500",
      "hot stone": "https://images.unsplash.com/photo-1582719471384-894fbb16e074?w=500",
      "hot stone massage": "https://images.unsplash.com/photo-1582719471384-894fbb16e074?w=500",
      "spa package": "https://images.unsplash.com/photo-1540555700478-4be289fbecef?w=500",
      "spa packages": "https://images.unsplash.com/photo-1540555700478-4be289fbecef?w=500",
      // Eyebrows & Lashes
      "eyebrow": "https://images.unsplash.com/photo-1634926878768-2a5b3c42f139?w=500",
      "eyebrow shaping": "https://images.unsplash.com/photo-1634926878768-2a5b3c42f139?w=500",
      "threading": "https://images.unsplash.com/photo-1542103749-8ef59b94f47e?w=500",
      "eyelash": "https://images.unsplash.com/photo-1583001931096-959e9a1a6223?w=500",
      "eyelash extensions": "https://images.unsplash.com/photo-1583001931096-959e9a1a6223?w=500",
      "lash lift": "https://images.unsplash.com/photo-1612293040335-d5e5e7a8eb8e?w=500",
      "lash lift & tint": "https://images.unsplash.com/photo-1612293040335-d5e5e7a8eb8e?w=500",
      "eyebrow tint": "https://images.unsplash.com/photo-1516975080664-ed2fc6a32937?w=500",
      "eyebrow tinting": "https://images.unsplash.com/photo-1516975080664-ed2fc6a32937?w=500",
      "microblading": "https://images.unsplash.com/photo-1595476108010-b4d1f102b1b1?w=500",
      // Hair Removal
      "wax": "https://images.unsplash.com/photo-1556228578-0d85b1a4d571?w=500",
      "waxing": "https://images.unsplash.com/photo-1556228578-0d85b1a4d571?w=500",
      "laser hair removal": "https://images.unsplash.com/photo-1571019613454-1cb2f99b2d8b?w=500",
      "full body wax": "https://images.unsplash.com/photo-1560750588-73207b1ef5b8?w=500",
      "full body waxing": "https://images.unsplash.com/photo-1560750588-73207b1ef5b8?w=500",
      "bikini wax": "https://images.unsplash.com/photo-1551122089-4e3e72477a97?w=500",
      "brazilian wax": "https://images.unsplash.com/photo-1551122089-4e3e72477a97?w=500",
      // Piercing
      "piercing": "https://images.unsplash.com/photo-1535632066927-ab7c9ab60908?w=500",
      "ear piercing": "https://images.unsplash.com/photo-1535632066927-ab7c9ab60908?w=500",
      "nose piercing": "https://images.unsplash.com/photo-1517841905240-472988babdf9?w=500",
      "belly piercing": "https://images.unsplash.com/photo-1524502397800-2eeaad7c3fe5?w=500",
      "lip piercing": "https://images.unsplash.com/photo-1494790108377-be9c29b29330?w=500",
      "eyebrow piercing": "https://images.unsplash.com/photo-1509967419530-da38b4704bc6?w=500",
      "cartilage piercing": "https://images.unsplash.com/photo-1530893776091-5003274b645c?w=500",
      // Tattoo
      "tattoo": "https://images.unsplash.com/photo-1565058379802-bbe93b2f703f?w=500",
      "small tattoo": "https://images.unsplash.com/photo-1565058379802-bbe93b2f703f?w=500",
      "medium tattoo": "https://images.unsplash.com/photo-1611501275019-9b5cda994e8d?w=500",
      "large tattoo": "https://images.unsplash.com/photo-1590246814883-57c511a8a1c4?w=500",
      "coverup tattoo": "https://images.unsplash.com/photo-1590817421957-09d9c652a604?w=500",
      "cover-up tattoo": "https://images.unsplash.com/photo-1590817421957-09d9c652a604?w=500",
      "tattoo removal": "https://images.unsplash.com/photo-1568602471122-7832951cc4c5?w=500",
      "permanent makeup": "https://images.unsplash.com/photo-1487412947147-5cebf100ffc2?w=500",
      "permanent makeup tattoo": "https://images.unsplash.com/photo-1487412947147-5cebf100ffc2?w=500",
      "henna": "https://images.unsplash.com/photo-1610195342108-891e89d0c33c?w=500",
      "henna tattoo": "https://images.unsplash.com/photo-1610195342108-891e89d0c33c?w=500",
      "mehndi": "https://images.unsplash.com/photo-1610195342108-891e89d0c33c?w=500",
      // Makeup
      "makeup": "https://images.unsplash.com/photo-1487412947147-5cebf100ffc2?w=500",
      "makup": "https://images.unsplash.com/photo-1487412947147-5cebf100ffc2?w=500",
      "bridal makeup": "https://images.unsplash.com/photo-1519741497674-611481863552?w=500",
      "party makeup": "https://images.unsplash.com/photo-1516975080664-ed2fc6a32937?w=500",
      "hd makeup": "https://images.unsplash.com/photo-1512496015851-a90fb38ba796?w=500",
      "airbrush makeup": "https://images.unsplash.com/photo-1487412947147-5cebf100ffc2?w=500",
      "natural makeup": "https://images.unsplash.com/photo-1522337360788-8b13dee7a37e?w=500",
      "daily makup": "https://images.unsplash.com/photo-1522337360788-8b13dee7a37e?w=500",
      // Body Treatments
      "body scrub": "https://images.unsplash.com/photo-1600334129128-685c5582fd35?w=500",
      "body scrub & polishing": "https://images.unsplash.com/photo-1600334129128-685c5582fd35?w=500",
      "body wrap": "https://images.unsplash.com/photo-1540555700478-4be289fbecef?w=500",
      "tan removal": "https://images.unsplash.com/photo-1560750588-73207b1ef5b8?w=500",
      "body polish": "https://images.unsplash.com/photo-1560750588-73207b1ef5b8?w=500",
      "body polishing": "https://images.unsplash.com/photo-1560750588-73207b1ef5b8?w=500",
      // Men's Grooming
      "mens haircut": "https://images.unsplash.com/photo-1503951914875-452162b0f3f1?w=500",
      "men's haircut": "https://images.unsplash.com/photo-1503951914875-452162b0f3f1?w=500",
      "beard": "https://images.unsplash.com/photo-1621605815971-fbc98d665033?w=500",
      "beard trim": "https://images.unsplash.com/photo-1621605815971-fbc98d665033?w=500",
      "beard trim & styling": "https://images.unsplash.com/photo-1621605815971-fbc98d665033?w=500",
      "mens facial": "https://images.unsplash.com/photo-1506794778202-cad84cf45f1d?w=500",
      "men's facial": "https://images.unsplash.com/photo-1506794778202-cad84cf45f1d?w=500",
      "mens grooming": "https://images.unsplash.com/photo-1600948836101-f9ffda59d250?w=500",
      "men's grooming package": "https://images.unsplash.com/photo-1600948836101-f9ffda59d250?w=500",
      // Wellness & Other
      "reflexology": "https://images.unsplash.com/photo-1519014816548-bf5fe059798b?w=500",
      "wellness therapy": "https://images.unsplash.com/photo-1544367567-0f2fcb009e0b?w=500",
      "consultation": "https://images.unsplash.com/photo-1573496359142-b8d87734a5a2?w=500",
      "beauty consultation": "https://images.unsplash.com/photo-1573496359142-b8d87734a5a2?w=500",
      // Additional services (fallbacks)
      "color treatment": "https://images.unsplash.com/photo-1562322140-8baeececf3df?w=500",
      "extra massage": "https://images.unsplash.com/photo-1544161515-4ab6ce6db874?w=500",
      "hair cut": "https://images.unsplash.com/photo-1560066984-138dadb4c035?w=500",
      "hair color man": "https://images.unsplash.com/photo-1562322140-8baeececf3df?w=500",
      "hair color wemen": "https://images.unsplash.com/photo-1562322140-8baeececf3df?w=500",
      "hair color women": "https://images.unsplash.com/photo-1562322140-8baeececf3df?w=500",
      "swedish massage": "https://images.unsplash.com/photo-1544161515-4ab6ce6db874?w=500"
    };
  }
});

// server/storage.ts
import { eq, and, or, isNull, gte, lte, desc, asc, sql as sql2, inArray, ne, like, isNotNull, lt, gt } from "drizzle-orm";
import { randomUUID } from "crypto";
async function initializeSalonsAndServices() {
  try {
    const existingSalons = await db.select().from(salons);
    if (existingSalons.length === 0) {
      console.log("\u{1F3EA} Initializing sample salons and services...");
      console.log("\u2705 Database initialized");
    }
  } catch (error) {
    console.error("Error initializing salons and services:", error);
  }
}
async function initializeServices() {
  await initializeSalonsAndServices();
}
var DatabaseStorage, storage;
var init_storage = __esm({
  "server/storage.ts"() {
    "use strict";
    init_schema();
    init_db();
    DatabaseStorage = class {
      async getUser(id) {
        const [user] = await db.select().from(users).where(eq(users.id, id));
        return user || void 0;
      }
      async getUserById(id) {
        const [user] = await db.select().from(users).where(eq(users.id, id));
        return user || void 0;
      }
      async getUserByUsername(username) {
        const [user] = await db.select().from(users).where(eq(users.username, username));
        return user || void 0;
      }
      async getUserByEmail(email) {
        const [user] = await db.select().from(users).where(sql2`LOWER(TRIM(${users.email})) = LOWER(TRIM(${email}))`);
        return user || void 0;
      }
      async getUserByPhone(phone) {
        const [user] = await db.select().from(users).where(eq(users.phone, phone));
        return user || void 0;
      }
      async searchUsersByEmail(emailQuery, limit = 10) {
        const searchResults = await db.select().from(users).where(sql2`${users.email} ILIKE ${`%${emailQuery}%`}`).limit(limit);
        return searchResults;
      }
      async createUser(user) {
        if (!user.username && user.email) {
          user.username = user.email.split("@")[0] + "_" + Date.now().toString().slice(-6);
        }
        const [newUser] = await db.insert(users).values(user).returning();
        return newUser;
      }
      async updateUser(id, updates) {
        await db.update(users).set({
          ...updates,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq(users.id, id));
      }
      async updateUserPreferences(userId, preferences) {
        await db.update(users).set({
          // Add a preferences column to the users table if needed, or store in customerProfiles
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq(users.id, userId));
      }
      async upsertUser(userData) {
        const [user] = await db.insert(users).values(userData).onConflictDoUpdate({
          target: users.id,
          set: {
            ...userData,
            updatedAt: /* @__PURE__ */ new Date()
          }
        }).returning();
        return user;
      }
      // Role operations
      async getRoleByName(name) {
        const [role] = await db.select().from(roles).where(eq(roles.name, name));
        return role || void 0;
      }
      async createRole(role) {
        const [newRole] = await db.insert(roles).values(role).returning();
        return newRole;
      }
      async getUserRoles(userId) {
        const userRolesList = await db.select({
          id: roles.id,
          name: roles.name,
          description: roles.description,
          createdAt: roles.createdAt
        }).from(userRoles).innerJoin(roles, eq(userRoles.roleId, roles.id)).where(eq(userRoles.userId, userId));
        return userRolesList;
      }
      async assignUserRole(userId, roleId) {
        await db.insert(userRoles).values({ userId, roleId });
      }
      // Organization operations
      async createOrganization(organization) {
        const [newOrg] = await db.insert(organizations).values(organization).returning();
        return newOrg;
      }
      async addUserToOrganization(orgId, userId, role) {
        await db.insert(orgUsers).values({ orgId, userId, orgRole: role });
      }
      async getUserOrganizations(userId) {
        const userOrgs = await db.select({
          orgId: orgUsers.orgId,
          orgRole: orgUsers.orgRole,
          orgName: organizations.name,
          orgId2: organizations.id,
          orgDescription: organizations.description
        }).from(orgUsers).innerJoin(organizations, eq(orgUsers.orgId, organizations.id)).where(eq(orgUsers.userId, userId));
        return userOrgs.map((org) => ({
          orgId: org.orgId,
          orgRole: org.orgRole,
          organization: {
            id: org.orgId2,
            name: org.orgName,
            type: "salon"
            // Default type for now
          }
        }));
      }
      async getSalonById(id) {
        return this.getSalon(id);
      }
      async getSalonsByOrgId(orgId) {
        const result = await db.select().from(salons).where(and(
          eq(salons.orgId, orgId),
          eq(salons.isActive, 1)
        ));
        return result || [];
      }
      async isUserStaffOfSalon(userId, salonId) {
        const [staffMember] = await db.select().from(staff).where(and(eq(staff.userId, userId), eq(staff.salonId, salonId)));
        return !!staffMember;
      }
      // Salon operations
      async getSalon(id) {
        const [salon] = await db.select().from(salons).where(eq(salons.id, id));
        return salon || void 0;
      }
      async getAllSalons() {
        const results = await db.select({ salons }).from(salons).innerJoin(publishState, eq(salons.id, publishState.salonId)).where(
          and(
            eq(salons.isActive, 1),
            eq(publishState.isPublished, 1)
            // Only show published salons
          )
        );
        return results.map((r) => r.salons) || [];
      }
      async getSalons() {
        const results = await db.select().from(salons).where(eq(salons.isActive, 1));
        return results || [];
      }
      async createSalon(salon) {
        const [newSalon] = await db.insert(salons).values(salon).returning();
        return newSalon;
      }
      async updateSalon(id, updates) {
        await db.update(salons).set(updates).where(eq(salons.id, id));
      }
      async deleteSalon(id) {
        await db.delete(salons).where(eq(salons.id, id));
      }
      // Proximity search operations
      async findSalonsNearLocation(latitude, longitude, radiusKm, limit) {
        try {
          if (latitude < -90 || latitude > 90) {
            throw new Error("Latitude must be between -90 and 90 degrees");
          }
          if (longitude < -180 || longitude > 180) {
            throw new Error("Longitude must be between -180 and 180 degrees");
          }
          if (radiusKm < 0.1 || radiusKm > 50) {
            throw new Error("Radius must be between 0.1 and 50 kilometers");
          }
          const searchLimit = Math.min(limit || 50, 500);
          const latDegreeOffset = radiusKm / 111;
          const lngDegreeOffset = radiusKm / (111 * Math.cos(latitude * Math.PI / 180));
          const minLat = latitude - latDegreeOffset;
          const maxLat = latitude + latDegreeOffset;
          const minLng = longitude - lngDegreeOffset;
          const maxLng = longitude + lngDegreeOffset;
          const results = await db.select().from(salons).innerJoin(publishState, eq(salons.id, publishState.salonId)).where(
            and(
              eq(salons.isActive, 1),
              eq(publishState.isPublished, 1),
              // Only show published salons
              // Bounding box prefilter for performance
              sql2`CAST(${salons.latitude} AS DECIMAL) >= ${minLat}`,
              sql2`CAST(${salons.latitude} AS DECIMAL) <= ${maxLat}`,
              sql2`CAST(${salons.longitude} AS DECIMAL) >= ${minLng}`,
              sql2`CAST(${salons.longitude} AS DECIMAL) <= ${maxLng}`,
              // Only include salons with valid coordinates
              sql2`${salons.latitude} IS NOT NULL`,
              sql2`${salons.longitude} IS NOT NULL`
            )
          ).limit(searchLimit);
          if (!results || results.length === 0) {
            return [];
          }
          const earthRadiusKm = 6371;
          const salonsWithDistance = results.map((result) => {
            const salon = result.salons;
            const salonLat = parseFloat(salon.latitude || "0");
            const salonLng = parseFloat(salon.longitude || "0");
            const dLat = this.toRadians(salonLat - latitude);
            const dLng = this.toRadians(salonLng - longitude);
            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(this.toRadians(latitude)) * Math.cos(this.toRadians(salonLat)) * Math.sin(dLng / 2) * Math.sin(dLng / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            const distance = earthRadiusKm * c;
            return {
              ...salon,
              distance
            };
          }).filter((salon) => salon.distance <= radiusKm).sort((a, b) => a.distance - b.distance).slice(0, Math.min(limit || 50, 100));
          return salonsWithDistance;
        } catch (error) {
          console.error("Error in findSalonsNearLocation:", error);
          throw error;
        }
      }
      // Helper method to convert degrees to radians
      toRadians(degrees) {
        return degrees * Math.PI / 180;
      }
      async findSalonsNearUserLocation(userId, locationLabel, radiusKm, limit) {
        try {
          const [userLocation] = await db.select().from(userSavedLocations).where(
            and(
              eq(userSavedLocations.userId, userId),
              eq(userSavedLocations.label, locationLabel)
            )
          );
          if (!userLocation) {
            throw new Error(`User location '${locationLabel}' not found`);
          }
          const latitude = parseFloat(userLocation.latitude);
          const longitude = parseFloat(userLocation.longitude);
          return this.findSalonsNearLocation(latitude, longitude, radiusKm, limit);
        } catch (error) {
          console.error("Error in findSalonsNearUserLocation:", error);
          throw error;
        }
      }
      // Service operations
      async getService(id) {
        const [service] = await db.select().from(services).where(eq(services.id, id));
        return service || void 0;
      }
      async getAllServices() {
        const result = await db.select().from(services).where(eq(services.isActive, 1));
        return result || [];
      }
      async getServicesBySalonId(salonId) {
        const result = await db.select().from(services).where(and(
          eq(services.salonId, salonId),
          eq(services.isActive, 1)
        ));
        return result || [];
      }
      async createService(service) {
        const serviceData = { ...service };
        if (!serviceData.imageUrl) {
          const { getServiceImage: getServiceImage2, getDefaultImageByCategory: getDefaultImageByCategory2 } = await Promise.resolve().then(() => (init_service_images(), service_images_exports));
          const autoImage = getServiceImage2(service.name) || getDefaultImageByCategory2(service.category || "");
          if (autoImage) {
            serviceData.imageUrl = autoImage;
          }
        }
        const [newService] = await db.insert(services).values(serviceData).returning();
        return newService;
      }
      async updateService(id, updates) {
        await db.update(services).set(updates).where(eq(services.id, id));
      }
      async deleteService(id) {
        await db.update(services).set({ isActive: 0 }).where(eq(services.id, id));
      }
      // Service template operations
      async getServiceTemplates(filters) {
        try {
          let query = db.select().from(serviceTemplates).where(eq(serviceTemplates.isActive, 1));
          const conditions = [eq(serviceTemplates.isActive, 1)];
          if (filters?.gender) {
            conditions.push(eq(serviceTemplates.gender, filters.gender));
          }
          if (filters?.category) {
            conditions.push(eq(serviceTemplates.category, filters.category));
          }
          if (filters?.isPopular !== void 0) {
            conditions.push(eq(serviceTemplates.isPopular, filters.isPopular ? 1 : 0));
          }
          const result = await db.select().from(serviceTemplates).where(and(...conditions)).orderBy(serviceTemplates.sortOrder, serviceTemplates.category, serviceTemplates.name);
          return result || [];
        } catch (error) {
          console.error("Error fetching service templates:", error);
          return [];
        }
      }
      // Package/Combo operations
      async getPackage(id) {
        const [pkg] = await db.select().from(servicePackages).where(eq(servicePackages.id, id));
        return pkg || void 0;
      }
      async getPackagesBySalonId(salonId) {
        const packages = await db.select().from(servicePackages).where(and(
          eq(servicePackages.salonId, salonId),
          eq(servicePackages.isActive, 1)
        ));
        const packagesWithServices = await Promise.all(
          packages.map(async (pkg) => {
            const packageSvcs = await db.select({
              packageService: packageServices,
              service: services
            }).from(packageServices).innerJoin(services, eq(packageServices.serviceId, services.id)).where(eq(packageServices.packageId, pkg.id)).orderBy(packageServices.sequenceOrder);
            return {
              ...pkg,
              services: packageSvcs.map((ps) => ({
                ...ps.service,
                sequenceOrder: ps.packageService.sequenceOrder
              }))
            };
          })
        );
        return packagesWithServices || [];
      }
      async getPackageWithServices(packageId) {
        const pkg = await this.getPackage(packageId);
        if (!pkg) return void 0;
        const packageSvcs = await db.select({
          packageService: packageServices,
          service: services
        }).from(packageServices).innerJoin(services, eq(packageServices.serviceId, services.id)).where(eq(packageServices.packageId, packageId)).orderBy(packageServices.sequenceOrder);
        return {
          ...pkg,
          services: packageSvcs.map((ps) => ({
            ...ps.service,
            sequenceOrder: ps.packageService.sequenceOrder
          }))
        };
      }
      async createPackage(packageData) {
        const [newPackage] = await db.insert(servicePackages).values(packageData).returning();
        return newPackage;
      }
      async updatePackage(id, updates) {
        await db.update(servicePackages).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq(servicePackages.id, id));
      }
      async deletePackage(id) {
        await db.update(servicePackages).set({ isActive: 0 }).where(eq(servicePackages.id, id));
      }
      async addServiceToPackage(data) {
        const [packageService] = await db.insert(packageServices).values(data).returning();
        return packageService;
      }
      async removeAllServicesFromPackage(packageId) {
        await db.delete(packageServices).where(eq(packageServices.packageId, packageId));
      }
      // Resilient transaction helper with retry logic for transient failures
      async withRetry(operation, maxAttempts = 3, baseDelay = 100) {
        let lastError;
        for (let attempt = 1; attempt <= maxAttempts; attempt++) {
          try {
            return await operation();
          } catch (error) {
            lastError = error;
            const isTransient = error.message?.includes("WebSocket") || error.message?.includes("fetch failed") || error.message?.includes("ECONNREFUSED") || error.message?.includes("ETIMEDOUT") || error.code === "57014" || // query_canceled
            error.code === "57P01" || // admin_shutdown
            error.code === "08006";
            if (!isTransient) {
              throw error;
            }
            if (attempt === maxAttempts) {
              console.error(`Transaction failed after ${maxAttempts} attempts:`, error.message);
              throw error;
            }
            const delay2 = baseDelay * Math.pow(2, attempt - 1) + Math.random() * 50;
            console.warn(`Transaction attempt ${attempt} failed (transient error), retrying in ${Math.round(delay2)}ms...`);
            await new Promise((resolve) => setTimeout(resolve, delay2));
          }
        }
        throw lastError || new Error("Transaction failed");
      }
      // Transactional package operations - ensures atomicity for create/update with services
      async createPackageWithServices(packageData, serviceIds, salonId) {
        return await this.withRetry(async () => {
          return await db.transaction(async (tx) => {
            const [newPackage] = await tx.insert(servicePackages).values(packageData).returning();
            for (let i = 0; i < serviceIds.length; i++) {
              await tx.insert(packageServices).values({
                packageId: newPackage.id,
                serviceId: serviceIds[i],
                salonId,
                sequenceOrder: i + 1
              });
            }
            return newPackage;
          });
        });
      }
      async updatePackageWithServices(packageId, packageData, serviceIds, salonId) {
        return await this.withRetry(async () => {
          return await db.transaction(async (tx) => {
            await tx.update(servicePackages).set({ ...packageData, updatedAt: /* @__PURE__ */ new Date() }).where(eq(servicePackages.id, packageId));
            if (serviceIds !== null && serviceIds !== void 0) {
              await tx.delete(packageServices).where(eq(packageServices.packageId, packageId));
              if (serviceIds.length > 0) {
                for (let i = 0; i < serviceIds.length; i++) {
                  await tx.insert(packageServices).values({
                    packageId,
                    serviceId: serviceIds[i],
                    salonId,
                    sequenceOrder: i + 1
                  });
                }
              }
            }
            const [updatedPackage] = await tx.select().from(servicePackages).where(eq(servicePackages.id, packageId));
            if (!updatedPackage) {
              throw new Error("Package not found");
            }
            return updatedPackage;
          });
        });
      }
      // Booking operations
      async getBooking(id) {
        const [booking] = await db.select().from(bookings).where(eq(bookings.id, id));
        return booking || void 0;
      }
      async getBookingServicesByBookingId(bookingId) {
        return db.select().from(bookingServices).where(eq(bookingServices.bookingId, bookingId));
      }
      async createBooking(booking) {
        const [newBooking] = await db.insert(bookings).values(booking).returning();
        return newBooking;
      }
      async updateBookingStatus(id, status) {
        const result = await db.update(bookings).set({ status }).where(eq(bookings.id, id));
        return result.rowCount || 0;
      }
      async updateBookingStatusWithCustomerValidation(bookingId, customerEmail, status) {
        const result = await db.update(bookings).set({ status }).where(and(
          eq(bookings.id, bookingId),
          eq(bookings.customerEmail, customerEmail)
        ));
        if (result.rowCount === 0) {
          throw new Error("Booking not found or access denied");
        }
      }
      async updateBookingNotes(id, notes) {
        const result = await db.update(bookings).set({ notes }).where(eq(bookings.id, id));
        return result.rowCount || 0;
      }
      async bulkUpdateBookingStatus(bookingIds, status, salonId) {
        const result = await db.update(bookings).set({ status }).where(and(
          inArray(bookings.id, bookingIds),
          eq(bookings.salonId, salonId)
          // Security: ensure bookings belong to the salon
        ));
        return result.rowCount || 0;
      }
      async getBookingsBySalonId(salonId, filters) {
        try {
          const conditions = [eq(bookings.salonId, salonId)];
          if (filters?.status) {
            conditions.push(eq(bookings.status, filters.status));
          }
          if (filters?.startDate) {
            conditions.push(gte(bookings.bookingDate, filters.startDate));
          }
          if (filters?.endDate) {
            conditions.push(lte(bookings.bookingDate, filters.endDate));
          }
          return await db.select({
            id: bookings.id,
            serviceId: bookings.serviceId,
            staffId: bookings.staffId,
            timeSlotId: bookings.timeSlotId,
            customerName: bookings.customerName,
            customerEmail: bookings.customerEmail,
            customerPhone: bookings.customerPhone,
            salonName: bookings.salonName,
            bookingDate: bookings.bookingDate,
            bookingTime: bookings.bookingTime,
            status: bookings.status,
            totalAmountPaisa: bookings.totalAmountPaisa,
            currency: bookings.currency,
            paymentMethod: bookings.paymentMethod,
            notes: bookings.notes,
            guestSessionId: bookings.guestSessionId,
            offerId: bookings.offerId,
            originalAmountPaisa: bookings.originalAmountPaisa,
            discountAmountPaisa: bookings.discountAmountPaisa,
            finalAmountPaisa: bookings.finalAmountPaisa,
            createdAt: bookings.createdAt,
            salonId: bookings.salonId,
            serviceName: services.name,
            serviceDuration: services.durationMinutes,
            jobCardId: jobCards.id,
            jobCardStatus: jobCards.status
          }).from(bookings).leftJoin(services, eq(bookings.serviceId, services.id)).leftJoin(jobCards, eq(bookings.id, jobCards.bookingId)).where(and(...conditions)).orderBy(desc(bookings.createdAt));
        } catch (error) {
          console.error("Error fetching bookings by salon ID:", error);
          throw error;
        }
      }
      async getCustomersBySalonId(salonId) {
        try {
          const customers = await db.select({
            name: bookings.customerName,
            email: bookings.customerEmail,
            phone: bookings.customerPhone,
            totalBookings: sql2`count(*)`,
            totalSpent: sql2`sum(${bookings.totalAmountPaisa})`,
            lastBookingDate: sql2`max(${bookings.bookingDate})`,
            lastBookingStatus: sql2`max(${bookings.status})`,
            lastCreated: sql2`max(${bookings.createdAt})`
          }).from(bookings).where(eq(bookings.salonId, salonId)).groupBy(bookings.customerEmail, bookings.customerName, bookings.customerPhone).orderBy(desc(sql2`max(${bookings.createdAt})`));
          return customers.map((customer) => ({
            name: customer.name,
            email: customer.email,
            phone: customer.phone,
            totalBookings: Number(customer.totalBookings) || 0,
            totalSpentPaisa: Number(customer.totalSpent) || 0,
            lastBookingDate: customer.lastBookingDate,
            lastBookingStatus: customer.lastBookingStatus
          }));
        } catch (error) {
          console.error("Error fetching customers by salon ID:", error);
          throw error;
        }
      }
      // Conflict detection and rescheduling operations
      computeBookingTimeRange(bookingDate, bookingTime, durationMinutes) {
        if (!bookingTime || typeof bookingTime !== "string") {
          throw new Error("Invalid booking time: time is required");
        }
        let hours, minutes;
        const time12HourMatch = bookingTime.match(/^(\d{1,2}):(\d{2})\s*(AM|PM)$/i);
        if (time12HourMatch) {
          const [, hourStr, minuteStr, period] = time12HourMatch;
          hours = parseInt(hourStr, 10);
          minutes = parseInt(minuteStr, 10);
          if (period.toUpperCase() === "PM" && hours !== 12) {
            hours += 12;
          } else if (period.toUpperCase() === "AM" && hours === 12) {
            hours = 0;
          }
        } else {
          const timeParts = bookingTime.split(":");
          if (timeParts.length !== 2) {
            throw new Error(`Invalid booking time format: ${bookingTime}. Expected "HH:MM" or "H:MM AM/PM"`);
          }
          hours = parseInt(timeParts[0], 10);
          minutes = parseInt(timeParts[1], 10);
        }
        if (isNaN(hours) || isNaN(minutes) || hours < 0 || hours > 23 || minutes < 0 || minutes > 59) {
          throw new Error(`Invalid booking time values: hours=${hours}, minutes=${minutes}`);
        }
        const start = new Date(bookingDate);
        if (isNaN(start.getTime())) {
          throw new Error(`Invalid booking date: ${bookingDate}`);
        }
        start.setHours(hours, minutes, 0, 0);
        const end = new Date(start);
        end.setMinutes(end.getMinutes() + durationMinutes);
        return { start, end };
      }
      async findOverlappingBookings(salonId, staffId, start, end, excludeId) {
        try {
          const startDateStr = start.toISOString().split("T")[0];
          const endDateStr = end.toISOString().split("T")[0];
          const startTimeStr = start.toTimeString().substring(0, 5);
          const endTimeStr = end.toTimeString().substring(0, 5);
          const potentialConflicts = await db.select({
            id: bookings.id,
            salonId: bookings.salonId,
            staffId: bookings.staffId,
            serviceId: bookings.serviceId,
            timeSlotId: bookings.timeSlotId,
            customerName: bookings.customerName,
            customerEmail: bookings.customerEmail,
            customerPhone: bookings.customerPhone,
            salonName: bookings.salonName,
            bookingDate: bookings.bookingDate,
            bookingTime: bookings.bookingTime,
            status: bookings.status,
            totalAmountPaisa: bookings.totalAmountPaisa,
            currency: bookings.currency,
            paymentMethod: bookings.paymentMethod,
            notes: bookings.notes,
            guestSessionId: bookings.guestSessionId,
            offerId: bookings.offerId,
            originalAmountPaisa: bookings.originalAmountPaisa,
            discountAmountPaisa: bookings.discountAmountPaisa,
            finalAmountPaisa: bookings.finalAmountPaisa,
            createdAt: bookings.createdAt,
            durationMinutes: services.durationMinutes
          }).from(bookings).innerJoin(services, eq(bookings.serviceId, services.id)).where(and(
            eq(bookings.salonId, salonId),
            ne(bookings.status, "cancelled"),
            ne(bookings.status, "completed"),
            eq(bookings.bookingDate, startDateStr),
            staffId ? eq(bookings.staffId, staffId) : sql2`1=1`,
            excludeId ? ne(bookings.id, excludeId) : sql2`1=1`
          ));
          const overlappingBookings = potentialConflicts.filter((booking) => {
            const [bookingHours, bookingMinutes] = booking.bookingTime.split(":").map(Number);
            const bookingStart = new Date(booking.bookingDate);
            bookingStart.setHours(bookingHours, bookingMinutes, 0, 0);
            const bookingEnd = new Date(bookingStart);
            bookingEnd.setMinutes(bookingEnd.getMinutes() + booking.durationMinutes);
            return bookingStart < end && bookingEnd > start;
          });
          return overlappingBookings;
        } catch (error) {
          console.error("Error finding overlapping bookings:", error);
          throw error;
        }
      }
      async isStaffAvailable(salonId, staffId, start, end) {
        try {
          const staffMember = await db.select().from(staff).where(and(
            eq(staff.id, staffId),
            eq(staff.salonId, salonId),
            eq(staff.isActive, 1)
          ));
          if (staffMember.length === 0) {
            return false;
          }
          const conflicts = await this.findOverlappingBookings(salonId, staffId, start, end);
          return conflicts.length === 0;
        } catch (error) {
          console.error("Error checking staff availability:", error);
          return false;
        }
      }
      async rescheduleBooking(id, fields) {
        return await db.transaction(async (tx) => {
          try {
            const [currentBooking] = await tx.select().from(bookings).where(eq(bookings.id, id)).for("update");
            if (!currentBooking) {
              throw new Error("Booking not found");
            }
            const [service] = await tx.select().from(services).where(eq(services.id, currentBooking.serviceId)).for("update");
            if (!service) {
              throw new Error("Associated service not found");
            }
            const { start, end } = this.computeBookingTimeRange(fields.bookingDate, fields.bookingTime, service.durationMinutes);
            const targetStaffId = fields.staffId || currentBooking.staffId;
            const conflictingBookings = await this.findOverlappingBookings(
              currentBooking.salonId,
              targetStaffId,
              start,
              end,
              id
              // Exclude current booking
            );
            if (conflictingBookings.length > 0) {
              throw new Error("Time slot conflicts with existing booking");
            }
            if (targetStaffId && targetStaffId !== currentBooking.staffId) {
              const [staffMember] = await tx.select().from(staff).where(and(
                eq(staff.id, targetStaffId),
                eq(staff.salonId, currentBooking.salonId),
                eq(staff.isActive, 1)
              )).for("update");
              if (!staffMember) {
                throw new Error("Staff member not found or inactive");
              }
            }
            const updateData = {
              bookingDate: fields.bookingDate,
              bookingTime: fields.bookingTime
            };
            if (fields.staffId !== void 0) {
              updateData.staffId = fields.staffId;
            }
            const [updatedBooking] = await tx.update(bookings).set(updateData).where(eq(bookings.id, id)).returning();
            return updatedBooking;
          } catch (error) {
            console.error("Error rescheduling booking:", error);
            throw error;
          }
        });
      }
      async getSalonAnalytics(salonId, period) {
        try {
          const endDate = /* @__PURE__ */ new Date();
          const startDate = /* @__PURE__ */ new Date();
          const previousStartDate = /* @__PURE__ */ new Date();
          const previousEndDate = /* @__PURE__ */ new Date();
          const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
          const todayStart = /* @__PURE__ */ new Date();
          todayStart.setHours(0, 0, 0, 0);
          const todayEnd = /* @__PURE__ */ new Date();
          todayEnd.setHours(23, 59, 59, 999);
          switch (period) {
            case "daily":
            case "1d":
              startDate.setDate(endDate.getDate() - 1);
              previousStartDate.setDate(endDate.getDate() - 2);
              previousEndDate.setDate(endDate.getDate() - 1);
              break;
            case "weekly":
            case "week":
            case "7d":
              startDate.setDate(endDate.getDate() - 7);
              previousStartDate.setDate(endDate.getDate() - 14);
              previousEndDate.setDate(endDate.getDate() - 7);
              break;
            case "monthly":
            case "month":
            case "30d":
              startDate.setMonth(endDate.getMonth() - 1);
              previousStartDate.setMonth(endDate.getMonth() - 2);
              previousEndDate.setMonth(endDate.getMonth() - 1);
              break;
            case "quarterly":
            case "quarter":
            case "90d":
              startDate.setMonth(endDate.getMonth() - 3);
              previousStartDate.setMonth(endDate.getMonth() - 6);
              previousEndDate.setMonth(endDate.getMonth() - 3);
              break;
            case "yearly":
            case "year":
            case "1y":
              startDate.setFullYear(endDate.getFullYear() - 1);
              previousStartDate.setFullYear(endDate.getFullYear() - 2);
              previousEndDate.setFullYear(endDate.getFullYear() - 1);
              break;
            default:
              startDate.setMonth(endDate.getMonth() - 1);
              previousStartDate.setMonth(endDate.getMonth() - 2);
              previousEndDate.setMonth(endDate.getMonth() - 1);
          }
          const startDateStr = startDate.toISOString().split("T")[0];
          const endDateStr = endDate.toISOString().split("T")[0];
          const previousStartDateStr = previousStartDate.toISOString().split("T")[0];
          const previousEndDateStr = previousEndDate.toISOString().split("T")[0];
          const periodStartDate = new Date(startDateStr);
          periodStartDate.setHours(0, 0, 0, 0);
          const periodEndDate = new Date(endDateStr);
          periodEndDate.setHours(23, 59, 59, 999);
          const prevPeriodStartDate = new Date(previousStartDateStr);
          prevPeriodStartDate.setHours(0, 0, 0, 0);
          const prevPeriodEndDate = new Date(previousEndDateStr);
          prevPeriodEndDate.setHours(23, 59, 59, 999);
          const bookingStats = await db.select({
            totalBookings: sql2`count(*)`,
            expectedRevenue: sql2`sum(case when ${bookings.status} IN ('confirmed', 'arrived') then ${bookings.totalAmountPaisa} else 0 end)`,
            confirmedBookings: sql2`count(case when ${bookings.status} = 'confirmed' then 1 end)`,
            arrivedBookings: sql2`count(case when ${bookings.status} = 'arrived' then 1 end)`,
            cancelledBookings: sql2`count(case when ${bookings.status} = 'cancelled' then 1 end)`,
            completedBookings: sql2`count(case when ${bookings.status} = 'completed' then 1 end)`
          }).from(bookings).where(and(
            eq(bookings.salonId, salonId),
            gte(bookings.bookingDate, startDateStr),
            lte(bookings.bookingDate, endDateStr)
          ));
          const jobCardStats = await db.select({
            totalJobCards: sql2`count(*)`,
            // Realized revenue = only from completed AND paid job cards
            realizedRevenue: sql2`sum(case when ${jobCards.status} = 'completed' AND ${jobCards.paymentStatus} = 'paid' then ${jobCards.paidAmountPaisa} else 0 end)`,
            // Pending revenue = from open/in-service job cards (service in progress but not yet paid)
            pendingRevenue: sql2`sum(case when ${jobCards.status} IN ('open', 'in_service', 'pending_checkout') then ${jobCards.totalAmountPaisa} else 0 end)`,
            completedJobCards: sql2`count(case when ${jobCards.status} = 'completed' then 1 end)`,
            paidJobCards: sql2`count(case when ${jobCards.status} = 'completed' AND ${jobCards.paymentStatus} = 'paid' then 1 end)`,
            walkInCount: sql2`count(case when ${jobCards.isWalkIn} = 1 then 1 end)`,
            // Walk-in revenue only from paid walk-ins
            walkInRevenue: sql2`sum(case when ${jobCards.isWalkIn} = 1 AND ${jobCards.status} = 'completed' AND ${jobCards.paymentStatus} = 'paid' then ${jobCards.paidAmountPaisa} else 0 end)`
          }).from(jobCards).where(and(
            eq(jobCards.salonId, salonId),
            gte(jobCards.checkInAt, periodStartDate),
            lte(jobCards.checkInAt, periodEndDate)
          ));
          const previousBookingStats = await db.select({
            totalBookings: sql2`count(*)`,
            totalRevenue: sql2`sum(${bookings.totalAmountPaisa})`,
            confirmedBookings: sql2`count(case when ${bookings.status} = 'confirmed' then 1 end)`,
            cancelledBookings: sql2`count(case when ${bookings.status} = 'cancelled' then 1 end)`,
            completedBookings: sql2`count(case when ${bookings.status} = 'completed' then 1 end)`
          }).from(bookings).where(and(
            eq(bookings.salonId, salonId),
            gte(bookings.bookingDate, previousStartDateStr),
            lte(bookings.bookingDate, previousEndDateStr)
          ));
          const previousJobCardStats = await db.select({
            totalJobCards: sql2`count(*)`,
            realizedRevenue: sql2`sum(case when ${jobCards.status} = 'completed' AND ${jobCards.paymentStatus} = 'paid' then ${jobCards.paidAmountPaisa} else 0 end)`,
            completedJobCards: sql2`count(case when ${jobCards.status} = 'completed' then 1 end)`,
            paidJobCards: sql2`count(case when ${jobCards.status} = 'completed' AND ${jobCards.paymentStatus} = 'paid' then 1 end)`
          }).from(jobCards).where(and(
            eq(jobCards.salonId, salonId),
            gte(jobCards.checkInAt, prevPeriodStartDate),
            lte(jobCards.checkInAt, prevPeriodEndDate)
          ));
          const todayBookingStats = await db.select({
            todayBookings: sql2`count(*)`,
            todayRevenue: sql2`sum(${bookings.totalAmountPaisa})`,
            todayConfirmed: sql2`count(case when ${bookings.status} = 'confirmed' then 1 end)`
          }).from(bookings).where(and(
            eq(bookings.salonId, salonId),
            eq(bookings.bookingDate, today)
          ));
          const todayJobCardStats = await db.select({
            todayJobCards: sql2`count(*)`,
            todayRealizedRevenue: sql2`sum(case when ${jobCards.status} = 'completed' AND ${jobCards.paymentStatus} = 'paid' then ${jobCards.paidAmountPaisa} else 0 end)`,
            todayPendingRevenue: sql2`sum(case when ${jobCards.status} IN ('open', 'in_service', 'pending_checkout') then ${jobCards.totalAmountPaisa} else 0 end)`,
            todayWalkIns: sql2`count(case when ${jobCards.isWalkIn} = 1 then 1 end)`,
            todayCompleted: sql2`count(case when ${jobCards.status} = 'completed' then 1 end)`,
            todayPaid: sql2`count(case when ${jobCards.status} = 'completed' AND ${jobCards.paymentStatus} = 'paid' then 1 end)`
          }).from(jobCards).where(and(
            eq(jobCards.salonId, salonId),
            gte(jobCards.checkInAt, todayStart),
            lte(jobCards.checkInAt, todayEnd)
          ));
          const activeStaffCount = await db.select({
            count: sql2`count(*)`
          }).from(staff).where(and(
            eq(staff.salonId, salonId),
            eq(staff.isActive, 1)
          ));
          const popularServicesFromBookings = await db.select({
            serviceId: services.id,
            serviceName: services.name,
            bookingCount: sql2`count(*)`,
            bookingRevenue: sql2`sum(${bookings.totalAmountPaisa})`
          }).from(bookings).innerJoin(services, eq(bookings.serviceId, services.id)).where(and(
            eq(bookings.salonId, salonId),
            gte(bookings.bookingDate, startDateStr),
            lte(bookings.bookingDate, endDateStr)
          )).groupBy(services.id, services.name);
          const popularServicesFromJobCards = await db.select({
            serviceId: jobCardServices.serviceId,
            jobCardCount: sql2`count(distinct ${jobCardServices.jobCardId})`,
            jobCardRevenue: sql2`sum(case when ${jobCardServices.status} = 'completed' then ${jobCardServices.finalPricePaisa} else 0 end)`
          }).from(jobCardServices).innerJoin(jobCards, and(
            eq(jobCardServices.jobCardId, jobCards.id),
            eq(jobCards.status, "completed"),
            eq(jobCards.paymentStatus, "paid"),
            gte(jobCards.checkInAt, startDate),
            lte(jobCards.checkInAt, endDate)
          )).where(eq(jobCardServices.salonId, salonId)).groupBy(jobCardServices.serviceId);
          const serviceMap = /* @__PURE__ */ new Map();
          popularServicesFromBookings.forEach((s) => {
            serviceMap.set(s.serviceId, {
              serviceId: s.serviceId,
              serviceName: s.serviceName,
              bookingCount: parseFloat(String(s.bookingCount)) || 0,
              jobCardCount: 0,
              realizedRevenue: 0
              // Revenue comes from job cards only
            });
          });
          const serviceNameLookup = /* @__PURE__ */ new Map();
          popularServicesFromBookings.forEach((s) => serviceNameLookup.set(s.serviceId, s.serviceName));
          const jobCardServiceIds = popularServicesFromJobCards.map((jc) => jc.serviceId);
          const missingServiceIds = jobCardServiceIds.filter((id) => !serviceNameLookup.has(id));
          if (missingServiceIds.length > 0) {
            const additionalServices = await db.select({ id: services.id, name: services.name }).from(services).where(inArray(services.id, missingServiceIds));
            additionalServices.forEach((s) => serviceNameLookup.set(s.id, s.name));
          }
          popularServicesFromJobCards.forEach((jc) => {
            const existing = serviceMap.get(jc.serviceId);
            const jcCount = parseFloat(String(jc.jobCardCount)) || 0;
            const jcRevenue = parseFloat(String(jc.jobCardRevenue)) || 0;
            if (existing) {
              existing.jobCardCount = jcCount;
              existing.realizedRevenue = jcRevenue;
            } else {
              serviceMap.set(jc.serviceId, {
                serviceId: jc.serviceId,
                serviceName: serviceNameLookup.get(jc.serviceId) || "Unknown Service",
                bookingCount: 0,
                jobCardCount: jcCount,
                realizedRevenue: jcRevenue
              });
            }
          });
          const popularServices = Array.from(serviceMap.values()).map((s) => ({
            ...s,
            totalCount: s.bookingCount + s.jobCardCount
          })).sort((a, b) => b.totalCount - a.totalCount).slice(0, 5);
          const bookingTrendsByDay = await db.select({
            date: bookings.bookingDate,
            bookingCount: sql2`count(*)`,
            revenue: sql2`sum(${bookings.totalAmountPaisa})`
          }).from(bookings).where(and(
            eq(bookings.salonId, salonId),
            gte(bookings.bookingDate, startDateStr),
            lte(bookings.bookingDate, endDateStr)
          )).groupBy(bookings.bookingDate).orderBy(asc(bookings.bookingDate));
          const jobCardTrendsByDay = await db.select({
            date: sql2`DATE(${jobCards.checkInAt})`,
            jobCardCount: sql2`count(*)`,
            revenue: sql2`sum(case when ${jobCards.status} = 'completed' AND ${jobCards.paymentStatus} = 'paid' then ${jobCards.paidAmountPaisa} else 0 end)`
          }).from(jobCards).where(and(
            eq(jobCards.salonId, salonId),
            gte(jobCards.checkInAt, startDate),
            lte(jobCards.checkInAt, endDate)
          )).groupBy(sql2`DATE(${jobCards.checkInAt})`).orderBy(asc(sql2`DATE(${jobCards.checkInAt})`));
          const trendsMap = /* @__PURE__ */ new Map();
          bookingTrendsByDay.forEach((t) => {
            trendsMap.set(t.date, {
              bookingCount: parseFloat(String(t.bookingCount)) || 0,
              jobCardCount: 0,
              realizedRevenue: 0,
              // Will come from job cards
              expectedRevenue: parseFloat(String(t.revenue)) || 0
              // Booking revenue is expected, not realized
            });
          });
          jobCardTrendsByDay.forEach((t) => {
            const dateKey = t.date;
            const jcCount = parseFloat(String(t.jobCardCount)) || 0;
            const jcRevenue = parseFloat(String(t.revenue)) || 0;
            const existing = trendsMap.get(dateKey);
            if (existing) {
              existing.jobCardCount = jcCount;
              existing.realizedRevenue = jcRevenue;
            } else {
              trendsMap.set(dateKey, {
                bookingCount: 0,
                jobCardCount: jcCount,
                realizedRevenue: jcRevenue,
                expectedRevenue: 0
              });
            }
          });
          const revenueTrends = Array.from(trendsMap.entries()).map(([date, data]) => ({ date, ...data })).sort((a, b) => a.date.localeCompare(b.date));
          const staffPerformanceFromBookings = await db.select({
            staffId: staff.id,
            staffName: staff.name,
            bookingCount: sql2`count(*)`,
            bookingRevenue: sql2`sum(${bookings.totalAmountPaisa})`
          }).from(bookings).leftJoin(staff, eq(bookings.staffId, staff.id)).where(and(
            eq(bookings.salonId, salonId),
            gte(bookings.bookingDate, startDateStr),
            lte(bookings.bookingDate, endDateStr)
          )).groupBy(staff.id, staff.name);
          const staffPerformanceFromJobCards = await db.select({
            staffId: jobCardServices.staffId,
            jobCardCount: sql2`count(distinct ${jobCardServices.jobCardId})`,
            jobCardRevenue: sql2`sum(case when ${jobCardServices.status} = 'completed' then ${jobCardServices.finalPricePaisa} else 0 end)`
          }).from(jobCardServices).innerJoin(jobCards, and(
            eq(jobCardServices.jobCardId, jobCards.id),
            eq(jobCards.status, "completed"),
            eq(jobCards.paymentStatus, "paid"),
            gte(jobCards.checkInAt, startDate),
            lte(jobCards.checkInAt, endDate)
          )).where(and(
            eq(jobCardServices.salonId, salonId),
            isNotNull(jobCardServices.staffId)
          )).groupBy(jobCardServices.staffId);
          const staffMap = /* @__PURE__ */ new Map();
          staffPerformanceFromBookings.forEach((s) => {
            const staffIdKey = s.staffId || "unassigned";
            staffMap.set(staffIdKey, {
              staffId: staffIdKey,
              staffName: s.staffName || "Unassigned",
              bookingCount: parseFloat(String(s.bookingCount)) || 0,
              jobCardCount: 0,
              realizedRevenue: 0
              // Revenue comes from job cards only
            });
          });
          const staffIdsFromJobCards = staffPerformanceFromJobCards.map((jc) => jc.staffId).filter((id) => id != null);
          const missingStaffIds = staffIdsFromJobCards.filter((id) => !staffMap.has(id));
          if (missingStaffIds.length > 0) {
            const additionalStaff = await db.select({ id: staff.id, name: staff.name }).from(staff).where(inArray(staff.id, missingStaffIds));
            additionalStaff.forEach((s) => {
              if (!staffMap.has(s.id)) {
                staffMap.set(s.id, {
                  staffId: s.id,
                  staffName: s.name,
                  bookingCount: 0,
                  jobCardCount: 0,
                  realizedRevenue: 0
                });
              }
            });
          }
          staffPerformanceFromJobCards.forEach((jc) => {
            const staffIdKey = jc.staffId || "unassigned";
            const jcCount = parseFloat(String(jc.jobCardCount)) || 0;
            const jcRevenue = parseFloat(String(jc.jobCardRevenue)) || 0;
            const existing = staffMap.get(staffIdKey);
            if (existing) {
              existing.jobCardCount = jcCount;
              existing.realizedRevenue = jcRevenue;
            }
          });
          const staffPerformance = Array.from(staffMap.values()).map((s) => ({
            ...s,
            totalCount: s.bookingCount + s.jobCardCount
          })).sort((a, b) => b.totalCount - a.totalCount);
          const bookingData = bookingStats[0] || {
            totalBookings: 0,
            expectedRevenue: 0,
            confirmedBookings: 0,
            arrivedBookings: 0,
            cancelledBookings: 0,
            completedBookings: 0
          };
          const jobCardData = jobCardStats[0] || {
            totalJobCards: 0,
            realizedRevenue: 0,
            pendingRevenue: 0,
            completedJobCards: 0,
            paidJobCards: 0,
            walkInCount: 0,
            walkInRevenue: 0
          };
          const previousBookingData = previousBookingStats[0] || {
            totalBookings: 0,
            totalRevenue: 0,
            confirmedBookings: 0,
            cancelledBookings: 0,
            completedBookings: 0
          };
          const previousJobCardData = previousJobCardStats[0] || {
            totalJobCards: 0,
            realizedRevenue: 0,
            completedJobCards: 0,
            paidJobCards: 0
          };
          const todayBookingData = todayBookingStats[0] || {
            todayBookings: 0,
            todayRevenue: 0,
            todayConfirmed: 0
          };
          const todayJobCardData = todayJobCardStats[0] || {
            todayJobCards: 0,
            todayRealizedRevenue: 0,
            todayPendingRevenue: 0,
            todayWalkIns: 0,
            todayCompleted: 0,
            todayPaid: 0
          };
          const staffCount = activeStaffCount[0]?.count || 0;
          const calculateTrend = (current, previous) => {
            if (previous === 0) return current > 0 ? { percentage: 100, trend: "up" } : { percentage: 0, trend: "neutral" };
            const change = (current - previous) / previous * 100;
            return {
              percentage: Math.abs(change),
              trend: change > 0 ? "up" : change < 0 ? "down" : "neutral"
            };
          };
          const currentBookings = Number(bookingData.totalBookings) || 0;
          const currentJobCards = Number(jobCardData.totalJobCards) || 0;
          const totalCustomers = currentBookings + currentJobCards;
          const realizedRevenue = Number(jobCardData.realizedRevenue) || 0;
          const expectedRevenue = Number(bookingData.expectedRevenue) || 0;
          const pendingRevenue = Number(jobCardData.pendingRevenue) || 0;
          const currentRevenue = realizedRevenue;
          const currentWalkIns = Number(jobCardData.walkInCount) || 0;
          const walkInRevenue = Number(jobCardData.walkInRevenue) || 0;
          const paidJobCards = Number(jobCardData.paidJobCards) || 0;
          const previousBookings = Number(previousBookingData.totalBookings) || 0;
          const previousJobCards = Number(previousJobCardData.totalJobCards) || 0;
          const previousTotalCustomers = previousBookings + previousJobCards;
          const previousRealizedRevenue = Number(previousJobCardData.realizedRevenue) || 0;
          const previousRevenue = previousRealizedRevenue;
          const todayBookings = Number(todayBookingData.todayBookings) || 0;
          const todayJobCards = Number(todayJobCardData.todayJobCards) || 0;
          const todayTotalCustomers = todayBookings + todayJobCards;
          const todayRealizedRevenue = Number(todayJobCardData.todayRealizedRevenue) || 0;
          const todayExpectedRevenue = Number(todayBookingData.todayRevenue) || 0;
          const todayPendingRevenue = Number(todayJobCardData.todayPendingRevenue) || 0;
          const todayRevenue = todayRealizedRevenue;
          const todayWalkIns = Number(todayJobCardData.todayWalkIns) || 0;
          const todayCompleted = Number(todayJobCardData.todayCompleted) || 0;
          const todayPaid = Number(todayJobCardData.todayPaid) || 0;
          const bookingsTrend = calculateTrend(totalCustomers, previousTotalCustomers);
          const revenueTrend = calculateTrend(currentRevenue, previousRevenue);
          const averageTransactionValue = paidJobCards > 0 ? realizedRevenue / paidJobCards : 0;
          const previousPaidJobCards = Number(previousJobCardData.paidJobCards) || 0;
          const previousAverageTransactionValue = previousPaidJobCards > 0 ? previousRealizedRevenue / previousPaidJobCards : 0;
          const averageValueTrend = calculateTrend(averageTransactionValue, previousAverageTransactionValue);
          return {
            period,
            startDate: startDateStr,
            endDate: endDateStr,
            overview: {
              // Combined customer/transaction data
              totalBookings: currentBookings,
              totalJobCards: currentJobCards,
              totalCustomers,
              // REVENUE BREAKDOWN - This is the key fix for the lifecycle issue
              // totalRevenuePaisa = ONLY realized revenue (actually collected from paid job cards)
              totalRevenuePaisa: currentRevenue,
              realizedRevenuePaisa: realizedRevenue,
              // Money actually collected
              expectedRevenuePaisa: expectedRevenue,
              // From confirmed bookings (not yet serviced)
              pendingRevenuePaisa: pendingRevenue,
              // From job cards in progress (not yet paid)
              // Booking status breakdown
              confirmedBookings: Number(bookingData.confirmedBookings) || 0,
              arrivedBookings: Number(bookingData.arrivedBookings) || 0,
              cancelledBookings: Number(bookingData.cancelledBookings) || 0,
              completedBookings: Number(bookingData.completedBookings) || 0,
              // Job card status breakdown
              completedJobCards: Number(jobCardData.completedJobCards) || 0,
              paidJobCards,
              cancellationRate: currentBookings > 0 ? ((Number(bookingData.cancelledBookings) || 0) / currentBookings * 100).toFixed(2) : "0.00",
              // Completion rate (job cards that were completed and paid vs total job cards)
              completionRate: currentJobCards > 0 ? (paidJobCards / currentJobCards * 100).toFixed(1) : "0.0",
              // Walk-in specific data (only from paid walk-ins)
              walkInCount: currentWalkIns,
              walkInRevenuePaisa: walkInRevenue,
              // Today's specific data (combined)
              todayBookings,
              todayJobCards,
              todayTotalCustomers,
              todayRevenuePaisa: todayRevenue,
              // Only realized revenue today
              todayRealizedRevenuePaisa: todayRealizedRevenue,
              todayExpectedRevenuePaisa: todayExpectedRevenue,
              todayPendingRevenuePaisa: todayPendingRevenue,
              todayConfirmed: Number(todayBookingData.todayConfirmed) || 0,
              todayWalkIns,
              todayCompleted,
              todayPaid,
              // Staff metrics
              activeStaffCount: Number(staffCount),
              // Average values (based on paid transactions only)
              averageBookingValuePaisa: Math.round(averageTransactionValue),
              // Trending data with percentages
              bookingsTrend: {
                percentage: bookingsTrend.percentage.toFixed(1),
                direction: bookingsTrend.trend,
                previousPeriodValue: previousTotalCustomers
              },
              revenueTrend: {
                percentage: revenueTrend.percentage.toFixed(1),
                direction: revenueTrend.trend,
                previousPeriodValue: previousRevenue
              },
              averageValueTrend: {
                percentage: averageValueTrend.percentage.toFixed(1),
                direction: averageValueTrend.trend,
                previousPeriodValue: Math.round(previousAverageTransactionValue)
              }
            },
            popularServices: popularServices.map((service) => ({
              serviceName: service.serviceName,
              bookingCount: service.bookingCount,
              jobCardCount: service.jobCardCount,
              serviceCount: service.totalCount,
              realizedRevenuePaisa: service.realizedRevenue
            })),
            revenueTrends: revenueTrends.map((trend) => ({
              date: trend.date,
              bookingCount: trend.bookingCount,
              jobCardCount: trend.jobCardCount,
              totalTransactions: trend.bookingCount + trend.jobCardCount,
              realizedRevenuePaisa: trend.realizedRevenue,
              expectedRevenuePaisa: trend.expectedRevenue
            })),
            staffPerformance: staffPerformance.filter((performer) => performer.staffName && performer.staffName !== "Unassigned").map((performer) => ({
              staffName: performer.staffName,
              bookingCount: performer.bookingCount,
              jobCardCount: performer.jobCardCount,
              transactionCount: performer.totalCount,
              realizedRevenuePaisa: performer.realizedRevenue,
              utilization: totalCustomers > 0 ? (performer.totalCount / totalCustomers * 100).toFixed(1) : "0.0"
            }))
          };
        } catch (error) {
          console.error("Error fetching salon analytics:", error);
          throw error;
        }
      }
      // Advanced Staff Analytics (includes both bookings and job cards/walk-ins)
      async getAdvancedStaffAnalytics(salonId, period) {
        try {
          const { startDate, endDate, previousStartDate, previousEndDate } = this.calculateDateRange(period);
          const startDateStr = startDate.toISOString().split("T")[0];
          const endDateStr = endDate.toISOString().split("T")[0];
          const bookingMetrics = await db.select({
            staffId: staff.id,
            staffName: staff.name,
            totalBookings: sql2`count(${bookings.id})`,
            completedBookings: sql2`count(case when ${bookings.status} = 'completed' then 1 end)`,
            cancelledBookings: sql2`count(case when ${bookings.status} = 'cancelled' then 1 end)`,
            bookingRevenue: sql2`sum(${bookings.totalAmountPaisa})`,
            workingDays: sql2`count(distinct ${bookings.bookingDate})`
          }).from(staff).leftJoin(bookings, and(
            eq(bookings.staffId, staff.id),
            gte(bookings.bookingDate, startDateStr),
            lte(bookings.bookingDate, endDateStr)
          )).where(and(
            eq(staff.salonId, salonId),
            eq(staff.isActive, 1)
          )).groupBy(staff.id, staff.name);
          const jobCardMetrics = await db.select({
            staffId: staff.id,
            totalJobCards: sql2`count(${jobCards.id})`,
            completedJobCards: sql2`count(case when ${jobCards.status} = 'completed' then 1 end)`,
            jobCardRevenue: sql2`sum(case when ${jobCards.status} = 'completed' AND ${jobCards.paymentStatus} = 'paid' then ${jobCards.paidAmountPaisa} else 0 end)`,
            walkInCount: sql2`count(case when ${jobCards.isWalkIn} = 1 then 1 end)`,
            jobCardWorkingDays: sql2`count(distinct DATE(${jobCards.checkInAt}))`
          }).from(staff).leftJoin(jobCards, and(
            eq(jobCards.assignedStaffId, staff.id),
            gte(jobCards.checkInAt, startDate),
            lte(jobCards.checkInAt, endDate)
          )).where(and(
            eq(staff.salonId, salonId),
            eq(staff.isActive, 1)
          )).groupBy(staff.id);
          const jobCardMap = /* @__PURE__ */ new Map();
          jobCardMetrics.forEach((m) => {
            jobCardMap.set(m.staffId, {
              totalJobCards: parseFloat(String(m.totalJobCards)) || 0,
              completedJobCards: parseFloat(String(m.completedJobCards)) || 0,
              jobCardRevenue: parseFloat(String(m.jobCardRevenue)) || 0,
              walkInCount: parseFloat(String(m.walkInCount)) || 0,
              jobCardWorkingDays: parseFloat(String(m.jobCardWorkingDays)) || 0
            });
          });
          const staffAnalytics = bookingMetrics.map((s) => {
            const bookingCount = parseFloat(String(s.totalBookings)) || 0;
            const completedBookings = parseFloat(String(s.completedBookings)) || 0;
            const cancelledBookings = parseFloat(String(s.cancelledBookings)) || 0;
            const bookingRevenue = parseFloat(String(s.bookingRevenue)) || 0;
            const bookingWorkingDays = parseFloat(String(s.workingDays)) || 0;
            const jc = jobCardMap.get(s.staffId) || { totalJobCards: 0, completedJobCards: 0, jobCardRevenue: 0, walkInCount: 0, jobCardWorkingDays: 0 };
            const totalServices = bookingCount + jc.totalJobCards;
            const totalCompleted = completedBookings + jc.completedJobCards;
            const totalRevenue = bookingRevenue + jc.jobCardRevenue;
            const workingDays = Math.max(bookingWorkingDays, jc.jobCardWorkingDays);
            const completionRate = totalServices > 0 ? totalCompleted / totalServices * 100 : 0;
            const cancellationRate = totalServices > 0 ? cancelledBookings / totalServices * 100 : 0;
            const servicesPerDay = workingDays > 0 ? totalServices / workingDays : 0;
            const revenuePerDay = workingDays > 0 ? totalRevenue / workingDays : 0;
            return {
              staffId: s.staffId,
              staffName: s.staffName,
              totalBookings: bookingCount,
              totalJobCards: jc.totalJobCards,
              totalServices,
              // Combined count
              completedServices: totalCompleted,
              walkInCount: jc.walkInCount,
              completionRate: Number(completionRate.toFixed(1)),
              cancellationRate: Number(cancellationRate.toFixed(1)),
              totalRevenuePaisa: totalRevenue,
              bookingRevenuePaisa: bookingRevenue,
              walkInRevenuePaisa: jc.jobCardRevenue,
              averageServiceValuePaisa: totalServices > 0 ? Math.round(totalRevenue / totalServices) : 0,
              workingDays,
              servicesPerDay: Number(servicesPerDay.toFixed(1)),
              revenuePerDay: Math.round(revenuePerDay),
              utilizationScore: Number((completionRate * 0.6 + servicesPerDay * 10).toFixed(1)),
              efficiency: Number((totalRevenue / Math.max(totalServices, 1)).toFixed(0))
            };
          });
          return {
            period,
            staffAnalytics: staffAnalytics.sort((a, b) => b.totalRevenuePaisa - a.totalRevenuePaisa),
            summary: {
              totalStaff: staffAnalytics.length,
              averageUtilization: staffAnalytics.length > 0 ? Number((staffAnalytics.reduce((sum4, s) => sum4 + s.utilizationScore, 0) / staffAnalytics.length).toFixed(1)) : 0,
              topPerformer: staffAnalytics.length > 0 ? staffAnalytics[0].staffName : null,
              totalStaffRevenue: staffAnalytics.reduce((sum4, s) => sum4 + s.totalRevenuePaisa, 0),
              totalWalkInRevenue: staffAnalytics.reduce((sum4, s) => sum4 + s.walkInRevenuePaisa, 0),
              totalBookingRevenue: staffAnalytics.reduce((sum4, s) => sum4 + s.bookingRevenuePaisa, 0)
            }
          };
        } catch (error) {
          console.error("Error fetching advanced staff analytics:", error);
          throw error;
        }
      }
      // Client Retention Analytics (includes both bookings and walk-in customers)
      async getClientRetentionAnalytics(salonId, period) {
        try {
          const { startDate, endDate } = this.calculateDateRange(period);
          const startDateStr = startDate.toISOString().split("T")[0];
          const endDateStr = endDate.toISOString().split("T")[0];
          const bookingCustomerMetrics = await db.select({
            customerEmail: bookings.customerEmail,
            customerName: bookings.customerName,
            totalVisits: sql2`count(*)`,
            totalSpent: sql2`sum(${bookings.totalAmountPaisa})`,
            firstVisit: sql2`min(${bookings.bookingDate})`,
            lastVisit: sql2`max(${bookings.bookingDate})`,
            completedVisits: sql2`count(case when ${bookings.status} = 'completed' then 1 end)`,
            cancelledVisits: sql2`count(case when ${bookings.status} = 'cancelled' then 1 end)`,
            source: sql2`'booking'`
          }).from(bookings).where(and(
            eq(bookings.salonId, salonId),
            gte(bookings.bookingDate, startDateStr),
            lte(bookings.bookingDate, endDateStr)
          )).groupBy(bookings.customerEmail, bookings.customerName);
          const jobCardCustomerMetrics = await db.select({
            customerPhone: jobCards.customerPhone,
            customerName: jobCards.customerName,
            totalVisits: sql2`count(*)`,
            totalSpent: sql2`sum(case when ${jobCards.status} = 'completed' AND ${jobCards.paymentStatus} = 'paid' then ${jobCards.paidAmountPaisa} else 0 end)`,
            firstVisit: sql2`min(DATE(${jobCards.checkInAt}))`,
            lastVisit: sql2`max(DATE(${jobCards.checkInAt}))`,
            completedVisits: sql2`count(case when ${jobCards.status} = 'completed' then 1 end)`,
            isWalkIn: sql2`max(case when ${jobCards.isWalkIn} = 1 then 1 else 0 end)`
          }).from(jobCards).where(and(
            eq(jobCards.salonId, salonId),
            gte(jobCards.checkInAt, startDate),
            lte(jobCards.checkInAt, endDate)
          )).groupBy(jobCards.customerPhone, jobCards.customerName);
          const customerMap = /* @__PURE__ */ new Map();
          bookingCustomerMetrics.forEach((c) => {
            const key = c.customerEmail || c.customerName;
            customerMap.set(key, {
              customerIdentifier: c.customerEmail,
              customerName: c.customerName,
              totalVisits: parseFloat(String(c.totalVisits)) || 0,
              totalSpent: parseFloat(String(c.totalSpent)) || 0,
              firstVisit: c.firstVisit,
              lastVisit: c.lastVisit,
              completedVisits: parseFloat(String(c.completedVisits)) || 0,
              cancelledVisits: parseFloat(String(c.cancelledVisits)) || 0,
              isWalkIn: false,
              source: "booking"
            });
          });
          jobCardCustomerMetrics.forEach((c) => {
            const key = c.customerPhone || c.customerName;
            const existing = customerMap.get(key);
            const visits = parseFloat(String(c.totalVisits)) || 0;
            const spent = parseFloat(String(c.totalSpent)) || 0;
            const completed = parseFloat(String(c.completedVisits)) || 0;
            const isWalkIn = parseFloat(String(c.isWalkIn)) === 1;
            if (existing) {
              existing.totalVisits += visits;
              existing.totalSpent += spent;
              existing.completedVisits += completed;
              if (c.firstVisit && (!existing.firstVisit || c.firstVisit < existing.firstVisit)) {
                existing.firstVisit = c.firstVisit;
              }
              if (c.lastVisit && (!existing.lastVisit || c.lastVisit > existing.lastVisit)) {
                existing.lastVisit = c.lastVisit;
              }
              existing.source = "both";
            } else {
              customerMap.set(key, {
                customerIdentifier: c.customerPhone,
                customerName: c.customerName,
                totalVisits: visits,
                totalSpent: spent,
                firstVisit: c.firstVisit,
                lastVisit: c.lastVisit,
                completedVisits: completed,
                cancelledVisits: 0,
                isWalkIn,
                source: isWalkIn ? "walk_in" : "job_card"
              });
            }
          });
          const now = /* @__PURE__ */ new Date();
          const retentionAnalytics = Array.from(customerMap.values()).map((customer) => {
            const totalVisits = customer.totalVisits;
            const totalSpent = customer.totalSpent;
            const completedVisits = customer.completedVisits;
            const firstVisitDate = customer.firstVisit ? new Date(customer.firstVisit) : now;
            const lastVisitDate = customer.lastVisit ? new Date(customer.lastVisit) : now;
            const daysSinceFirst = Math.floor((now.getTime() - firstVisitDate.getTime()) / (1e3 * 60 * 60 * 24));
            const daysSinceLast = Math.floor((now.getTime() - lastVisitDate.getTime()) / (1e3 * 60 * 60 * 24));
            const customerLifespan = Math.floor((lastVisitDate.getTime() - firstVisitDate.getTime()) / (1e3 * 60 * 60 * 24));
            const averageDaysBetweenVisits = totalVisits > 1 ? customerLifespan / (totalVisits - 1) : 0;
            let lifecycleStage = "new";
            if (totalVisits >= 5) lifecycleStage = "loyal";
            else if (totalVisits >= 2) lifecycleStage = "returning";
            let churnRisk = "low";
            if (daysSinceLast > 90) churnRisk = "high";
            else if (daysSinceLast > 45) churnRisk = "medium";
            return {
              customerIdentifier: customer.customerIdentifier,
              customerName: customer.customerName,
              totalVisits,
              completedVisits,
              totalSpentPaisa: totalSpent,
              averageVisitValuePaisa: totalVisits > 0 ? Math.round(totalSpent / totalVisits) : 0,
              daysSinceFirst,
              daysSinceLast,
              averageDaysBetweenVisits: Math.round(averageDaysBetweenVisits),
              lifecycleStage,
              churnRisk,
              lifetimeValue: totalSpent,
              isWalkIn: customer.isWalkIn,
              source: customer.source
            };
          });
          const totalCustomers = retentionAnalytics.length;
          const walkInCustomers = retentionAnalytics.filter((c) => c.source === "walk_in").length;
          const bookingCustomers = retentionAnalytics.filter((c) => c.source === "booking").length;
          const returningCustomers = retentionAnalytics.filter((c) => c.totalVisits > 1).length;
          const loyalCustomers = retentionAnalytics.filter((c) => c.lifecycleStage === "loyal").length;
          const highRiskCustomers = retentionAnalytics.filter((c) => c.churnRisk === "high").length;
          const averageLifetimeValue = totalCustomers > 0 ? retentionAnalytics.reduce((sum4, c) => sum4 + c.lifetimeValue, 0) / totalCustomers : 0;
          return {
            period,
            customerAnalytics: retentionAnalytics.sort((a, b) => b.lifetimeValue - a.lifetimeValue),
            retentionMetrics: {
              totalCustomers,
              walkInCustomers,
              bookingCustomers,
              newCustomers: retentionAnalytics.filter((c) => c.lifecycleStage === "new").length,
              returningCustomers,
              loyalCustomers,
              retentionRate: totalCustomers > 0 ? Number((returningCustomers / totalCustomers * 100).toFixed(1)) : 0,
              loyaltyRate: totalCustomers > 0 ? Number((loyalCustomers / totalCustomers * 100).toFixed(1)) : 0,
              churnRisk: {
                high: highRiskCustomers,
                medium: retentionAnalytics.filter((c) => c.churnRisk === "medium").length,
                low: retentionAnalytics.filter((c) => c.churnRisk === "low").length
              },
              averageLifetimeValuePaisa: Math.round(averageLifetimeValue),
              averageVisitsPerCustomer: totalCustomers > 0 ? Number((retentionAnalytics.reduce((sum4, c) => sum4 + c.totalVisits, 0) / totalCustomers).toFixed(1)) : 0
            }
          };
        } catch (error) {
          console.error("Error fetching client retention analytics:", error);
          throw error;
        }
      }
      // Service Popularity Analytics (includes both bookings and job card services)
      async getServicePopularityAnalytics(salonId, period) {
        try {
          const { startDate, endDate, previousStartDate, previousEndDate } = this.calculateDateRange(period);
          const startDateStr = startDate.toISOString().split("T")[0];
          const endDateStr = endDate.toISOString().split("T")[0];
          const previousStartDateStr = previousStartDate.toISOString().split("T")[0];
          const previousEndDateStr = previousEndDate.toISOString().split("T")[0];
          const bookingServiceMetrics = await db.select({
            serviceId: services.id,
            serviceName: services.name,
            serviceCategory: services.category,
            servicePricePaisa: services.priceInPaisa,
            serviceDuration: services.durationMinutes,
            bookingCount: sql2`count(${bookings.id})`,
            completedBookings: sql2`count(case when ${bookings.status} = 'completed' then 1 end)`,
            cancelledBookings: sql2`count(case when ${bookings.status} = 'cancelled' then 1 end)`,
            bookingRevenue: sql2`sum(${bookings.totalAmountPaisa})`,
            uniqueBookingCustomers: sql2`count(distinct ${bookings.customerEmail})`
          }).from(services).leftJoin(bookings, and(
            eq(bookings.serviceId, services.id),
            gte(bookings.bookingDate, startDateStr),
            lte(bookings.bookingDate, endDateStr)
          )).where(eq(services.salonId, salonId)).groupBy(services.id, services.name, services.category, services.priceInPaisa, services.durationMinutes);
          const jobCardServiceMetrics = await db.select({
            serviceId: jobCardServices.serviceId,
            jobCardCount: sql2`count(distinct ${jobCardServices.jobCardId})`,
            completedJobCards: sql2`count(case when ${jobCardServices.status} = 'completed' then 1 end)`,
            jobCardRevenue: sql2`sum(case when ${jobCardServices.status} = 'completed' then ${jobCardServices.finalPricePaisa} else 0 end)`
          }).from(jobCardServices).innerJoin(jobCards, and(
            eq(jobCardServices.jobCardId, jobCards.id),
            gte(jobCards.checkInAt, startDate),
            lte(jobCards.checkInAt, endDate)
          )).where(eq(jobCardServices.salonId, salonId)).groupBy(jobCardServices.serviceId);
          const jobCardMap = /* @__PURE__ */ new Map();
          jobCardServiceMetrics.forEach((m) => {
            jobCardMap.set(m.serviceId, {
              jobCardCount: parseFloat(String(m.jobCardCount)) || 0,
              completedJobCards: parseFloat(String(m.completedJobCards)) || 0,
              jobCardRevenue: parseFloat(String(m.jobCardRevenue)) || 0
            });
          });
          const previousBookingMetrics = await db.select({
            serviceId: services.id,
            totalBookings: sql2`count(${bookings.id})`,
            totalRevenue: sql2`sum(${bookings.totalAmountPaisa})`
          }).from(services).leftJoin(bookings, and(
            eq(bookings.serviceId, services.id),
            gte(bookings.bookingDate, previousStartDateStr),
            lte(bookings.bookingDate, previousEndDateStr)
          )).where(eq(services.salonId, salonId)).groupBy(services.id);
          const previousJobCardMetrics = await db.select({
            serviceId: jobCardServices.serviceId,
            jobCardCount: sql2`count(distinct ${jobCardServices.jobCardId})`,
            jobCardRevenue: sql2`sum(case when ${jobCardServices.status} = 'completed' then ${jobCardServices.finalPricePaisa} else 0 end)`
          }).from(jobCardServices).innerJoin(jobCards, and(
            eq(jobCardServices.jobCardId, jobCards.id),
            gte(jobCards.checkInAt, previousStartDate),
            lte(jobCards.checkInAt, previousEndDate)
          )).where(eq(jobCardServices.salonId, salonId)).groupBy(jobCardServices.serviceId);
          const previousMetricsMap = /* @__PURE__ */ new Map();
          previousBookingMetrics.forEach((metric) => {
            previousMetricsMap.set(metric.serviceId, {
              totalServices: parseFloat(String(metric.totalBookings)) || 0,
              totalRevenue: parseFloat(String(metric.totalRevenue)) || 0
            });
          });
          previousJobCardMetrics.forEach((m) => {
            const existing = previousMetricsMap.get(m.serviceId) || { totalServices: 0, totalRevenue: 0 };
            existing.totalServices += parseFloat(String(m.jobCardCount)) || 0;
            existing.totalRevenue += parseFloat(String(m.jobCardRevenue)) || 0;
            previousMetricsMap.set(m.serviceId, existing);
          });
          const serviceAnalytics = bookingServiceMetrics.map((service) => {
            const bookingCount = parseFloat(String(service.bookingCount)) || 0;
            const completedBookings = parseFloat(String(service.completedBookings)) || 0;
            const cancelledBookings = parseFloat(String(service.cancelledBookings)) || 0;
            const bookingRevenue = parseFloat(String(service.bookingRevenue)) || 0;
            const uniqueBookingCustomers = parseFloat(String(service.uniqueBookingCustomers)) || 0;
            const jc = jobCardMap.get(service.serviceId) || { jobCardCount: 0, completedJobCards: 0, jobCardRevenue: 0 };
            const totalServices = bookingCount + jc.jobCardCount;
            const totalCompleted = completedBookings + jc.completedJobCards;
            const totalRevenue = bookingRevenue + jc.jobCardRevenue;
            const uniqueCustomers = uniqueBookingCustomers;
            const previousData = previousMetricsMap.get(service.serviceId) || { totalServices: 0, totalRevenue: 0 };
            const completionRate = totalServices > 0 ? totalCompleted / totalServices * 100 : 0;
            const cancellationRate = totalServices > 0 ? cancelledBookings / totalServices * 100 : 0;
            const revenuePerService = totalServices > 0 ? totalRevenue / totalServices : 0;
            const servicesTrend = this.calculateTrendMetric(totalServices, previousData.totalServices);
            const revenueTrend = this.calculateTrendMetric(totalRevenue, previousData.totalRevenue);
            return {
              serviceId: service.serviceId,
              serviceName: service.serviceName,
              category: service.serviceCategory,
              standardPricePaisa: Number(service.servicePricePaisa) || 0,
              durationMinutes: Number(service.serviceDuration) || 0,
              totalBookings: bookingCount,
              totalJobCards: jc.jobCardCount,
              totalServices,
              // Combined count
              completedServices: totalCompleted,
              completionRate: Number(completionRate.toFixed(1)),
              cancellationRate: Number(cancellationRate.toFixed(1)),
              totalRevenuePaisa: totalRevenue,
              bookingRevenuePaisa: bookingRevenue,
              jobCardRevenuePaisa: jc.jobCardRevenue,
              averageRevenuePerServicePaisa: Math.round(revenuePerService),
              uniqueCustomers,
              customerReturnRate: uniqueCustomers > 0 ? Number(((totalServices - uniqueCustomers) / uniqueCustomers * 100).toFixed(1)) : 0,
              servicesTrend,
              revenueTrend,
              popularityScore: totalServices * 0.4 + completionRate * 0.3 + uniqueCustomers / Math.max(totalServices, 1) * 100 * 0.3
            };
          });
          const categoryAnalysis = {};
          serviceAnalytics.forEach((service) => {
            const category = service.category || "Other";
            if (!categoryAnalysis[category]) {
              categoryAnalysis[category] = {
                serviceCount: 0,
                totalServices: 0,
                totalRevenue: 0,
                averageCompletionRate: 0
              };
            }
            categoryAnalysis[category].serviceCount++;
            categoryAnalysis[category].totalServices += service.totalServices;
            categoryAnalysis[category].totalRevenue += service.totalRevenuePaisa;
            categoryAnalysis[category].averageCompletionRate += service.completionRate;
          });
          Object.values(categoryAnalysis).forEach((category) => {
            category.averageCompletionRate = category.serviceCount > 0 ? Number((category.averageCompletionRate / category.serviceCount).toFixed(1)) : 0;
          });
          return {
            period,
            serviceAnalytics: serviceAnalytics.sort((a, b) => b.popularityScore - a.popularityScore),
            categoryAnalysis,
            insights: {
              topService: serviceAnalytics.length > 0 ? serviceAnalytics[0].serviceName : null,
              mostProfitableService: serviceAnalytics.length > 0 ? serviceAnalytics.sort((a, b) => b.totalRevenuePaisa - a.totalRevenuePaisa)[0].serviceName : null,
              highestCompletionRate: serviceAnalytics.length > 0 ? Math.max(...serviceAnalytics.map((s) => s.completionRate)) : 0,
              lowestCancellationRate: serviceAnalytics.length > 0 ? Math.min(...serviceAnalytics.map((s) => s.cancellationRate)) : 0
            }
          };
        } catch (error) {
          console.error("Error fetching service popularity analytics:", error);
          throw error;
        }
      }
      // Business Intelligence Metrics
      async getBusinessIntelligenceMetrics(salonId, period) {
        try {
          const { startDate, endDate } = this.calculateDateRange(period);
          const startDateStr = startDate.toISOString().split("T")[0];
          const endDateStr = endDate.toISOString().split("T")[0];
          const dailyRevenue = await db.select({
            date: bookings.bookingDate,
            revenue: sql2`sum(${bookings.totalAmountPaisa})`,
            bookingCount: sql2`count(*)`
          }).from(bookings).where(and(
            eq(bookings.salonId, salonId),
            gte(bookings.bookingDate, startDateStr),
            lte(bookings.bookingDate, endDateStr),
            eq(bookings.status, "completed")
          )).groupBy(bookings.bookingDate).orderBy(asc(bookings.bookingDate));
          const revenueData = dailyRevenue.map((day) => Number(day.revenue) || 0);
          const bookingData = dailyRevenue.map((day) => Number(day.bookingCount) || 0);
          const averageRevenue = revenueData.length > 0 ? revenueData.reduce((a, b) => a + b, 0) / revenueData.length : 0;
          const averageBookings = bookingData.length > 0 ? bookingData.reduce((a, b) => a + b, 0) / bookingData.length : 0;
          const revenueTrend = this.calculateLinearTrend(revenueData);
          const bookingTrend = this.calculateLinearTrend(bookingData);
          const peakRevenueDay = dailyRevenue.length > 0 ? dailyRevenue.reduce((max, day) => Number(day.revenue) > Number(max.revenue) ? day : max) : null;
          const peakBookingDay = dailyRevenue.length > 0 ? dailyRevenue.reduce((max, day) => Number(day.bookingCount) > Number(max.bookingCount) ? day : max) : null;
          const totalStaff = await db.select({ count: sql2`count(*)` }).from(staff).where(and(eq(staff.salonId, salonId), eq(staff.isActive, 1)));
          const staffCount = totalStaff[0]?.count || 0;
          const workingDaysInPeriod = dailyRevenue.length;
          const totalBookings = bookingData.reduce((a, b) => a + b, 0);
          const theoreticalCapacity = staffCount * workingDaysInPeriod * 8;
          const capacityUtilization = theoreticalCapacity > 0 ? totalBookings / theoreticalCapacity * 100 : 0;
          return {
            period,
            forecasting: {
              averageDailyRevenuePaisa: Math.round(averageRevenue),
              averageDailyBookings: Number(averageBookings.toFixed(1)),
              revenueTrendSlope: revenueTrend.slope,
              bookingTrendSlope: bookingTrend.slope,
              projectedNextPeriodRevenuePaisa: Math.round(averageRevenue * (1 + revenueTrend.slope / 100)),
              projectedNextPeriodBookings: Math.round(averageBookings * (1 + bookingTrend.slope / 100))
            },
            performance: {
              peakRevenueDay: peakRevenueDay ? {
                date: peakRevenueDay.date,
                revenuePaisa: Number(peakRevenueDay.revenue),
                bookings: Number(peakRevenueDay.bookingCount)
              } : null,
              peakBookingDay: peakBookingDay ? {
                date: peakBookingDay.date,
                revenuePaisa: Number(peakBookingDay.revenue),
                bookings: Number(peakBookingDay.bookingCount)
              } : null,
              capacityUtilization: Number(capacityUtilization.toFixed(1)),
              staffCount,
              workingDays: workingDaysInPeriod
            },
            trends: {
              dailyData: dailyRevenue.map((day) => ({
                date: day.date,
                revenuePaisa: Number(day.revenue) || 0,
                bookings: Number(day.bookingCount) || 0
              })),
              revenueGrowthRate: Number(revenueTrend.slope.toFixed(2)),
              bookingGrowthRate: Number(bookingTrend.slope.toFixed(2))
            }
          };
        } catch (error) {
          console.error("Error fetching business intelligence metrics:", error);
          throw error;
        }
      }
      // Cohort Analysis
      async getCohortAnalysis(salonId) {
        try {
          const customerCohorts = await db.select({
            customerEmail: bookings.customerEmail,
            firstBookingDate: sql2`min(${bookings.bookingDate})`,
            totalBookings: sql2`count(*)`
          }).from(bookings).where(eq(bookings.salonId, salonId)).groupBy(bookings.customerEmail);
          const cohortData = {};
          customerCohorts.forEach((customer) => {
            const cohortMonth = customer.firstBookingDate.substring(0, 7);
            if (!cohortData[cohortMonth]) {
              cohortData[cohortMonth] = {
                cohortSize: 0,
                customers: []
              };
            }
            cohortData[cohortMonth].cohortSize++;
            cohortData[cohortMonth].customers.push({
              email: customer.customerEmail,
              totalBookings: Number(customer.totalBookings)
            });
          });
          const cohortAnalysis = Object.entries(cohortData).map(([cohortMonth, data]) => {
            const returningCustomers = data.customers.filter((c) => c.totalBookings > 1).length;
            const loyalCustomers = data.customers.filter((c) => c.totalBookings >= 5).length;
            return {
              cohortMonth,
              cohortSize: data.cohortSize,
              returningCustomers,
              loyalCustomers,
              retentionRate: data.cohortSize > 0 ? Number((returningCustomers / data.cohortSize * 100).toFixed(1)) : 0,
              loyaltyRate: data.cohortSize > 0 ? Number((loyalCustomers / data.cohortSize * 100).toFixed(1)) : 0,
              averageBookingsPerCustomer: data.cohortSize > 0 ? Number((data.customers.reduce((sum4, c) => sum4 + c.totalBookings, 0) / data.cohortSize).toFixed(1)) : 0
            };
          }).sort((a, b) => b.cohortMonth.localeCompare(a.cohortMonth));
          return {
            cohorts: cohortAnalysis,
            summary: {
              totalCohorts: cohortAnalysis.length,
              averageRetentionRate: cohortAnalysis.length > 0 ? Number((cohortAnalysis.reduce((sum4, c) => sum4 + c.retentionRate, 0) / cohortAnalysis.length).toFixed(1)) : 0,
              averageLoyaltyRate: cohortAnalysis.length > 0 ? Number((cohortAnalysis.reduce((sum4, c) => sum4 + c.loyaltyRate, 0) / cohortAnalysis.length).toFixed(1)) : 0,
              bestPerformingCohort: cohortAnalysis.length > 0 ? cohortAnalysis.reduce((best, current) => current.retentionRate > best.retentionRate ? current : best) : null
            }
          };
        } catch (error) {
          console.error("Error fetching cohort analysis:", error);
          throw error;
        }
      }
      // Customer Segmentation
      async getCustomerSegmentation(salonId) {
        try {
          const customerData = await db.select({
            customerEmail: bookings.customerEmail,
            customerName: bookings.customerName,
            totalBookings: sql2`count(*)`,
            totalSpent: sql2`sum(${bookings.totalAmountPaisa})`,
            lastBookingDate: sql2`max(${bookings.bookingDate})`,
            firstBookingDate: sql2`min(${bookings.bookingDate})`
          }).from(bookings).where(eq(bookings.salonId, salonId)).groupBy(bookings.customerEmail, bookings.customerName);
          const now = /* @__PURE__ */ new Date();
          const segments = {
            champions: [],
            // High value, frequent, recent
            loyalCustomers: [],
            // High frequency, good monetary
            potentialLoyalists: [],
            // Recent customers with good frequency
            newCustomers: [],
            // Recent but low frequency
            promising: [],
            // Recent customers with potential
            needsAttention: [],
            // Good monetary but declining frequency
            aboutToSleep: [],
            // Low recency but good historical value
            atRisk: [],
            // Low recency and frequency but good monetary
            cannotLoseThem: [],
            // High monetary value but low recency
            hibernating: []
            // Low on all metrics
          };
          customerData.forEach((customer) => {
            const totalBookings = Number(customer.totalBookings);
            const totalSpent = Number(customer.totalSpent);
            const lastBookingDate = new Date(customer.lastBookingDate);
            const firstBookingDate = new Date(customer.firstBookingDate);
            const daysSinceLastBooking = Math.floor((now.getTime() - lastBookingDate.getTime()) / (1e3 * 60 * 60 * 24));
            const customerAge = Math.floor((now.getTime() - firstBookingDate.getTime()) / (1e3 * 60 * 60 * 24));
            const averageBookingValue = totalBookings > 0 ? totalSpent / totalBookings : 0;
            if (totalBookings >= 5 && daysSinceLastBooking <= 30 && totalSpent >= 5e5) {
              segments.champions.push(customer);
            } else if (totalBookings >= 3 && daysSinceLastBooking <= 60) {
              segments.loyalCustomers.push(customer);
            } else if (daysSinceLastBooking <= 30 && totalBookings >= 2) {
              segments.potentialLoyalists.push(customer);
            } else if (daysSinceLastBooking <= 30 && totalBookings === 1) {
              segments.newCustomers.push(customer);
            } else if (daysSinceLastBooking <= 60 && totalBookings >= 2) {
              segments.promising.push(customer);
            } else if (totalSpent >= 3e5 && daysSinceLastBooking <= 90) {
              segments.needsAttention.push(customer);
            } else if (totalSpent >= 2e5 && daysSinceLastBooking <= 120) {
              segments.aboutToSleep.push(customer);
            } else if (totalBookings >= 2 && daysSinceLastBooking <= 180) {
              segments.atRisk.push(customer);
            } else if (totalSpent >= 5e5) {
              segments.cannotLoseThem.push(customer);
            } else {
              segments.hibernating.push(customer);
            }
          });
          const segmentMetrics = Object.entries(segments).map(([segmentName, customers]) => ({
            segmentName,
            customerCount: customers.length,
            totalRevenuePaisa: customers.reduce((sum4, c) => sum4 + Number(c.totalSpent), 0),
            averageLifetimeValuePaisa: customers.length > 0 ? Math.round(customers.reduce((sum4, c) => sum4 + Number(c.totalSpent), 0) / customers.length) : 0,
            averageBookings: customers.length > 0 ? Number((customers.reduce((sum4, c) => sum4 + Number(c.totalBookings), 0) / customers.length).toFixed(1)) : 0,
            percentage: customerData.length > 0 ? Number((customers.length / customerData.length * 100).toFixed(1)) : 0
          }));
          return {
            segments: segmentMetrics.sort((a, b) => b.totalRevenuePaisa - a.totalRevenuePaisa),
            totalCustomers: customerData.length,
            insights: {
              highValueSegments: ["champions", "loyalCustomers", "cannotLoseThem"],
              atRiskSegments: ["aboutToSleep", "atRisk", "hibernating"],
              growthOpportunitySegments: ["potentialLoyalists", "promising", "newCustomers"]
            }
          };
        } catch (error) {
          console.error("Error fetching customer segmentation:", error);
          throw error;
        }
      }
      // Helper methods
      calculateDateRange(period) {
        const endDate = /* @__PURE__ */ new Date();
        const startDate = /* @__PURE__ */ new Date();
        const previousStartDate = /* @__PURE__ */ new Date();
        const previousEndDate = /* @__PURE__ */ new Date();
        switch (period) {
          case "daily":
          case "1d":
            startDate.setDate(endDate.getDate() - 1);
            previousStartDate.setDate(endDate.getDate() - 2);
            previousEndDate.setDate(endDate.getDate() - 1);
            break;
          case "weekly":
          case "week":
          case "7d":
            startDate.setDate(endDate.getDate() - 7);
            previousStartDate.setDate(endDate.getDate() - 14);
            previousEndDate.setDate(endDate.getDate() - 7);
            break;
          case "monthly":
          case "month":
          case "30d":
            startDate.setMonth(endDate.getMonth() - 1);
            previousStartDate.setMonth(endDate.getMonth() - 2);
            previousEndDate.setMonth(endDate.getMonth() - 1);
            break;
          case "quarterly":
          case "quarter":
          case "90d":
            startDate.setMonth(endDate.getMonth() - 3);
            previousStartDate.setMonth(endDate.getMonth() - 6);
            previousEndDate.setMonth(endDate.getMonth() - 3);
            break;
          case "yearly":
          case "year":
          case "1y":
            startDate.setFullYear(endDate.getFullYear() - 1);
            previousStartDate.setFullYear(endDate.getFullYear() - 2);
            previousEndDate.setFullYear(endDate.getFullYear() - 1);
            break;
          default:
            startDate.setMonth(endDate.getMonth() - 1);
            previousStartDate.setMonth(endDate.getMonth() - 2);
            previousEndDate.setMonth(endDate.getMonth() - 1);
        }
        return { startDate, endDate, previousStartDate, previousEndDate };
      }
      calculateTrendMetric(current, previous) {
        if (previous === 0) {
          return current > 0 ? { percentage: "100.0", direction: "up" } : { percentage: "0.0", direction: "neutral" };
        }
        const change = (current - previous) / previous * 100;
        return {
          percentage: Math.abs(change).toFixed(1),
          direction: change > 0 ? "up" : change < 0 ? "down" : "neutral"
        };
      }
      calculateLinearTrend(data) {
        if (data.length < 2) return { slope: 0, intercept: 0 };
        const n = data.length;
        const sumX = n * (n - 1) / 2;
        const sumY = data.reduce((a, b) => a + b, 0);
        const sumXY = data.reduce((sum4, y, x) => sum4 + x * y, 0);
        const sumXX = data.reduce((sum4, _, x) => sum4 + x * x, 0);
        const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
        const intercept = (sumY - slope * sumX) / n;
        return { slope: slope || 0, intercept: intercept || 0 };
      }
      // Payment operations
      async getPayment(id) {
        const [payment] = await db.select().from(payments).where(eq(payments.id, id));
        return payment || void 0;
      }
      async getPaymentByBookingId(bookingId) {
        const [payment] = await db.select().from(payments).where(eq(payments.bookingId, bookingId));
        return payment || void 0;
      }
      async getAllPayments() {
        return await db.select().from(payments);
      }
      async createPayment(payment) {
        const [newPayment] = await db.insert(payments).values(payment).returning();
        return newPayment;
      }
      async updatePaymentStatus(id, status, completedAt) {
        const updates = { status };
        if (completedAt) {
          updates.completedAt = completedAt;
        }
        await db.update(payments).set(updates).where(eq(payments.id, id));
      }
      async updatePaymentOrderId(id, razorpayOrderId) {
        await db.update(payments).set({ razorpayOrderId }).where(eq(payments.id, id));
      }
      async updatePaymentDetails(id, razorpayPaymentId, razorpaySignature) {
        await db.update(payments).set({
          razorpayPaymentId,
          razorpaySignature
        }).where(eq(payments.id, id));
      }
      async getPaymentByRazorpayOrderId(razorpayOrderId) {
        const [payment] = await db.select().from(payments).where(eq(payments.razorpayOrderId, razorpayOrderId));
        return payment || void 0;
      }
      // Staff operations
      async getStaff(id) {
        const [staffMember] = await db.select().from(staff).where(eq(staff.id, id));
        return staffMember || void 0;
      }
      async getStaffBySalonId(salonId) {
        return await db.select().from(staff).where(eq(staff.salonId, salonId));
      }
      async createStaff(staffData) {
        const [newStaff] = await db.insert(staff).values(staffData).returning();
        return newStaff;
      }
      async updateStaff(id, updates) {
        await db.update(staff).set(updates).where(eq(staff.id, id));
      }
      // Availability pattern operations
      async getAvailabilityPattern(id) {
        const [pattern] = await db.select().from(availabilityPatterns).where(eq(availabilityPatterns.id, id));
        return pattern || void 0;
      }
      async getAvailabilityPatternsBySalonId(salonId) {
        return await db.select().from(availabilityPatterns).where(eq(availabilityPatterns.salonId, salonId));
      }
      async getAvailabilityPatternsByStaffId(staffId) {
        return await db.select().from(availabilityPatterns).where(eq(availabilityPatterns.staffId, staffId));
      }
      async createAvailabilityPattern(pattern) {
        const [newPattern] = await db.insert(availabilityPatterns).values(pattern).returning();
        return newPattern;
      }
      async updateAvailabilityPattern(id, updates) {
        await db.update(availabilityPatterns).set(updates).where(eq(availabilityPatterns.id, id));
      }
      async deleteAvailabilityPattern(id) {
        await db.delete(availabilityPatterns).where(eq(availabilityPatterns.id, id));
      }
      // Time slot operations
      async getTimeSlot(id) {
        const [slot] = await db.select().from(timeSlots).where(eq(timeSlots.id, id));
        return slot || void 0;
      }
      async getTimeSlotsByDateRange(salonId, startDate, endDate) {
        return await db.select().from(timeSlots).where(and(
          eq(timeSlots.salonId, salonId),
          eq(timeSlots.startDateTime, new Date(startDate)),
          eq(timeSlots.endDateTime, new Date(endDate))
        ));
      }
      async getAvailableTimeSlots(salonId, date, staffId) {
        const conditions = [
          eq(timeSlots.salonId, salonId),
          eq(timeSlots.isBooked, 0),
          eq(timeSlots.isBlocked, 0)
        ];
        if (staffId) {
          conditions.push(eq(timeSlots.staffId, staffId));
        }
        if (date) {
          const startOfDay = /* @__PURE__ */ new Date(date + "T00:00:00.000Z");
          const endOfDay = /* @__PURE__ */ new Date(date + "T23:59:59.999Z");
          conditions.push(
            sql2`${timeSlots.startDateTime} >= ${startOfDay.toISOString()}`,
            sql2`${timeSlots.startDateTime} <= ${endOfDay.toISOString()}`
          );
        }
        return await db.select().from(timeSlots).where(and(...conditions));
      }
      async createTimeSlot(timeSlot) {
        const [newSlot] = await db.insert(timeSlots).values(timeSlot).returning();
        return newSlot;
      }
      async updateTimeSlot(id, updates) {
        await db.update(timeSlots).set(updates).where(eq(timeSlots.id, id));
      }
      async blockTimeSlot(id) {
        await db.update(timeSlots).set({ isBlocked: 1 }).where(eq(timeSlots.id, id));
      }
      async unblockTimeSlot(id) {
        await db.update(timeSlots).set({ isBlocked: 0 }).where(eq(timeSlots.id, id));
      }
      // Availability generation methods
      async generateTimeSlotsFromPattern(patternId, startDate, endDate) {
        const pattern = await this.getAvailabilityPattern(patternId);
        if (!pattern) {
          throw new Error("Availability pattern not found");
        }
        const slots = [];
        const currentDate = new Date(startDate);
        while (currentDate <= endDate) {
          if (currentDate.getDay() === pattern.dayOfWeek) {
            const [startHour, startMinute] = pattern.startTime.split(":").map(Number);
            const [endHour, endMinute] = pattern.endTime.split(":").map(Number);
            let slotStart = new Date(currentDate);
            slotStart.setHours(startHour, startMinute, 0, 0);
            const dayEnd = new Date(currentDate);
            dayEnd.setHours(endHour, endMinute, 0, 0);
            while (slotStart < dayEnd) {
              const slotEnd = new Date(slotStart.getTime() + pattern.slotDurationMinutes * 6e4);
              if (slotEnd <= dayEnd) {
                slots.push({
                  patternId: pattern.id,
                  salonId: pattern.salonId,
                  staffId: pattern.staffId,
                  startDateTime: new Date(slotStart),
                  endDateTime: new Date(slotEnd),
                  isBooked: 0,
                  isBlocked: 0
                });
              }
              slotStart = new Date(slotEnd);
            }
          }
          currentDate.setDate(currentDate.getDate() + 1);
        }
        if (slots.length > 0) {
          return await db.insert(timeSlots).values(slots).returning();
        }
        return [];
      }
      async regenerateTimeSlotsForSalon(salonId, startDate, endDate) {
        await db.delete(timeSlots).where(and(
          eq(timeSlots.salonId, salonId),
          eq(timeSlots.isBooked, 0)
          // Only delete unbooked slots
        ));
        const patterns = await this.getAvailabilityPatternsBySalonId(salonId);
        const activePatterns = patterns.filter((p) => p.isActive === 1);
        for (const pattern of activePatterns) {
          await this.generateTimeSlotsFromPattern(pattern.id, startDate, endDate);
        }
      }
      // Email verification operations
      async createVerificationToken(email, userId) {
        const token = randomUUID();
        const expiresAt = /* @__PURE__ */ new Date();
        expiresAt.setHours(expiresAt.getHours() + 24);
        await db.insert(emailVerificationTokens).values({
          email,
          token,
          userId,
          expiresAt
        });
        return token;
      }
      async verifyEmailToken(token) {
        const [verificationToken] = await db.select().from(emailVerificationTokens).where(and(
          eq(emailVerificationTokens.token, token),
          isNull(emailVerificationTokens.verifiedAt)
          // Not already verified
        ));
        if (!verificationToken) {
          return { success: false };
        }
        if (/* @__PURE__ */ new Date() > verificationToken.expiresAt) {
          return { success: false };
        }
        await db.update(emailVerificationTokens).set({ verifiedAt: /* @__PURE__ */ new Date() }).where(eq(emailVerificationTokens.token, token));
        return {
          success: true,
          email: verificationToken.email,
          userId: verificationToken.userId || void 0
        };
      }
      async markEmailAsVerified(userId) {
        await db.update(users).set({
          emailVerified: 1,
          emailVerificationToken: null,
          emailVerificationExpiry: null
        }).where(eq(users.id, userId));
      }
      async saveEmailVerificationToken(userId, token, expiry) {
        await db.update(users).set({
          emailVerificationToken: token,
          emailVerificationExpiry: expiry,
          emailVerificationSentAt: /* @__PURE__ */ new Date()
        }).where(eq(users.id, userId));
      }
      async getUserByEmailVerificationToken(token) {
        const [user] = await db.select().from(users).where(eq(users.emailVerificationToken, token)).limit(1);
        return user || void 0;
      }
      async getUnverifiedUsers(hoursSinceRegistration = 24) {
        const cutoffDate = /* @__PURE__ */ new Date();
        cutoffDate.setHours(cutoffDate.getHours() - hoursSinceRegistration);
        const unverifiedUsers = await db.select().from(users).where(and(
          eq(users.emailVerified, 0),
          isNotNull(users.email),
          lt(users.createdAt, cutoffDate)
        ));
        return unverifiedUsers;
      }
      async clearEmailVerificationToken(userId) {
        await db.update(users).set({
          emailVerificationToken: null,
          emailVerificationExpiry: null
        }).where(eq(users.id, userId));
      }
      // Password reset operations
      async savePasswordResetToken(userId, token, expiry) {
        await db.update(users).set({
          passwordResetToken: token,
          passwordResetExpiry: expiry
        }).where(eq(users.id, userId));
      }
      async getUserByPasswordResetToken(token) {
        const [user] = await db.select().from(users).where(eq(users.passwordResetToken, token)).limit(1);
        return user || void 0;
      }
      async clearPasswordResetToken(userId) {
        await db.update(users).set({
          passwordResetToken: null,
          passwordResetExpiry: null
        }).where(eq(users.id, userId));
      }
      async updateUserPassword(userId, hashedPassword) {
        await db.update(users).set({ password: hashedPassword }).where(eq(users.id, userId));
      }
      // Business Profile Setup Implementation
      // Booking settings operations
      async getBookingSettings(salonId) {
        const [settings] = await db.select().from(bookingSettings).where(eq(bookingSettings.salonId, salonId));
        return settings || void 0;
      }
      async createBookingSettings(settings) {
        const [newSettings] = await db.insert(bookingSettings).values(settings).returning();
        return newSettings;
      }
      async updateBookingSettings(salonId, updates) {
        await db.update(bookingSettings).set(updates).where(eq(bookingSettings.salonId, salonId));
      }
      // Staff-service operations
      async getStaffService(staffId, serviceId) {
        const [staffService] = await db.select().from(staffServices).where(
          and(eq(staffServices.staffId, staffId), eq(staffServices.serviceId, serviceId))
        );
        return staffService || void 0;
      }
      async getStaffServicesBySalonId(salonId) {
        return await db.select().from(staffServices).where(eq(staffServices.salonId, salonId));
      }
      async getStaffServicesByStaffId(staffId) {
        return await db.select().from(staffServices).where(eq(staffServices.staffId, staffId));
      }
      async getStaffServicesByServiceId(serviceId) {
        return await db.select().from(staffServices).where(eq(staffServices.serviceId, serviceId));
      }
      async createStaffService(staffService) {
        const [newStaffService] = await db.insert(staffServices).values(staffService).returning();
        return newStaffService;
      }
      async updateStaffService(staffId, serviceId, updates) {
        await db.update(staffServices).set(updates).where(
          and(eq(staffServices.staffId, staffId), eq(staffServices.serviceId, serviceId))
        );
      }
      async deleteStaffService(staffId, serviceId) {
        await db.delete(staffServices).where(
          and(eq(staffServices.staffId, staffId), eq(staffServices.serviceId, serviceId))
        );
      }
      // Resource operations
      async getResource(id) {
        const [resource] = await db.select().from(resources).where(eq(resources.id, id));
        return resource || void 0;
      }
      async getResourcesBySalonId(salonId) {
        return await db.select().from(resources).where(and(
          eq(resources.salonId, salonId),
          eq(resources.isActive, 1)
        ));
      }
      async createResource(resource) {
        const [newResource] = await db.insert(resources).values(resource).returning();
        return newResource;
      }
      async updateResource(id, salonId, updates) {
        await db.update(resources).set(updates).where(and(eq(resources.id, id), eq(resources.salonId, salonId)));
      }
      async deleteResource(id, salonId) {
        await db.update(resources).set({ isActive: 0 }).where(and(eq(resources.id, id), eq(resources.salonId, salonId)));
      }
      // Service-resource operations
      async getServiceResource(serviceId, resourceId) {
        const [serviceResource] = await db.select().from(serviceResources).where(
          and(eq(serviceResources.serviceId, serviceId), eq(serviceResources.resourceId, resourceId))
        );
        return serviceResource || void 0;
      }
      async getServiceResourcesBySalonId(salonId) {
        return await db.select().from(serviceResources).where(eq(serviceResources.salonId, salonId));
      }
      async getServiceResourcesByServiceId(serviceId) {
        return await db.select().from(serviceResources).where(eq(serviceResources.serviceId, serviceId));
      }
      async getServiceResourcesByResourceId(resourceId) {
        return await db.select().from(serviceResources).where(eq(serviceResources.resourceId, resourceId));
      }
      async createServiceResource(serviceResource) {
        const [newServiceResource] = await db.insert(serviceResources).values(serviceResource).returning();
        return newServiceResource;
      }
      async updateServiceResource(serviceId, resourceId, updates) {
        await db.update(serviceResources).set(updates).where(
          and(eq(serviceResources.serviceId, serviceId), eq(serviceResources.resourceId, resourceId))
        );
      }
      async deleteServiceResource(serviceId, resourceId) {
        await db.delete(serviceResources).where(
          and(eq(serviceResources.serviceId, serviceId), eq(serviceResources.resourceId, resourceId))
        );
      }
      // Media asset operations
      async getMediaAsset(id) {
        const [asset] = await db.select().from(mediaAssets).where(eq(mediaAssets.id, id));
        return asset || void 0;
      }
      async getMediaAssetsBySalonId(salonId) {
        const result = await db.select().from(mediaAssets).where(eq(mediaAssets.salonId, salonId));
        return result || [];
      }
      async getMediaAssetsByType(salonId, assetType) {
        const result = await db.select().from(mediaAssets).where(
          and(eq(mediaAssets.salonId, salonId), eq(mediaAssets.assetType, assetType))
        );
        return result || [];
      }
      async createMediaAsset(asset) {
        const [newAsset] = await db.insert(mediaAssets).values(asset).returning();
        return newAsset;
      }
      async updateMediaAsset(id, salonId, updates) {
        await db.update(mediaAssets).set(updates).where(and(eq(mediaAssets.id, id), eq(mediaAssets.salonId, salonId)));
      }
      async setPrimaryMediaAsset(salonId, assetId) {
        return await db.transaction(async (tx) => {
          await tx.update(mediaAssets).set({ isPrimary: 0 }).where(eq(mediaAssets.salonId, salonId));
          await tx.update(mediaAssets).set({ isPrimary: 1 }).where(
            and(eq(mediaAssets.id, assetId), eq(mediaAssets.salonId, salonId))
          );
          const [updatedAsset] = await tx.select().from(mediaAssets).where(
            and(eq(mediaAssets.id, assetId), eq(mediaAssets.salonId, salonId))
          );
          if (!updatedAsset) {
            throw new Error("Media asset not found");
          }
          return updatedAsset;
        });
      }
      async deleteMediaAsset(id, salonId) {
        await db.delete(mediaAssets).where(and(eq(mediaAssets.id, id), eq(mediaAssets.salonId, salonId)));
      }
      // Tax rate operations
      async getTaxRate(id) {
        const [taxRate] = await db.select().from(taxRates).where(eq(taxRates.id, id));
        return taxRate || void 0;
      }
      async getTaxRatesBySalonId(salonId) {
        return await db.select().from(taxRates).where(and(
          eq(taxRates.salonId, salonId),
          eq(taxRates.isActive, 1)
        ));
      }
      async getDefaultTaxRate(salonId) {
        const [defaultTax] = await db.select().from(taxRates).where(
          and(eq(taxRates.salonId, salonId), eq(taxRates.isDefault, 1), eq(taxRates.isActive, 1))
        );
        return defaultTax || void 0;
      }
      async createTaxRate(taxRate) {
        const [newTaxRate] = await db.insert(taxRates).values(taxRate).returning();
        return newTaxRate;
      }
      async updateTaxRate(id, salonId, updates) {
        await db.update(taxRates).set(updates).where(and(eq(taxRates.id, id), eq(taxRates.salonId, salonId)));
      }
      async setDefaultTaxRate(salonId, taxRateId) {
        await db.transaction(async (tx) => {
          await tx.update(taxRates).set({ isDefault: 0 }).where(eq(taxRates.salonId, salonId));
          await tx.update(taxRates).set({ isDefault: 1 }).where(
            and(eq(taxRates.id, taxRateId), eq(taxRates.salonId, salonId))
          );
        });
      }
      async deleteTaxRate(id, salonId) {
        await db.update(taxRates).set({ isActive: 0 }).where(and(eq(taxRates.id, id), eq(taxRates.salonId, salonId)));
      }
      // Payout account operations
      async getPayoutAccount(id) {
        const [account] = await db.select().from(payoutAccounts).where(eq(payoutAccounts.id, id));
        return account || void 0;
      }
      async getPayoutAccountsBySalonId(salonId) {
        return await db.select().from(payoutAccounts).where(and(
          eq(payoutAccounts.salonId, salonId),
          eq(payoutAccounts.isActive, 1)
        ));
      }
      async getDefaultPayoutAccount(salonId) {
        const [defaultAccount] = await db.select().from(payoutAccounts).where(
          and(eq(payoutAccounts.salonId, salonId), eq(payoutAccounts.isDefault, 1), eq(payoutAccounts.isActive, 1))
        );
        return defaultAccount || void 0;
      }
      async createPayoutAccount(account) {
        const [newAccount] = await db.insert(payoutAccounts).values(account).returning();
        return newAccount;
      }
      async updatePayoutAccount(id, salonId, updates) {
        await db.update(payoutAccounts).set(updates).where(and(eq(payoutAccounts.id, id), eq(payoutAccounts.salonId, salonId)));
      }
      async setDefaultPayoutAccount(salonId, accountId) {
        await db.transaction(async (tx) => {
          await tx.update(payoutAccounts).set({ isDefault: 0 }).where(eq(payoutAccounts.salonId, salonId));
          await tx.update(payoutAccounts).set({ isDefault: 1 }).where(
            and(eq(payoutAccounts.id, accountId), eq(payoutAccounts.salonId, salonId))
          );
        });
      }
      async deletePayoutAccount(id, salonId) {
        await db.update(payoutAccounts).set({ isActive: 0 }).where(and(eq(payoutAccounts.id, id), eq(payoutAccounts.salonId, salonId)));
      }
      // Publish state operations
      async getPublishState(salonId) {
        const [state] = await db.select().from(publishState).where(eq(publishState.salonId, salonId));
        return state || void 0;
      }
      async createPublishState(state) {
        const [newState] = await db.insert(publishState).values(state).returning();
        return newState;
      }
      async updatePublishState(salonId, updates) {
        await db.update(publishState).set(updates).where(eq(publishState.salonId, salonId));
      }
      async checkBusinessReadiness(salonId) {
        const missingRequirements = [];
        const salon = await this.getSalon(salonId);
        if (!salon || !salon.name || !salon.address || !salon.phone) {
          missingRequirements.push("Complete salon basic information");
        }
        const services6 = await this.getServicesBySalonId(salonId);
        if (services6.length === 0) {
          missingRequirements.push("Add at least one service");
        }
        const staff5 = await this.getStaffBySalonId(salonId);
        if (staff5.length === 0) {
          missingRequirements.push("Add at least one staff member");
        }
        const bookingSettings2 = await this.getBookingSettings(salonId);
        if (!bookingSettings2) {
          missingRequirements.push("Configure booking settings");
        }
        const taxRates2 = await this.getTaxRatesBySalonId(salonId);
        if (taxRates2.length === 0) {
          missingRequirements.push("Configure tax rates");
        }
        const defaultPayoutAccount = await this.getDefaultPayoutAccount(salonId);
        if (!defaultPayoutAccount) {
          missingRequirements.push("Configure payout account");
        }
        return {
          isReady: missingRequirements.length === 0,
          missingRequirements
        };
      }
      async checkDashboardCompletion(salonId) {
        const salon = await this.getSalon(salonId);
        const services6 = await this.getServicesBySalonId(salonId);
        const staff5 = await this.getStaffBySalonId(salonId);
        const bookingSettings2 = await this.getBookingSettings(salonId);
        const mediaAssets2 = await this.getMediaAssetsBySalonId(salonId);
        const profileMissingFields = [];
        if (!salon?.name) profileMissingFields.push("name");
        if (!salon?.category) profileMissingFields.push("category");
        if (!salon?.address) profileMissingFields.push("address");
        if (!salon?.city) profileMissingFields.push("city");
        if (!salon?.state) profileMissingFields.push("state");
        if (!salon?.zipCode) profileMissingFields.push("zipCode");
        if (!salon?.phone) profileMissingFields.push("phone");
        if (!salon?.email) profileMissingFields.push("email");
        if (!salon?.latitude) profileMissingFields.push("latitude");
        if (!salon?.longitude) profileMissingFields.push("longitude");
        const profileComplete = profileMissingFields.length === 0;
        const servicesComplete = services6.length > 0;
        const staffComplete = staff5.length > 0;
        const settingsComplete = !!bookingSettings2;
        const mediaComplete = mediaAssets2.length > 0;
        const completedSections = [
          profileComplete,
          servicesComplete,
          staffComplete,
          settingsComplete,
          mediaComplete
        ].filter(Boolean).length;
        const overallProgress = Math.round(completedSections / 5 * 100);
        let nextStep;
        if (!profileComplete) {
          nextStep = "business-info";
        } else if (!servicesComplete) {
          nextStep = "services";
        } else if (!staffComplete) {
          nextStep = "staff";
        } else if (!settingsComplete) {
          nextStep = "booking-settings";
        } else if (!mediaComplete) {
          nextStep = "media";
        }
        return {
          profile: {
            isComplete: profileComplete,
            missingFields: profileComplete ? void 0 : profileMissingFields
          },
          services: {
            isComplete: servicesComplete,
            count: services6.length
          },
          staff: {
            isComplete: staffComplete,
            count: staff5.length
          },
          settings: {
            isComplete: settingsComplete
          },
          media: {
            isComplete: mediaComplete,
            count: mediaAssets2.length
          },
          overallProgress,
          nextStep
        };
      }
      // Customer Profile Operations
      async getCustomerProfile(salonId, customerEmail) {
        try {
          const [profile] = await db.select().from(customerProfiles).where(and(
            eq(customerProfiles.salonId, salonId),
            eq(customerProfiles.customerEmail, customerEmail)
          ));
          return profile || void 0;
        } catch (error) {
          console.error("Error fetching customer profile:", error);
          throw error;
        }
      }
      async getOrCreateCustomerProfile(salonId, customerEmail) {
        try {
          const existingProfile = await this.getCustomerProfile(salonId, customerEmail);
          if (existingProfile) {
            return existingProfile;
          }
          const [customerBooking] = await db.select({
            customerName: bookings.customerName,
            customerPhone: bookings.customerPhone,
            customerEmail: bookings.customerEmail
          }).from(bookings).where(and(
            eq(bookings.salonId, salonId),
            eq(bookings.customerEmail, customerEmail)
          )).orderBy(desc(bookings.createdAt)).limit(1);
          if (!customerBooking) {
            return void 0;
          }
          try {
            const [created] = await db.insert(customerProfiles).values({
              salonId,
              customerEmail,
              customerName: customerBooking.customerName,
              customerPhone: customerBooking.customerPhone,
              notes: "",
              preferences: {},
              isVip: 0,
              tags: []
            }).onConflictDoNothing().returning();
            if (!created) {
              return await this.getCustomerProfile(salonId, customerEmail);
            }
            return created;
          } catch (error) {
            console.warn("Profile creation conflict, fetching existing profile:", error);
            return await this.getCustomerProfile(salonId, customerEmail);
          }
        } catch (error) {
          console.error("Error getting or creating customer profile:", error);
          throw error;
        }
      }
      async getCustomerProfileById(id) {
        try {
          const [profile] = await db.select().from(customerProfiles).where(eq(customerProfiles.id, id));
          return profile || void 0;
        } catch (error) {
          console.error("Error fetching customer profile by ID:", error);
          throw error;
        }
      }
      async createCustomerProfile(profile) {
        try {
          const [created] = await db.insert(customerProfiles).values(profile).returning();
          return created;
        } catch (error) {
          console.error("Error creating customer profile:", error);
          throw error;
        }
      }
      async updateCustomerProfile(id, salonId, updates) {
        try {
          const updateData = {
            ...updates,
            updatedAt: /* @__PURE__ */ new Date()
          };
          if (updates.isVip !== void 0) {
            updateData.isVip = updates.isVip ? 1 : 0;
          }
          await db.update(customerProfiles).set(updateData).where(and(
            eq(customerProfiles.id, id),
            eq(customerProfiles.salonId, salonId)
          ));
        } catch (error) {
          console.error("Error updating customer profile:", error);
          throw error;
        }
      }
      async getCustomerBookingHistory(salonId, customerEmail) {
        try {
          const bookingHistory = await db.select({
            id: bookings.id,
            serviceId: bookings.serviceId,
            bookingDate: bookings.bookingDate,
            bookingTime: bookings.bookingTime,
            status: bookings.status,
            totalAmountPaisa: bookings.totalAmountPaisa,
            currency: bookings.currency,
            notes: bookings.notes,
            createdAt: bookings.createdAt,
            serviceName: services.name,
            serviceDuration: services.durationMinutes,
            staffName: staff.name
          }).from(bookings).leftJoin(services, eq(bookings.serviceId, services.id)).leftJoin(staff, eq(bookings.staffId, staff.id)).where(and(
            eq(bookings.salonId, salonId),
            eq(bookings.customerEmail, customerEmail)
          )).orderBy(desc(bookings.createdAt));
          return bookingHistory;
        } catch (error) {
          console.error("Error fetching customer booking history:", error);
          throw error;
        }
      }
      async getCustomerStats(salonId, customerEmail) {
        try {
          const [stats] = await db.select({
            totalBookings: sql2`count(*)`,
            totalSpent: sql2`sum(${bookings.totalAmountPaisa})`,
            lastVisit: sql2`max(${bookings.bookingDate})`
          }).from(bookings).where(and(
            eq(bookings.salonId, salonId),
            eq(bookings.customerEmail, customerEmail)
          ));
          const favoriteServices = await db.select({
            serviceId: bookings.serviceId,
            serviceName: services.name,
            count: sql2`count(*)`
          }).from(bookings).leftJoin(services, eq(bookings.serviceId, services.id)).where(and(
            eq(bookings.salonId, salonId),
            eq(bookings.customerEmail, customerEmail)
          )).groupBy(bookings.serviceId, services.name).orderBy(desc(sql2`count(*)`));
          const totalBookings = Number(stats?.totalBookings) || 0;
          const totalSpent = Number(stats?.totalSpent) || 0;
          const averageSpend = totalBookings > 0 ? totalSpent / totalBookings : 0;
          let bookingFrequency = "New Customer";
          if (totalBookings >= 10) {
            bookingFrequency = "Frequent";
          } else if (totalBookings >= 5) {
            bookingFrequency = "Regular";
          } else if (totalBookings >= 2) {
            bookingFrequency = "Returning";
          }
          return {
            totalBookings,
            totalSpent,
            lastVisit: stats?.lastVisit || null,
            favoriteServices: favoriteServices.map((f) => ({
              serviceId: f.serviceId,
              serviceName: f.serviceName || "Unknown Service",
              count: f.count
            })),
            averageSpend,
            bookingFrequency
          };
        } catch (error) {
          console.error("Error fetching customer stats:", error);
          throw error;
        }
      }
      // ===============================================
      // FINANCIAL REPORTING SYSTEM IMPLEMENTATIONS
      // ===============================================
      // Expense category operations
      async getExpenseCategory(id) {
        const [category] = await db.select().from(expenseCategories).where(eq(expenseCategories.id, id));
        return category || void 0;
      }
      async getExpenseCategoriesBySalonId(salonId) {
        return await db.select().from(expenseCategories).where(and(eq(expenseCategories.salonId, salonId), eq(expenseCategories.isActive, 1))).orderBy(asc(expenseCategories.name));
      }
      async createExpenseCategory(category) {
        const [newCategory] = await db.insert(expenseCategories).values(category).returning();
        return newCategory;
      }
      async updateExpenseCategory(id, salonId, updates) {
        await db.update(expenseCategories).set(updates).where(and(eq(expenseCategories.id, id), eq(expenseCategories.salonId, salonId)));
      }
      async deleteExpenseCategory(id, salonId) {
        await db.update(expenseCategories).set({ isActive: 0 }).where(and(eq(expenseCategories.id, id), eq(expenseCategories.salonId, salonId)));
      }
      async createDefaultExpenseCategories(salonId) {
        const defaultCategories = [
          { salonId, name: "Supplies", description: "Hair products, nail polish, tools", color: "#8B5CF6", isDefault: 1 },
          { salonId, name: "Utilities", description: "Electricity, water, internet", color: "#3B82F6", isDefault: 1 },
          { salonId, name: "Rent", description: "Office and salon space rental", color: "#EF4444", isDefault: 1 },
          { salonId, name: "Marketing", description: "Advertising and promotional expenses", color: "#F59E0B", isDefault: 1 },
          { salonId, name: "Equipment", description: "Salon equipment and maintenance", color: "#10B981", isDefault: 1 },
          { salonId, name: "Staff Costs", description: "Training, uniforms, benefits", color: "#F97316", isDefault: 1 },
          { salonId, name: "Professional Services", description: "Legal, accounting, consulting", color: "#6366F1", isDefault: 1 },
          { salonId, name: "Insurance", description: "Business and liability insurance", color: "#8B5A2B", isDefault: 1 }
        ];
        return await db.insert(expenseCategories).values(defaultCategories).returning();
      }
      // Expense operations
      async getExpense(id) {
        const [expense] = await db.select().from(expenses).where(eq(expenses.id, id));
        return expense || void 0;
      }
      async getExpensesBySalonId(salonId, filters) {
        const conditions = [eq(expenses.salonId, salonId)];
        if (filters?.categoryId) {
          conditions.push(eq(expenses.categoryId, filters.categoryId));
        }
        if (filters?.status) {
          conditions.push(eq(expenses.status, filters.status));
        }
        if (filters?.startDate) {
          conditions.push(gte(expenses.expenseDate, new Date(filters.startDate)));
        }
        if (filters?.endDate) {
          conditions.push(lte(expenses.expenseDate, new Date(filters.endDate)));
        }
        if (filters?.createdBy) {
          conditions.push(eq(expenses.createdBy, filters.createdBy));
        }
        return await db.select().from(expenses).where(and(...conditions)).orderBy(desc(expenses.expenseDate));
      }
      async createExpense(expense) {
        const [newExpense] = await db.insert(expenses).values(expense).returning();
        return newExpense;
      }
      async updateExpense(id, salonId, updates) {
        await db.update(expenses).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(and(eq(expenses.id, id), eq(expenses.salonId, salonId)));
      }
      async approveExpense(id, approvedBy) {
        await db.update(expenses).set({
          status: "approved",
          approvedBy,
          approvedAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq(expenses.id, id));
      }
      async rejectExpense(id, approvedBy) {
        await db.update(expenses).set({
          status: "rejected",
          approvedBy,
          approvedAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq(expenses.id, id));
      }
      async deleteExpense(id, salonId) {
        await db.delete(expenses).where(and(eq(expenses.id, id), eq(expenses.salonId, salonId)));
      }
      async getExpensesByCategory(salonId, categoryId, period) {
        const conditions = [eq(expenses.salonId, salonId), eq(expenses.categoryId, categoryId)];
        if (period) {
          const now = /* @__PURE__ */ new Date();
          const startDate = /* @__PURE__ */ new Date();
          switch (period) {
            case "monthly":
              startDate.setMonth(now.getMonth() - 1);
              break;
            case "quarterly":
              startDate.setMonth(now.getMonth() - 3);
              break;
            case "yearly":
              startDate.setFullYear(now.getFullYear() - 1);
              break;
          }
          conditions.push(gte(expenses.expenseDate, startDate));
        }
        return await db.select().from(expenses).where(and(...conditions)).orderBy(desc(expenses.expenseDate));
      }
      async getExpenseAnalytics(salonId, period) {
        const now = /* @__PURE__ */ new Date();
        const startDate = /* @__PURE__ */ new Date();
        switch (period) {
          case "monthly":
            startDate.setMonth(now.getMonth() - 1);
            break;
          case "quarterly":
            startDate.setMonth(now.getMonth() - 3);
            break;
          case "yearly":
            startDate.setFullYear(now.getFullYear() - 1);
            break;
        }
        const totalResult = await db.select({
          total: sql2`COALESCE(SUM(${expenses.amountPaisa}), 0)`
        }).from(expenses).where(and(
          eq(expenses.salonId, salonId),
          eq(expenses.status, "approved"),
          gte(expenses.expenseDate, startDate)
        ));
        const totalExpenses = totalResult[0]?.total || 0;
        const categoryResults = await db.select({
          categoryId: expenses.categoryId,
          categoryName: expenseCategories.name,
          amount: sql2`COALESCE(SUM(${expenses.amountPaisa}), 0)`
        }).from(expenses).innerJoin(expenseCategories, eq(expenses.categoryId, expenseCategories.id)).where(and(
          eq(expenses.salonId, salonId),
          eq(expenses.status, "approved"),
          gte(expenses.expenseDate, startDate)
        )).groupBy(expenses.categoryId, expenseCategories.name);
        const expensesByCategory = categoryResults.map((cat) => ({
          ...cat,
          percentage: totalExpenses > 0 ? cat.amount / totalExpenses * 100 : 0
        }));
        const monthlyResults = await db.select({
          month: sql2`TO_CHAR(${expenses.expenseDate}, 'YYYY-MM')`,
          amount: sql2`COALESCE(SUM(${expenses.amountPaisa}), 0)`
        }).from(expenses).where(and(
          eq(expenses.salonId, salonId),
          eq(expenses.status, "approved"),
          gte(expenses.expenseDate, new Date(now.getFullYear() - 1, now.getMonth(), 1))
        )).groupBy(sql2`TO_CHAR(${expenses.expenseDate}, 'YYYY-MM')`).orderBy(sql2`TO_CHAR(${expenses.expenseDate}, 'YYYY-MM')`);
        const vendorResults = await db.select({
          vendor: expenses.vendor,
          amount: sql2`COALESCE(SUM(${expenses.amountPaisa}), 0)`,
          count: sql2`COUNT(*)`
        }).from(expenses).where(and(
          eq(expenses.salonId, salonId),
          eq(expenses.status, "approved"),
          gte(expenses.expenseDate, startDate),
          sql2`${expenses.vendor} IS NOT NULL AND ${expenses.vendor} != ''`
        )).groupBy(expenses.vendor).orderBy(sql2`SUM(${expenses.amountPaisa}) DESC`).limit(5);
        const pendingResult = await db.select({
          count: sql2`COUNT(*)`
        }).from(expenses).where(and(eq(expenses.salonId, salonId), eq(expenses.status, "pending")));
        const taxDeductibleResult = await db.select({
          total: sql2`COALESCE(SUM(${expenses.amountPaisa}), 0)`
        }).from(expenses).where(and(
          eq(expenses.salonId, salonId),
          eq(expenses.status, "approved"),
          eq(expenses.taxDeductible, 1),
          gte(expenses.expenseDate, startDate)
        ));
        return {
          totalExpenses,
          expensesByCategory,
          monthlyTrend: monthlyResults,
          topVendors: vendorResults.map((v) => ({ vendor: v.vendor, amount: v.amount, count: v.count })),
          pendingApprovals: pendingResult[0]?.count || 0,
          taxDeductibleAmount: taxDeductibleResult[0]?.total || 0
        };
      }
      // Commission rate operations
      async getCommissionRate(id) {
        const [rate] = await db.select().from(commissionRates).where(eq(commissionRates.id, id));
        return rate || void 0;
      }
      async getCommissionRatesBySalonId(salonId) {
        return await db.select().from(commissionRates).where(and(eq(commissionRates.salonId, salonId), eq(commissionRates.isActive, 1))).orderBy(desc(commissionRates.effectiveFrom));
      }
      async getCommissionRatesByStaffId(staffId) {
        return await db.select().from(commissionRates).where(and(eq(commissionRates.staffId, staffId), eq(commissionRates.isActive, 1))).orderBy(desc(commissionRates.effectiveFrom));
      }
      async getActiveCommissionRate(salonId, staffId, serviceId) {
        const now = /* @__PURE__ */ new Date();
        const conditions = [
          eq(commissionRates.salonId, salonId),
          eq(commissionRates.isActive, 1),
          lte(commissionRates.effectiveFrom, now),
          sql2`(${commissionRates.effectiveTo} IS NULL OR ${commissionRates.effectiveTo} >= ${now})`
        ];
        if (staffId) {
          conditions.push(eq(commissionRates.staffId, staffId));
        }
        if (serviceId) {
          conditions.push(eq(commissionRates.serviceId, serviceId));
        }
        const rates = await db.select().from(commissionRates).where(and(...conditions)).orderBy(desc(commissionRates.effectiveFrom)).limit(1);
        return rates[0] || void 0;
      }
      async createCommissionRate(rate) {
        const [newRate] = await db.insert(commissionRates).values(rate).returning();
        return newRate;
      }
      async updateCommissionRate(id, salonId, updates) {
        await db.update(commissionRates).set(updates).where(and(eq(commissionRates.id, id), eq(commissionRates.salonId, salonId)));
      }
      async deactivateCommissionRate(id) {
        await db.update(commissionRates).set({ isActive: 0, effectiveTo: /* @__PURE__ */ new Date() }).where(eq(commissionRates.id, id));
      }
      // Commission operations
      async getCommission(id) {
        const [commission] = await db.select().from(commissions).where(eq(commissions.id, id));
        return commission || void 0;
      }
      async getCommissionsBySalonId(salonId, filters) {
        const conditions = [eq(commissions.salonId, salonId)];
        if (filters?.staffId) {
          conditions.push(eq(commissions.staffId, filters.staffId));
        }
        if (filters?.paymentStatus) {
          conditions.push(eq(commissions.paymentStatus, filters.paymentStatus));
        }
        if (filters?.startDate) {
          conditions.push(gte(commissions.serviceDate, new Date(filters.startDate)));
        }
        if (filters?.endDate) {
          conditions.push(lte(commissions.serviceDate, new Date(filters.endDate)));
        }
        return await db.select().from(commissions).where(and(...conditions)).orderBy(desc(commissions.serviceDate));
      }
      async getCommissionsByStaffId(staffId, period) {
        const conditions = [eq(commissions.staffId, staffId)];
        if (period) {
          const now = /* @__PURE__ */ new Date();
          const startDate = /* @__PURE__ */ new Date();
          switch (period) {
            case "monthly":
              startDate.setMonth(now.getMonth() - 1);
              break;
            case "quarterly":
              startDate.setMonth(now.getMonth() - 3);
              break;
            case "yearly":
              startDate.setFullYear(now.getFullYear() - 1);
              break;
          }
          conditions.push(gte(commissions.serviceDate, startDate));
        }
        return await db.select().from(commissions).where(and(...conditions)).orderBy(desc(commissions.serviceDate));
      }
      async createCommission(commission) {
        const [newCommission] = await db.insert(commissions).values(commission).returning();
        return newCommission;
      }
      async updateCommission(id, salonId, updates) {
        await db.update(commissions).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(and(eq(commissions.id, id), eq(commissions.salonId, salonId)));
      }
      async payCommissions(commissionIds, paidBy, paymentMethod, paymentReference) {
        const result = await db.update(commissions).set({
          paymentStatus: "paid",
          paidAt: /* @__PURE__ */ new Date(),
          paidBy,
          paymentMethod,
          paymentReference,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(inArray(commissions.id, commissionIds));
        return result.rowCount || 0;
      }
      async calculateCommissionForBooking(bookingId) {
        const booking = await db.select({
          id: bookings.id,
          salonId: bookings.salonId,
          serviceId: bookings.serviceId,
          staffId: bookings.staffId,
          bookingDate: bookings.bookingDate,
          servicePrice: services.priceInPaisa
        }).from(bookings).innerJoin(services, eq(bookings.serviceId, services.id)).where(eq(bookings.id, bookingId)).limit(1);
        if (!booking[0] || !booking[0].staffId) {
          return null;
        }
        const bookingData = booking[0];
        const rate = await this.getActiveCommissionRate(
          bookingData.salonId,
          bookingData.staffId || void 0,
          bookingData.serviceId
        );
        if (!rate) {
          return null;
        }
        let commissionAmount = 0;
        if (rate.rateType === "percentage") {
          commissionAmount = Math.round(bookingData.servicePrice * parseFloat(rate.rateValue) / 100);
        } else if (rate.rateType === "fixed_amount") {
          commissionAmount = Math.round(parseFloat(rate.rateValue) * 100);
        }
        if (rate.minAmount && commissionAmount < rate.minAmount) {
          commissionAmount = rate.minAmount;
        }
        if (rate.maxAmount && commissionAmount > rate.maxAmount) {
          commissionAmount = rate.maxAmount;
        }
        const serviceDate = new Date(bookingData.bookingDate);
        const commissionData = {
          salonId: bookingData.salonId,
          staffId: bookingData.staffId,
          // We know it's not null from the check above
          bookingId: bookingData.id,
          serviceId: bookingData.serviceId,
          rateId: rate.id,
          baseAmountPaisa: bookingData.servicePrice,
          commissionAmountPaisa: commissionAmount,
          commissionRate: rate.rateValue,
          serviceDate,
          periodYear: serviceDate.getFullYear(),
          periodMonth: serviceDate.getMonth() + 1,
          paymentStatus: "pending"
        };
        return await this.createCommission(commissionData);
      }
      async getCommissionAnalytics(salonId, period) {
        const now = /* @__PURE__ */ new Date();
        const startDate = /* @__PURE__ */ new Date();
        switch (period) {
          case "monthly":
            startDate.setMonth(now.getMonth() - 1);
            break;
          case "quarterly":
            startDate.setMonth(now.getMonth() - 3);
            break;
          case "yearly":
            startDate.setFullYear(now.getFullYear() - 1);
            break;
        }
        const totalsResult = await db.select({
          total: sql2`COALESCE(SUM(${commissions.commissionAmountPaisa}), 0)`,
          paid: sql2`COALESCE(SUM(CASE WHEN ${commissions.paymentStatus} = 'paid' THEN ${commissions.commissionAmountPaisa} ELSE 0 END), 0)`,
          pending: sql2`COALESCE(SUM(CASE WHEN ${commissions.paymentStatus} = 'pending' THEN ${commissions.commissionAmountPaisa} ELSE 0 END), 0)`
        }).from(commissions).where(and(
          eq(commissions.salonId, salonId),
          gte(commissions.serviceDate, startDate)
        ));
        const totals = totalsResult[0] || { total: 0, paid: 0, pending: 0 };
        const staffResults = await db.select({
          staffId: commissions.staffId,
          staffName: staff.name,
          earned: sql2`COALESCE(SUM(${commissions.commissionAmountPaisa}), 0)`,
          paid: sql2`COALESCE(SUM(CASE WHEN ${commissions.paymentStatus} = 'paid' THEN ${commissions.commissionAmountPaisa} ELSE 0 END), 0)`,
          pending: sql2`COALESCE(SUM(CASE WHEN ${commissions.paymentStatus} = 'pending' THEN ${commissions.commissionAmountPaisa} ELSE 0 END), 0)`
        }).from(commissions).innerJoin(staff, eq(commissions.staffId, staff.id)).where(and(
          eq(commissions.salonId, salonId),
          gte(commissions.serviceDate, startDate)
        )).groupBy(commissions.staffId, staff.name);
        const monthlyResults = await db.select({
          month: sql2`TO_CHAR(${commissions.serviceDate}, 'YYYY-MM')`,
          amount: sql2`COALESCE(SUM(${commissions.commissionAmountPaisa}), 0)`
        }).from(commissions).where(and(
          eq(commissions.salonId, salonId),
          gte(commissions.serviceDate, new Date(now.getFullYear() - 1, now.getMonth(), 1))
        )).groupBy(sql2`TO_CHAR(${commissions.serviceDate}, 'YYYY-MM')`).orderBy(sql2`TO_CHAR(${commissions.serviceDate}, 'YYYY-MM')`);
        const avgRateResult = await db.select({
          avgRate: sql2`COALESCE(AVG(${commissions.commissionRate}), 0)`
        }).from(commissions).where(and(
          eq(commissions.salonId, salonId),
          gte(commissions.serviceDate, startDate)
        ));
        return {
          totalCommissions: totals.total,
          paidCommissions: totals.paid,
          pendingCommissions: totals.pending,
          commissionsByStaff: staffResults,
          monthlyTrend: monthlyResults,
          averageCommissionRate: avgRateResult[0]?.avgRate || 0
        };
      }
      // Budget operations
      async getBudget(id) {
        const [budget] = await db.select().from(budgets).where(eq(budgets.id, id));
        return budget || void 0;
      }
      async getBudgetsBySalonId(salonId, filters) {
        const conditions = [eq(budgets.salonId, salonId)];
        if (filters?.categoryId) {
          conditions.push(eq(budgets.categoryId, filters.categoryId));
        }
        if (filters?.budgetType) {
          conditions.push(eq(budgets.budgetType, filters.budgetType));
        }
        if (filters?.isActive !== void 0) {
          conditions.push(eq(budgets.isActive, filters.isActive ? 1 : 0));
        }
        return await db.select().from(budgets).where(and(...conditions)).orderBy(desc(budgets.startDate));
      }
      async createBudget(budget) {
        const [newBudget] = await db.insert(budgets).values(budget).returning();
        return newBudget;
      }
      async updateBudget(id, salonId, updates) {
        await db.update(budgets).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(and(eq(budgets.id, id), eq(budgets.salonId, salonId)));
      }
      async updateBudgetSpentAmount(salonId, categoryId, additionalSpent) {
        await db.update(budgets).set({
          spentAmountPaisa: sql2`${budgets.spentAmountPaisa} + ${additionalSpent}`,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(and(
          eq(budgets.salonId, salonId),
          eq(budgets.categoryId, categoryId),
          eq(budgets.isActive, 1),
          lte(budgets.startDate, /* @__PURE__ */ new Date()),
          gte(budgets.endDate, /* @__PURE__ */ new Date())
        ));
      }
      async deleteBudget(id, salonId) {
        await db.update(budgets).set({ isActive: 0, updatedAt: /* @__PURE__ */ new Date() }).where(and(eq(budgets.id, id), eq(budgets.salonId, salonId)));
      }
      async getBudgetAnalytics(salonId, period) {
        const now = /* @__PURE__ */ new Date();
        const budgetResults = await db.select({
          budgetId: budgets.id,
          budgetName: budgets.name,
          categoryId: budgets.categoryId,
          categoryName: expenseCategories.name,
          budgeted: budgets.budgetAmountPaisa,
          spent: budgets.spentAmountPaisa,
          alertThreshold: budgets.alertThreshold
        }).from(budgets).leftJoin(expenseCategories, eq(budgets.categoryId, expenseCategories.id)).where(and(
          eq(budgets.salonId, salonId),
          eq(budgets.isActive, 1),
          lte(budgets.startDate, now),
          gte(budgets.endDate, now)
        ));
        const totalBudget = budgetResults.reduce((sum4, b) => sum4 + b.budgeted, 0);
        const totalSpent = budgetResults.reduce((sum4, b) => sum4 + b.spent, 0);
        const budgetUtilization = totalBudget > 0 ? totalSpent / totalBudget * 100 : 0;
        const budgetsByCategory = budgetResults.map((budget) => {
          const remaining = budget.budgeted - budget.spent;
          const utilization = budget.budgeted > 0 ? budget.spent / budget.budgeted * 100 : 0;
          let status = "under";
          if (utilization > 100) status = "over";
          else if (utilization > (budget.alertThreshold || 80)) status = "on-track";
          return {
            categoryId: budget.categoryId || "",
            categoryName: budget.categoryName || "Uncategorized",
            budgeted: budget.budgeted,
            spent: budget.spent,
            remaining,
            utilization,
            status
          };
        });
        const alertingBudgets = budgetResults.filter((b) => {
          const utilization = b.budgeted > 0 ? b.spent / b.budgeted * 100 : 0;
          return utilization >= (b.alertThreshold || 80);
        }).map((b) => ({
          budgetId: b.budgetId,
          name: b.budgetName,
          utilization: b.budgeted > 0 ? b.spent / b.budgeted * 100 : 0
        }));
        return {
          totalBudget,
          totalSpent,
          budgetUtilization,
          budgetsByCategory,
          alertingBudgets
        };
      }
      // Financial report operations
      async getFinancialReport(id) {
        const [report] = await db.select().from(financialReports).where(eq(financialReports.id, id));
        return report || void 0;
      }
      async getFinancialReportsBySalonId(salonId, filters) {
        const conditions = [eq(financialReports.salonId, salonId)];
        if (filters?.reportType) {
          conditions.push(eq(financialReports.reportType, filters.reportType));
        }
        if (filters?.reportPeriod) {
          conditions.push(eq(financialReports.reportPeriod, filters.reportPeriod));
        }
        return await db.select().from(financialReports).where(and(...conditions)).orderBy(desc(financialReports.createdAt));
      }
      async createFinancialReport(report) {
        const [newReport] = await db.insert(financialReports).values(report).returning();
        return newReport;
      }
      async updateFinancialReport(id, salonId, updates) {
        await db.update(financialReports).set(updates).where(and(eq(financialReports.id, id), eq(financialReports.salonId, salonId)));
      }
      async deleteFinancialReport(id, salonId) {
        await db.delete(financialReports).where(and(eq(financialReports.id, id), eq(financialReports.salonId, salonId)));
      }
      async generateProfitLossStatement(salonId, startDate, endDate) {
        const start = new Date(startDate);
        const end = new Date(endDate);
        const jobCardRevenueResult = await db.select({
          jobCardRevenue: sql2`COALESCE(SUM(${jobCards.totalAmountPaisa}), 0)`
        }).from(jobCards).where(and(
          eq(jobCards.salonId, salonId),
          eq(jobCards.status, "completed"),
          gte(jobCards.createdAt, start),
          lte(jobCards.createdAt, end)
        ));
        const jobCardRevenue = parseFloat(String(jobCardRevenueResult[0]?.jobCardRevenue)) || 0;
        const orphanBookingResult = await db.select({
          bookingRevenue: sql2`COALESCE(SUM(${services.priceInPaisa}), 0)`
        }).from(bookings).innerJoin(services, eq(bookings.serviceId, services.id)).leftJoin(jobCards, eq(jobCards.bookingId, bookings.id)).where(and(
          eq(bookings.salonId, salonId),
          eq(bookings.status, "completed"),
          gte(bookings.createdAt, start),
          lte(bookings.createdAt, end),
          sql2`${jobCards.id} IS NULL`
          // No job card linked
        ));
        const orphanBookingRevenue = parseFloat(String(orphanBookingResult[0]?.bookingRevenue)) || 0;
        const serviceRevenue = jobCardRevenue + orphanBookingRevenue;
        const otherRevenue = 0;
        const totalRevenue = serviceRevenue + otherRevenue;
        const expenseResults = await db.select({
          categoryId: expenses.categoryId,
          categoryName: expenseCategories.name,
          amount: sql2`COALESCE(SUM(${expenses.amountPaisa}), 0)`
        }).from(expenses).innerJoin(expenseCategories, eq(expenses.categoryId, expenseCategories.id)).where(and(
          eq(expenses.salonId, salonId),
          eq(expenses.status, "approved"),
          gte(expenses.expenseDate, start),
          lte(expenses.expenseDate, end)
        )).groupBy(expenses.categoryId, expenseCategories.name);
        const totalOperatingExpenses = expenseResults.reduce((sum4, exp) => sum4 + parseFloat(String(exp.amount)) || 0, 0);
        const commissionResult = await db.select({
          commissions: sql2`COALESCE(SUM(${commissions.commissionAmountPaisa}), 0)`
        }).from(commissions).where(and(
          eq(commissions.salonId, salonId),
          gte(commissions.serviceDate, start),
          lte(commissions.serviceDate, end)
        ));
        const commissionsExpense = parseFloat(String(commissionResult[0]?.commissions)) || 0;
        const taxResult = await db.select({
          taxes: sql2`COALESCE(SUM(${expenses.taxAmountPaisa}), 0)`
        }).from(expenses).where(and(
          eq(expenses.salonId, salonId),
          eq(expenses.status, "approved"),
          gte(expenses.expenseDate, start),
          lte(expenses.expenseDate, end)
        ));
        const taxes = parseFloat(String(taxResult[0]?.taxes)) || 0;
        const totalExpenses = totalOperatingExpenses + commissionsExpense + taxes;
        const grossProfit = totalRevenue - totalOperatingExpenses;
        const grossProfitMargin = totalRevenue > 0 ? grossProfit / totalRevenue * 100 : 0;
        const netProfit = totalRevenue - totalExpenses;
        const netProfitMargin = totalRevenue > 0 ? netProfit / totalRevenue * 100 : 0;
        const ebitda = grossProfit;
        return {
          period: { startDate, endDate },
          revenue: {
            serviceRevenue,
            otherRevenue,
            totalRevenue
          },
          expenses: {
            operatingExpenses: expenseResults,
            totalOperatingExpenses,
            commissions: commissionsExpense,
            taxes,
            totalExpenses
          },
          profitLoss: {
            grossProfit,
            grossProfitMargin,
            netProfit,
            netProfitMargin,
            ebitda
          }
        };
      }
      async generateCashFlowStatement(salonId, startDate, endDate) {
        const plStatement = await this.generateProfitLossStatement(salonId, startDate, endDate);
        const netIncome = plStatement.profitLoss.netProfit;
        const equipmentResult = await db.select({
          equipment: sql2`COALESCE(SUM(${expenses.amountPaisa}), 0)`
        }).from(expenses).innerJoin(expenseCategories, eq(expenses.categoryId, expenseCategories.id)).where(and(
          eq(expenses.salonId, salonId),
          eq(expenses.status, "approved"),
          eq(expenseCategories.name, "Equipment"),
          gte(expenses.expenseDate, new Date(startDate)),
          lte(expenses.expenseDate, new Date(endDate))
        ));
        const equipmentPurchases = -(equipmentResult[0]?.equipment || 0);
        const adjustments = [
          { item: "Depreciation", amount: 0 },
          // Would need asset tracking
          { item: "Accounts Receivable Changes", amount: 0 }
        ];
        const totalOperatingCashFlow = netIncome + adjustments.reduce((sum4, adj) => sum4 + adj.amount, 0);
        const totalInvestingCashFlow = equipmentPurchases;
        const ownerWithdrawals = 0;
        const totalFinancingCashFlow = ownerWithdrawals;
        const netCashFlow = totalOperatingCashFlow + totalInvestingCashFlow + totalFinancingCashFlow;
        return {
          period: { startDate, endDate },
          operatingActivities: {
            netIncome,
            adjustments,
            totalOperatingCashFlow
          },
          investingActivities: {
            equipmentPurchases,
            totalInvestingCashFlow
          },
          financingActivities: {
            ownerWithdrawals,
            totalFinancingCashFlow
          },
          netCashFlow
        };
      }
      // Tax setting operations
      async getTaxSetting(id) {
        const [setting] = await db.select().from(taxSettings).where(eq(taxSettings.id, id));
        return setting || void 0;
      }
      async getTaxSettingsBySalonId(salonId) {
        return await db.select().from(taxSettings).where(and(eq(taxSettings.salonId, salonId), eq(taxSettings.isActive, 1))).orderBy(asc(taxSettings.taxType));
      }
      async getTaxSettingByType(salonId, taxType) {
        const [setting] = await db.select().from(taxSettings).where(and(
          eq(taxSettings.salonId, salonId),
          eq(taxSettings.taxType, taxType),
          eq(taxSettings.isActive, 1)
        ));
        return setting || void 0;
      }
      async createTaxSetting(setting) {
        const [newSetting] = await db.insert(taxSettings).values(setting).returning();
        return newSetting;
      }
      async updateTaxSetting(id, salonId, updates) {
        await db.update(taxSettings).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(and(eq(taxSettings.id, id), eq(taxSettings.salonId, salonId)));
      }
      async deleteTaxSetting(id, salonId) {
        await db.update(taxSettings).set({ isActive: 0, updatedAt: /* @__PURE__ */ new Date() }).where(and(eq(taxSettings.id, id), eq(taxSettings.salonId, salonId)));
      }
      async calculateTaxLiability(salonId, period) {
        const now = /* @__PURE__ */ new Date();
        const startDate = /* @__PURE__ */ new Date();
        switch (period) {
          case "monthly":
            startDate.setMonth(now.getMonth() - 1);
            break;
          case "quarterly":
            startDate.setMonth(now.getMonth() - 3);
            break;
          case "yearly":
            startDate.setFullYear(now.getFullYear() - 1);
            break;
        }
        const revenueResult = await db.select({
          grossRevenue: sql2`COALESCE(SUM(${services.priceInPaisa}), 0)`
        }).from(bookings).innerJoin(services, eq(bookings.serviceId, services.id)).where(and(
          eq(bookings.salonId, salonId),
          eq(bookings.status, "completed"),
          gte(bookings.createdAt, startDate)
        ));
        const grossRevenue = revenueResult[0]?.grossRevenue || 0;
        const taxableRevenue = grossRevenue;
        const taxSettingsResults = await this.getTaxSettingsBySalonId(salonId);
        const taxBreakdown = taxSettingsResults.map((setting) => {
          const rate = parseFloat(setting.taxRate);
          const taxableAmount = taxableRevenue;
          const taxOwed = Math.round(taxableAmount * rate / 100);
          return {
            taxType: setting.taxType,
            taxName: setting.taxName,
            rate,
            taxableAmount,
            taxOwed
          };
        });
        const totalTaxOwed = taxBreakdown.reduce((sum4, tax) => sum4 + tax.taxOwed, 0);
        const nextFilingDates = taxSettingsResults.filter((setting) => setting.nextFilingDate).map((setting) => ({
          taxType: setting.taxType,
          dueDate: setting.nextFilingDate.toISOString().split("T")[0]
        }));
        return {
          period,
          grossRevenue,
          taxableRevenue,
          taxBreakdown,
          totalTaxOwed,
          nextFilingDates
        };
      }
      // Comprehensive financial analytics
      async getFinancialKPIs(salonId, period) {
        const now = /* @__PURE__ */ new Date();
        const startDate = /* @__PURE__ */ new Date();
        const prevStartDate = /* @__PURE__ */ new Date();
        switch (period) {
          case "monthly":
            startDate.setMonth(now.getMonth() - 1);
            prevStartDate.setMonth(now.getMonth() - 2);
            break;
          case "quarterly":
            startDate.setMonth(now.getMonth() - 3);
            prevStartDate.setMonth(now.getMonth() - 6);
            break;
          case "yearly":
            startDate.setFullYear(now.getFullYear() - 1);
            prevStartDate.setFullYear(now.getFullYear() - 2);
            break;
        }
        const jobCardRevenueResults = await db.select({
          totalRevenue: sql2`COALESCE(SUM(${jobCards.totalAmountPaisa}), 0)`,
          jobCardCount: sql2`COUNT(*)`,
          uniqueCustomers: sql2`COUNT(DISTINCT COALESCE(${jobCards.customerId}, ${jobCards.customerPhone}))`
        }).from(jobCards).where(and(
          eq(jobCards.salonId, salonId),
          eq(jobCards.status, "completed"),
          gte(jobCards.createdAt, startDate)
        ));
        const jobCardRevenue = parseFloat(String(jobCardRevenueResults[0]?.totalRevenue)) || 0;
        const jobCardCount = parseFloat(String(jobCardRevenueResults[0]?.jobCardCount)) || 0;
        const jobCardCustomers = parseFloat(String(jobCardRevenueResults[0]?.uniqueCustomers)) || 0;
        const orphanBookingResults = await db.select({
          totalRevenue: sql2`COALESCE(SUM(${services.priceInPaisa}), 0)`,
          bookingCount: sql2`COUNT(*)`,
          uniqueCustomers: sql2`COUNT(DISTINCT ${bookings.customerEmail})`
        }).from(bookings).innerJoin(services, eq(bookings.serviceId, services.id)).leftJoin(jobCards, eq(jobCards.bookingId, bookings.id)).where(and(
          eq(bookings.salonId, salonId),
          eq(bookings.status, "completed"),
          gte(bookings.createdAt, startDate),
          sql2`${jobCards.id} IS NULL`
          // No job card linked
        ));
        const orphanBookingRevenue = parseFloat(String(orphanBookingResults[0]?.totalRevenue)) || 0;
        const orphanBookingCount = parseFloat(String(orphanBookingResults[0]?.bookingCount)) || 0;
        const orphanBookingCustomers = parseFloat(String(orphanBookingResults[0]?.uniqueCustomers)) || 0;
        const currentRevenue = jobCardRevenue + orphanBookingRevenue;
        const totalTransactionCount = jobCardCount + orphanBookingCount;
        const uniqueCustomers = jobCardCustomers + orphanBookingCustomers;
        const prevJobCardResults = await db.select({
          prevRevenue: sql2`COALESCE(SUM(${jobCards.totalAmountPaisa}), 0)`
        }).from(jobCards).where(and(
          eq(jobCards.salonId, salonId),
          eq(jobCards.status, "completed"),
          gte(jobCards.createdAt, prevStartDate),
          lte(jobCards.createdAt, startDate)
        ));
        const prevOrphanBookingResults = await db.select({
          prevRevenue: sql2`COALESCE(SUM(${services.priceInPaisa}), 0)`
        }).from(bookings).innerJoin(services, eq(bookings.serviceId, services.id)).leftJoin(jobCards, eq(jobCards.bookingId, bookings.id)).where(and(
          eq(bookings.salonId, salonId),
          eq(bookings.status, "completed"),
          gte(bookings.createdAt, prevStartDate),
          lte(bookings.createdAt, startDate),
          sql2`${jobCards.id} IS NULL`
        ));
        const prevJobCardRevenue = parseFloat(String(prevJobCardResults[0]?.prevRevenue)) || 0;
        const prevOrphanRevenue = parseFloat(String(prevOrphanBookingResults[0]?.prevRevenue)) || 0;
        const prevRevenue = prevJobCardRevenue + prevOrphanRevenue;
        const revenueGrowthRate = prevRevenue > 0 ? (currentRevenue - prevRevenue) / prevRevenue * 100 : 0;
        const expenseResults = await db.select({
          totalExpenses: sql2`COALESCE(SUM(${expenses.amountPaisa}), 0)`
        }).from(expenses).where(and(
          eq(expenses.salonId, salonId),
          eq(expenses.status, "approved"),
          gte(expenses.expenseDate, startDate)
        ));
        const totalExpenses = expenseResults[0]?.totalExpenses || 0;
        const prevExpenseResults = await db.select({
          prevExpenses: sql2`COALESCE(SUM(${expenses.amountPaisa}), 0)`
        }).from(expenses).where(and(
          eq(expenses.salonId, salonId),
          eq(expenses.status, "approved"),
          gte(expenses.expenseDate, prevStartDate),
          lte(expenses.expenseDate, startDate)
        ));
        const prevExpenses = prevExpenseResults[0]?.prevExpenses || 0;
        const expenseGrowthRate = prevExpenses > 0 ? (totalExpenses - prevExpenses) / prevExpenses * 100 : 0;
        const staffResults = await db.select({
          staffCount: sql2`COUNT(*)`
        }).from(staff).where(and(eq(staff.salonId, salonId), eq(staff.isActive, 1)));
        const staffCount = staffResults[0]?.staffCount || 1;
        const avgServiceResults = await db.select({
          avgDuration: sql2`COALESCE(AVG(${services.durationMinutes}), 0)`
        }).from(services).where(and(eq(services.salonId, salonId), eq(services.isActive, 1)));
        const averageServiceTime = avgServiceResults[0]?.avgDuration || 0;
        const averageBookingValue = totalTransactionCount > 0 ? currentRevenue / totalTransactionCount : 0;
        const revenuePerCustomer = uniqueCustomers > 0 ? currentRevenue / uniqueCustomers : 0;
        const expenseRatio = currentRevenue > 0 ? totalExpenses / currentRevenue * 100 : 0;
        const costPerService = totalTransactionCount > 0 ? totalExpenses / totalTransactionCount : 0;
        const grossProfitMargin = currentRevenue > 0 ? (currentRevenue - totalExpenses) / currentRevenue * 100 : 0;
        const netProfitMargin = grossProfitMargin;
        const breakEvenPoint = averageBookingValue > 0 ? totalExpenses / averageBookingValue : 0;
        const returnOnInvestment = totalExpenses > 0 ? (currentRevenue - totalExpenses) / totalExpenses * 100 : 0;
        const revenuePerStaff = staffCount > 0 ? currentRevenue / staffCount : 0;
        const serviceUtilizationRate = 80;
        const staffProductivity = staffCount > 0 ? totalTransactionCount / staffCount : 0;
        return {
          revenue: {
            totalRevenue: currentRevenue,
            averageBookingValue,
            revenuePerCustomer,
            revenueGrowthRate
          },
          expenses: {
            totalExpenses,
            expenseRatio,
            costPerService,
            expenseGrowthRate
          },
          profitability: {
            grossProfitMargin,
            netProfitMargin,
            breakEvenPoint,
            returnOnInvestment
          },
          efficiency: {
            revenuePerStaff,
            serviceUtilizationRate,
            averageServiceTime,
            staffProductivity
          }
        };
      }
      async getFinancialForecast(salonId, months) {
        const oneYearAgo = new Date((/* @__PURE__ */ new Date()).getFullYear() - 1, (/* @__PURE__ */ new Date()).getMonth(), 1);
        const bookingHistoricalResults = await db.select({
          month: sql2`TO_CHAR(${bookings.createdAt}, 'YYYY-MM')`,
          revenue: sql2`COALESCE(SUM(${services.priceInPaisa}), 0)`
        }).from(bookings).innerJoin(services, eq(bookings.serviceId, services.id)).where(and(
          eq(bookings.salonId, salonId),
          eq(bookings.status, "completed"),
          gte(bookings.createdAt, oneYearAgo)
        )).groupBy(sql2`TO_CHAR(${bookings.createdAt}, 'YYYY-MM')`).orderBy(sql2`TO_CHAR(${bookings.createdAt}, 'YYYY-MM')`);
        const jobCardHistoricalResults = await db.select({
          month: sql2`TO_CHAR(${jobCards.checkInAt}, 'YYYY-MM')`,
          revenue: sql2`COALESCE(SUM(${jobCards.paidAmountPaisa}), 0)`
        }).from(jobCards).where(and(
          eq(jobCards.salonId, salonId),
          eq(jobCards.status, "completed"),
          eq(jobCards.paymentStatus, "paid"),
          gte(jobCards.checkInAt, oneYearAgo)
        )).groupBy(sql2`TO_CHAR(${jobCards.checkInAt}, 'YYYY-MM')`).orderBy(sql2`TO_CHAR(${jobCards.checkInAt}, 'YYYY-MM')`);
        const combinedHistoryMap = /* @__PURE__ */ new Map();
        bookingHistoricalResults.forEach((r) => {
          combinedHistoryMap.set(r.month, parseFloat(String(r.revenue)) || 0);
        });
        jobCardHistoricalResults.forEach((r) => {
          const existing = combinedHistoryMap.get(r.month) || 0;
          combinedHistoryMap.set(r.month, existing + (parseFloat(String(r.revenue)) || 0));
        });
        const historicalResults = Array.from(combinedHistoryMap.entries()).map(([month, revenue]) => ({ month, revenue })).sort((a, b) => a.month.localeCompare(b.month));
        const revenues = historicalResults.map((r) => r.revenue);
        const revenueGrowthRate = revenues.length > 1 ? (revenues[revenues.length - 1] - revenues[0]) / revenues[0] * 100 / revenues.length : 5;
        const kpis = await this.getFinancialKPIs(salonId, "monthly");
        const expenseRatio = kpis.expenses.expenseRatio / 100;
        const costInflationRate = 3;
        const seasonalFactors = [
          { month: 1, factor: 0.9 },
          { month: 2, factor: 0.95 },
          { month: 3, factor: 1.1 },
          { month: 4, factor: 1.05 },
          { month: 5, factor: 1.15 },
          { month: 6, factor: 1.2 },
          { month: 7, factor: 1.1 },
          { month: 8, factor: 1.05 },
          { month: 9, factor: 1 },
          { month: 10, factor: 1.1 },
          { month: 11, factor: 1.2 },
          { month: 12, factor: 1.3 }
        ];
        const baseRevenue = kpis.revenue.totalRevenue;
        const forecast = [];
        for (let i = 1; i <= months; i++) {
          const futureDate = /* @__PURE__ */ new Date();
          futureDate.setMonth(futureDate.getMonth() + i);
          const monthNumber = futureDate.getMonth() + 1;
          const seasonalFactor = seasonalFactors.find((f) => f.month === monthNumber)?.factor || 1;
          const growthFactor = Math.pow(1 + revenueGrowthRate / 100, i);
          const projectedRevenue = Math.round(baseRevenue * growthFactor * seasonalFactor);
          const expenseGrowthFactor = Math.pow(1 + costInflationRate / 100, i);
          const projectedExpenses = Math.round(baseRevenue * expenseRatio * expenseGrowthFactor);
          const projectedProfit = projectedRevenue - projectedExpenses;
          const confidence = Math.max(50, 95 - i * 5);
          forecast.push({
            month: futureDate.toISOString().substring(0, 7),
            projectedRevenue,
            projectedExpenses,
            projectedProfit,
            confidence
          });
        }
        const totalProjectedRevenue = forecast.reduce((sum4, f) => sum4 + f.projectedRevenue, 0);
        const totalProjectedProfit = forecast.reduce((sum4, f) => sum4 + f.projectedProfit, 0);
        const scenarios = {
          optimistic: {
            totalRevenue: Math.round(totalProjectedRevenue * 1.2),
            totalProfit: Math.round(totalProjectedProfit * 1.3)
          },
          realistic: {
            totalRevenue: totalProjectedRevenue,
            totalProfit: totalProjectedProfit
          },
          pessimistic: {
            totalRevenue: Math.round(totalProjectedRevenue * 0.8),
            totalProfit: Math.round(totalProjectedProfit * 0.6)
          }
        };
        return {
          forecast,
          assumptions: {
            revenueGrowthRate,
            seasonalFactors,
            costInflationRate
          },
          scenarios
        };
      }
      // Communication system method implementations
      // Scheduled message operations
      async getScheduledMessage(id) {
        const [message] = await db.select().from(scheduledMessages).where(eq(scheduledMessages.id, id));
        return message || void 0;
      }
      async getScheduledMessagesBySalonId(salonId, filters) {
        const conditions = [eq(scheduledMessages.salonId, salonId)];
        if (filters?.status) {
          conditions.push(eq(scheduledMessages.status, filters.status));
        }
        if (filters?.type) {
          conditions.push(eq(scheduledMessages.type, filters.type));
        }
        if (filters?.scheduledBefore) {
          conditions.push(lte(scheduledMessages.scheduledFor, filters.scheduledBefore));
        }
        const result = await db.select().from(scheduledMessages).where(and(...conditions));
        return result || [];
      }
      async getScheduledMessagesDue(beforeTime) {
        const cutoffTime = beforeTime || /* @__PURE__ */ new Date();
        const result = await db.select().from(scheduledMessages).where(
          and(
            eq(scheduledMessages.status, "pending"),
            lte(scheduledMessages.scheduledFor, cutoffTime)
          )
        ).orderBy(asc(scheduledMessages.scheduledFor));
        return result || [];
      }
      async createScheduledMessage(message) {
        const [created] = await db.insert(scheduledMessages).values(message).returning();
        return created;
      }
      async updateScheduledMessage(id, updates) {
        await db.update(scheduledMessages).set(updates).where(eq(scheduledMessages.id, id));
      }
      async markScheduledMessageSent(id, providerId) {
        await db.update(scheduledMessages).set({
          status: "sent",
          sentAt: /* @__PURE__ */ new Date()
        }).where(eq(scheduledMessages.id, id));
      }
      async markScheduledMessageFailed(id, reason) {
        await db.update(scheduledMessages).set({
          status: "failed",
          failureReason: reason
        }).where(eq(scheduledMessages.id, id));
      }
      async cancelScheduledMessage(id) {
        await db.update(scheduledMessages).set({
          status: "cancelled"
        }).where(eq(scheduledMessages.id, id));
      }
      async rescheduleMessage(id, newScheduleTime) {
        await db.update(scheduledMessages).set({
          scheduledFor: newScheduleTime,
          status: "pending"
        }).where(eq(scheduledMessages.id, id));
      }
      // Template processing and personalization
      async processTemplate(templateContent, variables) {
        let processed = templateContent;
        for (const [key, value] of Object.entries(variables)) {
          const regex = new RegExp(`{{${key}}}`, "g");
          processed = processed.replace(regex, String(value || ""));
        }
        return processed;
      }
      async getTemplateVariables(salonId, bookingId, customerId) {
        const variables = {};
        const salon = await this.getSalonById(salonId);
        if (salon) {
          variables.salonName = salon.name;
          variables.salonPhone = salon.phone;
          variables.salonEmail = salon.email;
          variables.salonAddress = `${salon.address}, ${salon.city}, ${salon.state} ${salon.zipCode}`;
        }
        if (bookingId) {
          const booking = await this.getBooking(bookingId);
          if (booking) {
            variables.customerName = booking.customerName;
            variables.customerEmail = booking.customerEmail;
            variables.customerPhone = booking.customerPhone;
            variables.bookingDate = booking.createdAt?.toLocaleDateString() || "";
            variables.bookingTime = booking.createdAt?.toLocaleTimeString() || "";
            const service = await this.getService(booking.serviceId);
            if (service) {
              variables.serviceName = service.name;
              variables.servicePrice = (service.priceInPaisa / 100).toFixed(2);
              variables.serviceDuration = service.durationMinutes;
            }
          }
        }
        variables.currentDate = (/* @__PURE__ */ new Date()).toLocaleDateString();
        variables.currentYear = (/* @__PURE__ */ new Date()).getFullYear();
        return variables;
      }
      // Basic implementations for other communication methods (stubs for now)
      async getMessageTemplate(id) {
        const [template] = await db.select().from(messageTemplates).where(eq(messageTemplates.id, id));
        return template || void 0;
      }
      async getMessageTemplatesBySalonId(salonId, type) {
        const conditions = [eq(messageTemplates.salonId, salonId)];
        if (type) {
          conditions.push(eq(messageTemplates.type, type));
        }
        return await db.select().from(messageTemplates).where(and(...conditions));
      }
      async createMessageTemplate(template) {
        const [created] = await db.insert(messageTemplates).values(template).returning();
        return created;
      }
      async updateMessageTemplate(id, salonId, updates) {
        await db.update(messageTemplates).set(updates).where(and(
          eq(messageTemplates.id, id),
          eq(messageTemplates.salonId, salonId)
        ));
      }
      async deleteMessageTemplate(id, salonId) {
        await db.delete(messageTemplates).where(and(
          eq(messageTemplates.id, id),
          eq(messageTemplates.salonId, salonId)
        ));
      }
      // Booking notification automation stubs
      async scheduleBookingNotifications(bookingId) {
        console.log(`Scheduling notifications for booking ${bookingId}`);
      }
      async cancelBookingNotifications(bookingId) {
        console.log(`Cancelling notifications for booking ${bookingId}`);
      }
      async sendBookingConfirmation(bookingId) {
        console.log(`Sending confirmation for booking ${bookingId}`);
        return true;
      }
      async sendBookingReminder(bookingId, reminderType) {
        console.log(`Sending ${reminderType} reminder for booking ${bookingId}`);
        return true;
      }
      async sendBookingCancellation(bookingId) {
        console.log(`Sending cancellation notice for booking ${bookingId}`);
        return true;
      }
      async sendFollowUpMessage(bookingId) {
        console.log(`Sending follow-up message for booking ${bookingId}`);
        return true;
      }
      // ====================================
      // A/B TESTING SYSTEM OPERATIONS
      // ====================================
      // A/B Test Campaign Operations
      async getAbTestCampaign(id) {
        try {
          const [campaign] = await db.select().from(abTestCampaigns).where(eq(abTestCampaigns.id, id));
          return campaign || void 0;
        } catch (error) {
          console.error("Error fetching A/B test campaign:", error);
          throw new Error("Failed to fetch A/B test campaign");
        }
      }
      async getAbTestCampaignsBySalonId(salonId, filters) {
        try {
          let query = db.select().from(abTestCampaigns).where(eq(abTestCampaigns.salonId, salonId));
          const conditions = [eq(abTestCampaigns.salonId, salonId)];
          if (filters?.status) {
            conditions.push(eq(abTestCampaigns.status, filters.status));
          }
          if (filters?.testType) {
            conditions.push(eq(abTestCampaigns.testType, filters.testType));
          }
          if (conditions.length > 1) {
            query = db.select().from(abTestCampaigns).where(and(...conditions));
          }
          const campaigns = await query.orderBy(desc(abTestCampaigns.createdAt));
          return campaigns;
        } catch (error) {
          console.error("Error fetching A/B test campaigns by salon:", error);
          throw new Error("Failed to fetch A/B test campaigns");
        }
      }
      async createAbTestCampaign(campaign) {
        try {
          const [newCampaign] = await db.insert(abTestCampaigns).values(campaign).returning();
          return newCampaign;
        } catch (error) {
          console.error("Error creating A/B test campaign:", error);
          throw new Error("Failed to create A/B test campaign");
        }
      }
      async updateAbTestCampaign(id, updates) {
        try {
          await db.update(abTestCampaigns).set(updates).where(eq(abTestCampaigns.id, id));
        } catch (error) {
          console.error("Error updating A/B test campaign:", error);
          throw new Error("Failed to update A/B test campaign");
        }
      }
      async deleteAbTestCampaign(id) {
        try {
          await db.delete(abTestCampaigns).where(eq(abTestCampaigns.id, id));
        } catch (error) {
          console.error("Error deleting A/B test campaign:", error);
          throw new Error("Failed to delete A/B test campaign");
        }
      }
      // Test Variant Operations
      async getTestVariant(id) {
        try {
          const [variant] = await db.select().from(testVariants).where(eq(testVariants.id, id));
          return variant || void 0;
        } catch (error) {
          console.error("Error fetching test variant:", error);
          throw new Error("Failed to fetch test variant");
        }
      }
      async getTestVariantsByTestId(testCampaignId) {
        try {
          const variants = await db.select().from(testVariants).where(eq(testVariants.testCampaignId, testCampaignId)).orderBy(asc(testVariants.priority));
          return variants;
        } catch (error) {
          console.error("Error fetching test variants by test ID:", error);
          throw new Error("Failed to fetch test variants");
        }
      }
      async createTestVariant(variant) {
        try {
          const [newVariant] = await db.insert(testVariants).values(variant).returning();
          return newVariant;
        } catch (error) {
          console.error("Error creating test variant:", error);
          throw new Error("Failed to create test variant");
        }
      }
      async updateTestVariant(id, updates) {
        try {
          await db.update(testVariants).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq(testVariants.id, id));
        } catch (error) {
          console.error("Error updating test variant:", error);
          throw new Error("Failed to update test variant");
        }
      }
      async deleteTestVariant(id) {
        try {
          await db.delete(testVariants).where(eq(testVariants.id, id));
        } catch (error) {
          console.error("Error deleting test variant:", error);
          throw new Error("Failed to delete test variant");
        }
      }
      // Test Metrics Operations
      async getTestMetric(id) {
        try {
          const [metric] = await db.select().from(testMetrics).where(eq(testMetrics.id, id));
          return metric || void 0;
        } catch (error) {
          console.error("Error fetching test metric:", error);
          throw new Error("Failed to fetch test metric");
        }
      }
      async getTestMetricsByVariantId(variantId, dateRange) {
        try {
          let query = db.select().from(testMetrics).where(eq(testMetrics.variantId, variantId));
          if (dateRange) {
            const conditions = [
              eq(testMetrics.variantId, variantId),
              gte(testMetrics.metricDate, new Date(dateRange.start)),
              lte(testMetrics.metricDate, new Date(dateRange.end))
            ];
            query = db.select().from(testMetrics).where(and(...conditions));
          }
          const metrics = await query.orderBy(desc(testMetrics.metricDate));
          return metrics;
        } catch (error) {
          console.error("Error fetching test metrics by variant ID:", error);
          throw new Error("Failed to fetch test metrics");
        }
      }
      async getTestMetricsByTestId(testCampaignId, dateRange) {
        try {
          let query = db.select().from(testMetrics).where(eq(testMetrics.testCampaignId, testCampaignId));
          if (dateRange) {
            const conditions = [
              eq(testMetrics.testCampaignId, testCampaignId),
              gte(testMetrics.metricDate, new Date(dateRange.start)),
              lte(testMetrics.metricDate, new Date(dateRange.end))
            ];
            query = db.select().from(testMetrics).where(and(...conditions));
          }
          const metrics = await query.orderBy(desc(testMetrics.metricDate));
          return metrics;
        } catch (error) {
          console.error("Error fetching test metrics by test ID:", error);
          throw new Error("Failed to fetch test metrics");
        }
      }
      async createTestMetric(metric) {
        try {
          const deliveredCount = metric.deliveredCount || 0;
          const openCount = metric.openCount || 0;
          const clickCount = metric.clickCount || 0;
          const conversionCount = metric.conversionCount || 0;
          const bookingCount = metric.bookingCount || 0;
          const calculatedMetric = {
            ...metric,
            openRate: deliveredCount > 0 ? (openCount / deliveredCount).toFixed(4) : "0.0000",
            clickRate: deliveredCount > 0 ? (clickCount / deliveredCount).toFixed(4) : "0.0000",
            conversionRate: deliveredCount > 0 ? (conversionCount / deliveredCount).toFixed(4) : "0.0000",
            bookingRate: deliveredCount > 0 ? (bookingCount / deliveredCount).toFixed(4) : "0.0000"
          };
          const [newMetric] = await db.insert(testMetrics).values([calculatedMetric]).returning();
          return newMetric;
        } catch (error) {
          console.error("Error creating test metric:", error);
          throw new Error("Failed to create test metric");
        }
      }
      async updateTestMetric(id, updates) {
        try {
          const updateData = { ...updates, updatedAt: /* @__PURE__ */ new Date() };
          if ("deliveredCount" in updates || "openCount" in updates || "clickCount" in updates || "conversionCount" in updates || "bookingCount" in updates) {
            const [currentMetric] = await db.select().from(testMetrics).where(eq(testMetrics.id, id));
            if (currentMetric) {
              const updatedMetric = { ...currentMetric, ...updates };
              const deliveredCount = updatedMetric.deliveredCount || 0;
              const openCount = updatedMetric.openCount || 0;
              const clickCount = updatedMetric.clickCount || 0;
              const conversionCount = updatedMetric.conversionCount || 0;
              const bookingCount = updatedMetric.bookingCount || 0;
              updateData.openRate = deliveredCount > 0 ? (openCount / deliveredCount).toFixed(4) : "0.0000";
              updateData.clickRate = deliveredCount > 0 ? (clickCount / deliveredCount).toFixed(4) : "0.0000";
              updateData.conversionRate = deliveredCount > 0 ? (conversionCount / deliveredCount).toFixed(4) : "0.0000";
              updateData.bookingRate = deliveredCount > 0 ? (bookingCount / deliveredCount).toFixed(4) : "0.0000";
            }
          }
          await db.update(testMetrics).set(updateData).where(eq(testMetrics.id, id));
        } catch (error) {
          console.error("Error updating test metric:", error);
          throw new Error("Failed to update test metric");
        }
      }
      async bulkCreateTestMetrics(metrics) {
        try {
          const calculatedMetrics = metrics.map((metric) => {
            const deliveredCount = metric.deliveredCount || 0;
            const openCount = metric.openCount || 0;
            const clickCount = metric.clickCount || 0;
            const conversionCount = metric.conversionCount || 0;
            const bookingCount = metric.bookingCount || 0;
            return {
              ...metric,
              openRate: deliveredCount > 0 ? (openCount / deliveredCount).toFixed(4) : "0.0000",
              clickRate: deliveredCount > 0 ? (clickCount / deliveredCount).toFixed(4) : "0.0000",
              conversionRate: deliveredCount > 0 ? (conversionCount / deliveredCount).toFixed(4) : "0.0000",
              bookingRate: deliveredCount > 0 ? (bookingCount / deliveredCount).toFixed(4) : "0.0000"
            };
          });
          const newMetrics = await db.insert(testMetrics).values(calculatedMetrics).returning();
          return newMetrics;
        } catch (error) {
          console.error("Error bulk creating test metrics:", error);
          throw new Error("Failed to bulk create test metrics");
        }
      }
      // Test Results Operations
      async getTestResult(id) {
        try {
          const [result] = await db.select().from(testResults).where(eq(testResults.id, id));
          return result || void 0;
        } catch (error) {
          console.error("Error fetching test result:", error);
          throw new Error("Failed to fetch test result");
        }
      }
      async getTestResultByTestId(testCampaignId) {
        try {
          const [result] = await db.select().from(testResults).where(eq(testResults.testCampaignId, testCampaignId));
          return result || void 0;
        } catch (error) {
          console.error("Error fetching test result by test ID:", error);
          throw new Error("Failed to fetch test result");
        }
      }
      async createTestResult(result) {
        try {
          const [newResult] = await db.insert(testResults).values(result).returning();
          return newResult;
        } catch (error) {
          console.error("Error creating test result:", error);
          throw new Error("Failed to create test result");
        }
      }
      async updateTestResult(id, updates) {
        try {
          await db.update(testResults).set(updates).where(eq(testResults.id, id));
        } catch (error) {
          console.error("Error updating test result:", error);
          throw new Error("Failed to update test result");
        }
      }
      // Analytics and Aggregation Methods
      async getAbTestPerformanceSummary(testCampaignId) {
        try {
          const [campaign] = await db.select().from(abTestCampaigns).where(eq(abTestCampaigns.id, testCampaignId));
          if (!campaign) {
            throw new Error("A/B test campaign not found");
          }
          const [result] = await db.select().from(testResults).where(eq(testResults.testCampaignId, testCampaignId));
          const variantsWithMetrics = await db.select({
            variantId: testVariants.id,
            variantName: testVariants.variantName,
            totalParticipants: sql2`SUM(${testMetrics.participantCount})`,
            avgOpenRate: sql2`AVG(${testMetrics.openRate})`,
            avgClickRate: sql2`AVG(${testMetrics.clickRate})`,
            avgConversionRate: sql2`AVG(${testMetrics.conversionRate})`,
            avgBookingRate: sql2`AVG(${testMetrics.bookingRate})`
          }).from(testVariants).leftJoin(testMetrics, eq(testVariants.id, testMetrics.variantId)).where(eq(testVariants.testCampaignId, testCampaignId)).groupBy(testVariants.id, testVariants.variantName);
          const totalParticipants = variantsWithMetrics.reduce(
            (sum4, variant) => sum4 + (variant.totalParticipants || 0),
            0
          );
          const variants = variantsWithMetrics.map((variant) => ({
            variantId: variant.variantId,
            variantName: variant.variantName,
            openRate: Number(variant.avgOpenRate) || 0,
            clickRate: Number(variant.avgClickRate) || 0,
            conversionRate: Number(variant.avgConversionRate) || 0,
            bookingRate: Number(variant.avgBookingRate) || 0,
            isWinner: result?.winnerVariantId === variant.variantId
          }));
          return {
            totalParticipants,
            variants
          };
        } catch (error) {
          console.error("Error fetching A/B test performance summary:", error);
          throw new Error("Failed to fetch A/B test performance summary");
        }
      }
      async getAbTestCampaignAnalytics(salonId, period) {
        try {
          const allCampaigns = await db.select({
            id: abTestCampaigns.id,
            status: abTestCampaigns.status,
            campaignName: abTestCampaigns.campaignName
          }).from(abTestCampaigns).where(eq(abTestCampaigns.salonId, salonId));
          const totalTests = allCampaigns.length;
          const activeTests = allCampaigns.filter((c) => c.status === "active").length;
          const completedTests = allCampaigns.filter((c) => c.status === "completed").length;
          const completedTestsWithResults = await db.select({
            campaignId: abTestCampaigns.id,
            campaignName: abTestCampaigns.campaignName,
            performanceImprovement: testResults.performanceImprovement
          }).from(abTestCampaigns).innerJoin(testResults, eq(abTestCampaigns.id, testResults.testCampaignId)).where(
            and(
              eq(abTestCampaigns.salonId, salonId),
              eq(abTestCampaigns.status, "completed")
            )
          );
          const averageImprovement = completedTestsWithResults.length > 0 ? completedTestsWithResults.reduce(
            (sum4, test) => sum4 + (Number(test.performanceImprovement) || 0),
            0
          ) / completedTestsWithResults.length : 0;
          const topPerformingVariants = await db.select({
            variantId: testVariants.id,
            variantName: testVariants.variantName,
            testName: abTestCampaigns.campaignName,
            avgBookingRate: sql2`AVG(${testMetrics.bookingRate})`,
            avgConversionRate: sql2`AVG(${testMetrics.conversionRate})`
          }).from(testVariants).innerJoin(abTestCampaigns, eq(testVariants.testCampaignId, abTestCampaigns.id)).leftJoin(testMetrics, eq(testVariants.id, testMetrics.variantId)).where(eq(abTestCampaigns.salonId, salonId)).groupBy(testVariants.id, testVariants.variantName, abTestCampaigns.campaignName).orderBy(desc(sql2`AVG(${testMetrics.bookingRate})`)).limit(5);
          return {
            totalTests,
            activeTests,
            completedTests,
            averageImprovement,
            topPerformingVariants: topPerformingVariants.map((variant) => ({
              variantId: variant.variantId,
              variantName: variant.variantName,
              testName: variant.testName,
              performanceMetric: Number(variant.avgBookingRate) || 0,
              improvement: Number(variant.avgConversionRate) || 0
            }))
          };
        } catch (error) {
          console.error("Error fetching A/B test campaign analytics:", error);
          throw new Error("Failed to fetch A/B test campaign analytics");
        }
      }
      // Customer Dashboard API Implementation
      async getCustomerAppointments(customerId, filters) {
        try {
          const limit = filters?.limit || 50;
          const offset = filters?.offset || 0;
          const status = filters?.status || "all";
          const user = await this.getUserById(customerId);
          if (!user?.email) {
            throw new Error("Customer email not found");
          }
          let whereCondition = eq(bookings.customerEmail, user.email);
          if (status === "upcoming") {
            const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
            whereCondition = and(
              whereCondition,
              gte(bookings.bookingDate, today),
              sql2`${bookings.status} IN ('confirmed', 'pending')`
            );
          } else if (status === "history") {
            whereCondition = and(
              whereCondition,
              sql2`${bookings.status} IN ('completed', 'cancelled')`
            );
          } else if (status !== "all") {
            whereCondition = and(whereCondition, eq(bookings.status, status));
          }
          const appointmentsQuery = db.select({
            id: bookings.id,
            salonId: bookings.salonId,
            salonName: salons.name,
            serviceId: bookings.serviceId,
            serviceName: services.name,
            staffId: bookings.staffId,
            staffName: staff.name,
            bookingDate: bookings.bookingDate,
            bookingTime: bookings.bookingTime,
            status: bookings.status,
            totalAmountPaisa: bookings.totalAmountPaisa,
            currency: bookings.currency,
            duration: services.durationMinutes,
            notes: bookings.notes,
            createdAt: bookings.createdAt
          }).from(bookings).innerJoin(salons, eq(bookings.salonId, salons.id)).innerJoin(services, eq(bookings.serviceId, services.id)).leftJoin(staff, eq(bookings.staffId, staff.id)).where(whereCondition).orderBy(desc(bookings.bookingDate), desc(bookings.bookingTime)).limit(limit).offset(offset);
          const appointments = await appointmentsQuery;
          const [{ count: count11 }] = await db.select({ count: sql2`count(*)` }).from(bookings).where(whereCondition);
          const hasMore = offset + limit < count11;
          return {
            appointments: appointments.map((apt) => ({
              id: apt.id,
              salonId: apt.salonId,
              salonName: apt.salonName,
              serviceId: apt.serviceId,
              serviceName: apt.serviceName,
              staffId: apt.staffId || "",
              staffName: apt.staffName || "Not assigned",
              bookingDate: apt.bookingDate,
              bookingTime: apt.bookingTime,
              status: apt.status,
              totalAmountPaisa: apt.totalAmountPaisa,
              currency: apt.currency,
              duration: apt.duration,
              notes: apt.notes || void 0,
              createdAt: apt.createdAt?.toISOString() || ""
            })),
            total: count11,
            hasMore
          };
        } catch (error) {
          console.error("Error fetching customer appointments:", error);
          throw new Error("Failed to fetch customer appointments");
        }
      }
      async getCustomerProfileWithStats(customerId) {
        try {
          const user = await this.getUserById(customerId);
          if (!user?.email) {
            throw new Error("User not found");
          }
          const bookingStats = await db.select({
            totalBookings: sql2`count(*)`,
            totalSpentPaisa: sql2`coalesce(sum(${bookings.totalAmountPaisa}), 0)`,
            lastBookingDate: sql2`max(${bookings.bookingDate})`
          }).from(bookings).where(eq(bookings.customerEmail, user.email));
          const favoriteServiceQuery = await db.select({
            serviceId: bookings.serviceId,
            serviceName: services.name,
            count: sql2`count(*)`
          }).from(bookings).innerJoin(services, eq(bookings.serviceId, services.id)).where(eq(bookings.customerEmail, user.email)).groupBy(bookings.serviceId, services.name).orderBy(desc(sql2`count(*)`)).limit(1);
          let communicationPrefs = {
            email: true,
            sms: true,
            push: true
          };
          try {
            const [userPrefs] = await db.select({
              emailOptIn: communicationPreferences.emailOptIn,
              smsOptIn: communicationPreferences.smsOptIn
            }).from(communicationPreferences).where(eq(communicationPreferences.customerId, customerId)).limit(1);
            if (userPrefs) {
              communicationPrefs = {
                email: Boolean(userPrefs.emailOptIn),
                sms: Boolean(userPrefs.smsOptIn),
                push: true
                // Default push to true
              };
            }
          } catch {
          }
          const stats = bookingStats[0];
          const favoriteService = favoriteServiceQuery[0];
          return {
            id: user.id,
            email: user.email || "",
            firstName: user.firstName || "",
            lastName: user.lastName || "",
            phone: user.phone || void 0,
            profileImageUrl: user.profileImageUrl || void 0,
            preferences: {
              favoriteServices: favoriteService ? [favoriteService.serviceId] : [],
              preferredStaff: [],
              // TODO: Can be calculated from booking history
              communicationPreferences: communicationPrefs
            },
            stats: {
              totalBookings: stats.totalBookings || 0,
              totalSpentPaisa: stats.totalSpentPaisa || 0,
              memberSince: user.createdAt?.toISOString() || (/* @__PURE__ */ new Date()).toISOString(),
              lastBookingDate: stats.lastBookingDate || void 0,
              favoriteService: favoriteService?.serviceName || void 0
            }
          };
        } catch (error) {
          console.error("Error fetching customer profile with stats:", error);
          throw new Error("Failed to fetch customer profile");
        }
      }
      async getCustomerPaymentHistory(customerId) {
        try {
          const user = await this.getUserById(customerId);
          if (!user?.email) {
            throw new Error("Customer email not found");
          }
          const paymentsQuery = await db.select({
            id: payments.id,
            bookingId: payments.bookingId,
            salonName: salons.name,
            serviceName: services.name,
            amountPaisa: payments.amountPaisa,
            currency: payments.currency,
            status: payments.status,
            transactionDate: payments.createdAt
          }).from(payments).innerJoin(bookings, eq(payments.bookingId, bookings.id)).innerJoin(salons, eq(bookings.salonId, salons.id)).innerJoin(services, eq(bookings.serviceId, services.id)).where(eq(bookings.customerEmail, user.email)).orderBy(desc(payments.createdAt));
          return {
            payments: paymentsQuery.map((payment) => ({
              id: payment.id,
              bookingId: payment.bookingId,
              salonName: payment.salonName,
              serviceName: payment.serviceName,
              amountPaisa: payment.amountPaisa,
              currency: payment.currency,
              status: payment.status,
              paymentMethod: "razorpay",
              // Default since we use Razorpay
              transactionDate: payment.transactionDate?.toISOString() || "",
              receiptUrl: void 0
              // Not available in schema
            })),
            total: paymentsQuery.length
          };
        } catch (error) {
          console.error("Error fetching customer payment history:", error);
          throw new Error("Failed to fetch customer payment history");
        }
      }
      // User saved locations operations - stub implementations
      async getUserSavedLocation(id) {
        const [location] = await db.select().from(userSavedLocations).where(eq(userSavedLocations.id, id));
        return location || void 0;
      }
      async getUserSavedLocationsByUserId(userId) {
        return await db.select().from(userSavedLocations).where(eq(userSavedLocations.userId, userId));
      }
      async getUserSavedLocationByUserIdAndLabel(userId, label) {
        const [location] = await db.select().from(userSavedLocations).where(and(eq(userSavedLocations.userId, userId), eq(userSavedLocations.label, label)));
        return location || void 0;
      }
      async createUserSavedLocation(location) {
        const [newLocation] = await db.insert(userSavedLocations).values(location).returning();
        return newLocation;
      }
      async updateUserSavedLocation(id, updates) {
        await db.update(userSavedLocations).set(updates).where(eq(userSavedLocations.id, id));
      }
      async deleteUserSavedLocation(id) {
        await db.delete(userSavedLocations).where(eq(userSavedLocations.id, id));
      }
      // Note: findSalonsNearUserLocation is already implemented earlier in the class
      // Note: Other methods like verifyEmailToken, markEmailAsVerified, isUserStaffOfSalon 
      // are already implemented elsewhere in the class
      // Minimal stubs for interface compliance - only truly missing methods
      // Communication system minimal stubs 
      async getDefaultMessageTemplate(salonId, type) {
        const templates = await this.getMessageTemplatesBySalonId(salonId, type);
        return templates.find((t) => t.isDefault) || void 0;
      }
      async createDefaultMessageTemplates(salonId) {
        return [];
      }
      async getCustomerSegment(id) {
        const [segment] = await db.select().from(customerSegments).where(eq(customerSegments.id, id));
        return segment || void 0;
      }
      async getCustomerSegmentsBySalonId(salonId) {
        return await db.select().from(customerSegments).where(eq(customerSegments.salonId, salonId));
      }
      async createCustomerSegment(segment) {
        const [created] = await db.insert(customerSegments).values(segment).returning();
        return created;
      }
      async updateCustomerSegment(id, salonId, updates) {
        await db.update(customerSegments).set(updates).where(and(eq(customerSegments.id, id), eq(customerSegments.salonId, salonId)));
      }
      async deleteCustomerSegment(id, salonId) {
        await db.delete(customerSegments).where(and(eq(customerSegments.id, id), eq(customerSegments.salonId, salonId)));
      }
      async updateSegmentCustomerCount(segmentId) {
      }
      async getCustomersInSegment(segmentId, salonId) {
        return [];
      }
      // Communication preferences methods
      async getCommunicationPreferences(customerId, salonId) {
        const [prefs] = await db.select().from(communicationPreferences).where(and(
          eq(communicationPreferences.customerId, customerId),
          eq(communicationPreferences.salonId, salonId)
        )).limit(1);
        return prefs;
      }
      async createCommunicationPreferences(preferences) {
        const [created] = await db.insert(communicationPreferences).values(preferences).returning();
        return created;
      }
      async updateCommunicationPreferences(customerId, salonId, updates) {
        await db.update(communicationPreferences).set(updates).where(and(
          eq(communicationPreferences.customerId, customerId),
          eq(communicationPreferences.salonId, salonId)
        ));
      }
      async unsubscribeFromCommunications(customerId, salonId, reason) {
        await this.updateCommunicationPreferences(customerId, salonId, {
          emailOptIn: 0,
          smsOptIn: 0,
          marketingOptIn: 0,
          unsubscribedAt: /* @__PURE__ */ new Date(),
          unsubscribeReason: reason
        });
      }
      async getUnsubscribedCustomers(salonId) {
        const unsubscribed = await db.select({ customerId: communicationPreferences.customerId }).from(communicationPreferences).where(and(
          eq(communicationPreferences.salonId, salonId),
          eq(communicationPreferences.emailOptIn, 0),
          eq(communicationPreferences.smsOptIn, 0)
        ));
        return unsubscribed.map((u) => u.customerId);
      }
      // Communication history methods
      async getCommunicationHistory(id) {
        const [history] = await db.select().from(communicationHistory).where(eq(communicationHistory.id, id)).limit(1);
        return history;
      }
      async getCommunicationHistoryBySalonId(salonId, filters) {
        let query = db.select().from(communicationHistory).where(eq(communicationHistory.salonId, salonId));
        return await query;
      }
      async getCommunicationHistoryByCustomer(customerId, salonId) {
        return await db.select().from(communicationHistory).where(and(
          eq(communicationHistory.customerId, customerId),
          eq(communicationHistory.salonId, salonId)
        ));
      }
      async createCommunicationHistory(history) {
        const [created] = await db.insert(communicationHistory).values(history).returning();
        return created;
      }
      async updateCommunicationHistory(id, updates) {
        await db.update(communicationHistory).set(updates).where(eq(communicationHistory.id, id));
      }
      async getCommunicationDashboardMetrics(salonId, period) {
        return {
          totalMessagesSent: 0,
          totalMessagesDelivered: 0,
          totalMessagesOpened: 0,
          totalMessagesClicked: 0,
          totalMessagesFailed: 0,
          emailOpenRate: 0,
          emailClickRate: 0,
          smsDeliveryRate: 0,
          unsubscribeRate: 0,
          activeCampaigns: 0,
          topPerformingCampaigns: [],
          channelPerformance: [],
          recentActivity: []
        };
      }
      async updateProductUsage(id, salonId, updates) {
      }
      async updateAutomationConfiguration(id, updates) {
      }
      async deleteAutomationConfiguration(id) {
      }
      // Remaining stub methods for interface compliance
      async startCommunicationCampaign(id) {
      }
      async pauseCommunicationCampaign(id) {
      }
      async completeCommunicationCampaign(id) {
      }
      async updateCampaignStats(campaignId, stats) {
      }
      async getCommunicationHistoryBySalonId(salonId, filters) {
        return [];
      }
      async getCommunicationHistoryByCustomer(customerId, salonId) {
        return [];
      }
      async updateCommunicationHistory(id, updates) {
      }
      // =================================
      // COMMUNICATION CAMPAIGN OPERATIONS
      // =================================
      async getCommunicationCampaign(id) {
        const [campaign] = await db.select().from(communicationCampaigns).where(eq(communicationCampaigns.id, id));
        return campaign || void 0;
      }
      async getCommunicationCampaignsBySalonId(salonId, filters) {
        let conditions = [eq(communicationCampaigns.salonId, salonId)];
        if (filters?.status) {
          conditions.push(eq(communicationCampaigns.status, filters.status));
        }
        if (filters?.type) {
          conditions.push(eq(communicationCampaigns.type, filters.type));
        }
        return await db.select().from(communicationCampaigns).where(and(...conditions)).orderBy(desc(communicationCampaigns.createdAt));
      }
      async createCommunicationCampaign(campaign) {
        const [newCampaign] = await db.insert(communicationCampaigns).values(campaign).returning();
        return newCampaign;
      }
      async updateCommunicationCampaign(id, salonId, updates) {
        await db.update(communicationCampaigns).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(and(
          eq(communicationCampaigns.id, id),
          eq(communicationCampaigns.salonId, salonId)
        ));
      }
      async deleteCommunicationCampaign(id, salonId) {
        await db.delete(communicationCampaigns).where(and(
          eq(communicationCampaigns.id, id),
          eq(communicationCampaigns.salonId, salonId)
        ));
      }
      // Add hundreds of minimal stubs to satisfy interface - basic empty implementations
      // Inventory management implementations
      // =================================
      // PRODUCT CATEGORY OPERATIONS
      // =================================
      async getProductCategory(id, salonId) {
        if (salonId) {
          const [category] = await db.select().from(productCategories).where(and(
            eq(productCategories.id, id),
            eq(productCategories.salonId, salonId)
          ));
          return category || void 0;
        } else {
          const [category] = await db.select().from(productCategories).where(eq(productCategories.id, id));
          return category || void 0;
        }
      }
      async getProductCategoriesBySalonId(salonId) {
        return await db.select().from(productCategories).where(and(
          eq(productCategories.salonId, salonId),
          eq(productCategories.isActive, 1)
        )).orderBy(productCategories.sortOrder, productCategories.name);
      }
      async createProductCategory(category) {
        const [newCategory] = await db.insert(productCategories).values(category).returning();
        return newCategory;
      }
      async updateProductCategory(id, salonId, updates) {
        const { salonId: _, ...safeUpdates } = updates;
        if (safeUpdates.parentCategoryId) {
          const parentCategory = await db.select().from(productCategories).where(and(
            eq(productCategories.id, safeUpdates.parentCategoryId),
            eq(productCategories.salonId, salonId)
          )).limit(1);
          if (parentCategory.length === 0) {
            throw new Error("Parent category not found or does not belong to this salon");
          }
        }
        await db.update(productCategories).set(safeUpdates).where(and(
          eq(productCategories.id, id),
          eq(productCategories.salonId, salonId)
        ));
      }
      async deleteProductCategory(id, salonId) {
        const productsWithCategory = await db.select().from(products).where(and(
          eq(products.categoryId, id),
          eq(products.salonId, salonId),
          eq(products.isActive, 1)
        )).limit(1);
        if (productsWithCategory.length > 0) {
          throw new Error("Cannot delete category that has active products. Please reassign or delete products first.");
        }
        await db.update(productCategories).set({ isActive: 0 }).where(and(
          eq(productCategories.id, id),
          eq(productCategories.salonId, salonId)
        ));
      }
      async createDefaultProductCategories(salonId) {
        const defaultCategories = [
          { salonId, name: "Hair Care Products", description: "Shampoos, conditioners, styling products", sortOrder: 1, isActive: 1 },
          { salonId, name: "Skin Care Products", description: "Cleansers, moisturizers, serums", sortOrder: 2, isActive: 1 },
          { salonId, name: "Nail Care Products", description: "Polishes, treatments, tools", sortOrder: 3, isActive: 1 },
          { salonId, name: "Hair Color & Treatments", description: "Hair dyes, bleaches, treatments", sortOrder: 4, isActive: 1 },
          { salonId, name: "Styling Tools", description: "Dryers, straighteners, curling irons", sortOrder: 5, isActive: 1 },
          { salonId, name: "Professional Tools", description: "Scissors, razors, combs", sortOrder: 6, isActive: 1 },
          { salonId, name: "Salon Supplies", description: "Towels, capes, foils, disposables", sortOrder: 7, isActive: 1 },
          { salonId, name: "Spa & Massage Products", description: "Oils, lotions, aromatherapy", sortOrder: 8, isActive: 1 }
        ];
        const createdCategories = await db.insert(productCategories).values(defaultCategories).returning();
        return createdCategories;
      }
      // =================================
      // VENDOR OPERATIONS
      // =================================
      async getVendor(id, salonId) {
        if (salonId) {
          const [vendor] = await db.select().from(vendors).where(and(
            eq(vendors.id, id),
            eq(vendors.salonId, salonId)
          ));
          return vendor || void 0;
        } else {
          const [vendor] = await db.select().from(vendors).where(eq(vendors.id, id));
          return vendor || void 0;
        }
      }
      async getVendorsBySalonId(salonId) {
        return await db.select().from(vendors).where(and(
          eq(vendors.salonId, salonId),
          eq(vendors.status, "active")
        )).orderBy(vendors.name);
      }
      async createVendor(vendor) {
        const [newVendor] = await db.insert(vendors).values(vendor).returning();
        return newVendor;
      }
      async updateVendor(id, salonId, updates) {
        const { salonId: _, ...safeUpdates } = updates;
        await db.update(vendors).set({
          ...safeUpdates,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(and(
          eq(vendors.id, id),
          eq(vendors.salonId, salonId)
        ));
      }
      async deleteVendor(id, salonId) {
        const productsWithVendor = await db.select().from(products).where(and(
          eq(products.vendorId, id),
          eq(products.salonId, salonId),
          eq(products.isActive, 1)
        )).limit(1);
        if (productsWithVendor.length > 0) {
          throw new Error("Cannot delete vendor that has active products. Please reassign or delete products first.");
        }
        const pendingPOs = await db.select().from(purchaseOrders).where(and(
          eq(purchaseOrders.vendorId, id),
          eq(purchaseOrders.salonId, salonId),
          or(
            eq(purchaseOrders.status, "draft"),
            eq(purchaseOrders.status, "approved")
          )
        )).limit(1);
        if (pendingPOs.length > 0) {
          throw new Error("Cannot delete vendor with pending purchase orders. Please complete or cancel them first.");
        }
        await db.update(vendors).set({
          status: "inactive",
          updatedAt: /* @__PURE__ */ new Date()
        }).where(and(
          eq(vendors.id, id),
          eq(vendors.salonId, salonId)
        ));
      }
      // =================================
      // PRODUCT OPERATIONS
      // =================================
      async getProduct(id, salonId) {
        if (salonId) {
          const [product] = await db.select().from(products).where(and(
            eq(products.id, id),
            eq(products.salonId, salonId)
          ));
          return product || void 0;
        } else {
          const [product] = await db.select().from(products).where(eq(products.id, id));
          return product || void 0;
        }
      }
      async getProductsBySalonId(salonId, filters) {
        const conditions = [eq(products.salonId, salonId)];
        if (filters) {
          if (filters.categoryId) {
            conditions.push(eq(products.categoryId, filters.categoryId));
          }
          if (filters.vendorId) {
            conditions.push(eq(products.vendorId, filters.vendorId));
          }
          if (filters.isActive !== void 0) {
            conditions.push(eq(products.isActive, filters.isActive ? 1 : 0));
          } else {
            conditions.push(eq(products.isActive, 1));
          }
          if (filters.lowStock) {
            conditions.push(sql2`${products.currentStock} <= ${products.minimumStock}`);
          }
          if (filters.search) {
            const searchTerm = `%${filters.search}%`;
            conditions.push(
              or(
                sql2`${products.name} ILIKE ${searchTerm}`,
                sql2`${products.sku} ILIKE ${searchTerm}`,
                sql2`${products.brand} ILIKE ${searchTerm}`,
                sql2`${products.barcode} ILIKE ${searchTerm}`
              )
            );
          }
        } else {
          conditions.push(eq(products.isActive, 1));
        }
        return await db.select().from(products).where(and(...conditions)).orderBy(products.name);
      }
      async getProductsByCategory(salonId, categoryId) {
        return await db.select().from(products).where(and(
          eq(products.salonId, salonId),
          eq(products.categoryId, categoryId),
          eq(products.isActive, 1)
        )).orderBy(products.name);
      }
      async getLowStockProducts(salonId) {
        return await db.select().from(products).where(and(
          eq(products.salonId, salonId),
          eq(products.isActive, 1),
          eq(products.lowStockAlert, 1),
          sql2`${products.currentStock} <= ${products.minimumStock}`
        )).orderBy(products.name);
      }
      async getProductBySKU(sku, salonId) {
        const [product] = await db.select().from(products).where(and(
          eq(products.sku, sku),
          eq(products.salonId, salonId)
        )).limit(1);
        return product || void 0;
      }
      async createProduct(product) {
        const existingProduct = await this.getProductBySKU(product.sku, product.salonId);
        if (existingProduct) {
          throw new Error(`Product with SKU '${product.sku}' already exists in this salon`);
        }
        const [newProduct] = await db.insert(products).values(product).returning();
        return newProduct;
      }
      async updateProduct(id, salonId, updates) {
        const { salonId: _, currentStock, ...safeUpdates } = updates;
        if (safeUpdates.sku) {
          const existingProduct = await this.getProductBySKU(safeUpdates.sku, salonId);
          if (existingProduct && existingProduct.id !== id) {
            throw new Error(`Product with SKU '${safeUpdates.sku}' already exists in this salon`);
          }
        }
        if (currentStock !== void 0) {
          throw new Error("Cannot update stock directly. Use stock movements instead.");
        }
        await db.update(products).set(safeUpdates).where(and(
          eq(products.id, id),
          eq(products.salonId, salonId)
        ));
      }
      async deleteProduct(id, salonId) {
        const pendingPOItems = await db.select().from(purchaseOrderItems).innerJoin(purchaseOrders, eq(purchaseOrderItems.purchaseOrderId, purchaseOrders.id)).where(and(
          eq(purchaseOrderItems.productId, id),
          eq(purchaseOrders.salonId, salonId),
          or(
            eq(purchaseOrders.status, "draft"),
            eq(purchaseOrders.status, "approved")
          )
        )).limit(1);
        if (pendingPOItems.length > 0) {
          throw new Error("Cannot delete product with pending purchase orders. Please complete or cancel them first.");
        }
        await db.update(products).set({ isActive: 0 }).where(and(
          eq(products.id, id),
          eq(products.salonId, salonId)
        ));
      }
      async getStockMovement(id, salonId) {
        if (salonId) {
          const [movement] = await db.select().from(stockMovements).where(and(
            eq(stockMovements.id, id),
            eq(stockMovements.salonId, salonId)
          ));
          return movement || void 0;
        } else {
          const [movement] = await db.select().from(stockMovements).where(eq(stockMovements.id, id));
          return movement || void 0;
        }
      }
      async getStockMovementsByProduct(productId, salonId) {
        return await db.select().from(stockMovements).where(and(
          eq(stockMovements.productId, productId),
          eq(stockMovements.salonId, salonId)
        )).orderBy(desc(stockMovements.createdAt));
      }
      async getStockMovementsBySalonId(salonId, filters) {
        const conditions = [eq(stockMovements.salonId, salonId)];
        if (filters) {
          if (filters.productId) {
            conditions.push(eq(stockMovements.productId, filters.productId));
          }
          if (filters.type) {
            conditions.push(eq(stockMovements.type, filters.type));
          }
          if (filters.referenceType) {
            conditions.push(eq(stockMovements.referenceType, filters.referenceType));
          }
          if (filters.staffId) {
            conditions.push(eq(stockMovements.staffId, filters.staffId));
          }
          if (filters.startDate) {
            conditions.push(sql2`${stockMovements.createdAt} >= ${filters.startDate}`);
          }
          if (filters.endDate) {
            conditions.push(sql2`${stockMovements.createdAt} <= ${filters.endDate}`);
          }
        }
        return await db.select().from(stockMovements).where(and(...conditions)).orderBy(desc(stockMovements.createdAt)).limit(filters?.limit || 100);
      }
      async createStockMovement(movement, options) {
        const quantity = parseFloat(movement.quantity.toString());
        const isIncrease = ["purchase", "return", "adjustment-in"].includes(movement.type);
        const isDecrease = ["usage", "waste", "adjustment-out", "transfer"].includes(movement.type);
        const isAdjustment = movement.type === "adjustment";
        if (!isIncrease && !isDecrease && !isAdjustment) {
          throw new Error(`Invalid stock movement type: ${movement.type}`);
        }
        return await db.transaction(async (tx) => {
          const [product] = await tx.select().from(products).where(and(
            eq(products.id, movement.productId),
            eq(products.salonId, movement.salonId)
          )).for("update");
          if (!product) {
            throw new Error("Product not found or does not belong to this salon");
          }
          const currentStock = parseFloat(product.currentStock);
          const previousStock = currentStock;
          let newStock;
          if (isIncrease) {
            newStock = currentStock + quantity;
          } else if (isDecrease) {
            newStock = currentStock - quantity;
          } else {
            newStock = currentStock + quantity;
          }
          if (newStock < 0 && !options?.allowNegativeStock) {
            throw new Error(`Insufficient stock. Current: ${currentStock}, Requested: ${Math.abs(quantity)}. Available: ${currentStock}`);
          }
          const [newMovement] = await tx.insert(stockMovements).values({
            ...movement,
            previousStock: previousStock.toString(),
            newStock: newStock.toString()
          }).returning();
          await tx.update(products).set({ currentStock: newStock.toString() }).where(and(
            eq(products.id, movement.productId),
            eq(products.salonId, movement.salonId)
          ));
          return newMovement;
        });
      }
      async getPurchaseOrder(id, salonId) {
        if (salonId) {
          const [po] = await db.select().from(purchaseOrders).where(and(
            eq(purchaseOrders.id, id),
            eq(purchaseOrders.salonId, salonId)
          ));
          return po || void 0;
        } else {
          const [po] = await db.select().from(purchaseOrders).where(eq(purchaseOrders.id, id));
          return po || void 0;
        }
      }
      async getPurchaseOrdersBySalonId(salonId, filters) {
        const conditions = [eq(purchaseOrders.salonId, salonId)];
        if (filters) {
          if (filters.status) {
            conditions.push(eq(purchaseOrders.status, filters.status));
          }
          if (filters.vendorId) {
            conditions.push(eq(purchaseOrders.vendorId, filters.vendorId));
          }
          if (filters.startDate) {
            conditions.push(sql2`${purchaseOrders.orderDate} >= ${filters.startDate}`);
          }
          if (filters.endDate) {
            conditions.push(sql2`${purchaseOrders.orderDate} <= ${filters.endDate}`);
          }
        }
        return await db.select().from(purchaseOrders).where(and(...conditions)).orderBy(desc(purchaseOrders.orderDate)).limit(filters?.limit || 100);
      }
      async getPurchaseOrderItems(purchaseOrderId, salonId) {
        const po = await this.getPurchaseOrder(purchaseOrderId, salonId);
        if (!po) {
          throw new Error("Purchase order not found or does not belong to this salon");
        }
        const items = await db.select({
          id: purchaseOrderItems.id,
          purchaseOrderId: purchaseOrderItems.purchaseOrderId,
          productId: purchaseOrderItems.productId,
          quantity: purchaseOrderItems.quantity,
          unit: purchaseOrderItems.unit,
          unitCostInPaisa: purchaseOrderItems.unitCostInPaisa,
          totalCostInPaisa: purchaseOrderItems.totalCostInPaisa,
          receivedQuantity: purchaseOrderItems.receivedQuantity,
          notes: purchaseOrderItems.notes,
          createdAt: purchaseOrderItems.createdAt,
          product_name: products.name,
          sku: products.sku
        }).from(purchaseOrderItems).leftJoin(products, eq(purchaseOrderItems.productId, products.id)).where(eq(purchaseOrderItems.purchaseOrderId, purchaseOrderId)).orderBy(purchaseOrderItems.createdAt);
        return items;
      }
      async createPurchaseOrder(po, items) {
        if (!items || items.length === 0) {
          throw new Error("Purchase order must have at least one item");
        }
        const vendor = await this.getVendor(po.vendorId, po.salonId);
        if (!vendor) {
          throw new Error("Vendor not found or does not belong to this salon");
        }
        for (const item of items) {
          const product = await this.getProduct(item.productId, po.salonId);
          if (!product) {
            throw new Error(`Product ${item.productId} not found or does not belong to this salon`);
          }
        }
        const subtotal = items.reduce((sum4, item) => sum4 + parseInt(item.totalCostInPaisa.toString()), 0);
        const tax = po.taxInPaisa || 0;
        const shipping = po.shippingInPaisa || 0;
        const discount = po.discountInPaisa || 0;
        const total = subtotal + tax + shipping - discount;
        return await db.transaction(async (tx) => {
          const uuid = randomUUID().replace(/-/g, "").substring(0, 12).toUpperCase();
          const orderNumber = `PO-${Date.now().toString(36)}-${uuid}`;
          const [newPO] = await tx.insert(purchaseOrders).values({
            ...po,
            orderNumber,
            subtotalInPaisa: subtotal,
            totalInPaisa: total,
            status: "draft"
          }).returning();
          const itemsWithPOId = items.map((item) => ({
            ...item,
            purchaseOrderId: newPO.id
          }));
          const newItems = await tx.insert(purchaseOrderItems).values(itemsWithPOId).returning();
          return { po: newPO, items: newItems };
        });
      }
      async updatePurchaseOrder(id, salonId, updates) {
        const po = await this.getPurchaseOrder(id, salonId);
        if (!po) {
          throw new Error("Purchase order not found or does not belong to this salon");
        }
        if (po.status !== "draft") {
          throw new Error("Only draft purchase orders can be updated");
        }
        const { salonId: _, createdBy, approvedBy, receivedBy, ...safeUpdates } = updates;
        await db.update(purchaseOrders).set({ ...safeUpdates, updatedAt: /* @__PURE__ */ new Date() }).where(and(
          eq(purchaseOrders.id, id),
          eq(purchaseOrders.salonId, salonId)
        ));
      }
      async approvePurchaseOrder(id, salonId, approvedBy) {
        const po = await this.getPurchaseOrder(id, salonId);
        if (!po) {
          throw new Error("Purchase order not found or does not belong to this salon");
        }
        if (po.status !== "draft") {
          throw new Error("Only draft purchase orders can be approved");
        }
        await db.update(purchaseOrders).set({
          status: "approved",
          approvedBy,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(and(
          eq(purchaseOrders.id, id),
          eq(purchaseOrders.salonId, salonId)
        ));
      }
      async receivePurchaseOrder(id, salonId, receivedBy, receivedItems) {
        const po = await this.getPurchaseOrder(id, salonId);
        if (!po) {
          throw new Error("Purchase order not found or does not belong to this salon");
        }
        if (po.status !== "delivered") {
          throw new Error("Only delivered purchase orders can be received");
        }
        const items = await this.getPurchaseOrderItems(id, salonId);
        await db.transaction(async (tx) => {
          await tx.update(purchaseOrders).set({
            status: "received",
            receivedBy,
            actualDeliveryDate: /* @__PURE__ */ new Date(),
            updatedAt: /* @__PURE__ */ new Date()
          }).where(and(
            eq(purchaseOrders.id, id),
            eq(purchaseOrders.salonId, salonId)
          ));
          for (const receivedItem of receivedItems) {
            const item = items.find((i) => i.id === receivedItem.itemId);
            if (!item) {
              throw new Error(`Purchase order item ${receivedItem.itemId} not found`);
            }
            await tx.update(purchaseOrderItems).set({ receivedQuantity: receivedItem.receivedQuantity }).where(eq(purchaseOrderItems.id, receivedItem.itemId));
            if (parseFloat(receivedItem.receivedQuantity) > 0) {
              const [product] = await tx.select().from(products).where(and(
                eq(products.id, item.productId),
                eq(products.salonId, salonId)
              )).for("update");
              if (!product) {
                throw new Error(`Product ${item.productId} not found`);
              }
              const currentStock = parseFloat(product.currentStock);
              const receivedQty = parseFloat(receivedItem.receivedQuantity);
              const newStock = currentStock + receivedQty;
              const [staffRecord] = await tx.select().from(staff).where(and(
                eq(staff.userId, receivedBy),
                eq(staff.salonId, salonId)
              )).limit(1);
              await tx.insert(stockMovements).values({
                salonId,
                productId: item.productId,
                type: "purchase",
                quantity: receivedItem.receivedQuantity,
                unit: item.unit,
                unitCostInPaisa: item.unitCostInPaisa,
                totalCostInPaisa: item.totalCostInPaisa,
                previousStock: currentStock.toString(),
                newStock: newStock.toString(),
                reason: "Purchase order received",
                reference: po.orderNumber,
                referenceId: po.id,
                referenceType: "purchase_order",
                staffId: staffRecord?.id || null
              });
              await tx.update(products).set({ currentStock: newStock.toString() }).where(and(
                eq(products.id, item.productId),
                eq(products.salonId, salonId)
              ));
            }
          }
        });
      }
      async updatePurchaseOrderStatus(id, status) {
        await db.update(purchaseOrders).set({ status, updatedAt: /* @__PURE__ */ new Date() }).where(eq(purchaseOrders.id, id));
      }
      async deletePurchaseOrder(id, salonId) {
        const po = await this.getPurchaseOrder(id, salonId);
        if (!po) {
          throw new Error("Purchase order not found or does not belong to this salon");
        }
        if (po.status !== "draft") {
          throw new Error("Only draft purchase orders can be deleted");
        }
        await db.delete(purchaseOrders).where(and(
          eq(purchaseOrders.id, id),
          eq(purchaseOrders.salonId, salonId)
        ));
      }
      async getPurchaseOrderItem(id) {
        return void 0;
      }
      async getPurchaseOrderItemsByOrderId(orderId) {
        return [];
      }
      async getProductUsage(id) {
        return void 0;
      }
      async getProductUsageByBooking(bookingId) {
        return [];
      }
      async getReorderRule(id) {
        return void 0;
      }
      async getReorderRulesBySalonId(salonId) {
        return [];
      }
      async getReorderRulesByProduct(productId) {
        return [];
      }
      async checkReorderRules(salonId) {
        return [];
      }
      async getInventoryAdjustment(id) {
        return void 0;
      }
      async getInventoryAdjustmentsBySalonId(salonId) {
        return [];
      }
      async approveInventoryAdjustment(id, approvedBy) {
      }
      async getInventoryAdjustmentItem(id) {
        return void 0;
      }
      async getInventoryAdjustmentItemsByAdjustmentId(adjustmentId) {
        return [];
      }
      async getInventoryAnalytics(salonId, period) {
        return {};
      }
      // A/B testing minimal stubs
      async startAbTestCampaign(id) {
      }
      async pauseAbTestCampaign(id) {
      }
      async stopAbTestCampaign(id, winnerVariantId) {
      }
      async getTestVariantsByCampaignId(campaignId) {
        return [];
      }
      async getTestMetricsByCampaignId(campaignId) {
        return [];
      }
      async getTestResultsByCampaignId(campaignId) {
        return [];
      }
      async getTestResultsByVariantId(variantId) {
        return [];
      }
      async calculateAbTestResults(campaignId) {
        return {};
      }
      // Automation minimal stubs
      async getAutomationConfiguration(id) {
        return void 0;
      }
      async getAutomationConfigurationsBySalonId(salonId) {
        return [];
      }
      async getVariantGenerationRule(id) {
        return void 0;
      }
      async getVariantGenerationRulesByConfigId(configId) {
        return [];
      }
      async getPerformanceMonitoringSetting(id) {
        return void 0;
      }
      async getPerformanceMonitoringSettingsByConfigId(configId) {
        return [];
      }
      async getOptimizationRecommendation(id) {
        return void 0;
      }
      async getOptimizationRecommendationsBySalonId(salonId) {
        return [];
      }
      async getAutomatedActionLog(id) {
        return void 0;
      }
      async getAutomatedActionLogsByConfigId(configId) {
        return [];
      }
      async getCampaignOptimizationInsight(id) {
        return void 0;
      }
      async getCampaignOptimizationInsightsByCampaignId(campaignId) {
        return [];
      }
      async generateVariantsForCampaign(campaignId, count11) {
        return [];
      }
      async optimizeCampaignAutomatically(campaignId) {
        return {};
      }
      async monitorCampaignPerformance(campaignId) {
        return {};
      }
      async getAutomationInsights(salonId, period) {
        return {};
      }
      // Additional stub methods for interface compliance
      async getCustomerInsights(salonId, customerId) {
        return {
          totalCustomers: 0,
          newCustomers: 0,
          returningCustomers: 0,
          topSpenders: [],
          customerSegments: [],
          communicationPreferences: { email: 0, sms: 0, push: 0 },
          stats: { totalBookings: 0, totalSpentPaisa: 0, memberSince: "", lastBookingDate: "", favoriteService: "" }
        };
      }
      // ==================== SUPER ADMIN METHODS ====================
      async getPlatformStats(period) {
        const totalBookingsResult = await db.select({ count: sql2`count(*)::int` }).from(bookings);
        const totalBookings = totalBookingsResult[0]?.count || 0;
        const totalJobCardsResult = await db.select({ count: sql2`count(*)::int` }).from(jobCards);
        const totalJobCards = totalJobCardsResult[0]?.count || 0;
        const jobCardRevenueResult = await db.select({
          sum: sql2`COALESCE(SUM(${jobCards.totalAmountPaisa}), 0)`
        }).from(jobCards).where(
          and(
            eq(jobCards.status, "completed"),
            eq(jobCards.paymentStatus, "paid")
          )
        );
        const jobCardRevenue = parseFloat(String(jobCardRevenueResult[0]?.sum || 0));
        const bookingRevenueResult = await db.select({
          sum: sql2`COALESCE(SUM(${bookings.totalAmountPaisa}), 0)`
        }).from(bookings).where(
          and(
            eq(bookings.status, "completed"),
            sql2`NOT EXISTS (SELECT 1 FROM job_cards WHERE job_cards.booking_id = ${bookings.id})`
          )
        );
        const bookingRevenue = parseFloat(String(bookingRevenueResult[0]?.sum || 0));
        const totalRevenue = Math.round(jobCardRevenue + bookingRevenue);
        const configResult = await db.select().from(platformConfig).where(eq(platformConfig.configKey, "payment_settings")).limit(1);
        let commissionPercent = 10;
        if (configResult[0]?.configValue) {
          try {
            const paymentSettings = configResult[0].configValue;
            if (paymentSettings.defaultCommissionPercent) {
              commissionPercent = paymentSettings.defaultCommissionPercent;
            }
          } catch (e) {
          }
        }
        const totalCommission = Math.round(totalRevenue * (commissionPercent / 100));
        const totalUsersResult = await db.select({ count: sql2`count(*)::int` }).from(users);
        const totalUsers = totalUsersResult[0]?.count || 0;
        const totalSalonsResult = await db.select({ count: sql2`count(*)::int` }).from(salons);
        const totalSalons = totalSalonsResult[0]?.count || 0;
        const pendingApprovalsResult = await db.select({ count: sql2`count(*)::int` }).from(salons).where(eq(salons.approvalStatus, "pending"));
        const pendingApprovals = pendingApprovalsResult[0]?.count || 0;
        const activeUsersResult = await db.select({ count: sql2`count(*)::int` }).from(users).where(eq(users.isActive, 1));
        const activeUsers = activeUsersResult[0]?.count || 0;
        const activeOffersResult = await db.select({ count: sql2`count(*)::int` }).from(platformOffers).where(
          and(
            eq(platformOffers.isActive, 1),
            eq(platformOffers.approvalStatus, "approved"),
            lte(platformOffers.validFrom, sql2`NOW()`),
            gte(platformOffers.validUntil, sql2`NOW()`)
          )
        );
        const activeOffers = activeOffersResult[0]?.count || 0;
        const bookingTrends = await db.select({
          date: sql2`DATE(${jobCards.checkInAt})`,
          count: sql2`count(*)::int`,
          revenue: sql2`COALESCE(SUM(CASE WHEN ${jobCards.status} = 'completed' AND ${jobCards.paymentStatus} = 'paid' THEN ${jobCards.totalAmountPaisa} ELSE 0 END), 0)`
        }).from(jobCards).where(gte(jobCards.checkInAt, sql2`NOW() - INTERVAL '7 days'`)).groupBy(sql2`DATE(${jobCards.checkInAt})`).orderBy(sql2`DATE(${jobCards.checkInAt})`);
        return {
          totalBookings,
          totalRevenue,
          totalCommission,
          totalJobCards,
          totalUsers,
          totalSalons,
          pendingApprovals,
          activeUsers,
          activeOffers,
          bookingTrends: bookingTrends.map((t) => ({
            date: t.date,
            count: t.count,
            revenue: parseFloat(String(t.revenue))
          }))
        };
      }
      async getAllSalonsForAdmin(filters) {
        let query = db.select({
          salon: salons,
          totalBookings: sql2`COALESCE(COUNT(DISTINCT ${bookings.id}), 0)::int`,
          totalRevenue: sql2`COALESCE(SUM(${bookings.totalAmountPaisa}), 0)::int`,
          ownerName: sql2`CONCAT(${users.firstName}, ' ', ${users.lastName})`
        }).from(salons).leftJoin(bookings, eq(salons.id, bookings.salonId)).leftJoin(users, eq(salons.ownerId, users.id)).groupBy(salons.id, users.id).$dynamic();
        if (filters?.approvalStatus) {
          query = query.where(eq(salons.approvalStatus, filters.approvalStatus));
        }
        if (filters?.city) {
          query = query.where(eq(salons.city, filters.city));
        }
        if (filters?.search) {
          query = query.where(sql2`${salons.name} ILIKE ${`%${filters.search}%`}`);
        }
        const results = await query;
        return results.map((r) => ({
          ...r.salon,
          totalBookings: r.totalBookings,
          totalRevenue: r.totalRevenue,
          ownerName: r.ownerName
        }));
      }
      async approveSalon(salonId, approvedBy) {
        await db.update(salons).set({
          approvalStatus: "approved",
          approvedAt: /* @__PURE__ */ new Date(),
          approvedBy
        }).where(eq(salons.id, salonId));
      }
      async rejectSalon(salonId, reason, rejectedBy) {
        await db.update(salons).set({
          approvalStatus: "rejected",
          rejectionReason: reason,
          approvedBy: rejectedBy,
          approvedAt: /* @__PURE__ */ new Date()
        }).where(eq(salons.id, salonId));
      }
      async toggleSalonStatus(salonId, isActive, options) {
        const updateData = {
          isActive: isActive ? 1 : 0
        };
        if (isActive) {
          updateData.disabledAt = null;
          updateData.disabledReason = null;
          updateData.disabledBy = null;
          updateData.disabledBySuperAdmin = 0;
        } else {
          updateData.disabledAt = /* @__PURE__ */ new Date();
          updateData.disabledReason = options?.disabledReason || "Temporarily paused by owner";
          updateData.disabledBy = options?.disabledBy || null;
          updateData.disabledBySuperAdmin = 0;
        }
        const result = await db.update(salons).set(updateData).where(
          and(
            eq(salons.id, salonId),
            eq(salons.disabledBySuperAdmin, 0)
            // Only modify if NOT admin-disabled
          )
        );
        const salon = await db.select().from(salons).where(eq(salons.id, salonId)).limit(1);
        if (salon.length === 0) {
          throw new Error("Salon not found");
        }
        if (salon[0].isActive !== (isActive ? 1 : 0)) {
          if (salon[0].disabledBySuperAdmin === 1) {
            throw new Error("Cannot modify salon: This salon was disabled by a platform administrator. Please contact support.");
          }
        }
      }
      async toggleSalonStatusBySuperAdmin(salonId, isActive, adminId, reason) {
        const updateData = {
          isActive: isActive ? 1 : 0
        };
        if (isActive) {
          updateData.disabledBySuperAdmin = 0;
          updateData.disabledAt = null;
          updateData.disabledReason = null;
          updateData.disabledBy = null;
        } else {
          updateData.disabledBySuperAdmin = 1;
          updateData.disabledAt = /* @__PURE__ */ new Date();
          updateData.disabledReason = reason || "Disabled by platform administrator";
          updateData.disabledBy = adminId;
        }
        await db.update(salons).set(updateData).where(eq(salons.id, salonId));
      }
      async getAllUsersForAdmin(filters) {
        let query = db.select({
          user: users,
          roles: sql2`ARRAY_AGG(DISTINCT ${roles.name})`,
          totalBookings: sql2`COALESCE(COUNT(DISTINCT ${bookings.id}), 0)::int`,
          totalSpent: sql2`COALESCE(SUM(${bookings.totalAmountPaisa}), 0)::int`
        }).from(users).leftJoin(userRoles, eq(users.id, userRoles.userId)).leftJoin(roles, eq(userRoles.roleId, roles.id)).leftJoin(bookings, eq(users.email, bookings.customerEmail)).groupBy(users.id).$dynamic();
        if (filters?.isActive !== void 0) {
          query = query.where(eq(users.isActive, filters.isActive));
        }
        if (filters?.search) {
          query = query.where(sql2`${users.email} ILIKE ${`%${filters.search}%`} OR ${users.firstName} ILIKE ${`%${filters.search}%`}`);
        }
        const results = await query;
        return results.map((r) => ({
          ...r.user,
          roles: r.roles.filter(Boolean),
          totalBookings: r.totalBookings,
          totalSpent: r.totalSpent
        }));
      }
      async toggleUserActive(userId, isActive) {
        await db.update(users).set({ isActive }).where(eq(users.id, userId));
      }
      async getAllBookingsForAdmin(filters) {
        let query = db.select({
          booking: bookings,
          salonName: salons.name,
          serviceName: services.name,
          customerName: bookings.customerName
        }).from(bookings).leftJoin(salons, eq(bookings.salonId, salons.id)).leftJoin(services, eq(bookings.serviceId, services.id)).$dynamic();
        if (filters?.status) {
          query = query.where(eq(bookings.status, filters.status));
        }
        if (filters?.salonId) {
          query = query.where(eq(bookings.salonId, filters.salonId));
        }
        if (filters?.startDate) {
          query = query.where(gte(bookings.bookingDate, filters.startDate));
        }
        if (filters?.endDate) {
          query = query.where(lte(bookings.bookingDate, filters.endDate));
        }
        const results = await query;
        return results.map((r) => ({
          ...r.booking,
          salonName: r.salonName || "",
          serviceName: r.serviceName || "",
          customerName: r.customerName
        }));
      }
      async getSalonBookingStats(salonId) {
        const stats = await db.select({
          totalBookings: sql2`COUNT(*)::int`,
          totalRevenue: sql2`COALESCE(SUM(CASE WHEN ${bookings.status} = 'completed' THEN ${bookings.totalAmountPaisa} ELSE 0 END), 0)::int`,
          cancelledBookings: sql2`COALESCE(SUM(CASE WHEN ${bookings.status} = 'cancelled' THEN 1 ELSE 0 END), 0)::int`,
          averageBookingValue: sql2`COALESCE(AVG(${bookings.totalAmountPaisa}), 0)::int`
        }).from(bookings).where(eq(bookings.salonId, salonId));
        const result = stats[0];
        const cancellationRate = result.totalBookings > 0 ? result.cancelledBookings / result.totalBookings * 100 : 0;
        return {
          totalBookings: result.totalBookings || 0,
          totalRevenue: result.totalRevenue || 0,
          cancellationRate,
          averageBookingValue: result.averageBookingValue || 0
        };
      }
      async getPlatformConfig(key) {
        const [config] = await db.select().from(platformConfig).where(eq(platformConfig.configKey, key));
        return config?.configValue;
      }
      async setPlatformConfig(key, value, updatedBy) {
        const existing = await db.select().from(platformConfig).where(eq(platformConfig.configKey, key));
        if (existing.length > 0) {
          await db.update(platformConfig).set({
            configValue: value,
            updatedBy,
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq(platformConfig.configKey, key));
        } else {
          await db.insert(platformConfig).values({
            configKey: key,
            configValue: value,
            updatedBy
          });
        }
      }
      async createPlatformCommission(data) {
        await db.insert(platformCommissions).values(data);
      }
      async getSalonEarnings(salonId) {
        const commissions2 = await db.select({
          totalEarnings: sql2`COALESCE(SUM(${platformCommissions.bookingAmountPaisa}), 0)::int`,
          platformCommission: sql2`COALESCE(SUM(${platformCommissions.commissionAmountPaisa}), 0)::int`,
          salonShare: sql2`COALESCE(SUM(${platformCommissions.salonEarningsPaisa}), 0)::int`
        }).from(platformCommissions).where(eq(platformCommissions.salonId, salonId));
        const payouts = await db.select({
          paidOut: sql2`COALESCE(SUM(${platformPayouts.amountPaisa}), 0)::int`
        }).from(platformPayouts).where(and(
          eq(platformPayouts.salonId, salonId),
          eq(platformPayouts.status, "paid")
        ));
        const result = commissions2[0];
        const paidOut = payouts[0]?.paidOut || 0;
        const pendingPayout = (result?.salonShare || 0) - paidOut;
        return {
          totalEarnings: result?.totalEarnings || 0,
          platformCommission: result?.platformCommission || 0,
          salonShare: result?.salonShare || 0,
          pendingPayout
        };
      }
      async createPayout(salonId, amount) {
        const [payout] = await db.insert(platformPayouts).values({
          salonId,
          amountPaisa: amount,
          status: "pending"
        }).returning();
        return payout;
      }
      async approvePayout(payoutId, approvedBy) {
        await db.update(platformPayouts).set({
          status: "approved",
          approvedBy,
          approvedAt: /* @__PURE__ */ new Date()
        }).where(eq(platformPayouts.id, payoutId));
      }
      async rejectPayout(payoutId, reason, rejectedBy) {
        await db.update(platformPayouts).set({
          status: "rejected",
          rejectionReason: reason,
          approvedBy: rejectedBy,
          approvedAt: /* @__PURE__ */ new Date()
        }).where(eq(platformPayouts.id, payoutId));
      }
      async getAllPayouts(filters) {
        let query = db.select({
          payout: platformPayouts,
          salonName: salons.name
        }).from(platformPayouts).leftJoin(salons, eq(platformPayouts.salonId, salons.id)).$dynamic();
        if (filters?.status) {
          query = query.where(eq(platformPayouts.status, filters.status));
        }
        if (filters?.salonId) {
          query = query.where(eq(platformPayouts.salonId, filters.salonId));
        }
        const results = await query.orderBy(desc(platformPayouts.createdAt));
        return results.map((r) => ({
          ...r.payout,
          salonName: r.salonName
        }));
      }
      // ==================== OFFERS MANAGEMENT ====================
      async getAllOffers(filters) {
        let query = db.select({
          offer: platformOffers,
          salonName: salons.name
        }).from(platformOffers).leftJoin(salons, eq(platformOffers.salonId, salons.id)).$dynamic();
        const conditions = [];
        if (filters?.status) {
          conditions.push(eq(platformOffers.isActive, filters.status === "active" ? 1 : 0));
        }
        if (filters?.approvalStatus) {
          conditions.push(eq(platformOffers.approvalStatus, filters.approvalStatus));
        }
        if (filters?.isPlatformWide !== void 0) {
          conditions.push(eq(platformOffers.isPlatformWide, filters.isPlatformWide));
        }
        if (filters?.salonId) {
          conditions.push(eq(platformOffers.salonId, filters.salonId));
        }
        if (filters?.ownedBySalonId !== void 0) {
          if (filters.ownedBySalonId === "null") {
            conditions.push(sql2`${platformOffers.ownedBySalonId} IS NULL`);
          } else {
            conditions.push(eq(platformOffers.ownedBySalonId, filters.ownedBySalonId));
          }
        }
        if (conditions.length > 0) {
          query = query.where(and(...conditions));
        }
        const results = await query.orderBy(desc(platformOffers.createdAt));
        return results.map((r) => ({
          ...r.offer,
          salonName: r.salonName || void 0
        }));
      }
      async getOfferById(offerId) {
        const [offer] = await db.select().from(platformOffers).where(eq(platformOffers.id, offerId));
        return offer || void 0;
      }
      async createOffer(data) {
        const [offer] = await db.insert(platformOffers).values(data).returning();
        return offer;
      }
      async updateOffer(offerId, updates) {
        await db.update(platformOffers).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq(platformOffers.id, offerId));
      }
      async approveOffer(offerId, approvedBy) {
        await db.update(platformOffers).set({
          approvalStatus: "approved",
          approvedBy,
          approvedAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq(platformOffers.id, offerId));
      }
      async rejectOffer(offerId, reason, rejectedBy) {
        await db.update(platformOffers).set({
          approvalStatus: "rejected",
          approvalNotes: reason,
          rejectedBy,
          rejectedAt: /* @__PURE__ */ new Date(),
          isActive: 0,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq(platformOffers.id, offerId));
      }
      async toggleOfferStatus(offerId, isActive) {
        await db.update(platformOffers).set({ isActive, updatedAt: /* @__PURE__ */ new Date() }).where(eq(platformOffers.id, offerId));
      }
      async deleteOffer(offerId) {
        await db.delete(platformOffers).where(eq(platformOffers.id, offerId));
      }
      // Salon-specific offer methods with ownership validation
      async getSalonOffers(salonId) {
        const offers = await db.select().from(platformOffers).where(eq(platformOffers.ownedBySalonId, salonId)).orderBy(desc(platformOffers.createdAt));
        return offers;
      }
      async createSalonOffer(salonId, data, createdBy) {
        const validFrom = data.validFrom instanceof Date ? data.validFrom : new Date(data.validFrom);
        const validUntil = data.validUntil instanceof Date ? data.validUntil : new Date(data.validUntil);
        const offerData = {
          salonId,
          ownedBySalonId: salonId,
          title: data.title,
          description: data.description,
          discountType: data.discountType,
          discountValue: data.discountValue,
          minimumPurchase: data.minimumPurchase,
          maxDiscount: data.maxDiscount,
          validFrom,
          validUntil,
          isActive: data.isActive,
          isPlatformWide: 0,
          // Salon offers are never platform-wide
          usageLimit: data.usageLimit,
          imageUrl: data.imageUrl,
          // Promotional image for offer card
          approvalStatus: "approved",
          // ALWAYS auto-approved
          autoApproved: 1,
          requiresApprovalOnEdit: 0,
          approvedBy: createdBy,
          // Set to the user creating the offer (auto-approved)
          approvedAt: /* @__PURE__ */ new Date(),
          createdBy
        };
        const [offer] = await db.insert(platformOffers).values(offerData).returning();
        return offer;
      }
      async updateSalonOffer(offerId, salonId, updates, editedBy) {
        const offer = await this.getOfferById(offerId);
        if (!offer || offer.ownedBySalonId !== salonId) {
          throw new Error("Unauthorized: Offer not owned by this salon");
        }
        const config = await this.getPlatformConfig("offerApprovalSettings");
        const autoApproveSalonOffers = config?.autoApproveSalonOffers ?? true;
        const needsReapproval = offer.requiresApprovalOnEdit === 1 || !autoApproveSalonOffers;
        const updateData = {
          ...updates,
          lastEditedBy: editedBy,
          lastEditedAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        };
        if (needsReapproval && offer.approvalStatus === "approved") {
          updateData.approvalStatus = "pending";
          updateData.autoApproved = 0;
        }
        await db.update(platformOffers).set(updateData).where(eq(platformOffers.id, offerId));
      }
      async toggleSalonOfferStatus(offerId, salonId, isActive) {
        const offer = await this.getOfferById(offerId);
        if (!offer || offer.ownedBySalonId !== salonId) {
          throw new Error("Unauthorized: Offer not owned by this salon");
        }
        await db.update(platformOffers).set({ isActive, updatedAt: /* @__PURE__ */ new Date() }).where(eq(platformOffers.id, offerId));
      }
      async deleteSalonOffer(offerId, salonId) {
        const offer = await this.getOfferById(offerId);
        if (!offer || offer.ownedBySalonId !== salonId) {
          throw new Error("Unauthorized: Offer not owned by this salon");
        }
        await db.delete(platformOffers).where(eq(platformOffers.id, offerId));
      }
      // Digital Wallet Management
      async getUserWallet(userId) {
        const [wallet] = await db.select().from(userWallets).where(eq(userWallets.userId, userId));
        return wallet || null;
      }
      async createUserWallet(userId) {
        const [wallet] = await db.insert(userWallets).values({
          userId,
          balanceInPaisa: 0,
          lifetimeEarnedInPaisa: 0,
          lifetimeSpentInPaisa: 0
        }).returning();
        return wallet;
      }
      async addWalletCredit(userId, amountInPaisa, reason, bookingId, offerId) {
        let wallet = await this.getUserWallet(userId);
        if (!wallet) {
          wallet = await this.createUserWallet(userId);
        }
        await db.update(userWallets).set({
          balanceInPaisa: wallet.balanceInPaisa + amountInPaisa,
          lifetimeEarnedInPaisa: wallet.lifetimeEarnedInPaisa + amountInPaisa,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq(userWallets.id, wallet.id));
        await db.insert(walletTransactions).values({
          walletId: wallet.id,
          userId,
          type: "credit",
          amountInPaisa,
          reason,
          bookingId: bookingId || null,
          offerId: offerId || null
        });
      }
      async deductWalletBalance(userId, amountInPaisa, reason, bookingId) {
        const wallet = await this.getUserWallet(userId);
        if (!wallet || wallet.balanceInPaisa < amountInPaisa) {
          throw new Error("Insufficient wallet balance");
        }
        await db.update(userWallets).set({
          balanceInPaisa: wallet.balanceInPaisa - amountInPaisa,
          lifetimeSpentInPaisa: wallet.lifetimeSpentInPaisa + amountInPaisa,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq(userWallets.id, wallet.id));
        await db.insert(walletTransactions).values({
          walletId: wallet.id,
          userId,
          type: "debit",
          amountInPaisa,
          reason,
          bookingId: bookingId || null
        });
      }
      async getWalletTransactions(userId) {
        const transactions = await db.select().from(walletTransactions).where(eq(walletTransactions.userId, userId)).orderBy(desc(walletTransactions.createdAt));
        return transactions;
      }
      // Launch Offers & Eligibility
      async getActiveLaunchOffers() {
        const now = /* @__PURE__ */ new Date();
        const offers = await db.select().from(launchOffers).where(
          and(
            eq(launchOffers.isActive, 1),
            lte(launchOffers.validFrom, now),
            gte(launchOffers.validUntil, now)
          )
        );
        return offers;
      }
      async getUserOfferEligibility(userId, offerId) {
        const [offer] = await db.select().from(launchOffers).where(eq(launchOffers.id, offerId));
        if (!offer) {
          return { eligible: false, usageCount: 0, maxUsage: 0, reason: "Offer not found" };
        }
        if (offer.isActive === 0) {
          return { eligible: false, usageCount: 0, maxUsage: offer.maxUsagePerUser || 0, reason: "Offer is inactive" };
        }
        const now = /* @__PURE__ */ new Date();
        if (now < offer.validFrom || now > offer.validUntil) {
          return { eligible: false, usageCount: 0, maxUsage: offer.maxUsagePerUser || 0, reason: "Offer expired or not yet valid" };
        }
        const usageRecords = await db.select().from(userOfferUsage).where(and(
          eq(userOfferUsage.userId, userId),
          eq(userOfferUsage.offerId, offerId)
        ));
        const usageCount = usageRecords.length;
        const maxUsage = offer.maxUsagePerUser || 999;
        if (usageCount >= maxUsage) {
          return { eligible: false, usageCount, maxUsage, reason: "Usage limit reached" };
        }
        return { eligible: true, usageCount, maxUsage };
      }
      async trackOfferUsage(userId, offerId, bookingId, discountInPaisa, usageNumber) {
        await db.insert(userOfferUsage).values({
          userId,
          offerId,
          bookingId,
          discountAppliedInPaisa: discountInPaisa,
          usageNumber
        });
      }
      async getCustomerOffers(userId, salonId) {
        const now = /* @__PURE__ */ new Date();
        const conditions = [
          eq(platformOffers.isActive, 1),
          eq(platformOffers.approvalStatus, "approved"),
          lte(platformOffers.validFrom, now),
          gte(platformOffers.validUntil, now)
        ];
        if (salonId) {
          conditions.push(
            or(
              eq(platformOffers.isPlatformWide, 1),
              eq(platformOffers.salonId, salonId)
            )
          );
        } else {
          conditions.push(eq(platformOffers.isPlatformWide, 1));
        }
        const results = await db.select({
          offer: platformOffers,
          salonName: salons.name
        }).from(platformOffers).leftJoin(salons, eq(platformOffers.salonId, salons.id)).where(and(...conditions)).orderBy(desc(platformOffers.createdAt));
        return results.map((r) => ({
          id: r.offer.id,
          title: r.offer.title,
          description: r.offer.description,
          discountType: r.offer.discountType,
          discountValue: r.offer.discountValue,
          minimumPurchase: r.offer.minimumPurchase,
          maxDiscount: r.offer.maxDiscount,
          isPlatformWide: r.offer.isPlatformWide,
          salonId: r.offer.salonId,
          ownedBySalonId: r.offer.ownedBySalonId,
          validFrom: r.offer.validFrom,
          validUntil: r.offer.validUntil,
          usageLimit: r.offer.usageLimit,
          usageCount: r.offer.usageCount,
          imageUrl: r.offer.imageUrl,
          isActive: r.offer.isActive,
          approvalStatus: r.offer.approvalStatus,
          salonName: r.salonName || void 0
        }));
      }
      async getAllOffersWithSalons() {
        const now = /* @__PURE__ */ new Date();
        const conditions = [
          eq(platformOffers.isActive, 1),
          eq(platformOffers.approvalStatus, "approved"),
          lte(platformOffers.validFrom, now),
          gte(platformOffers.validUntil, now)
        ];
        const results = await db.select({
          offer: platformOffers,
          salon: salons
        }).from(platformOffers).leftJoin(salons, eq(platformOffers.salonId, salons.id)).where(and(...conditions)).orderBy(desc(platformOffers.createdAt));
        return results.map((r) => ({
          id: r.offer.id,
          title: r.offer.title,
          description: r.offer.description,
          discountType: r.offer.discountType,
          discountValue: r.offer.discountValue,
          minimumPurchase: r.offer.minimumPurchase,
          maxDiscount: r.offer.maxDiscount,
          isPlatformWide: r.offer.isPlatformWide,
          salonId: r.offer.salonId,
          validFrom: r.offer.validFrom,
          validUntil: r.offer.validUntil,
          isActive: r.offer.isActive,
          approvalStatus: r.offer.approvalStatus,
          salon: r.salon ? {
            id: r.salon.id,
            name: r.salon.name,
            address: r.salon.address,
            city: r.salon.city,
            state: r.salon.state,
            rating: r.salon.rating,
            reviewCount: r.salon.reviewCount,
            category: r.salon.category,
            images: r.salon.images
          } : null
        }));
      }
      // ===============================================
      // GEOCODING CACHE METHODS - Production-Grade Location Accuracy
      // ===============================================
      async findLocationAlias(normalizedQuery) {
        const [alias] = await db.select({ placeId: locationAliases.placeId }).from(locationAliases).where(eq(locationAliases.normalizedQuery, normalizedQuery)).limit(1);
        return alias || null;
      }
      async getGeocodeLocation(placeId) {
        const [location] = await db.select().from(geocodeLocations).where(eq(geocodeLocations.placeId, placeId)).limit(1);
        return location || null;
      }
      async upsertGeocodeLocation(data) {
        await db.insert(geocodeLocations).values(data).onConflictDoUpdate({
          target: geocodeLocations.placeId,
          set: {
            formattedAddress: data.formattedAddress,
            latitude: data.latitude,
            longitude: data.longitude,
            locationType: data.locationType,
            confidence: data.confidence,
            viewport: data.viewport,
            rawResponse: data.rawResponse,
            verifiedAt: data.verifiedAt,
            expiresAt: data.expiresAt,
            usageCount: sql2`${geocodeLocations.usageCount} + 1`,
            updatedAt: /* @__PURE__ */ new Date()
          }
        });
      }
      async createLocationAlias(data) {
        try {
          await db.insert(locationAliases).values(data);
        } catch (error) {
          if (!(error instanceof Error && error.message.includes("duplicate"))) {
            throw error;
          }
        }
      }
      async incrementLocationUsage(placeId, normalizedQuery) {
        await db.update(geocodeLocations).set({
          usageCount: sql2`${geocodeLocations.usageCount} + 1`,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq(geocodeLocations.placeId, placeId));
        await db.update(locationAliases).set({ usageCount: sql2`${locationAliases.usageCount} + 1` }).where(
          and(
            eq(locationAliases.normalizedQuery, normalizedQuery),
            eq(locationAliases.placeId, placeId)
          )
        );
      }
      async findLocationByCoordinates(lat, lng, radiusMeters) {
        const results = await db.select().from(geocodeLocations).where(
          sql2`
          (
            6371000 * acos(
              cos(radians(${lat})) * 
              cos(radians(CAST(${geocodeLocations.latitude} AS FLOAT))) * 
              cos(radians(CAST(${geocodeLocations.longitude} AS FLOAT)) - radians(${lng})) + 
              sin(radians(${lat})) * 
              sin(radians(CAST(${geocodeLocations.latitude} AS FLOAT)))
            )
          ) <= ${radiusMeters}
        `
        ).limit(1);
        return results[0] || null;
      }
      // ==================== REVIEW MANAGEMENT ====================
      /**
       * Create a new review (Google or SalonHub)
       */
      async createReview(review) {
        const [newReview] = await db.insert(salonReviews).values(review).returning();
        return newReview;
      }
      /**
       * Get reviews for a salon with optional source filtering
       */
      async getReviewsBySalonId(salonId, source) {
        if (source) {
          return await db.select().from(salonReviews).where(and(eq(salonReviews.salonId, salonId), eq(salonReviews.source, source))).orderBy(desc(salonReviews.createdAt));
        }
        return await db.select().from(salonReviews).where(eq(salonReviews.salonId, salonId)).orderBy(desc(salonReviews.createdAt));
      }
      /**
       * Update salon's overall rating by computing weighted average of all reviews
       */
      async updateSalonRating(salonId) {
        const reviews = await db.select().from(salonReviews).where(eq(salonReviews.salonId, salonId));
        if (reviews.length === 0) {
          await db.update(salons).set({ rating: "0.00", reviewCount: 0 }).where(eq(salons.id, salonId));
          return;
        }
        const totalRating = reviews.reduce((sum4, review) => sum4 + review.rating, 0);
        const averageRating = (totalRating / reviews.length).toFixed(2);
        await db.update(salons).set({
          rating: averageRating,
          reviewCount: reviews.length
        }).where(eq(salons.id, salonId));
      }
      // ==================== GOOGLE PLACES CACHE ====================
      /**
       * Search for cached Google Places within radius
       */
      async searchCachedPlaces(latitude, longitude, businessName) {
        const radiusMeters = 100;
        const now = /* @__PURE__ */ new Date();
        const results = await db.select().from(googlePlacesCache).where(
          and(
            sql2`
            (
              6371000 * acos(
                cos(radians(${latitude})) * 
                cos(radians(CAST(${googlePlacesCache.latitude} AS FLOAT))) * 
                cos(radians(CAST(${googlePlacesCache.longitude} AS FLOAT)) - radians(${longitude})) + 
                sin(radians(${latitude})) * 
                sin(radians(CAST(${googlePlacesCache.latitude} AS FLOAT)))
              )
            ) <= ${radiusMeters}
          `,
            sql2`LOWER(${googlePlacesCache.businessName}) LIKE LOWER(${"%" + businessName + "%"})`,
            sql2`${googlePlacesCache.expiresAt} > ${now.toISOString()}`
          )
        ).limit(5);
        return results;
      }
      /**
       * Cache a Google Place result
       */
      async cacheGooglePlace(place) {
        try {
          await db.insert(googlePlacesCache).values(place).onConflictDoUpdate({
            target: googlePlacesCache.placeId,
            set: {
              businessName: place.businessName,
              address: place.address,
              latitude: place.latitude,
              longitude: place.longitude,
              rating: place.rating,
              reviewCount: place.reviewCount,
              payload: place.payload,
              fetchedAt: sql2`CURRENT_TIMESTAMP`,
              expiresAt: place.expiresAt
            }
          });
        } catch (error) {
          console.error("Error caching Google Place:", error);
          throw error;
        }
      }
      /**
       * Clean up expired cache entries
       */
      async cleanExpiredCache() {
        const now = /* @__PURE__ */ new Date();
        const result = await db.delete(googlePlacesCache).where(sql2`${googlePlacesCache.expiresAt} < ${now.toISOString()}`).returning();
        return result.length;
      }
      // ==================== PRODUCT E-COMMERCE OPERATIONS ====================
      /**
       * Get retail products for a salon with optional filtering
       */
      async getRetailProducts(salonId, filters) {
        const conditions = [
          // GATE 1: Product must be active
          eq(products.isActive, 1),
          // GATE 2: Product must be available for retail
          eq(products.availableForRetail, 1),
          // GATE 3: Product must have retail price configured
          gt(products.retailPriceInPaisa, 0)
        ];
        if (salonId && salonId !== "") {
          conditions.push(eq(products.salonId, salonId));
        }
        if (filters?.categoryId) {
          conditions.push(eq(products.categoryId, filters.categoryId));
        }
        if (filters?.search) {
          conditions.push(
            or(
              sql2`LOWER(${products.name}) LIKE LOWER(${`%${filters.search}%`})`,
              sql2`LOWER(${products.description}) LIKE LOWER(${`%${filters.search}%`})`,
              sql2`LOWER(${products.brand}) LIKE LOWER(${`%${filters.search}%`})`
            )
          );
        }
        if (filters?.minPrice !== void 0) {
          conditions.push(gte(products.retailPriceInPaisa, filters.minPrice));
        }
        if (filters?.maxPrice !== void 0) {
          conditions.push(lte(products.retailPriceInPaisa, filters.maxPrice));
        }
        const results = await db.select({
          product: products,
          retailConfig: productRetailConfig
        }).from(products).leftJoin(productRetailConfig, eq(products.id, productRetailConfig.productId)).where(and(...conditions)).limit(filters?.limit || 50).offset(filters?.offset || 0).orderBy(desc(products.createdAt));
        let filteredResults = results;
        filteredResults = filteredResults.filter((r) => {
          const retailStock = r.retailConfig?.retailStockAllocated;
          return retailStock && parseFloat(String(retailStock)) > 0;
        });
        if (filters?.featured !== void 0) {
          filteredResults = filteredResults.filter((r) => r.retailConfig?.featured === (filters.featured ? 1 : 0));
        }
        const productsWithData = await Promise.all(
          filteredResults.map(async (result) => {
            const variants = await db.select().from(productVariants).where(and(
              eq(productVariants.productId, result.product.id),
              eq(productVariants.isActive, 1)
            )).orderBy(asc(productVariants.displayOrder));
            return {
              ...result.product,
              retailConfig: result.retailConfig || void 0,
              variants: variants.length > 0 ? variants : void 0
            };
          })
        );
        return productsWithData;
      }
      /**
       * Get product by ID with variants and retail config
       */
      async getProductById(productId, includeVariants = true) {
        const [result] = await db.select({
          product: products,
          retailConfig: productRetailConfig
        }).from(products).leftJoin(productRetailConfig, eq(products.id, productRetailConfig.productId)).where(eq(products.id, productId));
        if (!result) {
          return void 0;
        }
        let variants;
        if (includeVariants) {
          variants = await db.select().from(productVariants).where(and(
            eq(productVariants.productId, productId),
            eq(productVariants.isActive, 1)
          )).orderBy(asc(productVariants.displayOrder));
        }
        return {
          ...result.product,
          retailConfig: result.retailConfig || void 0,
          variants: variants && variants.length > 0 ? variants : void 0
        };
      }
      /**
       * Get product by ID for specific salon (SECURE: prevents cross-salon access)
       */
      async getProductByIdForSalon(productId, salonId, includeVariants = true) {
        const [result] = await db.select({
          product: products,
          retailConfig: productRetailConfig
        }).from(products).leftJoin(productRetailConfig, eq(products.id, productRetailConfig.productId)).where(and(
          eq(products.id, productId),
          eq(products.salonId, salonId)
        ));
        if (!result) {
          return void 0;
        }
        let variants;
        if (includeVariants) {
          variants = await db.select().from(productVariants).where(and(
            eq(productVariants.productId, productId),
            eq(productVariants.isActive, 1)
          )).orderBy(asc(productVariants.displayOrder));
        }
        return {
          ...result.product,
          retailConfig: result.retailConfig || void 0,
          variants: variants && variants.length > 0 ? variants : void 0
        };
      }
      /**
       * Search products across salons (customer-facing with ALL 4 visibility gates)
       */
      async searchProducts(query, filters) {
        const conditions = [
          // GATE 1: Product must be active
          eq(products.isActive, 1),
          // GATE 2: Product must be available for retail
          eq(products.availableForRetail, 1),
          // GATE 3: Product must have retail price configured
          gt(products.retailPriceInPaisa, 0),
          or(
            sql2`LOWER(${products.name}) LIKE LOWER(${`%${query}%`})`,
            sql2`LOWER(${products.description}) LIKE LOWER(${`%${query}%`})`,
            sql2`LOWER(${products.brand}) LIKE LOWER(${`%${query}%`})`
          )
        ];
        if (filters?.salonId) {
          conditions.push(eq(products.salonId, filters.salonId));
        }
        if (filters?.categoryId) {
          conditions.push(eq(products.categoryId, filters.categoryId));
        }
        if (filters?.minPrice !== void 0) {
          conditions.push(gte(products.retailPriceInPaisa, filters.minPrice));
        }
        if (filters?.maxPrice !== void 0) {
          conditions.push(lte(products.retailPriceInPaisa, filters.maxPrice));
        }
        const results = await db.select({
          product: products,
          retailConfig: productRetailConfig
        }).from(products).leftJoin(productRetailConfig, eq(products.id, productRetailConfig.productId)).where(and(...conditions)).limit(filters?.limit || 50).orderBy(desc(products.createdAt));
        const filteredResults = results.filter((r) => {
          const retailStock = r.retailConfig?.retailStockAllocated;
          return retailStock && parseFloat(String(retailStock)) > 0;
        });
        return filteredResults.map((r) => ({
          ...r.product,
          retailConfig: r.retailConfig || void 0
        }));
      }
      /**
       * Get product variants
       */
      async getProductVariants(productId) {
        return await db.select().from(productVariants).where(and(
          eq(productVariants.productId, productId),
          eq(productVariants.isActive, 1)
        )).orderBy(asc(productVariants.displayOrder));
      }
      /**
       * Get variant by ID
       */
      async getVariantById(variantId) {
        const [variant] = await db.select().from(productVariants).where(eq(productVariants.id, variantId));
        return variant || void 0;
      }
      /**
       * Create or get active shopping cart for user
       */
      async createOrGetCart(userId, salonId) {
        const [existingCart] = await db.select().from(shoppingCarts).where(and(
          eq(shoppingCarts.userId, userId),
          eq(shoppingCarts.salonId, salonId),
          eq(shoppingCarts.status, "active")
        ));
        if (existingCart) {
          return existingCart;
        }
        const [newCart] = await db.insert(shoppingCarts).values({
          userId,
          salonId,
          status: "active"
        }).returning();
        return newCart;
      }
      /**
       * Get active cart with items
       */
      async getActiveCart(userId, salonId) {
        const [cart2] = await db.select().from(shoppingCarts).where(and(
          eq(shoppingCarts.userId, userId),
          eq(shoppingCarts.salonId, salonId),
          eq(shoppingCarts.status, "active")
        ));
        if (!cart2) {
          return void 0;
        }
        const items = await db.select({
          item: cartItems,
          product: products,
          variant: productVariants
        }).from(cartItems).leftJoin(products, eq(cartItems.productId, products.id)).leftJoin(productVariants, eq(cartItems.variantId, productVariants.id)).where(eq(cartItems.cartId, cart2.id));
        return {
          ...cart2,
          items: items.map((i) => ({
            ...i.item,
            product: i.product || void 0,
            variant: i.variant || void 0
          }))
        };
      }
      /**
       * Get all cart items for a user across all salons
       */
      async getUserCartItems(userId) {
        const activeCarts = await db.select().from(shoppingCarts).where(and(
          eq(shoppingCarts.userId, userId),
          eq(shoppingCarts.status, "active")
        ));
        if (activeCarts.length === 0) {
          return [];
        }
        const cartIds = activeCarts.map((c) => c.id);
        const items = await db.select({
          item: cartItems,
          product: products,
          retailConfig: productRetailConfig,
          variant: productVariants,
          cart: shoppingCarts
        }).from(cartItems).leftJoin(products, eq(cartItems.productId, products.id)).leftJoin(productRetailConfig, eq(cartItems.productId, productRetailConfig.productId)).leftJoin(productVariants, eq(cartItems.variantId, productVariants.id)).leftJoin(shoppingCarts, eq(cartItems.cartId, shoppingCarts.id)).where(inArray(cartItems.cartId, cartIds));
        return items.map((i) => ({
          ...i.item,
          product: i.product ? {
            ...i.product,
            retailConfig: i.retailConfig || void 0
          } : void 0,
          variant: i.variant || void 0,
          salonId: i.cart?.salonId
        }));
      }
      /**
       * Add item to cart
       */
      async addCartItem(cartId, item) {
        const existingItemConditions = [
          eq(cartItems.cartId, cartId),
          eq(cartItems.productId, item.productId)
        ];
        if (item.variantId) {
          existingItemConditions.push(eq(cartItems.variantId, item.variantId));
        } else {
          existingItemConditions.push(isNull(cartItems.variantId));
        }
        const [existingItem] = await db.select().from(cartItems).where(and(...existingItemConditions));
        if (existingItem) {
          const [updated] = await db.update(cartItems).set({
            quantity: existingItem.quantity + item.quantity,
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq(cartItems.id, existingItem.id)).returning();
          return updated;
        }
        const [newItem] = await db.insert(cartItems).values({
          cartId,
          productId: item.productId,
          variantId: item.variantId || null,
          quantity: item.quantity,
          priceAtAddPaisa: item.priceAtAdd,
          // Correct field name
          currentPricePaisa: item.priceAtAdd
          // Set current price same as add price initially
        }).returning();
        await db.update(shoppingCarts).set({ updatedAt: /* @__PURE__ */ new Date() }).where(eq(shoppingCarts.id, cartId));
        return newItem;
      }
      /**
       * Update cart item quantity
       */
      async updateCartItem(itemId, quantity) {
        if (quantity <= 0) {
          await this.removeCartItem(itemId);
          return;
        }
        await db.update(cartItems).set({ quantity, updatedAt: /* @__PURE__ */ new Date() }).where(eq(cartItems.id, itemId));
      }
      /**
       * Remove cart item
       */
      async removeCartItem(itemId) {
        await db.delete(cartItems).where(eq(cartItems.id, itemId));
      }
      /**
       * Clear all items from cart
       */
      async clearCart(cartId) {
        await db.delete(cartItems).where(eq(cartItems.cartId, cartId));
      }
      /**
       * Create product order
       */
      async createProductOrder(orderData) {
        const [order] = await db.insert(productOrders).values({
          customerId: orderData.userId,
          // Correct field name is customerId
          salonId: orderData.salonId,
          orderNumber: `ORD-${Date.now()}`,
          status: "pending",
          paymentStatus: "pending",
          paymentMethod: orderData.paymentMethod,
          fulfillmentType: orderData.fulfillmentType,
          // Required field
          deliveryAddress: orderData.deliveryAddress,
          subtotalPaisa: orderData.subtotalInPaisa,
          taxPaisa: orderData.taxInPaisa,
          deliveryChargePaisa: orderData.deliveryFeeInPaisa,
          totalPaisa: orderData.totalInPaisa
        }).returning();
        await db.insert(productOrderItems).values(
          orderData.items.map((item) => ({
            orderId: order.id,
            productId: item.productId,
            productName: item.productName,
            // Required snapshot field
            productSku: item.productSku || null,
            variantId: item.variantId || null,
            quantity: item.quantity,
            unitPricePaisa: item.priceInPaisa,
            // Correct field name
            subtotalPaisa: item.priceInPaisa * item.quantity
            // Required field
          }))
        );
        await db.update(shoppingCarts).set({ status: "converted", updatedAt: /* @__PURE__ */ new Date() }).where(eq(shoppingCarts.id, orderData.cartId));
        return order;
      }
      /**
       * Get product order with items
       */
      async getProductOrder(orderId) {
        const [order] = await db.select().from(productOrders).where(eq(productOrders.id, orderId));
        if (!order) {
          return void 0;
        }
        const items = await db.select().from(productOrderItems).where(eq(productOrderItems.orderId, orderId));
        return {
          ...order,
          items: items.length > 0 ? items : void 0
        };
      }
      /**
       * Get product orders by user
       */
      async getProductOrdersByUser(userId, limit = 50) {
        return await db.select().from(productOrders).where(eq(productOrders.customerId, userId)).orderBy(desc(productOrders.createdAt)).limit(limit);
      }
      /**
       * Update order status
       */
      async updateOrderStatus(orderId, status, updatedBy) {
        await db.update(productOrders).set({ status }).where(eq(productOrders.id, orderId));
      }
      /**
       * Cancel product order
       */
      async cancelProductOrder(orderId, reason) {
        await db.update(productOrders).set({
          status: "cancelled",
          cancellationReason: reason || null,
          cancelledAt: /* @__PURE__ */ new Date()
        }).where(eq(productOrders.id, orderId));
      }
      /**
       * Reserve product stock atomically (prevents overselling)
       * Returns success=false if insufficient stock available
       */
      async reserveProductStock(productId, quantity) {
        const [retailConfig] = await db.select().from(productRetailConfig).where(eq(productRetailConfig.productId, productId)).limit(1);
        if (!retailConfig) {
          return { success: false, availableStock: 0, message: "Product retail config not found" };
        }
        const availableStock = parseFloat(retailConfig.retailStockAllocated || "0");
        if (availableStock < quantity) {
          return {
            success: false,
            availableStock,
            message: `Insufficient stock. Available: ${availableStock}, Requested: ${quantity}`
          };
        }
        await db.update(productRetailConfig).set({
          retailStockAllocated: sql2`${productRetailConfig.retailStockAllocated} - ${quantity}`,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq(productRetailConfig.productId, productId));
        return { success: true, availableStock: availableStock - quantity };
      }
      /**
       * Release reserved stock (when order cancelled or payment failed)
       */
      async releaseProductStock(productId, quantity) {
        await db.update(productRetailConfig).set({
          retailStockAllocated: sql2`${productRetailConfig.retailStockAllocated} + ${quantity}`,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq(productRetailConfig.productId, productId));
      }
      /**
       * Commit stock reduction (same as reserve, but called after payment success for clarity)
       * Stock is already decremented by reserveProductStock, this is a no-op for now
       */
      async commitProductStockReduction(productId, quantity) {
        console.log(`Stock reduction committed for product ${productId}: ${quantity} units`);
      }
      /**
       * Add product to wishlist
       */
      async addToWishlist(userId, productId) {
        const [existing] = await db.select().from(wishlists).where(and(
          eq(wishlists.userId, userId),
          eq(wishlists.productId, productId)
        ));
        if (existing) {
          return existing;
        }
        const [product] = await db.select().from(products).where(eq(products.id, productId));
        const [wishlistItem] = await db.insert(wishlists).values({
          userId,
          productId,
          priceAtAddPaisa: product?.retailPriceInPaisa || 0
          // Required field for price tracking
        }).returning();
        return wishlistItem;
      }
      /**
       * Get user's wishlist
       */
      async getWishlist(userId, salonId) {
        let query = db.select({
          wishlist: wishlists,
          product: products
        }).from(wishlists).leftJoin(products, eq(wishlists.productId, products.id)).where(eq(wishlists.userId, userId));
        if (salonId) {
          const results2 = await query;
          const filtered = results2.filter((r) => r.product?.salonId === salonId);
          return filtered.map((r) => ({
            ...r.wishlist,
            product: r.product || void 0
          }));
        }
        const results = await query.orderBy(desc(wishlists.addedAt));
        return results.map((r) => ({
          ...r.wishlist,
          product: r.product || void 0
        }));
      }
      /**
       * Remove from wishlist
       */
      async removeFromWishlist(wishlistId) {
        await db.delete(wishlists).where(eq(wishlists.id, wishlistId));
      }
      /**
       * Check if product is in wishlist
       */
      async isInWishlist(userId, productId) {
        const [result] = await db.select().from(wishlists).where(and(
          eq(wishlists.userId, userId),
          eq(wishlists.productId, productId)
        ));
        return !!result;
      }
      /**
       * Create product review
       */
      async createProductReview(review) {
        const [product] = await db.select().from(products).where(eq(products.id, review.productId));
        if (!product) {
          throw new Error("Product not found");
        }
        let orderId = review.orderId;
        if (!orderId) {
          const [order] = await db.select().from(productOrders).innerJoin(productOrderItems, eq(productOrders.id, productOrderItems.orderId)).where(and(
            eq(productOrders.customerId, review.userId),
            eq(productOrderItems.productId, review.productId),
            eq(productOrders.status, "delivered")
          )).limit(1);
          orderId = order?.product_orders.id;
        }
        if (!orderId) {
          throw new Error("Cannot create review: No order found for this product purchase");
        }
        const [newReview] = await db.insert(productReviews).values({
          productId: review.productId,
          userId: review.userId,
          salonId: product.salonId,
          // Required field
          orderId,
          // Required field (schema doesn't allow null)
          rating: review.rating,
          title: review.title || null,
          comment: review.reviewText || null,
          // Correct field name is 'comment'
          imageUrls: review.images || null,
          // Correct field name is 'imageUrls'
          verifiedPurchase: 1
          // Always 1 since we require orderId
        }).returning();
        return newReview;
      }
      /**
       * Get product reviews
       */
      async getProductReviews(productId, filters) {
        const conditions = [eq(productReviews.productId, productId)];
        if (filters?.rating !== void 0) {
          conditions.push(eq(productReviews.rating, filters.rating));
        }
        if (filters?.verified !== void 0) {
          conditions.push(eq(productReviews.verifiedPurchase, filters.verified ? 1 : 0));
        }
        return await db.select().from(productReviews).where(and(...conditions)).orderBy(desc(productReviews.createdAt)).limit(filters?.limit || 50).offset(filters?.offset || 0);
      }
      /**
       * Update review helpfulness counts
       */
      async updateReviewHelpfulness(reviewId, helpfulCount, notHelpfulCount) {
        const updates = {};
        if (helpfulCount !== void 0) {
          updates.helpfulCount = helpfulCount;
        }
        if (notHelpfulCount !== void 0) {
          updates.notHelpfulCount = notHelpfulCount;
        }
        if (Object.keys(updates).length > 0) {
          await db.update(productReviews).set(updates).where(eq(productReviews.id, reviewId));
        }
      }
      /**
       * Track product view
       */
      async trackProductView(userId, productId, sessionId) {
        const [product] = await db.select().from(products).where(eq(products.id, productId));
        if (!product) {
          return;
        }
        await db.insert(productViews).values({
          productId,
          salonId: product.salonId,
          // Required field
          userId: userId || null,
          sessionId: sessionId || null
        });
      }
      /**
       * Get product view count
       */
      async getProductViewCount(productId, period) {
        const conditions = [eq(productViews.productId, productId)];
        if (period) {
          const now = /* @__PURE__ */ new Date();
          let startDate;
          switch (period) {
            case "today":
              startDate = new Date(now.getFullYear(), now.getMonth(), now.getDate());
              break;
            case "week":
              startDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1e3);
              break;
            case "month":
              startDate = new Date(now.getFullYear(), now.getMonth(), 1);
              break;
            default:
              startDate = /* @__PURE__ */ new Date(0);
          }
          conditions.push(gte(productViews.viewedAt, startDate));
        }
        const [result] = await db.select({ count: sql2`count(*)` }).from(productViews).where(and(...conditions));
        return result?.count || 0;
      }
      // ===============================================
      // BUSINESS ADMIN - Product Management
      // ===============================================
      async getAdminProductList(salonId, filters) {
        const conditions = [eq(products.salonId, salonId), eq(products.isActive, 1)];
        if (filters?.availableForRetail !== void 0) {
          conditions.push(eq(products.availableForRetail, filters.availableForRetail ? 1 : 0));
        }
        if (filters?.categoryId) {
          conditions.push(eq(products.categoryId, filters.categoryId));
        }
        if (filters?.search) {
          conditions.push(
            or(
              like(products.name, `%${filters.search}%`),
              like(products.sku, `%${filters.search}%`)
            )
          );
        }
        const productsList = await db.select().from(products).leftJoin(productRetailConfig, eq(products.id, productRetailConfig.productId)).where(and(...conditions)).limit(filters?.limit || 50).offset(filters?.offset || 0).orderBy(desc(products.createdAt));
        return productsList.map((p) => ({
          ...p.products,
          retailConfig: p.product_retail_config || null
        }));
      }
      async configureProductForRetail(productId, salonId, config) {
        await db.update(products).set({
          availableForRetail: config.availableForRetail ? 1 : 0,
          retailPriceInPaisa: config.retailPriceInPaisa || void 0,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(and(eq(products.id, productId), eq(products.salonId, salonId)));
        const existing = await db.select().from(productRetailConfig).where(eq(productRetailConfig.productId, productId)).limit(1);
        if (existing.length > 0) {
          await db.update(productRetailConfig).set({
            retailStockAllocated: config.retailStockAllocated !== void 0 ? String(config.retailStockAllocated) : void 0,
            retailDescription: config.retailDescription || void 0,
            retailImageUrls: config.retailImageUrls || void 0,
            featured: config.featured !== void 0 ? config.featured ? 1 : 0 : void 0,
            metaTitle: config.metaTitle || void 0,
            metaDescription: config.metaDescription || void 0,
            searchKeywords: config.searchKeywords || void 0,
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq(productRetailConfig.productId, productId));
        } else {
          await db.insert(productRetailConfig).values({
            productId,
            salonId,
            retailStockAllocated: String(config.retailStockAllocated || 0),
            retailDescription: config.retailDescription,
            retailImageUrls: config.retailImageUrls || [],
            featured: config.featured ? 1 : 0,
            metaTitle: config.metaTitle,
            metaDescription: config.metaDescription,
            searchKeywords: config.searchKeywords || []
          });
        }
      }
      async allocateRetailStock(productId, salonId, data) {
        const product = await db.select().from(products).where(and(
          eq(products.id, productId),
          eq(products.salonId, salonId)
        )).limit(1);
        if (product.length === 0) {
          throw new Error("Product not found or does not belong to this salon");
        }
        const existing = await db.select().from(productRetailConfig).where(eq(productRetailConfig.productId, productId)).limit(1);
        const updateData = {
          retailStockAllocated: String(data.retailStockAllocated),
          updatedAt: /* @__PURE__ */ new Date()
        };
        if (data.retailPriceInPaisa !== void 0) {
          updateData.retailPriceInPaisa = data.retailPriceInPaisa;
        }
        if (data.useAllocatedStock !== void 0) {
          updateData.useAllocatedStock = data.useAllocatedStock;
        }
        if (data.lowStockThreshold !== void 0) {
          updateData.lowStockThreshold = String(data.lowStockThreshold);
        }
        if (existing.length > 0) {
          await db.update(productRetailConfig).set(updateData).where(eq(productRetailConfig.productId, productId));
        } else {
          await db.insert(productRetailConfig).values({
            productId,
            salonId,
            retailStockAllocated: String(data.retailStockAllocated),
            retailPriceInPaisa: data.retailPriceInPaisa,
            useAllocatedStock: data.useAllocatedStock ?? 1,
            lowStockThreshold: data.lowStockThreshold !== void 0 ? String(data.lowStockThreshold) : "5",
            featured: 0,
            retailImageUrls: [],
            searchKeywords: []
          });
        }
      }
      // ===============================================
      // BUSINESS ADMIN - Order Management
      // ===============================================
      async getAdminOrders(salonId, filters) {
        const conditions = [eq(productOrders.salonId, salonId)];
        if (filters?.status) {
          conditions.push(eq(productOrders.status, filters.status));
        }
        if (filters?.fulfillmentType) {
          conditions.push(eq(productOrders.fulfillmentType, filters.fulfillmentType));
        }
        if (filters?.dateFrom) {
          conditions.push(gte(productOrders.createdAt, new Date(filters.dateFrom)));
        }
        if (filters?.dateTo) {
          conditions.push(lte(productOrders.createdAt, new Date(filters.dateTo)));
        }
        if (filters?.search) {
          conditions.push(like(productOrders.orderNumber, `%${filters.search}%`));
        }
        const orders = await db.select({
          order: productOrders,
          user: users
        }).from(productOrders).leftJoin(users, eq(productOrders.customerId, users.id)).where(and(...conditions)).limit(filters?.limit || 50).offset(filters?.offset || 0).orderBy(desc(productOrders.createdAt));
        const statusCounts = await db.select({
          status: productOrders.status,
          count: sql2`count(*)`
        }).from(productOrders).where(eq(productOrders.salonId, salonId)).groupBy(productOrders.status);
        const summary = statusCounts.reduce((acc, curr) => {
          acc[curr.status] = curr.count;
          acc.total = (acc.total || 0) + curr.count;
          return acc;
        }, {});
        return {
          orders: orders.map((o) => ({
            ...o.order,
            customer: o.user
          })),
          summary
        };
      }
      async updateOrderStatus(orderId, salonId, updates) {
        await db.update(productOrders).set({
          status: updates.status,
          trackingNumber: updates.trackingNumber,
          courierPartner: updates.courierPartner,
          estimatedDeliveryDate: updates.estimatedDeliveryDate ? new Date(updates.estimatedDeliveryDate) : void 0,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(and(eq(productOrders.id, orderId), eq(productOrders.salonId, salonId)));
      }
      async cancelOrderAdmin(orderId, salonId, reason, refundAmountPaisa) {
        const [order] = await db.select().from(productOrders).where(and(eq(productOrders.id, orderId), eq(productOrders.salonId, salonId))).limit(1);
        if (!order) {
          throw new Error("Order not found");
        }
        await db.update(productOrders).set({
          status: "cancelled",
          cancellationReason: reason,
          cancelledAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq(productOrders.id, orderId));
        if (["pending", "confirmed"].includes(order.status)) {
          const orderItems = await db.select().from(productOrderItems).where(eq(productOrderItems.orderId, orderId));
          for (const item of orderItems) {
            const [config] = await db.select().from(productRetailConfig).where(eq(productRetailConfig.productId, item.productId)).limit(1);
            if (config && config.retailStockAllocated !== null) {
              await db.update(productRetailConfig).set({
                retailStockAllocated: config.retailStockAllocated + item.quantity
              }).where(eq(productRetailConfig.productId, item.productId));
            }
          }
        }
      }
      // ===============================================
      // BUSINESS ADMIN - Analytics
      // ===============================================
      async getProductAnalytics(salonId, filters) {
        const now = /* @__PURE__ */ new Date();
        let startDate;
        if (filters?.dateFrom && filters?.dateTo) {
          startDate = new Date(filters.dateFrom);
        } else {
          switch (filters?.period) {
            case "today":
              startDate = new Date(now.getFullYear(), now.getMonth(), now.getDate());
              break;
            case "week":
              startDate = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1e3);
              break;
            case "month":
            default:
              startDate = new Date(now.getFullYear(), now.getMonth(), 1);
              break;
          }
        }
        const endDate = filters?.dateTo ? new Date(filters.dateTo) : now;
        const revenueData = await db.select({
          totalRevenue: sql2`COALESCE(SUM(${productOrders.totalPaisa}), 0)`,
          totalOrders: sql2`COUNT(*)`,
          averageOrderValue: sql2`COALESCE(AVG(${productOrders.totalPaisa}), 0)`
        }).from(productOrders).where(
          and(
            eq(productOrders.salonId, salonId),
            gte(productOrders.createdAt, startDate),
            lte(productOrders.createdAt, endDate),
            sql2`${productOrders.status} NOT IN ('cancelled', 'refunded')`
          )
        );
        const unitsData = await db.select({
          totalUnits: sql2`COALESCE(SUM(${productOrderItems.quantity}), 0)`
        }).from(productOrderItems).innerJoin(productOrders, eq(productOrderItems.orderId, productOrders.id)).where(
          and(
            eq(productOrders.salonId, salonId),
            gte(productOrders.createdAt, startDate),
            lte(productOrders.createdAt, endDate),
            sql2`${productOrders.status} NOT IN ('cancelled', 'refunded')`
          )
        );
        const topProducts = await db.select({
          productId: productOrderItems.productId,
          productName: products.name,
          unitsSold: sql2`SUM(${productOrderItems.quantity})`,
          revenue: sql2`SUM(${productOrderItems.unitPricePaisa} * ${productOrderItems.quantity})`
        }).from(productOrderItems).innerJoin(productOrders, eq(productOrderItems.orderId, productOrders.id)).innerJoin(products, eq(productOrderItems.productId, products.id)).where(
          and(
            eq(productOrders.salonId, salonId),
            gte(productOrders.createdAt, startDate),
            lte(productOrders.createdAt, endDate),
            sql2`${productOrders.status} NOT IN ('cancelled', 'refunded')`
          )
        ).groupBy(productOrderItems.productId, products.name).orderBy(desc(sql2`SUM(${productOrderItems.unitPricePaisa} * ${productOrderItems.quantity})`)).limit(10);
        return {
          period: filters?.period || "month",
          dateRange: {
            from: startDate.toISOString().split("T")[0],
            to: endDate.toISOString().split("T")[0]
          },
          summary: {
            totalRevenue: revenueData[0]?.totalRevenue || 0,
            totalOrders: revenueData[0]?.totalOrders || 0,
            totalUnits: unitsData[0]?.totalUnits || 0,
            averageOrderValue: Math.round(revenueData[0]?.averageOrderValue || 0)
          },
          topProducts: topProducts.map((p) => ({
            productId: p.productId,
            productName: p.productName,
            unitsSold: p.unitsSold,
            revenue: p.revenue
          }))
        };
      }
      // ===============================================
      // BUSINESS ADMIN - Delivery Settings
      // ===============================================
      async getDeliverySettings(salonId) {
        const [settings] = await db.select().from(deliverySettings).where(eq(deliverySettings.salonId, salonId)).limit(1);
        return settings || null;
      }
      async updateDeliverySettings(salonId, settings) {
        const existing = await db.select().from(deliverySettings).where(eq(deliverySettings.salonId, salonId)).limit(1);
        if (existing.length > 0) {
          await db.update(deliverySettings).set({
            ...settings,
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq(deliverySettings.salonId, salonId));
        } else {
          await db.insert(deliverySettings).values({
            salonId,
            ...settings
          });
        }
      }
      // ===============================================
      // SMART REBOOKING SYSTEM
      // ===============================================
      // Service Rebooking Cycles Operations
      async getServiceRebookingCycle(id) {
        const [cycle] = await db.select().from(serviceRebookingCycles).where(eq(serviceRebookingCycles.id, id)).limit(1);
        return cycle;
      }
      async getServiceRebookingCycleBySalonAndService(salonId, serviceId) {
        const [cycle] = await db.select().from(serviceRebookingCycles).where(and(
          eq(serviceRebookingCycles.salonId, salonId),
          eq(serviceRebookingCycles.serviceId, serviceId)
        )).limit(1);
        return cycle;
      }
      async getServiceRebookingCyclesBySalonId(salonId, filters) {
        const conditions = [eq(serviceRebookingCycles.salonId, salonId)];
        if (filters?.isActive !== void 0) {
          conditions.push(eq(serviceRebookingCycles.isActive, filters.isActive ? 1 : 0));
        }
        return db.select().from(serviceRebookingCycles).where(and(...conditions)).orderBy(desc(serviceRebookingCycles.createdAt));
      }
      async createServiceRebookingCycle(cycle) {
        const [created] = await db.insert(serviceRebookingCycles).values(cycle).returning();
        return created;
      }
      async updateServiceRebookingCycle(id, salonId, updates) {
        await db.update(serviceRebookingCycles).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(and(
          eq(serviceRebookingCycles.id, id),
          eq(serviceRebookingCycles.salonId, salonId)
        ));
      }
      async deleteServiceRebookingCycle(id, salonId) {
        await db.delete(serviceRebookingCycles).where(and(
          eq(serviceRebookingCycles.id, id),
          eq(serviceRebookingCycles.salonId, salonId)
        ));
      }
      // Customer Rebooking Stats Operations
      async getCustomerRebookingStat(id) {
        const [stat] = await db.select().from(customerRebookingStats).where(eq(customerRebookingStats.id, id)).limit(1);
        return stat;
      }
      async getCustomerRebookingStatByKeys(salonId, customerId, serviceId) {
        const [stat] = await db.select().from(customerRebookingStats).where(and(
          eq(customerRebookingStats.salonId, salonId),
          eq(customerRebookingStats.customerId, customerId),
          eq(customerRebookingStats.serviceId, serviceId)
        )).limit(1);
        return stat;
      }
      async getCustomerRebookingStatsBySalonId(salonId, filters) {
        const conditions = [eq(customerRebookingStats.salonId, salonId)];
        if (filters?.status) {
          conditions.push(eq(customerRebookingStats.rebookingStatus, filters.status));
        }
        if (filters?.dueBefore) {
          conditions.push(lte(customerRebookingStats.nextRebookingDue, filters.dueBefore));
        }
        if (filters?.dueAfter) {
          conditions.push(gte(customerRebookingStats.nextRebookingDue, filters.dueAfter));
        }
        return db.select().from(customerRebookingStats).where(and(...conditions)).orderBy(asc(customerRebookingStats.nextRebookingDue));
      }
      async getCustomerRebookingStatsByCustomerId(customerId, filters) {
        const conditions = [eq(customerRebookingStats.customerId, customerId)];
        if (filters?.salonId) {
          conditions.push(eq(customerRebookingStats.salonId, filters.salonId));
        }
        if (filters?.status) {
          conditions.push(eq(customerRebookingStats.rebookingStatus, filters.status));
        }
        return db.select().from(customerRebookingStats).where(and(...conditions)).orderBy(asc(customerRebookingStats.nextRebookingDue));
      }
      async getDueRebookings(salonId, limit) {
        const now = /* @__PURE__ */ new Date();
        const query = db.select().from(customerRebookingStats).where(and(
          eq(customerRebookingStats.salonId, salonId),
          lte(customerRebookingStats.nextRebookingDue, now),
          inArray(customerRebookingStats.rebookingStatus, ["approaching", "due", "overdue"])
        )).orderBy(asc(customerRebookingStats.nextRebookingDue));
        if (limit) {
          return query.limit(limit);
        }
        return query;
      }
      async createCustomerRebookingStat(stat) {
        const [created] = await db.insert(customerRebookingStats).values(stat).returning();
        return created;
      }
      async upsertCustomerRebookingStat(stat) {
        const existing = await this.getCustomerRebookingStatByKeys(stat.salonId, stat.customerId, stat.serviceId);
        if (existing) {
          await db.update(customerRebookingStats).set({ ...stat, updatedAt: /* @__PURE__ */ new Date() }).where(eq(customerRebookingStats.id, existing.id));
          return { ...existing, ...stat, updatedAt: /* @__PURE__ */ new Date() };
        }
        return this.createCustomerRebookingStat(stat);
      }
      async updateCustomerRebookingStat(id, updates) {
        await db.update(customerRebookingStats).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq(customerRebookingStats.id, id));
      }
      async updateCustomerRebookingStatus(id, status) {
        await db.update(customerRebookingStats).set({ rebookingStatus: status, updatedAt: /* @__PURE__ */ new Date() }).where(eq(customerRebookingStats.id, id));
      }
      async incrementRebookingRemindersReceived(id) {
        await db.update(customerRebookingStats).set({
          remindersReceived: sql2`${customerRebookingStats.remindersReceived} + 1`,
          lastReminderSentAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq(customerRebookingStats.id, id));
      }
      async dismissCustomerRebooking(id, dismissUntil) {
        await db.update(customerRebookingStats).set({
          rebookingStatus: "dismissed",
          remindersDismissed: sql2`${customerRebookingStats.remindersDismissed} + 1`,
          lastDismissedAt: /* @__PURE__ */ new Date(),
          dismissUntil: dismissUntil || null,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq(customerRebookingStats.id, id));
      }
      // Rebooking Reminders Operations
      async getRebookingReminder(id) {
        const [reminder] = await db.select().from(rebookingReminders).where(eq(rebookingReminders.id, id)).limit(1);
        return reminder;
      }
      async getRebookingRemindersBySalonId(salonId, filters) {
        const conditions = [eq(rebookingReminders.salonId, salonId)];
        if (filters?.status) {
          conditions.push(eq(rebookingReminders.status, filters.status));
        }
        if (filters?.channel) {
          conditions.push(eq(rebookingReminders.channel, filters.channel));
        }
        if (filters?.scheduledBefore) {
          conditions.push(lte(rebookingReminders.scheduledAt, filters.scheduledBefore));
        }
        if (filters?.scheduledAfter) {
          conditions.push(gte(rebookingReminders.scheduledAt, filters.scheduledAfter));
        }
        return db.select().from(rebookingReminders).where(and(...conditions)).orderBy(desc(rebookingReminders.createdAt));
      }
      async getPendingRebookingReminders(limit) {
        const now = /* @__PURE__ */ new Date();
        const query = db.select().from(rebookingReminders).where(and(
          eq(rebookingReminders.status, "scheduled"),
          lte(rebookingReminders.scheduledAt, now)
        )).orderBy(asc(rebookingReminders.scheduledAt));
        if (limit) {
          return query.limit(limit);
        }
        return query;
      }
      async createRebookingReminder(reminder) {
        const [created] = await db.insert(rebookingReminders).values(reminder).returning();
        return created;
      }
      async updateRebookingReminder(id, updates) {
        await db.update(rebookingReminders).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq(rebookingReminders.id, id));
      }
      async markReminderSent(id, externalMessageId) {
        await db.update(rebookingReminders).set({
          status: "sent",
          sentAt: /* @__PURE__ */ new Date(),
          externalMessageId: externalMessageId || null,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq(rebookingReminders.id, id));
      }
      async markReminderDelivered(id) {
        await db.update(rebookingReminders).set({
          status: "delivered",
          deliveredAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq(rebookingReminders.id, id));
      }
      async markReminderOpened(id) {
        await db.update(rebookingReminders).set({
          status: "opened",
          openedAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq(rebookingReminders.id, id));
      }
      async markReminderClicked(id) {
        await db.update(rebookingReminders).set({
          clickedAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq(rebookingReminders.id, id));
      }
      async markReminderConverted(id, bookingId) {
        await db.update(rebookingReminders).set({
          status: "converted",
          convertedBookingId: bookingId,
          convertedAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq(rebookingReminders.id, id));
      }
      async markReminderFailed(id, reason) {
        const reminder = await this.getRebookingReminder(id);
        const newRetryCount = (reminder?.retryCount || 0) + 1;
        await db.update(rebookingReminders).set({
          status: newRetryCount >= (reminder?.maxRetries || 3) ? "failed" : "pending",
          failedAt: /* @__PURE__ */ new Date(),
          failureReason: reason,
          retryCount: newRetryCount,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq(rebookingReminders.id, id));
      }
      async dismissRebookingReminder(id, reason) {
        await db.update(rebookingReminders).set({
          status: "dismissed",
          dismissedAt: /* @__PURE__ */ new Date(),
          dismissReason: reason,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq(rebookingReminders.id, id));
      }
      async getRebookingReminderAnalytics(salonId, startDate, endDate) {
        const reminders = await db.select().from(rebookingReminders).where(and(
          eq(rebookingReminders.salonId, salonId),
          gte(rebookingReminders.createdAt, startDate),
          lte(rebookingReminders.createdAt, endDate)
        ));
        const totalSent = reminders.filter((r) => r.sentAt).length;
        const delivered = reminders.filter((r) => r.deliveredAt).length;
        const opened = reminders.filter((r) => r.openedAt).length;
        const clicked = reminders.filter((r) => r.clickedAt).length;
        const converted = reminders.filter((r) => r.convertedAt).length;
        const failed = reminders.filter((r) => r.status === "failed").length;
        return {
          totalSent,
          delivered,
          opened,
          clicked,
          converted,
          failed,
          deliveryRate: totalSent > 0 ? delivered / totalSent * 100 : 0,
          openRate: delivered > 0 ? opened / delivered * 100 : 0,
          clickRate: opened > 0 ? clicked / opened * 100 : 0,
          conversionRate: totalSent > 0 ? converted / totalSent * 100 : 0
        };
      }
      async getRebookingRemindersForChannelAnalysis(salonId, startDate, endDate) {
        return db.select().from(rebookingReminders).where(and(
          eq(rebookingReminders.salonId, salonId),
          gte(rebookingReminders.createdAt, startDate),
          lte(rebookingReminders.createdAt, endDate),
          or(
            eq(rebookingReminders.status, "sent"),
            eq(rebookingReminders.status, "converted")
          )
        ));
      }
      // Rebooking Settings Operations
      async getRebookingSettings(salonId) {
        const [settings] = await db.select().from(rebookingSettings).where(eq(rebookingSettings.salonId, salonId)).limit(1);
        return settings;
      }
      async createRebookingSettings(settings) {
        const [created] = await db.insert(rebookingSettings).values(settings).returning();
        return created;
      }
      async updateRebookingSettings(salonId, updates) {
        await db.update(rebookingSettings).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq(rebookingSettings.salonId, salonId));
      }
      async getOrCreateRebookingSettings(salonId) {
        const existing = await this.getRebookingSettings(salonId);
        if (existing) {
          return existing;
        }
        return this.createRebookingSettings({ salonId });
      }
      // Rebooking Analytics Operations
      async getRebookingDashboardAnalytics(salonId) {
        const stats = await db.select().from(customerRebookingStats).where(eq(customerRebookingStats.salonId, salonId));
        const totalCustomersTracked = stats.length;
        const customersApproaching = stats.filter((s) => s.rebookingStatus === "approaching").length;
        const customersDue = stats.filter((s) => s.rebookingStatus === "due").length;
        const customersOverdue = stats.filter((s) => s.rebookingStatus === "overdue").length;
        const totalRemindersSent = stats.reduce((sum4, s) => sum4 + (s.remindersReceived || 0), 0);
        const totalConversions = stats.reduce((sum4, s) => sum4 + (s.rebookingsFromReminders || 0), 0);
        const avgDaysValues = stats.filter((s) => s.avgDaysBetweenBookings).map((s) => parseFloat(s.avgDaysBetweenBookings || "0"));
        const avgDaysBetweenBookings = avgDaysValues.length > 0 ? avgDaysValues.reduce((a, b) => a + b, 0) / avgDaysValues.length : 0;
        return {
          totalCustomersTracked,
          customersApproaching,
          customersDue,
          customersOverdue,
          totalRemindersSent,
          totalConversions,
          overallConversionRate: totalRemindersSent > 0 ? totalConversions / totalRemindersSent * 100 : 0,
          avgDaysBetweenBookings
        };
      }
    };
    storage = new DatabaseStorage();
    initializeSalonsAndServices();
  }
});

// server/services/rbacService.ts
var rbacService_exports = {};
__export(rbacService_exports, {
  RBACService: () => RBACService,
  rbacService: () => rbacService
});
import { eq as eq3, and as and3, sql as sql3 } from "drizzle-orm";
var RBACService, rbacService;
var init_rbacService = __esm({
  "server/services/rbacService.ts"() {
    "use strict";
    init_db();
    init_schema();
    RBACService = class {
      async getUserSalonRole(userId, salonId) {
        const salon = await db.query.salons.findFirst({
          where: eq3(salons.id, salonId)
        });
        if (!salon) {
          return null;
        }
        if (salon.ownerId === userId) {
          return "business_owner";
        }
        if (salon.orgId) {
          const orgUser = await db.query.orgUsers.findFirst({
            where: and3(
              eq3(orgUsers.orgId, salon.orgId),
              eq3(orgUsers.userId, userId),
              eq3(orgUsers.isActive, 1)
            )
          });
          if (orgUser && orgUser.orgRole === "owner") {
            return "business_owner";
          }
        }
        const roleAssignment = await db.select().from(shopRoleAssignments).where(
          and3(
            eq3(shopRoleAssignments.userId, userId),
            eq3(shopRoleAssignments.salonId, salonId),
            eq3(shopRoleAssignments.isActive, 1)
          )
        ).limit(1);
        if (roleAssignment.length > 0) {
          return roleAssignment[0].role;
        }
        return null;
      }
      async getUserPermissions(userId, salonId) {
        const role = await this.getUserSalonRole(userId, salonId);
        if (!role) {
          return null;
        }
        const rolePerms = await db.select({
          code: permissions.code
        }).from(shopRolePermissions).innerJoin(permissions, eq3(shopRolePermissions.permissionId, permissions.id)).where(
          and3(
            eq3(shopRolePermissions.role, role),
            eq3(permissions.isActive, 1)
          )
        );
        return {
          userId,
          salonId,
          role,
          permissions: rolePerms.map((p) => p.code),
          isBusinessOwner: role === "business_owner"
        };
      }
      async hasPermission(userId, salonId, permissionCode) {
        const userPermissions = await this.getUserPermissions(userId, salonId);
        if (!userPermissions) {
          return false;
        }
        return userPermissions.permissions.includes(permissionCode);
      }
      async hasAnyPermission(userId, salonId, permissionCodes) {
        const userPermissions = await this.getUserPermissions(userId, salonId);
        if (!userPermissions) {
          return false;
        }
        return permissionCodes.some((code) => userPermissions.permissions.includes(code));
      }
      async hasAllPermissions(userId, salonId, permissionCodes) {
        const userPermissions = await this.getUserPermissions(userId, salonId);
        if (!userPermissions) {
          return false;
        }
        return permissionCodes.every((code) => userPermissions.permissions.includes(code));
      }
      async isBusinessOwner(userId, salonId) {
        const role = await this.getUserSalonRole(userId, salonId);
        return role === "business_owner";
      }
      async isShopAdmin(userId, salonId) {
        const role = await this.getUserSalonRole(userId, salonId);
        return role === "shop_admin" || role === "business_owner";
      }
      async canAccessSalon(userId, salonId) {
        const role = await this.getUserSalonRole(userId, salonId);
        return role !== null;
      }
      async assignRole(targetUserId, salonId, role, assignedByUserId, notes, ipAddress, userAgent) {
        const isOwner = await this.isBusinessOwner(assignedByUserId, salonId);
        if (!isOwner) {
          return { success: false, error: "Only business owners can assign roles" };
        }
        const existingAssignment = await db.select().from(shopRoleAssignments).where(
          and3(
            eq3(shopRoleAssignments.userId, targetUserId),
            eq3(shopRoleAssignments.salonId, salonId),
            eq3(shopRoleAssignments.isActive, 1)
          )
        ).limit(1);
        if (existingAssignment.length > 0) {
          return { success: false, error: "User already has an active role for this salon" };
        }
        const [newAssignment] = await db.insert(shopRoleAssignments).values({
          userId: targetUserId,
          salonId,
          role,
          assignedBy: assignedByUserId,
          notes,
          isActive: 1
        }).returning();
        await this.logAction(
          assignedByUserId,
          salonId,
          "role_assigned",
          targetUserId,
          null,
          { role },
          ipAddress,
          userAgent
        );
        return { success: true, assignment: newAssignment };
      }
      async revokeRole(targetUserId, salonId, revokedByUserId, ipAddress, userAgent) {
        const isOwner = await this.isBusinessOwner(revokedByUserId, salonId);
        if (!isOwner) {
          return { success: false, error: "Only business owners can revoke roles" };
        }
        const existingAssignment = await db.select().from(shopRoleAssignments).where(
          and3(
            eq3(shopRoleAssignments.userId, targetUserId),
            eq3(shopRoleAssignments.salonId, salonId),
            eq3(shopRoleAssignments.isActive, 1)
          )
        ).limit(1);
        if (existingAssignment.length === 0) {
          return { success: false, error: "No active role found for this user" };
        }
        const previousRole = existingAssignment[0].role;
        await db.update(shopRoleAssignments).set({
          isActive: 0,
          revokedAt: /* @__PURE__ */ new Date(),
          revokedBy: revokedByUserId
        }).where(eq3(shopRoleAssignments.id, existingAssignment[0].id));
        await this.logAction(
          revokedByUserId,
          salonId,
          "role_revoked",
          targetUserId,
          { role: previousRole },
          null,
          ipAddress,
          userAgent
        );
        return { success: true };
      }
      async updateRole(targetUserId, salonId, newRole, updatedByUserId, notes, ipAddress, userAgent) {
        const isOwner = await this.isBusinessOwner(updatedByUserId, salonId);
        if (!isOwner) {
          return { success: false, error: "Only business owners can update roles" };
        }
        const existingAssignment = await db.select().from(shopRoleAssignments).where(
          and3(
            eq3(shopRoleAssignments.userId, targetUserId),
            eq3(shopRoleAssignments.salonId, salonId),
            eq3(shopRoleAssignments.isActive, 1)
          )
        ).limit(1);
        if (existingAssignment.length === 0) {
          return { success: false, error: "No active role found for this user" };
        }
        const previousRole = existingAssignment[0].role;
        await db.update(shopRoleAssignments).set({
          role: newRole,
          notes: notes || existingAssignment[0].notes
        }).where(eq3(shopRoleAssignments.id, existingAssignment[0].id));
        await this.logAction(
          updatedByUserId,
          salonId,
          "role_updated",
          targetUserId,
          { role: previousRole },
          { role: newRole },
          ipAddress,
          userAgent
        );
        return { success: true };
      }
      async getShopAdmins(salonId) {
        const assignments = await db.select({
          id: shopRoleAssignments.id,
          userId: shopRoleAssignments.userId,
          role: shopRoleAssignments.role,
          assignedAt: shopRoleAssignments.assignedAt,
          isActive: shopRoleAssignments.isActive,
          assignedBy: shopRoleAssignments.assignedBy,
          userName: sql3`COALESCE(${users.firstName} || ' ' || ${users.lastName}, ${users.username}, 'Unknown')`,
          userEmail: users.email,
          userPhone: users.phone,
          userProfileImage: users.profileImageUrl
        }).from(shopRoleAssignments).innerJoin(users, eq3(shopRoleAssignments.userId, users.id)).where(
          and3(
            eq3(shopRoleAssignments.salonId, salonId),
            eq3(shopRoleAssignments.isActive, 1)
          )
        );
        const result = [];
        for (const assignment of assignments) {
          let assignedByName = null;
          if (assignment.assignedBy) {
            const assigner = await db.query.users.findFirst({
              where: eq3(users.id, assignment.assignedBy)
            });
            if (assigner) {
              assignedByName = `${assigner.firstName || ""} ${assigner.lastName || ""}`.trim() || assigner.username || "Unknown";
            }
          }
          result.push({
            userId: assignment.userId,
            userName: assignment.userName,
            userEmail: assignment.userEmail,
            userPhone: assignment.userPhone,
            userProfileImage: assignment.userProfileImage,
            role: assignment.role,
            assignedAt: assignment.assignedAt?.toISOString() || (/* @__PURE__ */ new Date()).toISOString(),
            assignedByName,
            isActive: assignment.isActive === 1
          });
        }
        return result;
      }
      async getSalonsForUser(userId) {
        const ownedSalons = await db.select({
          salonId: salons.id,
          salonName: salons.name
        }).from(salons).where(eq3(salons.ownerId, userId));
        const assignedSalons = await db.select({
          salonId: shopRoleAssignments.salonId,
          role: shopRoleAssignments.role,
          salonName: salons.name
        }).from(shopRoleAssignments).innerJoin(salons, eq3(shopRoleAssignments.salonId, salons.id)).where(
          and3(
            eq3(shopRoleAssignments.userId, userId),
            eq3(shopRoleAssignments.isActive, 1)
          )
        );
        const result = [];
        for (const salon of ownedSalons) {
          result.push({
            salonId: salon.salonId,
            salonName: salon.salonName,
            role: "business_owner"
          });
        }
        for (const assignment of assignedSalons) {
          if (!result.some((r) => r.salonId === assignment.salonId)) {
            result.push({
              salonId: assignment.salonId,
              salonName: assignment.salonName,
              role: assignment.role
            });
          }
        }
        return result;
      }
      async getAllPermissions() {
        return db.select().from(permissions).where(eq3(permissions.isActive, 1));
      }
      async getRolePermissions(role) {
        const perms = await db.select({ code: permissions.code }).from(shopRolePermissions).innerJoin(permissions, eq3(shopRolePermissions.permissionId, permissions.id)).where(
          and3(
            eq3(shopRolePermissions.role, role),
            eq3(permissions.isActive, 1)
          )
        );
        return perms.map((p) => p.code);
      }
      async logAction(userId, salonId, action, targetUserId, previousValue, newValue, ipAddress, userAgent) {
        await db.insert(adminAuditLogs).values({
          userId,
          salonId,
          action,
          targetUserId,
          previousValue,
          newValue,
          ipAddress,
          userAgent
        });
      }
      /**
       * Public method to log privileged actions for audit trail
       * Use this for logging booking changes, staff edits, service modifications, etc.
       */
      async logPrivilegedAction(params) {
        const {
          userId,
          salonId,
          action,
          targetUserId,
          resourceType,
          resourceId,
          previousValue,
          newValue,
          ipAddress,
          userAgent
        } = params;
        const enrichedPreviousValue = previousValue ? {
          ...previousValue,
          _resourceType: resourceType,
          _resourceId: resourceId
        } : resourceType ? { _resourceType: resourceType, _resourceId: resourceId } : null;
        await db.insert(adminAuditLogs).values({
          userId,
          salonId,
          action,
          targetUserId: targetUserId || null,
          previousValue: enrichedPreviousValue,
          newValue,
          ipAddress,
          userAgent
        });
      }
      /**
       * Log common privileged actions with standard formats
       */
      async logBookingAction(userId, salonId, bookingId, action, previousData, newData, ipAddress, userAgent) {
        await this.logPrivilegedAction({
          userId,
          salonId,
          action,
          resourceType: "booking",
          resourceId: bookingId,
          previousValue: previousData,
          newValue: newData,
          ipAddress,
          userAgent
        });
      }
      async logServiceAction(userId, salonId, serviceId, action, previousData, newData, ipAddress, userAgent) {
        await this.logPrivilegedAction({
          userId,
          salonId,
          action,
          resourceType: "service",
          resourceId: serviceId,
          previousValue: previousData,
          newValue: newData,
          ipAddress,
          userAgent
        });
      }
      async logStaffAction(userId, salonId, staffId, action, previousData, newData, ipAddress, userAgent) {
        await this.logPrivilegedAction({
          userId,
          salonId,
          action,
          resourceType: "staff",
          resourceId: staffId,
          previousValue: previousData,
          newValue: newData,
          ipAddress,
          userAgent
        });
      }
      async logSettingsAction(userId, salonId, settingType, action, previousData, newData, ipAddress, userAgent) {
        await this.logPrivilegedAction({
          userId,
          salonId,
          action,
          resourceType: "settings",
          resourceId: settingType,
          previousValue: previousData,
          newValue: newData,
          ipAddress,
          userAgent
        });
      }
      async getAuditLogs(salonId, limit = 50, offset = 0) {
        return db.select().from(adminAuditLogs).where(eq3(adminAuditLogs.salonId, salonId)).orderBy(sql3`${adminAuditLogs.createdAt} DESC`).limit(limit).offset(offset);
      }
    };
    rbacService = new RBACService();
  }
});

// server/firebaseAdmin.ts
var firebaseAdmin_exports = {};
__export(firebaseAdmin_exports, {
  getPhoneNumberFromToken: () => getPhoneNumberFromToken,
  initializeFirebaseAdmin: () => initializeFirebaseAdmin,
  verifyFirebaseToken: () => verifyFirebaseToken
});
import admin from "firebase-admin";
function initializeFirebaseAdmin() {
  if (firebaseAdmin) {
    return firebaseAdmin;
  }
  try {
    const serviceAccountJson = process.env.FIREBASE_SERVICE_ACCOUNT;
    if (!serviceAccountJson) {
      console.warn("\u26A0\uFE0F  FIREBASE_SERVICE_ACCOUNT not configured - server-side phone verification disabled");
      return null;
    }
    const serviceAccount = JSON.parse(serviceAccountJson);
    firebaseAdmin = admin.initializeApp({
      credential: admin.credential.cert(serviceAccount)
    });
    console.log("\u2705 Firebase Admin SDK initialized successfully");
    return firebaseAdmin;
  } catch (error) {
    console.error("\u274C Error initializing Firebase Admin SDK:", error);
    return null;
  }
}
async function verifyFirebaseToken(idToken) {
  try {
    if (!firebaseAdmin) {
      console.warn("\u26A0\uFE0F  Firebase Admin not initialized - skipping token verification");
      return null;
    }
    const decodedToken = await admin.auth().verifyIdToken(idToken);
    console.log("\u2705 Firebase token verified successfully for user:", decodedToken.uid);
    return decodedToken;
  } catch (error) {
    console.error("\u274C Error verifying Firebase token:", error.message);
    if (error.code === "auth/id-token-expired") {
      throw new Error("Firebase token has expired. Please verify your phone again.");
    } else if (error.code === "auth/argument-error") {
      throw new Error("Invalid Firebase token format.");
    } else if (error.code === "auth/invalid-id-token") {
      throw new Error("Invalid Firebase token. Please verify your phone again.");
    }
    throw new Error("Failed to verify Firebase token.");
  }
}
function getPhoneNumberFromToken(decodedToken) {
  return decodedToken.phone_number || null;
}
var firebaseAdmin;
var init_firebaseAdmin = __esm({
  "server/firebaseAdmin.ts"() {
    "use strict";
    firebaseAdmin = null;
    initializeFirebaseAdmin();
  }
});

// server/services/exportService.ts
var exportService_exports = {};
__export(exportService_exports, {
  ExportService: () => ExportService
});
import ExcelJS from "exceljs";
import PDFDocument from "pdfkit";
import { eq as eq7, and as and7, ne as ne2 } from "drizzle-orm";
var ExportService;
var init_exportService = __esm({
  "server/services/exportService.ts"() {
    "use strict";
    init_db();
    init_schema();
    ExportService = class {
      formatDate(dateStr, timeStr) {
        if (!dateStr) return "-";
        if (timeStr) {
          try {
            const [year, month, day] = dateStr.split("-");
            const [hour, minute] = timeStr.split(":");
            const date = new Date(parseInt(year), parseInt(month) - 1, parseInt(day), parseInt(hour), parseInt(minute));
            return date.toLocaleString("en-IN", {
              year: "numeric",
              month: "short",
              day: "numeric",
              hour: "2-digit",
              minute: "2-digit"
            });
          } catch (e) {
            return dateStr;
          }
        }
        return dateStr;
      }
      formatTimestamp(date) {
        if (!date) return "-";
        return new Date(date).toLocaleString("en-IN", {
          year: "numeric",
          month: "short",
          day: "numeric",
          hour: "2-digit",
          minute: "2-digit"
        });
      }
      formatCurrency(amountInPaisa) {
        return `\u20B9${(amountInPaisa / 100).toFixed(2)}`;
      }
      async getEventWithRegistrations(eventId) {
        const [event] = await db.select().from(events).where(eq7(events.id, eventId)).limit(1);
        if (!event) {
          const error = new Error("Event not found");
          error.statusCode = 404;
          throw error;
        }
        const registrations = await db.select().from(eventRegistrations).where(
          and7(
            eq7(eventRegistrations.eventId, eventId),
            ne2(eventRegistrations.status, "cancelled")
          )
        );
        return { event, registrations };
      }
      async exportAttendeesToExcel(eventId) {
        const { event, registrations } = await this.getEventWithRegistrations(eventId);
        const workbook = new ExcelJS.Workbook();
        const worksheet = workbook.addWorksheet("Attendees");
        worksheet.columns = [
          { header: "Booking ID", key: "bookingReference", width: 20 },
          { header: "Name", key: "name", width: 30 },
          { header: "Email", key: "email", width: 35 },
          { header: "Phone", key: "phone", width: 15 },
          { header: "Amount Paid", key: "amountPaid", width: 15 },
          { header: "Payment Status", key: "paymentStatus", width: 15 },
          { header: "Registered", key: "registeredAt", width: 20 },
          { header: "Checked In", key: "checkedInAt", width: 20 },
          { header: "Special Requirements", key: "specialRequirements", width: 40 }
        ];
        worksheet.insertRow(1, [`${event.title} - Attendee List`]);
        worksheet.mergeCells("A1:I1");
        worksheet.getCell("A1").font = { size: 16, bold: true };
        worksheet.getCell("A1").alignment = { horizontal: "center" };
        worksheet.insertRow(2, [`Event Date: ${this.formatDate(event.startDate, event.startTime)}`]);
        worksheet.mergeCells("A2:I2");
        worksheet.getCell("A2").alignment = { horizontal: "center" };
        worksheet.insertRow(3, []);
        const headerRow = worksheet.getRow(4);
        headerRow.font = { bold: true, color: { argb: "FFFFFFFF" } };
        headerRow.fill = {
          type: "pattern",
          pattern: "solid",
          fgColor: { argb: "FF4F46E5" }
        };
        headerRow.alignment = { horizontal: "center", vertical: "middle" };
        headerRow.height = 25;
        registrations.forEach((reg) => {
          const rowData = {
            bookingReference: reg.bookingId,
            name: reg.attendeeName,
            email: reg.attendeeEmail,
            phone: reg.attendeePhone,
            amountPaid: this.formatCurrency(reg.totalAmountPaisa),
            paymentStatus: reg.paymentStatus || "-",
            registeredAt: this.formatTimestamp(reg.createdAt),
            checkedInAt: this.formatTimestamp(reg.checkedInAt),
            specialRequirements: reg.specialRequirements || "-"
          };
          const row = worksheet.addRow(rowData);
          if (row.number % 2 === 0) {
            row.fill = {
              type: "pattern",
              pattern: "solid",
              fgColor: { argb: "FFF3F4F6" }
            };
          }
        });
        const summaryStartRow = worksheet.rowCount + 3;
        worksheet.getCell(`A${summaryStartRow}`).value = "Summary";
        worksheet.getCell(`A${summaryStartRow}`).font = { bold: true, size: 14 };
        const checkedInCount = registrations.filter((r) => r.checkedInAt !== null).length;
        const totalRevenue = registrations.reduce((sum4, r) => sum4 + r.totalAmountPaisa, 0);
        worksheet.getCell(`A${summaryStartRow + 1}`).value = "Total Registrations:";
        worksheet.getCell(`B${summaryStartRow + 1}`).value = registrations.length;
        worksheet.getCell(`B${summaryStartRow + 1}`).font = { bold: true };
        worksheet.getCell(`A${summaryStartRow + 2}`).value = "Checked In:";
        worksheet.getCell(`B${summaryStartRow + 2}`).value = checkedInCount;
        worksheet.getCell(`B${summaryStartRow + 2}`).font = { bold: true };
        worksheet.getCell(`A${summaryStartRow + 3}`).value = "Attendance Rate:";
        worksheet.getCell(`B${summaryStartRow + 3}`).value = `${registrations.length > 0 ? (checkedInCount / registrations.length * 100).toFixed(1) : 0}%`;
        worksheet.getCell(`B${summaryStartRow + 3}`).font = { bold: true };
        worksheet.getCell(`A${summaryStartRow + 4}`).value = "Total Revenue:";
        worksheet.getCell(`B${summaryStartRow + 4}`).value = this.formatCurrency(totalRevenue);
        worksheet.getCell(`B${summaryStartRow + 4}`).font = { bold: true, color: { argb: "FF059669" } };
        worksheet.eachRow((row, rowNumber) => {
          if (rowNumber >= 4) {
            row.eachCell((cell) => {
              cell.border = {
                top: { style: "thin", color: { argb: "FFD1D5DB" } },
                left: { style: "thin", color: { argb: "FFD1D5DB" } },
                bottom: { style: "thin", color: { argb: "FFD1D5DB" } },
                right: { style: "thin", color: { argb: "FFD1D5DB" } }
              };
            });
          }
        });
        const buffer = await workbook.xlsx.writeBuffer();
        return Buffer.from(buffer);
      }
      async exportAttendeesToPDF(eventId) {
        const { event, registrations } = await this.getEventWithRegistrations(eventId);
        return new Promise((resolve, reject) => {
          const chunks = [];
          const doc = new PDFDocument({
            margin: 50,
            size: "A4",
            info: {
              Title: `${event.title} - Attendee List`,
              Author: "SalonHub",
              Subject: "Event Attendee Report"
            }
          });
          doc.on("data", (chunk) => chunks.push(chunk));
          doc.on("end", () => resolve(Buffer.concat(chunks)));
          doc.on("error", reject);
          doc.fontSize(20).font("Helvetica-Bold").text(event.title, { align: "center" });
          doc.fontSize(12).font("Helvetica").text(
            `Attendee List - ${this.formatDate(event.startDate, event.startTime)}`,
            { align: "center" }
          );
          doc.moveDown(2);
          const checkedInCount = registrations.filter((r) => r.checkedInAt !== null).length;
          const totalRevenue = registrations.reduce((sum4, r) => sum4 + r.totalAmountPaisa, 0);
          const boxY = doc.y;
          const boxWidth = 150;
          const boxHeight = 60;
          const spacing = 20;
          doc.rect(50, boxY, boxWidth, boxHeight).stroke();
          doc.fontSize(10).font("Helvetica").text("Total Registrations", 60, boxY + 10);
          doc.fontSize(24).font("Helvetica-Bold").text(registrations.length.toString(), 60, boxY + 28);
          doc.rect(50 + boxWidth + spacing, boxY, boxWidth, boxHeight).stroke();
          doc.fontSize(10).font("Helvetica").text("Checked In", 60 + boxWidth + spacing, boxY + 10);
          doc.fontSize(24).font("Helvetica-Bold").text(checkedInCount.toString(), 60 + boxWidth + spacing, boxY + 28);
          doc.rect(50 + (boxWidth + spacing) * 2, boxY, boxWidth, boxHeight).stroke();
          doc.fontSize(10).font("Helvetica").text("Total Revenue", 60 + (boxWidth + spacing) * 2, boxY + 10);
          doc.fontSize(16).font("Helvetica-Bold").text(
            this.formatCurrency(totalRevenue),
            60 + (boxWidth + spacing) * 2,
            boxY + 28
          );
          doc.moveDown(5);
          const tableTop = doc.y;
          const rowHeight = 25;
          doc.fontSize(10).font("Helvetica-Bold");
          doc.text("Name", 50, tableTop);
          doc.text("Email", 200, tableTop);
          doc.text("Phone", 350, tableTop);
          doc.text("Status", 480, tableTop);
          doc.moveTo(50, tableTop + 15).lineTo(550, tableTop + 15).stroke();
          doc.font("Helvetica").fontSize(9);
          let currentY = tableTop + 20;
          registrations.forEach((reg, index2) => {
            if (currentY > 720) {
              doc.addPage();
              currentY = 50;
              doc.fontSize(10).font("Helvetica-Bold");
              doc.text("Name", 50, currentY);
              doc.text("Email", 200, currentY);
              doc.text("Phone", 350, currentY);
              doc.text("Status", 480, currentY);
              doc.moveTo(50, currentY + 15).lineTo(550, currentY + 15).stroke();
              currentY += 20;
              doc.font("Helvetica").fontSize(9);
            }
            if (index2 % 2 === 1) {
              doc.rect(50, currentY - 2, 500, rowHeight).fill("#F3F4F6").stroke();
            }
            const isCheckedIn = reg.checkedInAt !== null;
            doc.fillColor("#000000");
            doc.text(reg.attendeeName, 50, currentY, { width: 140, ellipsis: true });
            doc.text(reg.attendeeEmail, 200, currentY, { width: 140, ellipsis: true });
            doc.text(reg.attendeePhone, 350, currentY);
            doc.fillColor(isCheckedIn ? "#059669" : "#6B7280");
            doc.text(isCheckedIn ? "\u2713 Checked In" : "Registered", 480, currentY);
            doc.fillColor("#000000");
            currentY += rowHeight;
          });
          doc.fontSize(8).fillColor("#6B7280");
          doc.text(
            `Generated on ${(/* @__PURE__ */ new Date()).toLocaleString("en-IN")} | SalonHub Event Management`,
            50,
            doc.page.height - 50,
            { align: "center" }
          );
          doc.end();
        });
      }
      async exportCheckInSheet(eventId) {
        const { event, registrations } = await this.getEventWithRegistrations(eventId);
        return new Promise((resolve, reject) => {
          const chunks = [];
          const doc = new PDFDocument({ margin: 50 });
          doc.on("data", (chunk) => chunks.push(chunk));
          doc.on("end", () => resolve(Buffer.concat(chunks)));
          doc.on("error", reject);
          doc.fontSize(18).font("Helvetica-Bold").text(event.title, { align: "center" });
          doc.fontSize(12).font("Helvetica").text("Check-In Sheet", { align: "center" });
          doc.fontSize(10).text(this.formatDate(event.startDate, event.startTime), { align: "center" });
          doc.moveDown(2);
          doc.fontSize(9).fillColor("#6B7280");
          doc.text("Instructions: Check the box as each attendee arrives. Verify their name and booking ID.", {
            align: "left"
          });
          doc.moveDown();
          doc.fillColor("#000000");
          doc.fontSize(10).font("Helvetica-Bold");
          doc.text(`Total Expected: ${registrations.length} attendee(s)`);
          doc.moveDown();
          registrations.forEach((reg, index2) => {
            const y = doc.y;
            if (y > 700) {
              doc.addPage();
              doc.fontSize(18).font("Helvetica-Bold").text(event.title, { align: "center" });
              doc.fontSize(12).font("Helvetica").text("Check-In Sheet (cont.)", { align: "center" });
              doc.moveDown(2);
            }
            doc.rect(50, doc.y, 20, 20).stroke();
            doc.fontSize(8).fillColor("#6B7280");
            doc.text(`#${index2 + 1}`, 35, doc.y + 6, { width: 10 });
            doc.fillColor("#000000");
            doc.fontSize(12).font("Helvetica-Bold");
            doc.text(reg.attendeeName, 80, doc.y - 14);
            doc.fontSize(9).font("Helvetica");
            doc.text(reg.attendeeEmail, 80, doc.y + 2);
            doc.text(`Phone: ${reg.attendeePhone}`, 80, doc.y + 2);
            doc.text(`Booking: ${reg.bookingId}`, 80, doc.y + 2);
            doc.moveTo(50, doc.y + 5).lineTo(550, doc.y + 5).strokeColor("#E5E7EB").stroke().strokeColor("#000000");
            doc.moveDown(1.5);
          });
          if (doc.y < 650) {
            doc.moveDown(3);
            doc.fontSize(10).font("Helvetica-Bold");
            doc.text("Staff Signature:", 50, doc.y);
            doc.moveTo(150, doc.y + 15).lineTo(350, doc.y + 15).stroke();
            doc.text("Date & Time:", 380, doc.y - 15);
            doc.moveTo(470, doc.y).lineTo(550, doc.y).stroke();
          }
          doc.end();
        });
      }
    };
  }
});

// server/services/noshow.service.ts
var noshow_service_exports = {};
__export(noshow_service_exports, {
  noShowService: () => noShowService
});
import { eq as eq21, and as and21, sql as sql18 } from "drizzle-orm";
var NoShowService, noShowService;
var init_noshow_service = __esm({
  "server/services/noshow.service.ts"() {
    "use strict";
    init_db();
    init_schema();
    NoShowService = class {
      async markBookingAsNoShow(bookingId, salonId, processedBy) {
        try {
          const booking = await db.query.bookings.findFirst({
            where: and21(
              eq21(bookings.id, bookingId),
              eq21(bookings.salonId, salonId)
            )
          });
          if (!booking) {
            return {
              success: false,
              bookingId,
              previousStatus: "",
              error: "Booking not found"
            };
          }
          if (booking.status !== "confirmed") {
            return {
              success: false,
              bookingId,
              previousStatus: booking.status,
              error: `Cannot mark as no-show: booking status is ${booking.status}, must be confirmed`
            };
          }
          await db.update(bookings).set({
            status: "no_show",
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq21(bookings.id, bookingId));
          const depositResult = await this.processDepositForNoShow(
            bookingId,
            salonId,
            booking.userId,
            processedBy
          );
          await this.updateCustomerNoShowStats(salonId, booking.userId);
          return {
            success: true,
            bookingId,
            previousStatus: booking.status,
            depositAction: depositResult.action,
            depositAmountPaisa: depositResult.amountPaisa
          };
        } catch (error) {
          console.error("Error marking booking as no-show:", error);
          return {
            success: false,
            bookingId,
            previousStatus: "",
            error: error instanceof Error ? error.message : "Unknown error"
          };
        }
      }
      async processDepositForNoShow(bookingId, salonId, customerId, processedBy) {
        const depositTx = await db.query.depositTransactions.findFirst({
          where: and21(
            eq21(depositTransactions.bookingId, bookingId),
            eq21(depositTransactions.transactionType, "deposit_collected"),
            eq21(depositTransactions.status, "completed")
          )
        });
        if (!depositTx) {
          return { action: "no_deposit" };
        }
        const policy = await db.query.cancellationPolicies.findFirst({
          where: eq21(cancellationPolicies.salonId, salonId)
        });
        const noShowAction = policy?.noShowAction || "forfeit_full";
        const originalDepositAmount = depositTx.amountPaisa;
        let forfeitAmount = originalDepositAmount;
        let refundAmount = 0;
        let action = "forfeited";
        if (noShowAction === "forfeit_partial" && policy?.partialForfeitPercentage) {
          forfeitAmount = Math.round(originalDepositAmount * policy.partialForfeitPercentage / 100);
          refundAmount = originalDepositAmount - forfeitAmount;
          action = "partial_forfeit";
        } else if (noShowAction === "charge_full_service" && policy?.noShowChargeFull === 1) {
          forfeitAmount = depositTx.serviceAmountPaisa;
          action = "charged_full";
        }
        await db.update(depositTransactions).set({
          transactionType: "deposit_forfeited",
          amountPaisa: forfeitAmount,
          status: "completed",
          reason: `No-show: ${noShowAction}`,
          wasNoShow: 1,
          forfeitedAt: /* @__PURE__ */ new Date(),
          processedAt: /* @__PURE__ */ new Date(),
          processedBy: processedBy || null,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq21(depositTransactions.id, depositTx.id));
        if (noShowAction === "forfeit_partial" && refundAmount > 0) {
          await db.insert(depositTransactions).values({
            salonId,
            bookingId,
            customerId: customerId || depositTx.customerId,
            transactionType: "deposit_refunded",
            amountPaisa: refundAmount,
            serviceAmountPaisa: depositTx.serviceAmountPaisa,
            depositPercentage: 100 - (policy?.partialForfeitPercentage || 0),
            status: "pending",
            reason: "Partial refund for no-show (policy allows partial forfeit)",
            wasNoShow: 1,
            notes: `Refund of ${refundAmount / 100} (${100 - (policy?.partialForfeitPercentage || 0)}% of deposit) per cancellation policy`
          });
        }
        if (noShowAction === "charge_full_service" && forfeitAmount > originalDepositAmount) {
          await db.insert(depositTransactions).values({
            salonId,
            bookingId,
            customerId: customerId || depositTx.customerId,
            transactionType: "no_show_charged",
            amountPaisa: forfeitAmount - originalDepositAmount,
            serviceAmountPaisa: depositTx.serviceAmountPaisa,
            depositPercentage: 100,
            status: "pending",
            reason: "Additional charge for no-show (full service price)",
            wasNoShow: 1,
            notes: "Pending charge for remaining service amount due to no-show"
          });
        }
        return { action, amountPaisa: forfeitAmount, refundedPaisa: refundAmount > 0 ? refundAmount : void 0 };
      }
      async updateCustomerNoShowStats(salonId, customerId) {
        if (!customerId) return;
        const trustedCustomer = await db.query.trustedCustomers.findFirst({
          where: and21(
            eq21(trustedCustomers.salonId, salonId),
            eq21(trustedCustomers.customerId, customerId)
          )
        });
        if (trustedCustomer) {
          const newNoShowCount = (trustedCustomer.noShowCount || 0) + 1;
          let newTrustLevel = trustedCustomer.trustLevel;
          let newCanBypassDeposit = trustedCustomer.canBypassDeposit;
          if (newNoShowCount >= 3) {
            newTrustLevel = "blacklisted";
            newCanBypassDeposit = 0;
          } else if (newNoShowCount >= 2) {
            newCanBypassDeposit = 0;
          }
          await db.update(trustedCustomers).set({
            noShowCount: newNoShowCount,
            trustLevel: newTrustLevel,
            canBypassDeposit: newCanBypassDeposit,
            lastUpdatedAt: /* @__PURE__ */ new Date()
          }).where(eq21(trustedCustomers.id, trustedCustomer.id));
        } else {
          await db.insert(trustedCustomers).values({
            salonId,
            customerId,
            trustLevel: "trusted",
            noShowCount: 1,
            totalBookings: 1,
            completedBookings: 0,
            canBypassDeposit: 0
          });
        }
      }
      async detectAndMarkNoShows() {
        const result = {
          processed: 0,
          noShowsMarked: 0,
          depositsForfeited: 0,
          errors: []
        };
        try {
          const allSalons = await db.query.salons.findMany({
            where: eq21(salons.status, "active")
          });
          for (const salon of allSalons) {
            const policy = await db.query.cancellationPolicies.findFirst({
              where: eq21(cancellationPolicies.salonId, salon.id)
            });
            const graceMinutes = policy?.noShowGraceMinutes || 15;
            const now = /* @__PURE__ */ new Date();
            const cutoffTime = new Date(now.getTime() - graceMinutes * 60 * 1e3);
            const overdueBookings = await db.select().from(bookings).where(and21(
              eq21(bookings.salonId, salon.id),
              eq21(bookings.status, "confirmed"),
              sql18`CONCAT(${bookings.bookingDate}, ' ', ${bookings.bookingTime})::timestamp < ${cutoffTime.toISOString()}`
            ));
            for (const booking of overdueBookings) {
              result.processed++;
              const noShowResult = await this.markBookingAsNoShow(
                booking.id,
                salon.id,
                "system_auto_detection"
              );
              if (noShowResult.success) {
                result.noShowsMarked++;
                if (noShowResult.depositAction && noShowResult.depositAction !== "no_deposit") {
                  result.depositsForfeited++;
                }
              } else {
                result.errors.push(`Booking ${booking.id}: ${noShowResult.error}`);
              }
            }
          }
          console.log(`[NoShow Detection] Processed: ${result.processed}, Marked: ${result.noShowsMarked}, Deposits: ${result.depositsForfeited}`);
          return result;
        } catch (error) {
          console.error("Error in no-show detection:", error);
          result.errors.push(error instanceof Error ? error.message : "Unknown error");
          return result;
        }
      }
      async getNoShowStatistics(salonId, days = 30) {
        const startDate = /* @__PURE__ */ new Date();
        startDate.setDate(startDate.getDate() - days);
        const [stats] = await db.select({
          totalNoShows: sql18`COUNT(DISTINCT ${bookings.id})::int`,
          depositsForfeited: sql18`COUNT(CASE WHEN ${depositTransactions.transactionType} = 'deposit_forfeited' AND ${depositTransactions.wasNoShow} = 1 THEN 1 END)::int`,
          totalForfeitedAmountPaisa: sql18`COALESCE(SUM(CASE WHEN ${depositTransactions.transactionType} = 'deposit_forfeited' AND ${depositTransactions.wasNoShow} = 1 THEN ${depositTransactions.amountPaisa} ELSE 0 END), 0)::int`,
          totalRefundedAmountPaisa: sql18`COALESCE(SUM(CASE WHEN ${depositTransactions.transactionType} = 'deposit_refunded' AND ${depositTransactions.wasNoShow} = 1 THEN ${depositTransactions.amountPaisa} ELSE 0 END), 0)::int`
        }).from(bookings).leftJoin(depositTransactions, eq21(bookings.id, depositTransactions.bookingId)).where(and21(
          eq21(bookings.salonId, salonId),
          eq21(bookings.status, "no_show"),
          sql18`${bookings.createdAt} >= ${startDate}`
        ));
        const [repeatOffendersResult] = await db.select({
          count: sql18`COUNT(*)::int`
        }).from(trustedCustomers).where(and21(
          eq21(trustedCustomers.salonId, salonId),
          sql18`${trustedCustomers.noShowCount} >= 2`
        ));
        return {
          totalNoShows: stats?.totalNoShows || 0,
          depositsForfeited: stats?.depositsForfeited || 0,
          totalForfeitedAmountPaisa: stats?.totalForfeitedAmountPaisa || 0,
          totalRefundedAmountPaisa: stats?.totalRefundedAmountPaisa || 0,
          repeatOffenders: repeatOffendersResult?.count || 0
        };
      }
    };
    noShowService = new NoShowService();
  }
});

// server/communicationService.ts
var communicationService_exports = {};
__export(communicationService_exports, {
  communicationService: () => communicationService,
  sendBookingConfirmation: () => sendBookingConfirmation,
  sendBookingReminder: () => sendBookingReminder,
  sendGuestWelcomeEmail: () => sendGuestWelcomeEmail,
  sendLowStockAlert: () => sendLowStockAlert,
  sendOrderCancellation: () => sendOrderCancellation,
  sendOrderConfirmation: () => sendOrderConfirmation,
  sendOrderStatusUpdate: () => sendOrderStatusUpdate,
  sendPaymentFailure: () => sendPaymentFailure,
  sendPaymentSuccess: () => sendPaymentSuccess,
  sendRescheduleNotification: () => sendRescheduleNotification
});
import { MailService } from "@sendgrid/mail";
import twilio2 from "twilio";
async function sendBookingConfirmation(salonId, bookingId, customerEmail, customerPhone, variables = {}) {
  const results = [];
  const preferences = await storage.getCommunicationPreferences(customerEmail, salonId);
  const preferredChannel = preferences?.preferredChannel || "email";
  if (preferredChannel === "email" || !customerPhone) {
    const emailResult = await communicationService.sendMessage({
      to: customerEmail,
      channel: "email",
      type: "booking_confirmation",
      salonId,
      customerId: customerEmail,
      bookingId,
      customContent: {
        subject: "Booking Confirmation - {{salon_name}}",
        body: `Hi {{customer_name}},

Your booking has been confirmed!

Details:
- Service: {{service_name}}
- Date: {{booking_date}}
- Time: {{booking_time}}
- Staff: {{staff_name}}

We look forward to seeing you!

Best regards,
{{salon_name}}`
      },
      variables
    });
    results.push(emailResult);
  }
  if (preferredChannel === "sms" && customerPhone) {
    const smsResult = await communicationService.sendMessage({
      to: customerPhone,
      channel: "sms",
      type: "booking_confirmation",
      salonId,
      customerId: customerEmail,
      bookingId,
      customContent: {
        body: `Hi {{customer_name}}! Your booking at {{salon_name}} is confirmed for {{booking_date}} at {{booking_time}}. Service: {{service_name}}, Staff: {{staff_name}}. See you soon!`
      },
      variables
    });
    results.push(smsResult);
  }
  return results;
}
async function sendBookingReminder(salonId, bookingId, customerEmail, customerPhone, variables = {}) {
  const results = [];
  const preferences = await storage.getCommunicationPreferences(customerEmail, salonId);
  if (preferences?.bookingNotifications !== false) {
    const preferredChannel = preferences?.preferredChannel || "email";
    if (preferredChannel === "email" || !customerPhone) {
      const emailResult = await communicationService.sendMessage({
        to: customerEmail,
        channel: "email",
        type: "booking_reminder",
        salonId,
        customerId: customerEmail,
        bookingId,
        customContent: {
          subject: "Appointment Reminder - {{salon_name}}",
          body: `Hi {{customer_name}},

This is a friendly reminder about your upcoming appointment:

- Service: {{service_name}}
- Date: {{booking_date}}
- Time: {{booking_time}}
- Staff: {{staff_name}}

We're excited to see you soon!

{{salon_name}}`
        },
        variables
      });
      results.push(emailResult);
    }
    if (preferredChannel === "sms" && customerPhone) {
      const smsResult = await communicationService.sendMessage({
        to: customerPhone,
        channel: "sms",
        type: "booking_reminder",
        salonId,
        customerId: customerEmail,
        bookingId,
        customContent: {
          body: `Reminder: You have an appointment at {{salon_name}} tomorrow at {{booking_time}} for {{service_name}} with {{staff_name}}. Looking forward to seeing you!`
        },
        variables
      });
      results.push(smsResult);
    }
  }
  return results;
}
async function sendRescheduleNotification(salonId, bookingId, customerEmail, customerPhone, variables = {}) {
  const results = [];
  const preferences = await storage.getCommunicationPreferences(customerEmail, salonId);
  if (preferences?.bookingNotifications !== false) {
    const preferredChannel = preferences?.preferredChannel || "email";
    if (preferredChannel === "email" || !customerPhone) {
      const emailResult = await communicationService.sendMessage({
        to: customerEmail,
        channel: "email",
        type: "booking_rescheduled",
        salonId,
        customerId: customerEmail,
        bookingId,
        customContent: {
          subject: "Booking Rescheduled - {{salon_name}}",
          body: `Hi {{customer_name}},

Your booking has been rescheduled.

Previous Time:
Date: {{old_date}}
Time: {{old_time}}

New Time:
Date: {{new_date}}
Time: {{new_time}}

Service: {{service_name}}
Staff: {{staff_name}}
Total: Rs.{{total_amount}}

Thank you for your flexibility!

{{salon_name}}`
        },
        variables
      });
      results.push(emailResult);
    }
    if (preferredChannel === "sms" && customerPhone) {
      const smsResult = await communicationService.sendMessage({
        to: customerPhone,
        channel: "sms",
        type: "booking_rescheduled",
        salonId,
        customerId: customerEmail,
        bookingId,
        customContent: {
          body: `Hi {{customer_name}}! Your booking at {{salon_name}} has been rescheduled from {{old_date}} {{old_time}} to {{new_date}} {{new_time}}. Service: {{service_name}}.`
        },
        variables
      });
      results.push(smsResult);
    }
  }
  return results;
}
async function sendOrderConfirmation(salonId, orderId, customerEmail, variables = {}) {
  return await communicationService.sendMessage({
    to: customerEmail,
    channel: "email",
    type: "transactional",
    salonId,
    customerId: customerEmail,
    customContent: {
      subject: "Order Confirmation #{{order_number}} - {{salon_name}}",
      body: `Hi {{customer_name}},

Thank you for your order! Your order has been confirmed and is being prepared.

Order Details:
Order Number: #{{order_number}}
Total Items: {{item_count}}
Total Amount: Rs.{{total_amount}}

Delivery Address:
{{delivery_address}}

Order Items:
{{order_items}}

Payment Method: {{payment_method}}
Payment Status: {{payment_status}}

We'll notify you when your order is ready for pickup/delivery!

Thank you for shopping with us!

{{salon_name}}`
    },
    variables
  });
}
async function sendPaymentSuccess(salonId, orderId, customerEmail, variables = {}) {
  return await communicationService.sendMessage({
    to: customerEmail,
    channel: "email",
    type: "transactional",
    salonId,
    customerId: customerEmail,
    customContent: {
      subject: "Payment Successful - Order #{{order_number}}",
      body: `Hi {{customer_name}},

Your payment has been successfully processed!

Payment Details:
Order Number: #{{order_number}}
Amount Paid: Rs.{{amount_paid}}
Payment Method: {{payment_method}}
Transaction ID: {{transaction_id}}

Your order is now being prepared and you'll receive updates as it progresses.

Thank you for your purchase!

{{salon_name}}`
    },
    variables
  });
}
async function sendPaymentFailure(salonId, orderId, customerEmail, variables = {}) {
  return await communicationService.sendMessage({
    to: customerEmail,
    channel: "email",
    type: "transactional",
    salonId,
    customerId: customerEmail,
    customContent: {
      subject: "Payment Failed - Order #{{order_number}}",
      body: `Hi {{customer_name}},

We were unable to process your payment for order #{{order_number}}.

Payment Details:
Order Number: #{{order_number}}
Amount: Rs.{{amount}}
Payment Method: {{payment_method}}
Reason: {{failure_reason}}

What's Next?
1. Your order has been saved and is on hold
2. Please retry payment from your Order History
3. Or contact us if you need assistance

Don't worry - we've reserved your items for the next 24 hours!

Need help? Reply to this email or contact our support team.

{{salon_name}}`
    },
    variables
  });
}
async function sendOrderStatusUpdate(salonId, orderId, customerEmail, newStatus, variables = {}) {
  const statusMessages = {
    processing: {
      subject: "Order #{{order_number}} is Being Prepared",
      body: `Hi {{customer_name}},

Great news! Your order is now being prepared.

Order Number: #{{order_number}}
Status: Processing

We'll notify you once your order is packed and ready!

{{salon_name}}`
    },
    packed: {
      subject: "Order #{{order_number}} is Packed & Ready",
      body: `Hi {{customer_name}},

Your order has been packed and is ready!

Order Number: #{{order_number}}
Status: Packed

{{#if delivery_method_pickup}}
Pickup Details:
Location: {{salon_address}}
Ready for pickup anytime during business hours
{{else}}
Your order will be shipped soon!
{{/if}}

{{salon_name}}`
    },
    shipped: {
      subject: "Order #{{order_number}} Has Been Shipped",
      body: `Hi {{customer_name}},

Your order is on its way!

Order Number: #{{order_number}}
Status: Shipped
{{#if tracking_number}}
Tracking Number: {{tracking_number}}
{{/if}}
Estimated Delivery: {{estimated_delivery}}

You can track your order from your Order History page.

{{salon_name}}`
    },
    delivered: {
      subject: "Order #{{order_number}} Delivered Successfully",
      body: `Hi {{customer_name}},

Your order has been delivered!

Order Number: #{{order_number}}
Status: Delivered
Delivered On: {{delivered_date}}

We hope you love your products! If you have any concerns, please contact us within 7 days.

We'd love your feedback! Please rate your experience and help other customers.

Thank you for shopping with us!

{{salon_name}}`
    }
  };
  const statusMessage = statusMessages[newStatus] || {
    subject: "Order #{{order_number}} Status Update",
    body: `Hi {{customer_name}},

Your order status has been updated.

Order Number: #{{order_number}}
New Status: ${newStatus}

{{salon_name}}`
  };
  return await communicationService.sendMessage({
    to: customerEmail,
    channel: "email",
    type: "transactional",
    salonId,
    customerId: customerEmail,
    customContent: statusMessage,
    variables
  });
}
async function sendOrderCancellation(salonId, orderId, customerEmail, variables = {}) {
  return await communicationService.sendMessage({
    to: customerEmail,
    channel: "email",
    type: "transactional",
    salonId,
    customerId: customerEmail,
    customContent: {
      subject: "Order #{{order_number}} Cancelled",
      body: `Hi {{customer_name}},

Your order has been cancelled.

Order Number: #{{order_number}}
Cancellation Reason: {{cancellation_reason}}
Cancelled On: {{cancelled_date}}

Refund Information:
{{#if refund_applicable}}
Amount to be Refunded: Rs.{{refund_amount}}
Refund Method: {{refund_method}}
Expected in: {{refund_timeline}}
{{else}}
No refund applicable for this order.
{{/if}}

If you have any questions, please don't hesitate to contact us.

We hope to serve you again soon!

{{salon_name}}`
    },
    variables
  });
}
async function sendLowStockAlert(salonId, adminEmail, variables = {}) {
  return await communicationService.sendMessage({
    to: adminEmail,
    channel: "email",
    type: "transactional",
    salonId,
    customContent: {
      subject: "LOW STOCK ALERT - {{product_name}}",
      body: `Hello Admin,

Stock Alert: {{product_name}} is running low!

Stock Details:
Product: {{product_name}}
Current Stock: {{current_stock}} units
Low Stock Threshold: {{threshold}} units
Retail Allocated: {{retail_allocated}} units
Service Allocated: {{service_allocated}} units

Recommended Action:
Please restock this product soon to avoid running out.

View Product: {{product_link}}

Stylemate Admin`
    },
    variables
  });
}
async function sendGuestWelcomeEmail(salonId, customerEmail, customerName, tempPassword) {
  const escapeTemplateChars = (str) => str.replace(/\{/g, "&#123;").replace(/\}/g, "&#125;");
  const safeName = escapeTemplateChars(customerName);
  const safeEmail = escapeTemplateChars(customerEmail);
  const safePassword = escapeTemplateChars(tempPassword);
  return await communicationService.sendMessage({
    to: customerEmail,
    channel: "email",
    type: "transactional",
    salonId,
    customerId: customerEmail,
    customContent: {
      subject: "Welcome to Stylemate - Your Account is Ready!",
      body: `Hi ${safeName},

Welcome to Stylemate! An account has been created for you based on your recent booking.

You can now log in to view and manage all your bookings in one place.

Your Login Credentials:
Email: ${safeEmail}
Temporary Password: ${safePassword}

For security, please change your password after your first login.

To log in, visit our website and click "Sign In".

Best regards,
The Stylemate Team`
    },
    variables: {}
  });
}
var CommunicationService, communicationService;
var init_communicationService = __esm({
  "server/communicationService.ts"() {
    "use strict";
    init_storage();
    CommunicationService = class {
      emailService = null;
      smsService = null;
      // Twilio client
      constructor() {
        this.initializeProviders();
      }
      initializeProviders() {
        if (process.env.SENDGRID_API_KEY) {
          this.emailService = new MailService();
          this.emailService.setApiKey(process.env.SENDGRID_API_KEY);
        } else {
          console.warn("SENDGRID_API_KEY not set - email functionality disabled");
        }
        if (process.env.TWILIO_ACCOUNT_SID && process.env.TWILIO_AUTH_TOKEN) {
          this.smsService = twilio2(
            process.env.TWILIO_ACCOUNT_SID,
            process.env.TWILIO_AUTH_TOKEN
          );
        } else {
          console.warn("Twilio credentials not set - SMS functionality disabled");
        }
      }
      // Main method to send messages across channels
      async sendMessage(request) {
        try {
          const historyRecord = {
            salonId: request.salonId,
            customerId: request.customerId || null,
            bookingId: request.bookingId || null,
            campaignId: request.campaignId || null,
            templateId: request.templateId || null,
            type: request.type,
            channel: request.channel,
            recipient: request.to,
            status: "pending",
            subject: request.customContent?.subject || null,
            content: request.customContent?.body || null,
            metadata: request.variables ? JSON.stringify(request.variables) : null,
            createdAt: /* @__PURE__ */ new Date()
          };
          const history = await storage.createCommunicationHistory(historyRecord);
          let content;
          if (request.templateId) {
            const template = await storage.getMessageTemplate(request.templateId);
            if (!template) {
              await this.updateHistoryStatus(history.id, "failed", "Template not found");
              return { success: false, error: "Template not found", historyId: history.id };
            }
            content = this.applyTemplateVariables(template, request.variables || {});
          } else if (request.customContent) {
            content = request.customContent;
          } else {
            await this.updateHistoryStatus(history.id, "failed", "No content provided");
            return { success: false, error: "No content provided", historyId: history.id };
          }
          let result;
          if (request.channel === "email") {
            result = await this.sendEmail({
              to: request.to,
              subject: content.subject || "Notification from your salon",
              body: content.body,
              html: content.html,
              salonId: request.salonId
            });
          } else if (request.channel === "sms") {
            result = await this.sendSMS({
              to: request.to,
              body: content.body,
              salonId: request.salonId
            });
          } else {
            await this.updateHistoryStatus(history.id, "failed", "Invalid channel");
            return { success: false, error: "Invalid channel", historyId: history.id };
          }
          await storage.updateCommunicationHistory(history.id, {
            status: "sent",
            providerId: result.messageId,
            sentAt: /* @__PURE__ */ new Date()
          });
          return {
            success: true,
            messageId: result.messageId,
            providerId: result.messageId,
            historyId: history.id
          };
        } catch (error) {
          console.error("Error sending message:", error);
          if (request.customerId) {
            try {
              const historyRecord = {
                salonId: request.salonId,
                customerId: request.customerId,
                bookingId: request.bookingId || null,
                campaignId: request.campaignId || null,
                templateId: request.templateId || null,
                type: request.type,
                channel: request.channel,
                recipient: request.to,
                status: "failed",
                subject: request.customContent?.subject || null,
                content: request.customContent?.body || null,
                failureReason: error instanceof Error ? error.message : "Unknown error",
                metadata: request.variables ? JSON.stringify(request.variables) : null,
                createdAt: /* @__PURE__ */ new Date()
              };
              await storage.createCommunicationHistory(historyRecord);
            } catch (historyError) {
              console.error("Error creating failure history record:", historyError);
            }
          }
          return {
            success: false,
            error: error instanceof Error ? error.message : "Unknown error"
          };
        }
      }
      async sendEmail(params) {
        if (!this.emailService) {
          throw new Error("Email service not configured");
        }
        const salon = await storage.getSalon(params.salonId);
        const fromEmail = process.env.SENDGRID_FROM_EMAIL || salon?.email || "noreply@stylemate.com";
        const fromName = salon?.name || "Stylemate";
        const emailData = {
          to: params.to,
          from: {
            email: fromEmail,
            name: fromName
          },
          subject: params.subject,
          html: params.html || this.formatEmailHTML(params.body, salon?.name),
          text: params.body
        };
        const [response] = await this.emailService.send(emailData);
        return { messageId: response.headers["x-message-id"] || "email-sent" };
      }
      async sendSMS(params) {
        if (!this.smsService) {
          throw new Error("SMS service not configured");
        }
        const fromNumber = process.env.TWILIO_PHONE_NUMBER;
        if (!fromNumber) {
          throw new Error("Twilio phone number not configured");
        }
        let toNumber = params.to;
        if (!toNumber.startsWith("+")) {
          toNumber = "+91" + toNumber.replace(/^0/, "");
        }
        const message = await this.smsService.messages.create({
          to: toNumber,
          from: fromNumber,
          body: params.body
        });
        return { messageId: message.sid };
      }
      // Apply template variables to template content
      applyTemplateVariables(template, variables) {
        let subject = template.subject;
        let body = template.content;
        for (const [key, value] of Object.entries(variables)) {
          const regex = new RegExp(`{{\\s*${key}\\s*}}`, "g");
          if (subject) {
            subject = subject.replace(regex, value);
          }
          body = body.replace(regex, value);
        }
        return { subject: subject || void 0, body };
      }
      // Format email content with basic HTML structure
      formatEmailHTML(content, salonName) {
        const htmlContent = content.replace(/\n/g, "<br>");
        return `
      <!DOCTYPE html>
      <html>
      <head>
          <meta charset="utf-8">
          <meta name="viewport" content="width=device-width, initial-scale=1.0">
          <title>Message from ${salonName || "Your Salon"}</title>
      </head>
      <body style="margin: 0; padding: 0; font-family: Arial, sans-serif; background-color: #f5f5f5;">
          <div style="max-width: 600px; margin: 0 auto; background-color: white; padding: 40px 20px;">
              <div style="text-align: center; margin-bottom: 30px;">
                  <h2 style="color: #8b5cf6; font-size: 20px; margin: 0;">${salonName || "Your Salon"}</h2>
              </div>
              
              <div style="color: #333; font-size: 16px; line-height: 1.6;">
                  ${htmlContent}
              </div>
              
              <div style="margin-top: 40px; padding-top: 20px; border-top: 1px solid #eee; text-align: center;">
                  <p style="color: #999; font-size: 12px;">
                      You received this message because you are a valued customer.
                      If you no longer wish to receive these messages, please contact us.
                  </p>
              </div>
          </div>
      </body>
      </html>
    `;
      }
      async updateHistoryStatus(historyId, status, failureReason) {
        try {
          await storage.updateCommunicationHistory(historyId, {
            status,
            failureReason: failureReason || null
          });
        } catch (error) {
          console.error("Error updating communication history:", error);
        }
      }
      // Bulk send messages (for campaigns)
      async sendBulkMessages(requests) {
        const results = await Promise.allSettled(
          requests.map((request) => this.sendMessage(request))
        );
        return results.map(
          (result) => result.status === "fulfilled" ? result.value : { success: false, error: "Failed to send message" }
        );
      }
      // Get delivery status from providers
      async getDeliveryStatus(providerId, channel) {
        return { status: "sent" };
      }
      // Validate phone number format
      isValidPhoneNumber(phone) {
        const phoneRegex = /^\+?[1-9]\d{1,14}$/;
        return phoneRegex.test(phone.replace(/\s/g, ""));
      }
      // Validate email address format  
      isValidEmail(email) {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(email);
      }
    };
    communicationService = new CommunicationService();
  }
});

// server/emailService.ts
var emailService_exports = {};
__export(emailService_exports, {
  generateVerificationEmailHTML: () => generateVerificationEmailHTML,
  sendEmail: () => sendEmail,
  sendVerificationEmail: () => sendVerificationEmail
});
import { MailService as MailService2 } from "@sendgrid/mail";
function getMailService() {
  if (!process.env.SENDGRID_API_KEY) {
    console.warn("SENDGRID_API_KEY not set - email functionality disabled");
    return null;
  }
  if (!mailService) {
    mailService = new MailService2();
    mailService.setApiKey(process.env.SENDGRID_API_KEY);
  }
  return mailService;
}
async function sendEmail(params) {
  const service = getMailService();
  if (!service) {
    console.log(`Email would be sent to ${params.to}: ${params.subject}`);
    return false;
  }
  try {
    await service.send({
      to: params.to,
      from: params.from,
      subject: params.subject,
      text: params.text || "",
      html: params.html || ""
    });
    return true;
  } catch (error) {
    console.error("SendGrid email error:", error);
    return false;
  }
}
function generateVerificationEmailHTML(firstName, verificationLink) {
  return `
    <!DOCTYPE html>
    <html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Verify your Stylemate email</title>
    </head>
    <body style="margin: 0; padding: 0; font-family: Arial, sans-serif; background-color: #f5f5f5;">
        <div style="max-width: 600px; margin: 0 auto; background-color: white; padding: 40px 20px;">
            <!-- Header -->
            <div style="text-align: center; margin-bottom: 40px;">
                <h1 style="color: #8b5cf6; font-size: 24px; margin: 0;">Stylemate</h1>
            </div>
            
            <!-- Main Content -->
            <div style="text-align: center;">
                <h2 style="color: #333; font-size: 24px; margin-bottom: 20px;">
                    Hi ${firstName}, please verify your email address
                </h2>
                
                <p style="color: #666; font-size: 16px; line-height: 1.5; margin-bottom: 30px;">
                    To keep your account secure we need to check that the email address belongs to you. 
                    You'll only need to do this once, click below to verify now.
                </p>
                
                <!-- Verify Button -->
                <div style="margin: 40px 0;">
                    <a href="${verificationLink}" 
                       style="background-color: #333; color: white; padding: 12px 30px; text-decoration: none; 
                              border-radius: 6px; font-weight: bold; display: inline-block;">
                        Verify email
                    </a>
                </div>
                
                <!-- Alternative link -->
                <p style="color: #999; font-size: 14px; margin-top: 30px;">
                    If the button doesn't work, copy and paste this link: <br>
                    <a href="${verificationLink}" style="color: #8b5cf6;">${verificationLink}</a>
                </p>
            </div>
            
            <!-- Footer -->
            <div style="margin-top: 50px; padding-top: 30px; border-top: 1px solid #eee; text-align: center;">
                <h3 style="color: #333; font-size: 18px; margin-bottom: 10px;">Why did I receive this?</h3>
                <p style="color: #666; font-size: 14px; line-height: 1.5;">
                    Your email address was used to create an account on Stylemate. If you have received this email by mistake, you can safely ignore it.
                </p>
                
                <div style="margin-top: 30px;">
                    <p style="color: #999; font-size: 12px;">
                        The world's premier beauty & wellness booking platform, trusted by millions worldwide.<br>
                        Powerful features, unlimited possibilities.
                    </p>
                </div>
            </div>
        </div>
    </body>
    </html>
  `;
}
async function sendVerificationEmail(email, firstName, verificationToken) {
  const verificationLink = `${process.env.REPL_SLUG ? `https://${process.env.REPL_SLUG}.${process.env.REPL_OWNER}.repl.co` : "http://localhost:5000"}/verify-email?token=${verificationToken}`;
  const htmlContent = generateVerificationEmailHTML(firstName, verificationLink);
  const fromEmail = process.env.SENDGRID_FROM_EMAIL || process.env.FROM_EMAIL || "noreply@example.com";
  return await sendEmail({
    to: email,
    from: fromEmail,
    subject: "Verify your Stylemate email",
    html: htmlContent,
    text: `Hi ${firstName}, please verify your email address by clicking this link: ${verificationLink}`
  });
}
var mailService;
var init_emailService = __esm({
  "server/emailService.ts"() {
    "use strict";
    mailService = null;
  }
});

// server/lib/sendgrid.ts
var sendgrid_exports = {};
__export(sendgrid_exports, {
  sendBusinessWelcomeVerificationEmail: () => sendBusinessWelcomeVerificationEmail,
  sendPasswordChangedEmail: () => sendPasswordChangedEmail,
  sendPasswordResetEmail: () => sendPasswordResetEmail,
  sendVerificationReminderEmail: () => sendVerificationReminderEmail,
  sendWelcomeVerificationEmail: () => sendWelcomeVerificationEmail
});
import sgMail from "@sendgrid/mail";
async function getSendGridClient() {
  if (cachedClient && cachedFromEmail) {
    return { client: cachedClient, fromEmail: cachedFromEmail };
  }
  const apiKey = process.env.SENDGRID_API_KEY;
  const fromEmail = process.env.SENDGRID_FROM_EMAIL;
  if (!apiKey || !fromEmail) {
    throw new Error("SendGrid not configured. Set SENDGRID_API_KEY and SENDGRID_FROM_EMAIL");
  }
  sgMail.setApiKey(apiKey);
  cachedClient = sgMail;
  cachedFromEmail = fromEmail;
  return { client: sgMail, fromEmail };
}
async function sendPasswordResetEmail(email, resetLink, firstName) {
  const { client, fromEmail } = await getSendGridClient();
  const name = firstName || "there";
  const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Reset Your Password - Stylemate</title>
</head>
<body style="margin: 0; padding: 0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #f7f7f7;">
  <table width="100%" cellpadding="0" cellspacing="0" style="background-color: #f7f7f7; padding: 40px 20px;">
    <tr>
      <td align="center">
        <table width="600" cellpadding="0" cellspacing="0" style="background-color: #ffffff; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.08); overflow: hidden;">
          <!-- Header -->
          <tr>
            <td style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 40px; text-align: center;">
              <h1 style="margin: 0; color: #ffffff; font-size: 28px; font-weight: 600; letter-spacing: -0.5px;">Stylemate</h1>
              <p style="margin: 10px 0 0; color: rgba(255,255,255,0.9); font-size: 14px;">Beauty & Wellness Platform</p>
            </td>
          </tr>
          
          <!-- Body -->
          <tr>
            <td style="padding: 40px 40px 30px;">
              <h2 style="margin: 0 0 20px; color: #1a1a1a; font-size: 24px; font-weight: 600;">Reset Your Password</h2>
              <p style="margin: 0 0 16px; color: #4a4a4a; font-size: 16px; line-height: 1.6;">
                Hi ${name},
              </p>
              <p style="margin: 0 0 24px; color: #4a4a4a; font-size: 16px; line-height: 1.6;">
                We received a request to reset your password for your Stylemate business account. Click the button below to create a new password:
              </p>
              
              <!-- Reset Button -->
              <table cellpadding="0" cellspacing="0" style="margin: 30px 0;">
                <tr>
                  <td align="center" bgcolor="#667eea" style="background-color: #667eea; border-radius: 8px; box-shadow: 0 4px 8px rgba(102, 126, 234, 0.3);">
                    <a href="${resetLink}" style="display: block; padding: 16px 48px; color: #ffffff; background-color: #667eea; text-decoration: none; font-size: 16px; font-weight: 600; letter-spacing: 0.5px; border-radius: 8px;">
                      Reset Password
                    </a>
                  </td>
                </tr>
              </table>
              
              <!-- Security Info -->
              <div style="background-color: #fff8e1; border-left: 4px solid #ffc107; padding: 16px; margin: 24px 0; border-radius: 4px;">
                <p style="margin: 0 0 8px; color: #f57c00; font-size: 14px; font-weight: 600;">
                  \u23F1\uFE0F This link expires in <strong>1 hour</strong>
                </p>
                <p style="margin: 0; color: #e65100; font-size: 13px; line-height: 1.5;">
                  For security reasons, this password reset link will only work once and expires after 60 minutes.
                </p>
              </div>
              
              <p style="margin: 20px 0 0; color: #666666; font-size: 14px; line-height: 1.5;">
                If you didn't request this password reset, you can safely ignore this email. Your password will remain unchanged.
              </p>
            </td>
          </tr>
          
          <!-- Divider -->
          <tr>
            <td style="padding: 0 40px;">
              <hr style="border: none; border-top: 1px solid #e0e0e0; margin: 0;">
            </td>
          </tr>
          
          <!-- Alternative Link -->
          <tr>
            <td style="padding: 24px 40px 40px;">
              <p style="margin: 0 0 12px; color: #888888; font-size: 12px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px;">
                Button not working?
              </p>
              <p style="margin: 0; color: #666666; font-size: 12px; line-height: 1.6;">
                Copy and paste this link into your browser:
              </p>
              <p style="margin: 8px 0 0; color: #667eea; font-size: 12px; word-break: break-all; line-height: 1.5;">
                ${resetLink}
              </p>
            </td>
          </tr>
          
          <!-- Footer -->
          <tr>
            <td style="background-color: #f9f9f9; padding: 24px 40px; text-align: center; border-top: 1px solid #e0e0e0;">
              <p style="margin: 0 0 8px; color: #888888; font-size: 12px; line-height: 1.5;">
                This email was sent by <strong>Stylemate</strong>
              </p>
              <p style="margin: 0; color: #aaaaaa; font-size: 11px; line-height: 1.4;">
                The world's premier beauty & wellness booking platform
              </p>
            </td>
          </tr>
        </table>
        
        <!-- Security Notice -->
        <table width="600" cellpadding="0" cellspacing="0" style="margin-top: 20px;">
          <tr>
            <td style="text-align: center; padding: 0 20px;">
              <p style="margin: 0; color: #999999; font-size: 11px; line-height: 1.5;">
                \u{1F512} This is an automated security email. Please do not reply to this message.
              </p>
            </td>
          </tr>
        </table>
      </td>
    </tr>
  </table>
</body>
</html>
  `;
  const textContent = `
Hi ${name},

We received a request to reset your password for your Stylemate business account.

Click this link to reset your password:
${resetLink}

This link will expire in 1 hour for security reasons.

If you didn't request this password reset, you can safely ignore this email. Your password will remain unchanged.

---
This email was sent by Stylemate
The world's premier beauty & wellness booking platform
  `.trim();
  await client.send({
    to: email,
    from: { email: fromEmail, name: "Stylemate" },
    subject: "Reset your Stylemate password",
    html,
    text: textContent
  });
}
async function sendPasswordChangedEmail(email, firstName) {
  const { client, fromEmail } = await getSendGridClient();
  const name = firstName || "there";
  const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Password Changed - Stylemate</title>
</head>
<body style="margin: 0; padding: 0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #f7f7f7;">
  <table width="100%" cellpadding="0" cellspacing="0" style="background-color: #f7f7f7; padding: 40px 20px;">
    <tr>
      <td align="center">
        <table width="600" cellpadding="0" cellspacing="0" style="background-color: #ffffff; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.08);">
          <tr>
            <td style="padding: 40px;">
              <div style="text-align: center; margin-bottom: 24px;">
                <div style="display: inline-block; width: 64px; height: 64px; background-color: #4caf50; border-radius: 50%; line-height: 64px;">
                  <span style="color: white; font-size: 32px;">\u2713</span>
                </div>
              </div>
              
              <h2 style="margin: 0 0 16px; color: #1a1a1a; font-size: 24px; font-weight: 600; text-align: center;">Password Changed Successfully</h2>
              
              <p style="margin: 0 0 16px; color: #4a4a4a; font-size: 16px; line-height: 1.6;">
                Hi ${name},
              </p>
              
              <p style="margin: 0 0 24px; color: #4a4a4a; font-size: 16px; line-height: 1.6;">
                This is to confirm that your Stylemate password has been successfully changed.
              </p>
              
              <div style="background-color: #e3f2fd; border-left: 4px solid #2196f3; padding: 16px; margin: 24px 0; border-radius: 4px;">
                <p style="margin: 0; color: #1565c0; font-size: 14px; line-height: 1.5;">
                  <strong>What this means:</strong><br>
                  You can now log in to your account using your new password.
                </p>
              </div>
              
              <div style="background-color: #ffebee; border-left: 4px solid #f44336; padding: 16px; margin: 24px 0; border-radius: 4px;">
                <p style="margin: 0 0 8px; color: #c62828; font-size: 14px; font-weight: 600;">
                  \u26A0\uFE0F Didn't make this change?
                </p>
                <p style="margin: 0; color: #d32f2f; font-size: 13px; line-height: 1.5;">
                  If you did not request this password change, please contact our support team immediately.
                </p>
              </div>
            </td>
          </tr>
          
          <tr>
            <td style="background-color: #f9f9f9; padding: 24px 40px; text-align: center; border-top: 1px solid #e0e0e0;">
              <p style="margin: 0 0 8px; color: #888888; font-size: 12px;">
                This email was sent by <strong>Stylemate</strong>
              </p>
              <p style="margin: 0; color: #aaaaaa; font-size: 11px;">
                The world's premier beauty & wellness booking platform
              </p>
            </td>
          </tr>
        </table>
      </td>
    </tr>
  </table>
</body>
</html>
  `;
  await client.send({
    to: email,
    from: { email: fromEmail, name: "Stylemate" },
    subject: "Your Stylemate password has been changed",
    html,
    text: `Hi ${name},

This is to confirm that your Stylemate password has been successfully changed.

If you did not make this change, please contact our support team immediately.

---
Stylemate Team`
  });
}
async function sendWelcomeVerificationEmail(email, verificationLink, firstName) {
  const { client, fromEmail } = await getSendGridClient();
  const name = firstName || "there";
  const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Welcome to Stylemate - Verify Your Email</title>
  <!--[if mso]>
  <style type="text/css">
    table {border-collapse: collapse;}
  </style>
  <![endif]-->
</head>
<body style="margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; background-color: #f7f7f7; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;">
  <table width="100%" cellpadding="0" cellspacing="0" role="presentation" style="background-color: #f7f7f7; padding: 20px 10px;">
    <tr>
      <td align="center">
        <!-- Main Container -->
        <table width="600" cellpadding="0" cellspacing="0" role="presentation" style="max-width: 600px; width: 100%; background-color: #ffffff; border-radius: 16px; box-shadow: 0 4px 20px rgba(0,0,0,0.08); overflow: hidden;">
          
          <!-- Header with Gradient -->
          <tr>
            <td style="background: linear-gradient(135deg, #ec4899 0%, #8b5cf6 50%, #6366f1 100%); padding: 48px 32px; text-align: center;">
              <h1 style="margin: 0; color: #ffffff; font-size: 32px; font-weight: 700; letter-spacing: -0.5px; text-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                Stylemate
              </h1>
              <p style="margin: 12px 0 0; color: rgba(255,255,255,0.95); font-size: 16px; font-weight: 500;">
                Beauty & Wellness at Your Fingertips
              </p>
            </td>
          </tr>
          
          <!-- Welcome Message -->
          <tr>
            <td style="padding: 48px 32px 32px;">
              <h2 style="margin: 0 0 24px; color: #1a1a1a; font-size: 28px; font-weight: 700; line-height: 1.3;">
                Welcome to Stylemate! \u{1F44B}
              </h2>
              <p style="margin: 0 0 16px; color: #4a4a4a; font-size: 17px; line-height: 1.6;">
                Hi <strong>${name}</strong>,
              </p>
              <p style="margin: 0 0 24px; color: #4a4a4a; font-size: 17px; line-height: 1.6;">
                We're thrilled to have you join our community of beauty enthusiasts! Get ready to discover amazing salons, book appointments with ease, and enjoy exclusive offers.
              </p>
              
              <!-- Verify Button -->
              <table cellpadding="0" cellspacing="0" role="presentation" style="margin: 36px 0;">
                <tr>
                  <td align="center" style="border-radius: 12px; background: linear-gradient(135deg, #ec4899 0%, #8b5cf6 100%); box-shadow: 0 4px 12px rgba(236, 72, 153, 0.4);">
                    <a href="${verificationLink}" target="_blank" style="display: inline-block; padding: 18px 48px; color: #ffffff; background-color: transparent; text-decoration: none; font-size: 18px; font-weight: 700; letter-spacing: 0.5px; border-radius: 12px;">
                      Verify Email Address
                    </a>
                  </td>
                </tr>
              </table>
              
              <!-- Benefits Section -->
              <div style="background: linear-gradient(135deg, #fef3ff 0%, #f5f3ff 100%); border-left: 4px solid #ec4899; padding: 24px; margin: 32px 0; border-radius: 8px;">
                <p style="margin: 0 0 16px; color: #7c3aed; font-size: 16px; font-weight: 700;">
                  \u2728 What you can do after verification:
                </p>
                <ul style="margin: 0; padding-left: 24px; color: #4a4a4a; font-size: 15px; line-height: 1.8;">
                  <li style="margin-bottom: 8px;"><strong>Book appointments</strong> at top-rated salons</li>
                  <li style="margin-bottom: 8px;"><strong>Save your favorites</strong> and track your beauty journey</li>
                  <li style="margin-bottom: 8px;"><strong>Get exclusive offers</strong> and early access to deals</li>
                  <li style="margin-bottom: 0;"><strong>Manage bookings</strong> easily from your dashboard</li>
                </ul>
              </div>
              
              <!-- Expiration Notice -->
              <div style="background-color: #fff8e1; border-left: 4px solid #fbbf24; padding: 20px; margin: 24px 0; border-radius: 8px;">
                <p style="margin: 0 0 8px; color: #b45309; font-size: 15px; font-weight: 700;">
                  \u23F1\uFE0F This verification link expires in <strong>24 hours</strong>
                </p>
                <p style="margin: 0; color: #92400e; font-size: 14px; line-height: 1.5;">
                  For your security, please verify your email within 24 hours. You can request a new link from your dashboard if this one expires.
                </p>
              </div>
              
              <p style="margin: 24px 0 0; color: #666666; font-size: 15px; line-height: 1.6;">
                Didn't create an account? You can safely ignore this email.
              </p>
            </td>
          </tr>
          
          <!-- Divider -->
          <tr>
            <td style="padding: 0 32px;">
              <hr style="border: none; border-top: 2px solid #f0f0f0; margin: 0;">
            </td>
          </tr>
          
          <!-- Alternative Link Section -->
          <tr>
            <td style="padding: 32px 32px 48px;">
              <p style="margin: 0 0 12px; color: #888888; font-size: 13px; font-weight: 700; text-transform: uppercase; letter-spacing: 1px;">
                Button not working?
              </p>
              <p style="margin: 0 0 12px; color: #666666; font-size: 14px; line-height: 1.5;">
                Copy and paste this link into your browser:
              </p>
              <div style="background-color: #f9fafb; padding: 16px; border-radius: 8px; border: 1px solid #e5e7eb;">
                <p style="margin: 0; color: #8b5cf6; font-size: 13px; word-break: break-all; line-height: 1.6;">
                  ${verificationLink}
                </p>
              </div>
            </td>
          </tr>
          
          <!-- Footer -->
          <tr>
            <td style="background: linear-gradient(135deg, #fafafa 0%, #f5f5f5 100%); padding: 32px; text-align: center; border-top: 1px solid #e0e0e0;">
              <p style="margin: 0 0 8px; color: #666666; font-size: 14px; font-weight: 600;">
                Need help? We're here for you!
              </p>
              <p style="margin: 0 0 16px; color: #888888; font-size: 13px; line-height: 1.5;">
                Reply to this email or contact us at support@stylemate.com
              </p>
              <p style="margin: 0 0 8px; color: #888888; font-size: 13px;">
                This email was sent by <strong style="color: #ec4899;">Stylemate</strong>
              </p>
              <p style="margin: 0; color: #aaaaaa; font-size: 12px;">
                The world's premier beauty & wellness booking platform
              </p>
            </td>
          </tr>
        </table>
        
        <!-- Mobile Optimization Notice -->
        <!--[if !mso]><!-->
        <table width="600" cellpadding="0" cellspacing="0" role="presentation" style="max-width: 600px; width: 100%; margin-top: 20px;">
          <tr>
            <td style="text-align: center; padding: 16px;">
              <p style="margin: 0; color: #999999; font-size: 11px; line-height: 1.5;">
                \xA9 2025 Stylemate. All rights reserved.
              </p>
            </td>
          </tr>
        </table>
        <!--<![endif]-->
      </td>
    </tr>
  </table>
</body>
</html>
  `;
  const plainText = `
Hi ${name},

Welcome to Stylemate! \u{1F389}

We're thrilled to have you join our community. To get started and unlock all features, please verify your email address by clicking the link below:

${verificationLink}

What you can do after verification:
\u2022 Book appointments at top-rated salons
\u2022 Save your favorites and track your beauty journey
\u2022 Get exclusive offers and early access to deals
\u2022 Manage bookings easily from your dashboard

\u23F1\uFE0F This verification link expires in 24 hours.

Didn't create an account? You can safely ignore this email.

Need help? Reply to this email or contact us at support@stylemate.com

---
Stylemate Team
The world's premier beauty & wellness booking platform
  `.trim();
  await client.send({
    to: email,
    from: { email: fromEmail, name: "Stylemate" },
    subject: "Welcome to Stylemate! Verify your email to start booking \u{1F389}",
    html,
    text: plainText
  });
}
async function sendBusinessWelcomeVerificationEmail(email, verificationLink, firstName) {
  const { client, fromEmail } = await getSendGridClient();
  const name = firstName || "there";
  const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Welcome to Stylemate Business - Verify Your Email</title>
  <!--[if mso]>
  <style type="text/css">
    table {border-collapse: collapse;}
  </style>
  <![endif]-->
</head>
<body style="margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; background-color: #f7f7f7; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;">
  <table width="100%" cellpadding="0" cellspacing="0" role="presentation" style="background-color: #f7f7f7; padding: 20px 10px;">
    <tr>
      <td align="center">
        <!-- Main Container -->
        <table width="600" cellpadding="0" cellspacing="0" role="presentation" style="max-width: 600px; width: 100%; background-color: #ffffff; border-radius: 16px; box-shadow: 0 4px 20px rgba(0,0,0,0.08); overflow: hidden;">
          
          <!-- Header with Professional Gradient -->
          <tr>
            <td style="background: linear-gradient(135deg, #0f172a 0%, #1e293b 50%, #334155 100%); padding: 48px 32px; text-align: center;">
              <h1 style="margin: 0; color: #ffffff; font-size: 32px; font-weight: 700; letter-spacing: -0.5px; text-shadow: 0 2px 4px rgba(0,0,0,0.2);">
                Stylemate Business
              </h1>
              <p style="margin: 12px 0 0; color: rgba(255,255,255,0.9); font-size: 16px; font-weight: 500;">
                Grow Your Beauty Business
              </p>
            </td>
          </tr>
          
          <!-- Welcome Message -->
          <tr>
            <td style="padding: 48px 32px 32px;">
              <h2 style="margin: 0 0 24px; color: #1a1a1a; font-size: 28px; font-weight: 700; line-height: 1.3;">
                Welcome to Stylemate! \u{1F680}
              </h2>
              <p style="margin: 0 0 16px; color: #4a4a4a; font-size: 17px; line-height: 1.6;">
                Hi <strong>${name}</strong>,
              </p>
              <p style="margin: 0 0 24px; color: #4a4a4a; font-size: 17px; line-height: 1.6;">
                Congratulations on joining Stylemate Business! You're about to connect with thousands of customers and take your salon to the next level.
              </p>
              
              <!-- Verify Button -->
              <table cellpadding="0" cellspacing="0" role="presentation" style="margin: 36px 0;">
                <tr>
                  <td align="center" style="border-radius: 12px; background: linear-gradient(135deg, #0f172a 0%, #1e3a8a 100%); box-shadow: 0 4px 12px rgba(15, 23, 42, 0.4);">
                    <a href="${verificationLink}" target="_blank" style="display: inline-block; padding: 18px 48px; color: #ffffff; background-color: transparent; text-decoration: none; font-size: 18px; font-weight: 700; letter-spacing: 0.5px; border-radius: 12px;">
                      Verify Email & Get Started
                    </a>
                  </td>
                </tr>
              </table>
              
              <!-- Benefits Section -->
              <div style="background: linear-gradient(135deg, #eff6ff 0%, #e0f2fe 100%); border-left: 4px solid #0369a1; padding: 24px; margin: 32px 0; border-radius: 8px;">
                <p style="margin: 0 0 16px; color: #0369a1; font-size: 16px; font-weight: 700;">
                  \u{1F4BC} What you can do after verification:
                </p>
                <ul style="margin: 0; padding-left: 24px; color: #4a4a4a; font-size: 15px; line-height: 1.8;">
                  <li style="margin-bottom: 8px;"><strong>Publish your salon</strong> and go live instantly</li>
                  <li style="margin-bottom: 8px;"><strong>Receive bookings 24/7</strong> from our customer network</li>
                  <li style="margin-bottom: 8px;"><strong>Manage staff & services</strong> with professional tools</li>
                  <li style="margin-bottom: 0;"><strong>Track revenue & analytics</strong> from your dashboard</li>
                </ul>
              </div>
              
              <!-- Expiration Notice -->
              <div style="background-color: #fef3c7; border-left: 4px solid #f59e0b; padding: 20px; margin: 24px 0; border-radius: 8px;">
                <p style="margin: 0 0 8px; color: #b45309; font-size: 15px; font-weight: 700;">
                  \u23F1\uFE0F This verification link expires in <strong>24 hours</strong>
                </p>
                <p style="margin: 0; color: #92400e; font-size: 14px; line-height: 1.5;">
                  Verify your email to unlock full business features. You can request a new link if this one expires.
                </p>
              </div>
              
              <p style="margin: 24px 0 0; color: #666666; font-size: 15px; line-height: 1.6;">
                Didn't sign up for a business account? You can safely ignore this email.
              </p>
            </td>
          </tr>
          
          <!-- Divider -->
          <tr>
            <td style="padding: 0 32px;">
              <hr style="border: none; border-top: 2px solid #f0f0f0; margin: 0;">
            </td>
          </tr>
          
          <!-- Alternative Link Section -->
          <tr>
            <td style="padding: 32px 32px 48px;">
              <p style="margin: 0 0 12px; color: #888888; font-size: 13px; font-weight: 700; text-transform: uppercase; letter-spacing: 1px;">
                Button not working?
              </p>
              <p style="margin: 0 0 12px; color: #666666; font-size: 14px; line-height: 1.5;">
                Copy and paste this link into your browser:
              </p>
              <div style="background-color: #f9fafb; padding: 16px; border-radius: 8px; border: 1px solid #e5e7eb;">
                <p style="margin: 0; color: #0369a1; font-size: 13px; word-break: break-all; line-height: 1.6;">
                  ${verificationLink}
                </p>
              </div>
            </td>
          </tr>
          
          <!-- Footer -->
          <tr>
            <td style="background: linear-gradient(135deg, #fafafa 0%, #f5f5f5 100%); padding: 32px; text-align: center; border-top: 1px solid #e0e0e0;">
              <p style="margin: 0 0 8px; color: #666666; font-size: 14px; font-weight: 600;">
                Need help getting started?
              </p>
              <p style="margin: 0 0 16px; color: #888888; font-size: 13px; line-height: 1.5;">
                Reply to this email or contact our business team at business@stylemate.com
              </p>
              <p style="margin: 0 0 8px; color: #888888; font-size: 13px;">
                This email was sent by <strong style="color: #0369a1;">Stylemate Business</strong>
              </p>
              <p style="margin: 0; color: #aaaaaa; font-size: 12px;">
                Empowering beauty & wellness businesses worldwide
              </p>
            </td>
          </tr>
        </table>
        
        <!-- Mobile Optimization Notice -->
        <!--[if !mso]><!-->
        <table width="600" cellpadding="0" cellspacing="0" role="presentation" style="max-width: 600px; width: 100%; margin-top: 20px;">
          <tr>
            <td style="text-align: center; padding: 16px;">
              <p style="margin: 0; color: #999999; font-size: 11px; line-height: 1.5;">
                \xA9 2025 Stylemate. All rights reserved.
              </p>
            </td>
          </tr>
        </table>
        <!--<![endif]-->
      </td>
    </tr>
  </table>
</body>
</html>
  `;
  const plainText = `
Hi ${name},

Welcome to Stylemate Business! \u{1F680}

Congratulations on joining our platform. You're about to connect with thousands of customers and take your salon to the next level.

To unlock all business features and start receiving bookings, please verify your email address:

${verificationLink}

What you can do after verification:
\u2022 Publish your salon and go live instantly
\u2022 Receive bookings 24/7 from our customer network
\u2022 Manage staff & services with professional tools
\u2022 Track revenue & analytics from your dashboard

\u23F1\uFE0F This verification link expires in 24 hours.

Didn't sign up for a business account? You can safely ignore this email.

Need help? Reply to this email or contact our business team at business@stylemate.com

---
Stylemate Business Team
Empowering beauty & wellness businesses worldwide
  `.trim();
  await client.send({
    to: email,
    from: { email: fromEmail, name: "Stylemate Business" },
    subject: "Welcome to Stylemate Business! Verify to start receiving bookings \u{1F4BC}",
    html,
    text: plainText
  });
}
async function sendVerificationReminderEmail(email, verificationLink, firstName, isBusinessUser = false) {
  const { client, fromEmail } = await getSendGridClient();
  const name = firstName || "there";
  const platform = isBusinessUser ? "Stylemate Business" : "Stylemate";
  const actionText = isBusinessUser ? "start receiving bookings" : "book your first appointment";
  const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Verify Your Email - Stylemate</title>
  <!--[if mso]>
  <style type="text/css">
    table {border-collapse: collapse;}
  </style>
  <![endif]-->
</head>
<body style="margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; background-color: #f7f7f7; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;">
  <table width="100%" cellpadding="0" cellspacing="0" role="presentation" style="background-color: #f7f7f7; padding: 20px 10px;">
    <tr>
      <td align="center">
        <!-- Main Container -->
        <table width="600" cellpadding="0" cellspacing="0" role="presentation" style="max-width: 600px; width: 100%; background-color: #ffffff; border-radius: 16px; box-shadow: 0 4px 20px rgba(0,0,0,0.08); overflow: hidden;">
          
          <!-- Header -->
          <tr>
            <td style="background: ${isBusinessUser ? "linear-gradient(135deg, #0f172a 0%, #1e293b 100%)" : "linear-gradient(135deg, #ec4899 0%, #8b5cf6 100%)"}; padding: 40px 32px; text-align: center;">
              <h1 style="margin: 0; color: #ffffff; font-size: 28px; font-weight: 700;">
                ${platform}
              </h1>
            </td>
          </tr>
          
          <!-- Reminder Content -->
          <tr>
            <td style="padding: 48px 32px 32px;">
              <h2 style="margin: 0 0 24px; color: #1a1a1a; font-size: 26px; font-weight: 700; line-height: 1.3;">
                You're almost there! \u23F0
              </h2>
              <p style="margin: 0 0 16px; color: #4a4a4a; font-size: 17px; line-height: 1.6;">
                Hi <strong>${name}</strong>,
              </p>
              <p style="margin: 0 0 24px; color: #4a4a4a; font-size: 17px; line-height: 1.6;">
                We noticed you haven't verified your email yet. Your account is ready to go \u2014 you're just one click away from ${actionText}!
              </p>
              
              <!-- Verify Button -->
              <table cellpadding="0" cellspacing="0" role="presentation" style="margin: 36px 0;">
                <tr>
                  <td align="center" style="border-radius: 12px; background: ${isBusinessUser ? "linear-gradient(135deg, #0f172a 0%, #1e3a8a 100%)" : "linear-gradient(135deg, #ec4899 0%, #8b5cf6 100%)"}; box-shadow: 0 4px 12px rgba(${isBusinessUser ? "15, 23, 42" : "236, 72, 153"}, 0.4);">
                    <a href="${verificationLink}" target="_blank" style="display: inline-block; padding: 18px 48px; color: #ffffff; background-color: transparent; text-decoration: none; font-size: 18px; font-weight: 700; letter-spacing: 0.5px; border-radius: 12px;">
                      Verify My Email Now
                    </a>
                  </td>
                </tr>
              </table>
              
              <!-- Troubleshooting Tips -->
              <div style="background-color: #f0f9ff; border-left: 4px solid #0284c7; padding: 24px; margin: 32px 0; border-radius: 8px;">
                <p style="margin: 0 0 16px; color: #0369a1; font-size: 16px; font-weight: 700;">
                  \u{1F4A1} Common questions:
                </p>
                <div style="color: #4a4a4a; font-size: 15px; line-height: 1.8;">
                  <p style="margin: 0 0 12px;">
                    <strong>Can't find the link?</strong> It's at the end of this email.
                  </p>
                  <p style="margin: 0 0 12px;">
                    <strong>Link not working?</strong> Copy and paste the full URL into your browser.
                  </p>
                  <p style="margin: 0;">
                    <strong>Need a new link?</strong> Log in to your dashboard and click "Resend verification email".
                  </p>
                </div>
              </div>
              
              <!-- Why Verify -->
              <div style="background: linear-gradient(135deg, ${isBusinessUser ? "#eff6ff" : "#fef3ff"} 0%, ${isBusinessUser ? "#e0f2fe" : "#f5f3ff"} 100%); border-left: 4px solid ${isBusinessUser ? "#0369a1" : "#ec4899"}; padding: 24px; margin: 24px 0; border-radius: 8px;">
                <p style="margin: 0 0 12px; color: ${isBusinessUser ? "#0369a1" : "#7c3aed"}; font-size: 16px; font-weight: 700;">
                  \u{1F512} Why we need verification:
                </p>
                <p style="margin: 0; color: #4a4a4a; font-size: 15px; line-height: 1.6;">
                  Email verification helps protect your account from unauthorized access and ensures you receive important booking notifications and updates.
                </p>
              </div>
              
              <p style="margin: 24px 0 0; color: #666666; font-size: 15px; line-height: 1.6;">
                If you didn't create this account, you can safely ignore this email.
              </p>
            </td>
          </tr>
          
          <!-- Divider -->
          <tr>
            <td style="padding: 0 32px;">
              <hr style="border: none; border-top: 2px solid #f0f0f0; margin: 0;">
            </td>
          </tr>
          
          <!-- Alternative Link Section -->
          <tr>
            <td style="padding: 32px 32px 48px;">
              <p style="margin: 0 0 12px; color: #888888; font-size: 13px; font-weight: 700; text-transform: uppercase; letter-spacing: 1px;">
                Verification Link
              </p>
              <div style="background-color: #f9fafb; padding: 16px; border-radius: 8px; border: 1px solid #e5e7eb;">
                <p style="margin: 0; color: ${isBusinessUser ? "#0369a1" : "#8b5cf6"}; font-size: 13px; word-break: break-all; line-height: 1.6;">
                  ${verificationLink}
                </p>
              </div>
            </td>
          </tr>
          
          <!-- Footer -->
          <tr>
            <td style="background: linear-gradient(135deg, #fafafa 0%, #f5f5f5 100%); padding: 32px; text-align: center; border-top: 1px solid #e0e0e0;">
              <p style="margin: 0 0 8px; color: #666666; font-size: 14px; font-weight: 600;">
                Need help?
              </p>
              <p style="margin: 0 0 16px; color: #888888; font-size: 13px; line-height: 1.5;">
                Reply to this email or contact us at ${isBusinessUser ? "business@stylemate.com" : "support@stylemate.com"}
              </p>
              <p style="margin: 0 0 8px; color: #888888; font-size: 13px;">
                This email was sent by <strong style="color: ${isBusinessUser ? "#0369a1" : "#ec4899"};">${platform}</strong>
              </p>
            </td>
          </tr>
        </table>
        
        <!-- Copyright -->
        <!--[if !mso]><!-->
        <table width="600" cellpadding="0" cellspacing="0" role="presentation" style="max-width: 600px; width: 100%; margin-top: 20px;">
          <tr>
            <td style="text-align: center; padding: 16px;">
              <p style="margin: 0; color: #999999; font-size: 11px; line-height: 1.5;">
                \xA9 2025 Stylemate. All rights reserved.
              </p>
            </td>
          </tr>
        </table>
        <!--<![endif]-->
      </td>
    </tr>
  </table>
</body>
</html>
  `;
  const plainText = `
Hi ${name},

You're almost there! \u23F0

We noticed you haven't verified your email yet. Your account is ready to go \u2014 you're just one click away from ${actionText}!

Verify your email here:
${verificationLink}

Common questions:
\u2022 Can't find the link? It's at the end of this email.
\u2022 Link not working? Copy and paste the full URL into your browser.
\u2022 Need a new link? Log in to your dashboard and click "Resend verification email".

Why we need verification:
Email verification helps protect your account from unauthorized access and ensures you receive important booking notifications and updates.

If you didn't create this account, you can safely ignore this email.

Need help? Reply to this email or contact us at ${isBusinessUser ? "business@stylemate.com" : "support@stylemate.com"}

---
${platform} Team
  `.trim();
  await client.send({
    to: email,
    from: { email: fromEmail, name: platform },
    subject: `Reminder: Verify your email to ${actionText} \u{1F4E7}`,
    html,
    text: plainText
  });
}
var cachedClient, cachedFromEmail;
var init_sendgrid = __esm({
  "server/lib/sendgrid.ts"() {
    "use strict";
    cachedClient = null;
    cachedFromEmail = null;
  }
});

// shared/service-role-mapping.ts
var service_role_mapping_exports = {};
__export(service_role_mapping_exports, {
  ROLE_TEMPLATES_WITH_MAPPING: () => ROLE_TEMPLATES_WITH_MAPPING,
  getAllRoleNames: () => getAllRoleNames,
  getRoleTemplate: () => getRoleTemplate,
  getSuggestedRolesFromServices: () => getSuggestedRolesFromServices
});
function getSuggestedRolesFromServices(services6) {
  const suggestedRolesMap = /* @__PURE__ */ new Map();
  services6.forEach((service) => {
    const serviceName = service.name.toLowerCase();
    const serviceCategory = service.category?.toLowerCase() || "";
    ROLE_TEMPLATES_WITH_MAPPING.forEach((roleTemplate) => {
      let isMatch = false;
      const matchType = [];
      if (serviceCategory && roleTemplate.serviceCategories.some(
        (cat) => serviceCategory.includes(cat.toLowerCase()) || cat.toLowerCase().includes(serviceCategory)
      )) {
        isMatch = true;
        matchType.push("category");
      }
      if (roleTemplate.serviceKeywords.some((keyword) => serviceName.includes(keyword.toLowerCase()))) {
        isMatch = true;
        matchType.push("service name");
      }
      if (isMatch) {
        if (!suggestedRolesMap.has(roleTemplate.value)) {
          suggestedRolesMap.set(roleTemplate.value, {
            reason: `Based on ${matchType.join(" and ")} match`,
            matchedServices: /* @__PURE__ */ new Set()
          });
        }
        suggestedRolesMap.get(roleTemplate.value).matchedServices.add(service.name);
      }
    });
  });
  return Array.from(suggestedRolesMap.entries()).map(([role, data]) => ({
    role,
    reason: data.reason,
    matchedServices: Array.from(data.matchedServices)
  }));
}
function getRoleTemplate(roleName) {
  return ROLE_TEMPLATES_WITH_MAPPING.find((r) => r.value === roleName);
}
function getAllRoleNames() {
  return ROLE_TEMPLATES_WITH_MAPPING.map((r) => r.value);
}
var ROLE_TEMPLATES_WITH_MAPPING;
var init_service_role_mapping = __esm({
  "shared/service-role-mapping.ts"() {
    "use strict";
    ROLE_TEMPLATES_WITH_MAPPING = [
      {
        value: "Stylist",
        icon: "Scissors",
        color: "from-purple-500 to-pink-500",
        serviceCategories: ["Hair & styling", "Hair"],
        serviceKeywords: ["haircut", "hair cut", "styling", "blowdry", "blow dry", "hair styling", "men's haircut", "women's haircut", "kids haircut"]
      },
      {
        value: "Colorist",
        icon: "PaintBucket",
        color: "from-pink-500 to-rose-500",
        serviceCategories: ["Hair & styling", "Hair"],
        serviceKeywords: ["color", "coloring", "highlights", "balayage", "ombre", "hair color", "dye", "tint", "bleach", "root touch"]
      },
      {
        value: "Nail Technician",
        icon: "Sparkles",
        color: "from-violet-500 to-purple-500",
        serviceCategories: ["Nails"],
        serviceKeywords: ["manicure", "pedicure", "nail", "gel nails", "acrylic", "nail art", "nail polish", "shellac"]
      },
      {
        value: "Makeup Artist",
        icon: "Smile",
        color: "from-rose-500 to-pink-500",
        serviceCategories: ["Makeup"],
        serviceKeywords: ["makeup", "make up", "bridal makeup", "party makeup", "special occasion", "cosmetics"]
      },
      {
        value: "Esthetician",
        icon: "Star",
        color: "from-purple-500 to-violet-500",
        serviceCategories: ["Skincare & Facials", "Eyebrows & Lashes", "Body Treatments"],
        serviceKeywords: ["facial", "skincare", "skin care", "eyebrow", "lashes", "waxing", "threading", "microdermabrasion", "chemical peel", "body scrub", "body wrap"]
      },
      {
        value: "Massage Therapist",
        icon: "Briefcase",
        color: "from-pink-500 to-purple-500",
        serviceCategories: ["Massage & Spa", "Body Treatments", "Wellness & Other"],
        serviceKeywords: ["massage", "spa", "body massage", "deep tissue", "swedish", "aromatherapy", "hot stone", "reflexology"]
      },
      {
        value: "Piercing Specialist",
        icon: "Circle",
        color: "from-indigo-500 to-purple-500",
        serviceCategories: ["Piercing"],
        serviceKeywords: ["piercing", "ear piercing", "nose piercing", "cartilage", "body piercing"]
      },
      {
        value: "Tattoo Artist",
        icon: "Palette",
        color: "from-purple-500 to-indigo-500",
        serviceCategories: ["Tattoo"],
        serviceKeywords: ["tattoo", "ink", "body art", "permanent art"]
      },
      {
        value: "Barber",
        icon: "Scissors",
        color: "from-blue-500 to-indigo-500",
        serviceCategories: ["Men's Grooming", "Hair & styling"],
        serviceKeywords: ["beard", "shave", "men's grooming", "barber", "men's haircut", "beard trim", "hot towel"]
      },
      {
        value: "Lash Technician",
        icon: "Eye",
        color: "from-pink-500 to-rose-500",
        serviceCategories: ["Eyebrows & Lashes"],
        serviceKeywords: ["lash", "lashes", "eyelash", "lash extension", "lash lift", "lash tint"]
      },
      {
        value: "Waxing Specialist",
        icon: "Zap",
        color: "from-orange-500 to-pink-500",
        serviceCategories: ["Hair Removal"],
        serviceKeywords: ["wax", "waxing", "hair removal", "brazilian", "bikini wax", "body wax"]
      }
    ];
  }
});

// server/config/env.ts
import dotenv from "dotenv";
dotenv.config();

// server/index.ts
import express6 from "express";
import cookieParser from "cookie-parser";

// server/routes.ts
init_storage();
init_db();
init_schema();
import { createServer } from "http";
import { eq as eq58, and as and56, or as or18, inArray as inArray22, sql as sql44, ne as ne5, isNotNull as isNotNull3, gte as gte30, lte as lte24 } from "drizzle-orm";
import session from "express-session";
import connectPgSimple from "connect-pg-simple";
import pg from "pg";

// server/middleware/auth.ts
init_storage();
import jwt2 from "jsonwebtoken";

// server/utils/jwt.ts
init_db();
init_schema();
import jwt from "jsonwebtoken";
import crypto from "crypto";
import { eq as eq2, and as and2, gt as gt2, isNull as isNull2, lt as lt2 } from "drizzle-orm";
var JWT_SECRET = process.env.JWT_SECRET;
if (!JWT_SECRET) {
  if (process.env.NODE_ENV === "production") {
    throw new Error(
      "JWT_SECRET environment variable is required in production. Generate a secure secret with: openssl rand -base64 64"
    );
  } else {
    console.warn(
      "\u26A0\uFE0F  WARNING: JWT_SECRET not set. Using temporary secret for development. All tokens will be invalidated on server restart. Set JWT_SECRET environment variable for persistent authentication."
    );
  }
}
var FINAL_ACCESS_SECRET = JWT_SECRET || crypto.randomBytes(64).toString("hex");
var FINAL_REFRESH_SECRET = JWT_SECRET || crypto.randomBytes(64).toString("hex");
var ACCESS_TOKEN_EXPIRY = "15m";
var REFRESH_TOKEN_EXPIRY = "7d";
function generateAccessToken(userId, email) {
  const payload = {
    userId,
    email,
    type: "access"
  };
  return jwt.sign(payload, FINAL_ACCESS_SECRET, {
    expiresIn: ACCESS_TOKEN_EXPIRY,
    issuer: "stylemate",
    audience: "stylemate-api"
  });
}
async function generateRefreshToken(userId, deviceInfo, ipAddress) {
  const tokenId = crypto.randomUUID();
  const payload = {
    userId,
    tokenId,
    type: "refresh"
  };
  const token = jwt.sign(payload, FINAL_REFRESH_SECRET, {
    expiresIn: REFRESH_TOKEN_EXPIRY,
    issuer: "stylemate",
    audience: "stylemate-api"
  });
  const expiresAt = /* @__PURE__ */ new Date();
  expiresAt.setDate(expiresAt.getDate() + 7);
  await db.insert(refreshTokens).values({
    id: tokenId,
    userId,
    token,
    deviceInfo: deviceInfo || null,
    ipAddress: ipAddress || null,
    expiresAt
  });
  return { token, tokenId };
}
function verifyAccessToken(token) {
  try {
    const decoded = jwt.verify(token, FINAL_ACCESS_SECRET, {
      issuer: "stylemate",
      audience: "stylemate-api"
    });
    if (decoded.type !== "access") {
      throw new Error("Invalid token type");
    }
    return decoded;
  } catch (error) {
    if (error instanceof jwt.TokenExpiredError) {
      throw new Error("Access token expired");
    }
    if (error instanceof jwt.JsonWebTokenError) {
      throw new Error("Invalid access token");
    }
    throw error;
  }
}
async function verifyRefreshToken(token) {
  try {
    const decoded = jwt.verify(token, FINAL_REFRESH_SECRET, {
      issuer: "stylemate",
      audience: "stylemate-api"
    });
    if (decoded.type !== "refresh") {
      throw new Error("Invalid token type");
    }
    const storedToken = await db.query.refreshTokens.findFirst({
      where: and2(
        eq2(refreshTokens.id, decoded.tokenId),
        eq2(refreshTokens.token, token),
        gt2(refreshTokens.expiresAt, /* @__PURE__ */ new Date()),
        isNull2(refreshTokens.revokedAt)
      )
    });
    if (!storedToken) {
      throw new Error("Refresh token not found or has been revoked");
    }
    await db.update(refreshTokens).set({ lastUsedAt: /* @__PURE__ */ new Date() }).where(eq2(refreshTokens.id, decoded.tokenId));
    return decoded;
  } catch (error) {
    if (error instanceof jwt.TokenExpiredError) {
      throw new Error("Refresh token expired");
    }
    if (error instanceof jwt.JsonWebTokenError) {
      throw new Error("Invalid refresh token");
    }
    throw error;
  }
}
async function revokeRefreshToken(tokenId) {
  await db.update(refreshTokens).set({ revokedAt: /* @__PURE__ */ new Date() }).where(eq2(refreshTokens.id, tokenId));
}
async function revokeAllUserTokens(userId) {
  await db.update(refreshTokens).set({ revokedAt: /* @__PURE__ */ new Date() }).where(and2(
    eq2(refreshTokens.userId, userId),
    isNull2(refreshTokens.revokedAt)
  ));
}
function extractBearerToken(authHeader) {
  if (!authHeader || !authHeader.startsWith("Bearer ")) {
    return null;
  }
  return authHeader.substring(7);
}

// server/middleware/auth.ts
init_rbacService();
function getJWTSecret() {
  const JWT_SECRET2 = process.env.JWT_SECRET;
  if (!JWT_SECRET2) {
    throw new Error("JWT_SECRET environment variable is required");
  }
  return JWT_SECRET2;
}
async function authenticateToken(req, res, next) {
  const authHeader = req.headers["authorization"];
  const token = authHeader && authHeader.split(" ")[1];
  if (!token) {
    return res.status(401).json({ error: "Access token required" });
  }
  try {
    const decoded = jwt2.verify(token, getJWTSecret());
    const user = await storage.getUserById(decoded.userId);
    if (!user) {
      return res.status(401).json({ error: "User not found" });
    }
    const userRoles2 = await storage.getUserRoles(user.id);
    const roles2 = userRoles2.map((role) => role.name);
    const orgMemberships = await storage.getUserOrganizations(user.id);
    req.user = {
      id: user.id,
      email: user.email || "",
      roles: roles2,
      orgMemberships
    };
    next();
  } catch (error) {
    console.error("Token verification failed:", error);
    return res.status(403).json({ error: "Invalid or expired token" });
  }
}
async function populateUserFromSession(req, res, next) {
  if (req.user) {
    return next();
  }
  const authHeader = req.headers.authorization;
  if (authHeader) {
    const token = extractBearerToken(authHeader);
    if (token) {
      try {
        const decoded = verifyAccessToken(token);
        const dbUser = await storage.getUserById(decoded.userId);
        if (dbUser) {
          const userRoles2 = await storage.getUserRoles(dbUser.id);
          const orgMemberships = await storage.getUserOrganizations(dbUser.id);
          req.user = {
            id: dbUser.id,
            email: dbUser.email || "",
            roles: userRoles2.map((role) => role.name),
            orgMemberships,
            authMethod: "jwt"
            // Track which auth method was used
          };
          return next();
        }
      } catch (error) {
        console.debug("JWT verification failed, trying session:", error);
      }
    }
  }
  if (!req.session?.userId) {
    return next();
  }
  try {
    const userId = req.session.userId;
    const dbUser = await storage.getUserById(userId);
    if (!dbUser) {
      return next();
    }
    const userRoles2 = await storage.getUserRoles(userId);
    const orgMemberships = await storage.getUserOrganizations(userId);
    req.user = {
      id: userId,
      email: dbUser.email || "",
      roles: userRoles2.map((role) => role.name),
      orgMemberships,
      authMethod: "session"
      // Track which auth method was used
    };
    next();
  } catch (error) {
    console.error("Failed to populate user from session:", error);
    next();
  }
}
function requireSuperAdmin() {
  return (req, res, next) => {
    if (!req.user) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const isSuperAdmin = req.user.roles?.includes("super_admin");
    if (!isSuperAdmin) {
      return res.status(403).json({ error: "Super admin access required" });
    }
    next();
  };
}
function requireSalonAccess(allowedOrgRoles = ["owner", "manager"], requiredPermission) {
  return async (req, res, next) => {
    if (!req.user) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const salonId = req.params.salonId;
    if (!salonId) {
      return res.status(400).json({ error: "Salon ID required" });
    }
    try {
      const userId = req.user.id;
      const permissions2 = await rbacService.getUserPermissions(userId, salonId);
      if (permissions2) {
        req.salonPermissions = permissions2;
        if (requiredPermission) {
          const codes = Array.isArray(requiredPermission) ? requiredPermission : [requiredPermission];
          const hasPermission = codes.some((code) => permissions2.permissions.includes(code));
          if (!hasPermission) {
            return res.status(403).json({ error: "You do not have permission to perform this action" });
          }
        }
        next();
        return;
      }
      const salon = await storage.getSalonById(salonId);
      if (!salon) {
        return res.status(404).json({ error: "Salon not found" });
      }
      if (salon.ownerId === userId) {
        const ownerPermissions = await rbacService.getRolePermissions("business_owner");
        req.salonPermissions = {
          userId,
          salonId,
          role: "business_owner",
          permissions: ownerPermissions,
          isBusinessOwner: true
        };
        next();
        return;
      }
      const hasAccess = req.user.orgMemberships?.some(
        (membership) => membership.orgId === salon.orgId && allowedOrgRoles.includes(membership.orgRole)
      );
      if (!hasAccess) {
        return res.status(403).json({ error: "Access denied to this salon" });
      }
      const orgRole = req.user.orgMemberships?.find((m) => m.orgId === salon.orgId)?.orgRole;
      const role = orgRole === "owner" ? "business_owner" : "shop_admin";
      const rolePermissions = await rbacService.getRolePermissions(role);
      req.salonPermissions = {
        userId,
        salonId,
        role,
        permissions: rolePermissions,
        isBusinessOwner: role === "business_owner"
      };
      if (requiredPermission) {
        const codes = Array.isArray(requiredPermission) ? requiredPermission : [requiredPermission];
        const hasPermission = codes.some((code) => rolePermissions.includes(code));
        if (!hasPermission) {
          return res.status(403).json({ error: "You do not have permission to perform this action" });
        }
      }
      next();
    } catch (error) {
      console.error("Salon access check failed:", error);
      return res.status(500).json({ error: "Authorization check failed" });
    }
  };
}
function requireStaffAccess() {
  return async (req, res, next) => {
    if (!req.user) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const salonId = req.params.salonId;
    if (!salonId) {
      return res.status(400).json({ error: "Salon ID required" });
    }
    try {
      const userId = req.user.id;
      const permissions2 = await rbacService.getUserPermissions(userId, salonId);
      if (permissions2) {
        req.salonPermissions = permissions2;
        next();
        return;
      }
      const isStaff = await storage.isUserStaffOfSalon(userId, salonId);
      const salon = await storage.getSalonById(salonId);
      const hasManagerAccess = salon && req.user.orgMemberships?.some(
        (membership) => membership.orgId === salon.orgId && ["owner", "manager"].includes(membership.orgRole)
      );
      if (!isStaff && !hasManagerAccess) {
        return res.status(403).json({ error: "Access denied - must be staff member or have management access" });
      }
      if (hasManagerAccess) {
        const orgRole = req.user.orgMemberships?.find((m) => m.orgId === salon?.orgId)?.orgRole;
        const role = orgRole === "owner" ? "business_owner" : "shop_admin";
        const rolePermissions = await rbacService.getRolePermissions(role);
        req.salonPermissions = {
          userId,
          salonId,
          role,
          permissions: rolePermissions,
          isBusinessOwner: role === "business_owner"
        };
      } else if (isStaff) {
        const staffPermissions = await rbacService.getRolePermissions("staff");
        req.salonPermissions = {
          userId,
          salonId,
          role: "staff",
          permissions: staffPermissions,
          isBusinessOwner: false
        };
      }
      next();
    } catch (error) {
      console.error("Staff access check failed:", error);
      return res.status(500).json({ error: "Authorization check failed" });
    }
  };
}
function requireBusinessOwner() {
  return async (req, res, next) => {
    if (!req.salonPermissions) {
      return res.status(403).json({ error: "Salon access not established" });
    }
    if (!req.salonPermissions.isBusinessOwner) {
      return res.status(403).json({ error: "Only business owners can perform this action" });
    }
    next();
  };
}

// server/routes.ts
init_firebaseAdmin();
import Razorpay8 from "razorpay";
import crypto12 from "crypto";
import express4 from "express";
import { createClient } from "redis";

// server/offerCalculator.ts
var OfferCalculator = class {
  /**
   * Calculate discount amount from an offer
   * Handles percentage and fixed discounts with max caps
   */
  static calculateDiscount(offer, totalAmountPaisa) {
    if (!offer) return 0;
    if (offer.minimumPurchase && totalAmountPaisa < offer.minimumPurchase) {
      return 0;
    }
    let discount = 0;
    if (offer.discountType === "percentage") {
      discount = Math.floor(totalAmountPaisa * offer.discountValue / 100);
    } else if (offer.discountType === "fixed") {
      discount = offer.discountValue;
    }
    if (offer.maxDiscount && discount > offer.maxDiscount) {
      discount = offer.maxDiscount;
    }
    if (discount > totalAmountPaisa) {
      discount = totalAmountPaisa;
    }
    return Math.floor(discount);
  }
  /**
   * Check if offer is currently valid (date-wise)
   */
  static isOfferValid(offer) {
    const now = /* @__PURE__ */ new Date();
    const validFrom = new Date(offer.validFrom);
    const validUntil = new Date(offer.validUntil);
    return now >= validFrom && now <= validUntil;
  }
  /**
   * Check if offer has usage limit reached
   */
  static hasUsageRemaining(offer) {
    if (!offer.usageLimit) return true;
    return offer.usageCount < offer.usageLimit;
  }
  /**
   * Calculate all applicable offers with their discount amounts
   */
  static calculateAllOffers(offers, totalAmountPaisa, salonId) {
    return offers.map((offer) => {
      let isApplicable = true;
      let ineligibilityReason;
      if (!this.isOfferValid(offer)) {
        isApplicable = false;
        ineligibilityReason = "Offer expired or not yet active";
      }
      if (isApplicable && !this.hasUsageRemaining(offer)) {
        isApplicable = false;
        ineligibilityReason = "Usage limit reached";
      }
      if (isApplicable && offer.minimumPurchase && totalAmountPaisa < offer.minimumPurchase) {
        isApplicable = false;
        ineligibilityReason = `Minimum purchase \u20B9${offer.minimumPurchase / 100} required`;
      }
      if (isApplicable && salonId && offer.salonId && offer.salonId !== salonId) {
        isApplicable = false;
        ineligibilityReason = "Offer not valid for this salon";
      }
      const discountAmountPaisa = isApplicable ? this.calculateDiscount(offer, totalAmountPaisa) : 0;
      const finalAmountPaisa = totalAmountPaisa - discountAmountPaisa;
      const savingsPercentage = totalAmountPaisa > 0 ? Math.floor(discountAmountPaisa / totalAmountPaisa * 100) : 0;
      return {
        ...offer,
        discountAmountPaisa,
        finalAmountPaisa,
        savingsPercentage,
        isApplicable,
        ineligibilityReason
      };
    });
  }
  /**
   * Get the best applicable offer (highest discount)
   * Priority: User promo code > Highest discount value
   */
  static getBestOffer(offers, totalAmountPaisa, salonId, userPromoCode) {
    const calculatedOffers = this.calculateAllOffers(offers, totalAmountPaisa, salonId);
    const applicableOffers = calculatedOffers.filter((offer) => offer.isApplicable);
    if (applicableOffers.length === 0) {
      return null;
    }
    if (userPromoCode) {
      const promoOffer = applicableOffers.find(
        (offer) => offer.title.toLowerCase().includes(userPromoCode.toLowerCase())
      );
      if (promoOffer) {
        return promoOffer;
      }
    }
    const bestOffer = applicableOffers.reduce((best, current) => {
      if (current.discountAmountPaisa > best.discountAmountPaisa) {
        return current;
      }
      if (current.discountAmountPaisa === best.discountAmountPaisa) {
        return current.isPlatformWide > best.isPlatformWide ? current : best;
      }
      return best;
    });
    return bestOffer;
  }
  /**
   * Format offer display text for UI
   */
  static formatOfferSummary(offer) {
    if (offer.discountType === "percentage") {
      return `${offer.discountValue}% OFF`;
    } else {
      return `\u20B9${offer.discountValue / 100} OFF`;
    }
  }
  /**
   * Format savings display
   */
  static formatSavings(offer) {
    return `Save \u20B9${offer.discountAmountPaisa / 100}`;
  }
  /**
   * Get offer badge color based on type
   */
  static getOfferBadgeColor(offer) {
    if (offer.isPlatformWide === 1) {
      return "purple";
    }
    return "orange";
  }
  /**
   * Calculate price breakdown for checkout display
   */
  static getPriceBreakdown(totalAmountPaisa, offer) {
    const discountAmount = offer?.discountAmountPaisa || 0;
    const finalAmount = totalAmountPaisa - discountAmount;
    const savingsPercentage = totalAmountPaisa > 0 ? Math.floor(discountAmount / totalAmountPaisa * 100) : 0;
    return {
      originalAmount: totalAmountPaisa,
      discountAmount,
      finalAmount,
      savingsPercentage,
      formattedOriginal: `\u20B9${totalAmountPaisa / 100}`,
      formattedDiscount: `\u20B9${discountAmount / 100}`,
      formattedFinal: `\u20B9${finalAmount / 100}`
    };
  }
  /**
   * Validate promo code (basic string matching)
   * In production, this could be enhanced with actual promo code database
   */
  static validatePromoCode(promoCode, offers) {
    const normalized = promoCode.trim().toUpperCase();
    const matchedOffer = offers.find(
      (offer) => offer.title.toUpperCase().includes(normalized) || offer.description?.toUpperCase().includes(normalized)
    );
    return matchedOffer || null;
  }
};

// server/services/googlePlaces.ts
init_storage();
var CircuitBreaker = class {
  failures = 0;
  lastFailureTime = 0;
  threshold = 5;
  // Open circuit after 5 failures
  timeout = 6e4;
  // 1 minute timeout
  state = "CLOSED";
  canProceed() {
    if (this.state === "CLOSED") return true;
    if (this.state === "OPEN") {
      const timeSinceLastFailure = Date.now() - this.lastFailureTime;
      if (timeSinceLastFailure >= this.timeout) {
        this.state = "HALF_OPEN";
        return true;
      }
      return false;
    }
    return true;
  }
  recordSuccess() {
    this.failures = 0;
    this.state = "CLOSED";
  }
  recordFailure() {
    this.failures++;
    this.lastFailureTime = Date.now();
    if (this.failures >= this.threshold) {
      this.state = "OPEN";
      console.warn(`Circuit breaker OPEN - too many failures (${this.failures})`);
    }
  }
};
var GooglePlacesService = class {
  apiKey;
  baseUrl = "https://maps.googleapis.com/maps/api/place";
  circuitBreaker = new CircuitBreaker();
  cacheExpiryDays = 30;
  constructor(apiKey) {
    if (!apiKey) {
      throw new Error("Google Places API key is required");
    }
    this.apiKey = apiKey;
  }
  /**
   * Search for businesses near coordinates with cache-first approach
   */
  async searchNearby(params) {
    const { latitude, longitude, businessName, radius = 50 } = params;
    if (!this.circuitBreaker.canProceed()) {
      throw new Error("Google Places API circuit breaker is OPEN - service temporarily unavailable");
    }
    try {
      const cachedResults = await this.checkCache(latitude, longitude, businessName);
      if (cachedResults.length > 0) {
        console.log(`\u2705 Cache HIT for "${businessName}" near (${latitude}, ${longitude})`);
        this.circuitBreaker.recordSuccess();
        return cachedResults;
      }
      console.log(`\u274C Cache MISS for "${businessName}" - calling Google Places API`);
      const results = await this.callNearbySearchAPI(latitude, longitude, businessName, radius);
      await this.cacheResults(results);
      this.circuitBreaker.recordSuccess();
      return results;
    } catch (error) {
      this.circuitBreaker.recordFailure();
      console.error("Error in searchNearby:", error);
      throw new Error(`Failed to search nearby businesses: ${error.message}`);
    }
  }
  /**
   * Import reviews from Google Place and store in database
   */
  async importReviews(params) {
    const { placeId, salonId } = params;
    if (!this.circuitBreaker.canProceed()) {
      throw new Error("Google Places API circuit breaker is OPEN - service temporarily unavailable");
    }
    try {
      const placeDetails = await this.getPlaceDetails(placeId);
      if (!placeDetails.reviews || placeDetails.reviews.length === 0) {
        return { imported: 0, skipped: 0 };
      }
      let imported = 0;
      let skipped = 0;
      for (const review of placeDetails.reviews) {
        const reviewData = {
          salonId,
          customerId: null,
          // Google reviews don't have customer ID
          bookingId: null,
          // Google reviews aren't linked to bookings
          rating: review.rating,
          comment: review.text || "",
          source: "google",
          googleAuthorName: review.author_name,
          googleAuthorPhoto: review.profile_photo_url || null,
          googleReviewId: `${placeId}_${review.time}`,
          // Unique ID for deduplication
          isVerified: 0,
          googlePublishedAt: new Date(review.time * 1e3)
        };
        try {
          await storage.createReview(reviewData);
          imported++;
        } catch (error) {
          if (error.message?.includes("unique") || error.message?.includes("duplicate")) {
            skipped++;
          } else {
            throw error;
          }
        }
      }
      await storage.updateSalon(salonId, {
        googlePlaceId: placeId,
        googleRating: placeDetails.rating?.toString() || null,
        googleReviewCount: placeDetails.user_ratings_total || 0,
        googleRatingSyncedAt: /* @__PURE__ */ new Date()
      });
      await storage.updateSalonRating(salonId);
      this.circuitBreaker.recordSuccess();
      return { imported, skipped };
    } catch (error) {
      this.circuitBreaker.recordFailure();
      console.error("Error importing reviews:", error);
      throw new Error(`Failed to import reviews: ${error.message}`);
    }
  }
  /**
   * Check cache for nearby businesses (30-day TTL)
   */
  async checkCache(latitude, longitude, businessName) {
    try {
      const cached = await storage.searchCachedPlaces(latitude, longitude, businessName);
      const now = /* @__PURE__ */ new Date();
      const validCached = cached.filter((entry) => {
        return new Date(entry.expiresAt) > now;
      });
      return validCached.map((entry) => entry.payload);
    } catch (error) {
      console.error("Cache check error:", error);
      return [];
    }
  }
  /**
   * Cache API results for 30 days
   */
  async cacheResults(results) {
    const expiresAt = /* @__PURE__ */ new Date();
    expiresAt.setDate(expiresAt.getDate() + this.cacheExpiryDays);
    for (const result of results) {
      try {
        const cacheEntry = {
          placeId: result.place_id,
          businessName: result.name,
          address: result.formatted_address,
          latitude: result.geometry.location.lat.toString(),
          longitude: result.geometry.location.lng.toString(),
          rating: result.rating?.toString() || null,
          reviewCount: result.user_ratings_total || 0,
          payload: result,
          expiresAt
        };
        await storage.cacheGooglePlace(cacheEntry);
      } catch (error) {
        console.error("Cache insertion error:", error);
      }
    }
  }
  /**
   * Call Google Places Nearby Search API with retry logic
   */
  async callNearbySearchAPI(latitude, longitude, keyword, radius) {
    const url = new URL(`${this.baseUrl}/nearbysearch/json`);
    url.searchParams.set("location", `${latitude},${longitude}`);
    url.searchParams.set("radius", radius.toString());
    url.searchParams.set("keyword", keyword);
    url.searchParams.set("key", this.apiKey);
    const maxRetries = 3;
    let lastError = null;
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        const response = await fetch(url.toString());
        const data = await response.json();
        if (data.status === "OK" || data.status === "ZERO_RESULTS") {
          return data.results || [];
        }
        throw new Error(`Google Places API error: ${data.status} - ${data.error_message || "Unknown error"}`);
      } catch (error) {
        lastError = error;
        console.error(`Attempt ${attempt}/${maxRetries} failed:`, error.message);
        if (attempt < maxRetries) {
          const backoffMs = Math.pow(2, attempt - 1) * 1e3;
          await new Promise((resolve) => setTimeout(resolve, backoffMs));
        }
      }
    }
    throw lastError || new Error("Failed to call Google Places API after retries");
  }
  /**
   * Get place details including reviews
   */
  async getPlaceDetails(placeId) {
    const url = new URL(`${this.baseUrl}/details/json`);
    url.searchParams.set("place_id", placeId);
    url.searchParams.set("fields", "name,formatted_address,geometry,rating,user_ratings_total,reviews");
    url.searchParams.set("key", this.apiKey);
    const maxRetries = 3;
    let lastError = null;
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        const response = await fetch(url.toString());
        const data = await response.json();
        if (data.status === "OK") {
          return data.result;
        }
        throw new Error(`Google Places API error: ${data.status} - ${data.error_message || "Unknown error"}`);
      } catch (error) {
        lastError = error;
        console.error(`Attempt ${attempt}/${maxRetries} failed:`, error.message);
        if (attempt < maxRetries) {
          const backoffMs = Math.pow(2, attempt - 1) * 1e3;
          await new Promise((resolve) => setTimeout(resolve, backoffMs));
        }
      }
    }
    throw lastError || new Error("Failed to get place details after retries");
  }
};
var googlePlacesService = null;
function getGooglePlacesService() {
  if (!googlePlacesService) {
    const apiKey = process.env.GOOGLE_MAPS_API_KEY;
    if (!apiKey) {
      throw new Error("GOOGLE_MAPS_API_KEY environment variable is not set");
    }
    googlePlacesService = new GooglePlacesService(apiKey);
  }
  return googlePlacesService;
}

// server/geocodingUtils.ts
function calculateDistance(lat1, lng1, lat2, lng2) {
  const R = 6371e3;
  const \u03C61 = lat1 * Math.PI / 180;
  const \u03C62 = lat2 * Math.PI / 180;
  const \u0394\u03C6 = (lat2 - lat1) * Math.PI / 180;
  const \u0394\u03BB = (lng2 - lng1) * Math.PI / 180;
  const a = Math.sin(\u0394\u03C6 / 2) * Math.sin(\u0394\u03C6 / 2) + Math.cos(\u03C61) * Math.cos(\u03C62) * Math.sin(\u0394\u03BB / 2) * Math.sin(\u0394\u03BB / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  return R * c;
}

// server/routes.ts
import { z as z23 } from "zod";

// server/routes/ai-look.routes.ts
init_storage();
import { Router } from "express";
import rateLimit from "express-rate-limit";

// server/services/gemini.service.ts
import { GoogleGenAI } from "@google/genai";

// server/services/inventory-context.service.ts
init_db();
init_schema();
import { eq as eq4, and as and4, sql as sql4 } from "drizzle-orm";
async function buildInventoryContextForAI(salonId, maxPerCategory = 10, preferredBrands) {
  let productsWithInventory = await db.select({
    id: beautyProducts.id,
    category: beautyProducts.category,
    brand: beautyProducts.brand,
    name: beautyProducts.name,
    shade: beautyProducts.shade,
    finishType: beautyProducts.finishType,
    price: beautyProducts.price,
    gender: beautyProducts.gender,
    quantity: salonInventory.quantity
  }).from(salonInventory).innerJoin(
    beautyProducts,
    eq4(beautyProducts.id, salonInventory.productId)
  ).where(
    and4(
      eq4(salonInventory.salonId, salonId),
      sql4`${salonInventory.quantity} > 0`
      // Only in-stock products
    )
  ).orderBy(sql4`${salonInventory.quantity} DESC`);
  if (preferredBrands && preferredBrands.length > 0) {
    const brandsLower = preferredBrands.map((b) => b.toLowerCase());
    productsWithInventory = productsWithInventory.filter(
      (p) => brandsLower.includes(p.brand.toLowerCase())
    );
    console.log(`[Inventory] Filtered to ${preferredBrands.join(", ")} brands: ${productsWithInventory.length} products`);
  }
  const productsByCategory = productsWithInventory.reduce((acc, product) => {
    if (!acc[product.category]) {
      acc[product.category] = [];
    }
    acc[product.category].push({
      id: product.id,
      category: product.category,
      brand: product.brand,
      name: product.name,
      shade: product.shade,
      finishType: product.finishType,
      price: product.price,
      inStock: (product.quantity || 0) > 0,
      quantity: product.quantity || 0
    });
    return acc;
  }, {});
  const limitedProducts = {};
  const productIdMap = /* @__PURE__ */ new Map();
  for (const [category, products2] of Object.entries(productsByCategory)) {
    const sorted = products2.sort((a, b) => {
      if (a.inStock && !b.inStock) return -1;
      if (!a.inStock && b.inStock) return 1;
      return b.quantity - a.quantity;
    });
    limitedProducts[category] = sorted.slice(0, maxPerCategory);
    limitedProducts[category].forEach((product) => {
      productIdMap.set(product.id, product);
    });
  }
  const formattedInventory = Object.entries(limitedProducts).map(([category, products2]) => {
    const productList = products2.map((p, idx) => {
      const stockStatus = p.inStock ? `\u2713 In stock (${p.quantity})` : "\u2717 Out of stock";
      const shadeInfo = p.shade ? ` - Shade: ${p.shade}` : "";
      const finishInfo = p.finishType ? ` - Finish: ${p.finishType}` : "";
      return `  ${idx + 1}. [ID: ${p.id}] ${p.brand} ${p.name}${shadeInfo}${finishInfo} (${stockStatus})`;
    }).join("\n");
    return `**${category.toUpperCase()}** (${products2.length} products):
${productList}`;
  }).join("\n\n");
  const categoriesAvailable = Object.keys(limitedProducts);
  const totalProducts = Array.from(productIdMap.values()).length;
  if (totalProducts === 0) {
    console.warn(`[Inventory Context] WARNING: Salon ${salonId} has no products in inventory${preferredBrands ? ` for brands: ${preferredBrands.join(", ")}` : ""}`);
  }
  return {
    totalProducts,
    categoriesAvailable,
    productsByCategoryFormatted: formattedInventory,
    productIdMap
  };
}

// server/services/openai.service.ts
import OpenAI from "openai";
var openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY || "" });
async function analyzeBeautyImageWithOpenAI(input) {
  const model = "gpt-5";
  const inventoryContext = await buildInventoryContextForAI(input.salonId, 10, input.preferredBrands);
  const brandContext = input.preferredBrands && input.preferredBrands.length > 0 ? ` (filtered to: ${input.preferredBrands.join(", ")})` : "";
  console.log(`[AI Look - OpenAI] Loaded ${inventoryContext.totalProducts} products across ${inventoryContext.categoriesAvailable.length} categories for salon ${input.salonId}${brandContext}`);
  if (inventoryContext.totalProducts === 0) {
    const errorMessage = input.preferredBrands && input.preferredBrands.length > 0 ? `This salon does not stock any products from the selected brands (${input.preferredBrands.join(", ")}). Please try selecting different brands or contact the salon to stock these products.` : "This salon has no products in inventory. Please add products to the salon inventory before using AI Look Advisor.";
    throw new Error(errorMessage);
  }
  const systemPrompt = `You are an expert beauty consultant and makeup artist with deep knowledge of cosmetic products, skin tones, face shapes, and beauty trends. Your role is to analyze customer photos and provide personalized makeup and hairstyle recommendations for salon staff.

IMPORTANT CONTEXT:
- You are helping salon staff recommend looks for their customers
- **CRITICAL**: You MUST ONLY recommend products from the INVENTORY CONTEXT provided below. Each product has an [ID: xxx] - you MUST include this ID in your response
- Consider the customer's skin tone, facial features, event type, weather, and location
- Each look should include specific product recommendations with product IDs from the inventory
- Preset categories map to AR effects: makeup_natural, makeup_glamorous, makeup_bridal, makeup_party, makeup_smokey, hair_brown, hair_blonde, hair_red, hair_black, hair_highlights, hair_ombre, beard_full, beard_stubble, beard_goatee

GENDER-SPECIFIC RECOMMENDATIONS:
- Customer gender: ${input.gender}
${input.gender === "male" ? "- Focus on MALE grooming: haircare, skincare, beard care (if applicable), and subtle enhancement (foundation, concealer, eyebrow grooming). Emphasize natural, professional looks suitable for men." : ""}
${input.gender === "female" ? "- Focus on FEMALE makeup: Provide full makeup looks including foundation, concealer, eyeshadow, lipstick, blush, highlighter. Focus on cosmetics and beauty enhancement for women." : ""}
${input.gender === "prefer_not" || !input.gender ? "- Provide gender-neutral recommendations emphasizing unisex skincare and subtle enhancement products suitable for all genders." : ""}

ANALYSIS STEPS:
1. Analyze the customer's photo for:
   - Skin tone (fair, light, medium, olive, tan, dark, deep)
   - Face shape (oval, round, square, heart, diamond, oblong)
   - Eye color and shape
   - Lip shape
   - Facial features (high cheekbones, prominent jaw, etc.)
   - Hair color and texture (if visible)

2. Consider the context:
   - Event type: ${input.eventType || "casual"} (adjust intensity and style)
   - Weather: ${input.weather || "normal"} (waterproof/long-lasting for humid)
   - Location: ${input.location || "indoor"} (lighting considerations)
   - Skin tone preference: ${input.skinTone || "auto-detect"}
   - Hair type: ${input.hairType || "auto-detect"}

3. Generate 2-4 distinct looks from available inventory products:
   - Each look must use ONLY products from the inventory below
   - Include the product ID [ID: xxx] for every product
   - Provide a confidence score (0-100) for how well each look suits this customer
   - Assign appropriate preset categories for AR preview
   - Explain WHY each product was chosen (e.g., "complements your warm undertones")

INVENTORY CONTEXT:
${JSON.stringify(inventoryContext, null, 2)}

RESPONSE FORMAT (STRICT JSON):
{
  "customerAnalysis": {
    "skinTone": "detected skin tone",
    "facialFeatures": "description of key facial features",
    "recommendations": "overall beauty recommendations"
  },
  "looks": [
    {
      "lookName": "Look name (e.g., Natural Day Look, Glamorous Evening)",
      "description": "Detailed description of this look and why it suits the customer",
      "confidenceScore": 85,
      "presetCategories": ["makeup_natural", "hair_brown"],
      "products": [
        {
          "category": "Foundation",
          "productId": "product-uuid-from-inventory",
          "reason": "Why this product was chosen for this customer",
          "attributes": {
            "finish": "matte",
            "shade": "medium beige",
            "type": "liquid"
          }
        }
      ]
    }
  ]
}

CRITICAL VALIDATION:
- Every productId MUST match an [ID: xxx] from the inventory context above
- If inventory is limited, work creatively with what's available
- Prioritize products that match customer's skin tone and event type
- If certain categories are missing (e.g., no foundation), skip them gracefully`;
  try {
    console.log(`[AI Look - OpenAI] Calling GPT-4o vision API for customer: ${input.customerName}`);
    const response = await openai.chat.completions.create({
      model,
      messages: [
        {
          role: "system",
          content: systemPrompt
        },
        {
          role: "user",
          content: [
            {
              type: "text",
              text: `Please analyze this photo of ${input.customerName} and provide personalized beauty recommendations using the products from the salon's inventory.`
            },
            {
              type: "image_url",
              image_url: {
                url: input.imageBase64.startsWith("data:") ? input.imageBase64 : `data:image/jpeg;base64,${input.imageBase64}`
              }
            }
          ]
        }
      ],
      response_format: { type: "json_object" },
      max_tokens: 4e3,
      temperature: 0.7
    });
    const content = response.choices[0].message.content;
    if (!content) {
      throw new Error("OpenAI returned empty response");
    }
    console.log(`[AI Look - OpenAI] Successfully received response`);
    const analysisResult = JSON.parse(content);
    for (const look of analysisResult.looks) {
      for (const product of look.products) {
        if (!inventoryContext.productIdMap.has(product.productId)) {
          console.warn(`[AI Look - OpenAI] Product ID ${product.productId} not found in inventory, removing from recommendations`);
          look.products = look.products.filter((p) => p.productId !== product.productId);
        }
      }
    }
    analysisResult.looks = analysisResult.looks.filter((look) => look.products.length > 0);
    if (analysisResult.looks.length === 0) {
      throw new Error("OpenAI could not generate valid product recommendations from available inventory");
    }
    return analysisResult;
  } catch (error) {
    console.error("OpenAI beauty analysis error:", error);
    if (error?.status === 401) {
      throw new Error("Invalid OpenAI API key. Please check your OPENAI_API_KEY configuration.");
    }
    if (error?.status === 429) {
      throw new Error("OpenAI rate limit exceeded. Please try again in a few moments.");
    }
    if (error?.status === 400 && error?.message?.includes("image")) {
      throw new Error("Invalid image format. Please upload a clear photo of your face.");
    }
    throw new Error(`OpenAI analysis failed: ${error.message || "Unknown error occurred"}`);
  }
}

// server/services/gemini.service.ts
var genAI = new GoogleGenAI({ apiKey: process.env.GEMINI_API_KEY || "" });
async function retryWithExponentialBackoff(fn, maxRetries = 3, baseDelay = 2e3) {
  let lastError = null;
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error;
      const status = error.status || error.error?.code || error.code;
      const message = error.message || error.error?.message || "";
      const errorCode = typeof error.code === "string" ? error.code : "";
      const isQuotaOrPermissionError = status === 429 || status === 403 || status === "RESOURCE_EXHAUSTED" || status === "PERMISSION_DENIED" || errorCode === "RESOURCE_EXHAUSTED" || errorCode === "PERMISSION_DENIED" || message.includes("quota") || message.includes("RESOURCE_EXHAUSTED") || message.includes("PERMISSION_DENIED") || message.includes("exceeded your current quota");
      if (isQuotaOrPermissionError) {
        console.log(`[No Retry] Quota/permission error detected. Failing fast for OpenAI fallback.`);
        throw error;
      }
      const isRetryableError = (
        // HTTP transient status codes
        status === 408 || status === 500 || status === 502 || status === 503 || status === 504 || status === 509 || // Google SDK status strings
        status === "UNAVAILABLE" || status === "ABORTED" || status === "DEADLINE_EXCEEDED" || status === "INTERNAL" || // Error code strings
        errorCode === "UNAVAILABLE" || errorCode === "ABORTED" || errorCode === "DEADLINE_EXCEEDED" || errorCode === "INTERNAL" || // Network errors
        errorCode === "ECONNRESET" || errorCode === "ETIMEDOUT" || errorCode === "ENOTFOUND" || errorCode === "ECONNREFUSED" || // Message-based detection (fallback)
        message.includes("UNAVAILABLE") || message.includes("ABORTED") || message.includes("DEADLINE_EXCEEDED") || message.includes("INTERNAL")
      );
      if (isRetryableError && attempt < maxRetries - 1) {
        const jitter = Math.random() * 500;
        const delay2 = Math.pow(2, attempt) * baseDelay + jitter;
        console.log(`[Retry ${attempt + 1}/${maxRetries - 1}] Transient error (status: ${status}, code: ${errorCode}). Waiting ${Math.round(delay2 / 1e3)}s before retry...`);
        await new Promise((resolve) => setTimeout(resolve, delay2));
        continue;
      }
      console.log(`[No Retry] Non-retryable error or max retries reached (status: ${status}, code: ${errorCode})`);
      throw error;
    }
  }
  throw lastError;
}
async function analyzeBeautyImage(input) {
  const model = "gemini-2.5-flash";
  const inventoryContext = await buildInventoryContextForAI(input.salonId, 5, input.preferredBrands);
  const brandContext = input.preferredBrands && input.preferredBrands.length > 0 ? ` (filtered to: ${input.preferredBrands.join(", ")})` : "";
  console.log(`[AI Look] Loaded ${inventoryContext.totalProducts} products across ${inventoryContext.categoriesAvailable.length} categories for salon ${input.salonId}${brandContext}`);
  if (inventoryContext.totalProducts === 0) {
    const errorMessage = input.preferredBrands && input.preferredBrands.length > 0 ? `This salon does not stock any products from the selected brands (${input.preferredBrands.join(", ")}). Please try selecting different brands or contact the salon to stock these products.` : "This salon has no products in inventory. Please add products to the salon inventory before using AI Look Advisor.";
    throw new Error(errorMessage);
  }
  const systemPrompt = `You are an expert beauty consultant and makeup artist with deep knowledge of cosmetic products, skin tones, face shapes, and beauty trends. Your role is to analyze customer photos and provide personalized makeup and hairstyle recommendations for salon staff.

IMPORTANT CONTEXT:
- You are helping salon staff recommend looks for their customers
- **CRITICAL**: You MUST ONLY recommend products from the INVENTORY CONTEXT provided below. Each product has an [ID: xxx] - you MUST include this ID in your response
- Consider the customer's skin tone, facial features, event type, weather, and location
- Each look should include specific product recommendations with product IDs from the inventory
- Preset categories map to AR effects: makeup_natural, makeup_glamorous, makeup_bridal, makeup_party, makeup_smokey, hair_brown, hair_blonde, hair_red, hair_black, hair_highlights, hair_ombre, beard_full, beard_stubble, beard_goatee

GENDER-SPECIFIC RECOMMENDATIONS:
- Customer gender: ${input.gender}
${input.gender === "male" ? "- Focus on MALE grooming: haircare, skincare, beard care (if applicable), and subtle enhancement (foundation, concealer, eyebrow grooming). Emphasize natural, professional looks suitable for men." : ""}
${input.gender === "female" ? "- Focus on FEMALE makeup: Provide full makeup looks including foundation, concealer, eyeshadow, lipstick, blush, highlighter. Focus on cosmetics and beauty enhancement for women." : ""}
${input.gender === "prefer_not" || !input.gender ? "- Provide gender-neutral recommendations emphasizing unisex skincare and subtle enhancement products suitable for all genders." : ""}

ANALYSIS STEPS:
1. Analyze the customer's photo for:
   - Skin tone (fair, light, medium, olive, tan, dark, deep)
   - Face shape (oval, round, square, heart, diamond, oblong)
   - Eye color and shape
   - Lip shape
   - Facial features (high cheekbones, prominent jaw, etc.)
   - Hair color and texture (if visible)

2. Consider the context:
   - Event type: ${input.eventType || "casual"} (adjust intensity and style)
   - Weather: ${input.weather || "normal"} (waterproof/long-lasting for humid)
   - Location: ${input.location || "indoor"} (lighting considerations)
   - Skin tone preference: ${input.skinTone || "auto-detect"}
   - Hair type: ${input.hairType || "auto-detect"}

3. Generate EXACTLY 2 distinct look options:
   - Each look should have a creative name and compelling description
   - Include confidence score (0-100) based on how well it suits the customer
   - List preset categories needed for AR preview (makeup + optional hair/beard)
   - Recommend specific product types with attributes (shade, finish, etc.)
   - Keep it concise: 6-8 products per look (focus on essentials)

PRODUCT CATEGORIES (use these exactly):
- foundation (attributes: shade, finish: matte/dewy/natural)
- concealer (attributes: shade)
- powder (attributes: shade, finish: translucent/pressed)
- blush (attributes: shade, finish: powder/cream)
- bronzer (attributes: shade)
- highlighter (attributes: shade, finish: powder/liquid)
- eyeshadow (attributes: shade, finish: matte/shimmer/metallic)
- eyeliner (attributes: type: pencil/liquid/gel, shade)
- mascara (attributes: type: volumizing/lengthening, shade)
- eyebrow_pencil (attributes: shade)
- lipstick (attributes: shade, finish: matte/cream/glossy)
- lip_liner (attributes: shade)
- lip_gloss (attributes: shade)
- setting_spray (attributes: type: matte/dewy)
- primer (attributes: type: pore-minimizing/hydrating/mattifying)
- hair_color (attributes: shade, type: permanent/semi-permanent)

SHADE NAMING CONVENTIONS:
- Foundation: Fair Ivory, Light Beige, Medium Tan, Golden Beige, Caramel, Mocha, Deep Espresso
- Lipstick: Nude Rose, Mauve Pink, Coral Red, Berry Wine, Classic Red, Plum, etc.
- Eyeshadow: Champagne Gold, Bronze, Copper, Soft Pink, Mauve, Charcoal, etc.

RESPONSE FORMAT (JSON) - **IMPORTANT: You MUST include productId from the INVENTORY CONTEXT**:
{
  "customerAnalysis": {
    "skinTone": "detected skin tone category",
    "facialFeatures": "brief description of key features",
    "recommendations": "general beauty recommendations for this customer"
  },
  "looks": [
    {
      "lookName": "creative look name",
      "description": "compelling 2-3 sentence description",
      "confidenceScore": 85,
      "presetCategories": ["makeup_natural", "hair_brown"],
      "products": [
        {
          "category": "foundation",
          "productId": "exact-product-id-from-inventory-context",
          "reason": "Evens skin tone while maintaining natural glow",
          "attributes": {
            "shade": "Medium Tan",
            "finish": "dewy"
          }
        },
        {
          "category": "lipstick",
          "productId": "exact-product-id-from-inventory-context",
          "reason": "Complements skin tone for understated elegance",
          "attributes": {
            "shade": "Nude Rose",
            "finish": "matte"
          }
        }
      ]
    }
  ]
}

**Remember**: Every product MUST have a valid productId from the INVENTORY CONTEXT below. The attributes field is optional but helpful for staff understanding.

QUALITY GUIDELINES:
- Be specific and actionable (not "natural lipstick" but "Nude Rose matte lipstick")
- Ensure each look is distinctly different (natural vs. glamorous)
- Confidence scores should reflect genuine suitability (don't give everything 95+)
- Include 6-8 essential products per look (foundation, concealer, eyes, lips, cheeks)
- Provide clear reasons for each product choice
- Consider color theory (complementary shades, undertones)
- **IMPORTANT**: Keep responses concise to avoid truncation`;
  try {
    const imagePart = {
      inlineData: {
        data: input.imageBase64.replace(/^data:image\/\w+;base64,/, ""),
        mimeType: input.imageBase64.match(/^data:image\/(\w+);base64,/)?.[1] === "png" ? "image/png" : "image/jpeg"
      }
    };
    const inventoryPrompt = `

## INVENTORY CONTEXT
${input.preferredBrands && input.preferredBrands.length > 0 ? `**Customer prefers these brands: ${input.preferredBrands.join(", ")}** - Recommend ONLY from these brands.

` : ""}Available products for this salon (total: ${inventoryContext.totalProducts} across ${inventoryContext.categoriesAvailable.length} categories):

${inventoryContext.productsByCategoryFormatted}

**CRITICAL**: You MUST use the [ID: xxx] values from above in your productId field. Do not make up product IDs.`;
    const result = await retryWithExponentialBackoff(
      () => genAI.models.generateContent({
        model,
        contents: [
          {
            role: "user",
            parts: [
              { text: systemPrompt },
              imagePart,
              { text: `Analyze this photo of ${input.customerName} and provide personalized beauty recommendations.` },
              { text: inventoryPrompt }
            ]
          }
        ],
        config: {
          temperature: 0.7,
          topP: 0.95,
          topK: 40,
          maxOutputTokens: 8192,
          responseMimeType: "application/json"
        }
      })
      // Using default params: maxRetries=3, baseDelay=2000 (defined in function signature)
    );
    const text2 = result.text || "";
    if (!text2) {
      console.error("[Gemini] Empty response - may be due to safety filters or MAX_TOKENS limit");
      throw new Error("Gemini returned empty response. This may be due to safety filters or content blocks.");
    }
    let analysis;
    try {
      analysis = JSON.parse(text2);
      if (!analysis || typeof analysis !== "object") {
        throw new Error("Invalid response structure");
      }
      if (!analysis.looks || !Array.isArray(analysis.looks) || analysis.looks.length === 0) {
        throw new Error("No looks generated by AI");
      }
      if (!analysis.customerAnalysis || typeof analysis.customerAnalysis !== "object") {
        analysis.customerAnalysis = {
          skinTone: "auto-detected",
          facialFeatures: "",
          recommendations: "Unable to generate detailed analysis."
        };
      }
    } catch (parseError) {
      console.error("Failed to parse Gemini response:", text2);
      throw new Error(`AI response parsing failed: ${parseError.message}. Raw response may be malformed.`);
    }
    return analysis;
  } catch (error) {
    console.error("Gemini AI analysis error:", error);
    if (error.status === 429) {
      throw new Error('\u23F3 Our AI service is experiencing high demand right now. Please wait 30-60 seconds before trying again. Tip: Avoid clicking "Analyze" multiple times in quick succession to prevent rate limiting.');
    }
    if (error.message?.includes("RESOURCE_EXHAUSTED")) {
      throw new Error("\u23F3 AI quota temporarily exhausted. Please wait 1-2 minutes before trying again. The service will automatically recover.");
    }
    throw new Error(`AI analysis failed: ${error.message}`);
  }
}
async function analyzeBeautyImageWithFallback(input) {
  console.log(`[AI Look] Starting analysis for ${input.customerName} at salon ${input.salonId}`);
  try {
    console.log("[AI Look] Attempting primary provider: Gemini");
    const geminiResult = await analyzeBeautyImage(input);
    console.log("[AI Look] \u2713 Gemini analysis successful");
    return {
      ...geminiResult,
      provider: "gemini"
    };
  } catch (geminiError) {
    console.log(`[AI Look] \u2717 Gemini failed: ${geminiError.message}`);
    const isOpenAIConfigured = process.env.OPENAI_API_KEY && process.env.OPENAI_API_KEY.length > 0;
    const isInventoryError = geminiError.message?.includes("no products in inventory") || geminiError.message?.includes("does not stock any products");
    if (isInventoryError) {
      console.log("[AI Look] Inventory error detected, not attempting fallback");
      throw geminiError;
    }
    if (isOpenAIConfigured) {
      const errorType = geminiError.status === 429 || geminiError.message?.includes("quota") || geminiError.message?.includes("RESOURCE_EXHAUSTED") ? "quota/rate limit" : "provider error";
      console.log(`[AI Look] Gemini ${errorType} detected. Attempting fallback to OpenAI...`);
      try {
        const openaiResult = await analyzeBeautyImageWithOpenAI(input);
        console.log("[AI Look] \u2713 OpenAI fallback successful");
        return {
          ...openaiResult,
          provider: "openai"
        };
      } catch (openaiError) {
        console.error("[AI Look] \u2717 OpenAI fallback also failed:", openaiError.message);
        const errorMessage = geminiError.status === 429 || geminiError.message?.includes("quota") ? "Both AI providers are currently unavailable. Gemini quota exhausted and OpenAI also failed. Please try again in a few minutes." : `AI analysis failed with both providers. Gemini: ${geminiError.message}. OpenAI: ${openaiError.message}`;
        throw new Error(errorMessage);
      }
    } else {
      if (geminiError.status === 429 || geminiError.message?.includes("quota") || geminiError.message?.includes("RESOURCE_EXHAUSTED")) {
        throw new Error("Gemini quota exhausted and OpenAI backup is not configured. Please add OPENAI_API_KEY to your secrets or wait for Gemini quota to reset.");
      }
      throw geminiError;
    }
  }
}
async function generateApplicationInstructions(lookDescription, products2) {
  const model = "gemini-1.5-flash";
  const prompt = `You are a professional makeup artist providing step-by-step application instructions.

LOOK DESCRIPTION: ${lookDescription}

PRODUCTS TO USE:
${products2.map((p) => `- ${p.brand} ${p.productName} (${p.category})`).join("\n")}

Generate detailed, professional application instructions in the following format:

**STEP 1: PREP**
[Prep instructions]

**STEP 2: BASE**
[Foundation, concealer, powder instructions]

**STEP 3: EYES**
[Eye makeup instructions]

**STEP 4: CHEEKS**
[Blush, bronzer, highlighter instructions]

**STEP 5: LIPS**
[Lip product instructions]

**STEP 6: FINISHING TOUCHES**
[Setting spray, final touches]

GUIDELINES:
- Be specific about application techniques (stippling, blending, tapping, etc.)
- Include tool recommendations (beauty blender, brush types)
- Mention wait times if needed (let primer dry, etc.)
- Add pro tips for longevity and best results
- Use conversational but professional tone
- Maximum 2-3 sentences per product
`;
  try {
    const result = await genAI.models.generateContent({
      model,
      contents: prompt,
      config: {
        temperature: 0.8,
        maxOutputTokens: 2048
      }
    });
    return result.text || "Application instructions could not be generated. Please follow standard makeup application techniques.";
  } catch (error) {
    console.error("Error generating application instructions:", error);
    return "Application instructions could not be generated. Please follow standard makeup application techniques.";
  }
}

// server/services/product-matcher.service.ts
init_db();
init_schema();
import { eq as eq5, and as and5, sql as sql5, or as or2 } from "drizzle-orm";
async function matchProductsForLook(salonId, productRecommendations, customerGender) {
  const matchedProducts = [];
  for (const recommendation of productRecommendations) {
    const { category, productId } = recommendation;
    const attributes = recommendation.attributes || {};
    let matchingProducts;
    if (productId) {
      console.log(`[Product Matcher] Using direct productId: ${productId} for category: ${category}`);
      matchingProducts = await db.select({
        id: beautyProducts.id,
        brand: beautyProducts.brand,
        productLine: beautyProducts.productLine,
        name: beautyProducts.name,
        category: beautyProducts.category,
        shade: beautyProducts.shade,
        sku: beautyProducts.sku,
        finishType: beautyProducts.finishType,
        price: beautyProducts.price,
        imageUrl: beautyProducts.imageUrl,
        description: beautyProducts.description,
        gender: beautyProducts.gender,
        inventoryQuantity: sql5`COALESCE(${salonInventory.quantity}, 0)`
      }).from(beautyProducts).leftJoin(
        salonInventory,
        and5(
          eq5(salonInventory.productId, beautyProducts.id),
          eq5(salonInventory.salonId, salonId)
        )
      ).where(eq5(beautyProducts.id, productId)).limit(1);
      if (matchingProducts.length === 0) {
        console.warn(`[Product Matcher] Invalid productId ${productId} - falling back to attribute matching`);
      }
    }
    if (!matchingProducts || matchingProducts.length === 0) {
      console.log(`[Product Matcher] Using attribute matching for category: ${category}`);
      matchingProducts = await db.select({
        id: beautyProducts.id,
        brand: beautyProducts.brand,
        productLine: beautyProducts.productLine,
        name: beautyProducts.name,
        category: beautyProducts.category,
        shade: beautyProducts.shade,
        sku: beautyProducts.sku,
        finishType: beautyProducts.finishType,
        price: beautyProducts.price,
        imageUrl: beautyProducts.imageUrl,
        description: beautyProducts.description,
        gender: beautyProducts.gender,
        inventoryQuantity: sql5`COALESCE(${salonInventory.quantity}, 0)`
      }).from(beautyProducts).leftJoin(
        salonInventory,
        and5(
          eq5(salonInventory.productId, beautyProducts.id),
          eq5(salonInventory.salonId, salonId)
        )
      ).where(buildProductMatchQuery(category, attributes, customerGender)).limit(5);
    }
    if (matchingProducts.length === 0) {
      console.warn(`[Product Matcher] No product match found for category: ${category}, productId: ${productId}, attributes:`, attributes);
      continue;
    }
    const inStockProducts = matchingProducts.filter((p) => (p.inventoryQuantity || 0) > 0);
    const selectedProduct = inStockProducts.length > 0 ? inStockProducts[0] : matchingProducts[0];
    let substituteProduct = null;
    if (inStockProducts.length === 0 && matchingProducts.length > 1) {
      const alternativeInStock = matchingProducts.find((p) => (p.inventoryQuantity || 0) > 0);
      if (alternativeInStock) {
        substituteProduct = {
          id: alternativeInStock.id,
          brand: alternativeInStock.brand,
          productLine: alternativeInStock.productLine,
          name: alternativeInStock.name,
          category: alternativeInStock.category,
          shade: alternativeInStock.shade,
          sku: alternativeInStock.sku,
          finishType: alternativeInStock.finishType,
          price: alternativeInStock.price,
          imageUrl: alternativeInStock.imageUrl,
          description: alternativeInStock.description,
          isInStock: true,
          quantity: alternativeInStock.inventoryQuantity || 0,
          substituteProduct: null
        };
      }
    }
    matchedProducts.push({
      product: {
        id: selectedProduct.id,
        brand: selectedProduct.brand,
        productLine: selectedProduct.productLine,
        name: selectedProduct.name,
        category: selectedProduct.category,
        shade: selectedProduct.shade,
        sku: selectedProduct.sku,
        finishType: selectedProduct.finishType,
        price: selectedProduct.price,
        imageUrl: selectedProduct.imageUrl,
        description: selectedProduct.description,
        isInStock: (selectedProduct.inventoryQuantity || 0) > 0,
        quantity: selectedProduct.inventoryQuantity || 0,
        substituteProduct
      },
      recommendation
    });
  }
  return matchedProducts;
}
function buildProductMatchQuery(category, attributes = {}, customerGender) {
  const conditions = [eq5(beautyProducts.category, category)];
  if (customerGender === "male") {
    conditions.push(
      or2(
        eq5(beautyProducts.gender, "male"),
        eq5(beautyProducts.gender, "unisex")
      )
    );
  } else if (customerGender === "female") {
    conditions.push(
      or2(
        eq5(beautyProducts.gender, "female"),
        eq5(beautyProducts.gender, "unisex")
      )
    );
  }
  if (attributes?.shade) {
    conditions.push(
      or2(
        sql5`LOWER(${beautyProducts.shade}) LIKE LOWER('%' || ${attributes.shade} || '%')`,
        sql5`LOWER(${beautyProducts.name}) LIKE LOWER('%' || ${attributes.shade} || '%')`
      )
    );
  }
  if (attributes?.finish) {
    conditions.push(
      or2(
        sql5`LOWER(${beautyProducts.finishType}) LIKE LOWER('%' || ${attributes.finish} || '%')`,
        sql5`LOWER(${beautyProducts.name}) LIKE LOWER('%' || ${attributes.finish} || '%')`
      )
    );
  }
  if (attributes?.type) {
    conditions.push(
      sql5`LOWER(${beautyProducts.name}) LIKE LOWER('%' || ${attributes.type} || '%')`
    );
  }
  return and5(...conditions);
}
async function resolvePresetsToEffects(presetCategories) {
  if (presetCategories.length === 0) {
    console.log("[resolvePresetsToEffects] No preset categories provided, returning empty array");
    return [];
  }
  console.log("[resolvePresetsToEffects] Looking up preset slugs:", presetCategories);
  const presets = await db.select().from(effectPresets).where(
    or2(...presetCategories.map((slug) => eq5(effectPresets.slug, slug)))
  ).limit(10);
  console.log("[resolvePresetsToEffects] Found presets:", presets.map((p) => ({ id: p.id, slug: p.slug, name: p.name })));
  if (presets.length === 0) {
    console.warn("[resolvePresetsToEffects] No exact slug matches found for:", presetCategories);
    console.warn("[resolvePresetsToEffects] Falling back to generic presets");
    const categorySet = /* @__PURE__ */ new Set();
    presetCategories.forEach((slug) => categorySet.add(slug.split("_")[0]));
    const categories = Array.from(categorySet);
    const fallbackPresets = await db.select().from(effectPresets).where(
      or2(...categories.map((cat) => eq5(effectPresets.category, cat)))
    ).limit(categories.length);
    console.log("[resolvePresetsToEffects] Fallback presets:", fallbackPresets.map((p) => ({ id: p.id, slug: p.slug })));
    return fallbackPresets.map((p) => p.id);
  }
  const presetIds = presets.map((p) => p.id);
  console.log("[resolvePresetsToEffects] Returning preset IDs:", presetIds);
  return presetIds;
}
async function decrementInventory(salonId, productId, quantity = 1) {
  const inventory = await db.select().from(salonInventory).where(
    and5(
      eq5(salonInventory.salonId, salonId),
      eq5(salonInventory.productId, productId)
    )
  ).limit(1);
  if (inventory.length === 0) {
    throw new Error("Product not in salon inventory");
  }
  const currentQty = inventory[0].quantity || 0;
  if (currentQty < quantity) {
    throw new Error("Insufficient inventory");
  }
  await db.update(salonInventory).set({
    quantity: currentQty - quantity
  }).where(
    and5(
      eq5(salonInventory.salonId, salonId),
      eq5(salonInventory.productId, productId)
    )
  );
}
async function getProductsBySalon(salonId) {
  const products2 = await db.select({
    id: beautyProducts.id,
    brand: beautyProducts.brand,
    productLine: beautyProducts.productLine,
    name: beautyProducts.name,
    category: beautyProducts.category,
    shade: beautyProducts.shade,
    sku: beautyProducts.sku,
    finishType: beautyProducts.finishType,
    price: beautyProducts.price,
    imageUrl: beautyProducts.imageUrl,
    description: beautyProducts.description,
    quantity: salonInventory.quantity
  }).from(beautyProducts).innerJoin(
    salonInventory,
    and5(
      eq5(salonInventory.productId, beautyProducts.id),
      eq5(salonInventory.salonId, salonId)
    )
  ).orderBy(beautyProducts.brand, beautyProducts.name);
  return products2.map((p) => ({
    id: p.id,
    brand: p.brand,
    productLine: p.productLine,
    name: p.name,
    category: p.category,
    shade: p.shade,
    sku: p.sku,
    finishType: p.finishType,
    price: p.price,
    imageUrl: p.imageUrl,
    description: p.description,
    isInStock: (p.quantity || 0) > 0,
    quantity: p.quantity || 0,
    substituteProduct: null
  }));
}

// server/routes/ai-look.routes.ts
init_db();
init_schema();
import { eq as eq6, desc as desc2, sql as sql6 } from "drizzle-orm";
import { z as z2 } from "zod";

// server/services/tempImageStorage.ts
import crypto2 from "crypto";
var TempImageStorage = class {
  images = /* @__PURE__ */ new Map();
  TTL_MS = 60 * 60 * 1e3;
  // 1 hour
  MAX_SIZE_MB = 10;
  MAX_SIZE_BYTES = this.MAX_SIZE_MB * 1024 * 1024;
  cleanupInterval = null;
  constructor() {
    this.startCleanup();
  }
  startCleanup() {
    this.cleanupInterval = setInterval(() => {
      this.removeExpired();
    }, 5 * 60 * 1e3);
  }
  removeExpired() {
    const now = Date.now();
    let removedCount = 0;
    const entries = Array.from(this.images.entries());
    for (const [id, image] of entries) {
      if (now > image.expiresAt) {
        this.images.delete(id);
        removedCount++;
      }
    }
    if (removedCount > 0) {
      console.log(`[TempImageStorage] Cleaned up ${removedCount} expired images. Remaining: ${this.images.size}`);
    }
  }
  uploadImage(buffer, mimeType, baseUrl) {
    if (buffer.length > this.MAX_SIZE_BYTES) {
      throw new Error(`Image size exceeds maximum allowed size of ${this.MAX_SIZE_MB}MB`);
    }
    const id = crypto2.randomBytes(16).toString("hex");
    const now = Date.now();
    const expiresAt = now + this.TTL_MS;
    const image = {
      id,
      buffer,
      mimeType,
      uploadedAt: now,
      expiresAt
    };
    this.images.set(id, image);
    console.log(`[TempImageStorage] Uploaded image ${id}, size: ${(buffer.length / 1024).toFixed(2)}KB, expires in 1 hour. Total images: ${this.images.size}`);
    const finalBaseUrl = baseUrl || (process.env.REPLIT_DEV_DOMAIN ? `https://${process.env.REPLIT_DEV_DOMAIN}` : "http://localhost:5000");
    return {
      publicUrl: `${finalBaseUrl}/api/temp-images/${id}`,
      imageId: id,
      expiresAt
    };
  }
  getImage(id) {
    const image = this.images.get(id);
    if (!image) {
      return null;
    }
    const now = Date.now();
    if (now > image.expiresAt) {
      this.images.delete(id);
      console.log(`[TempImageStorage] Image ${id} expired, removed from cache`);
      return null;
    }
    return {
      buffer: image.buffer,
      mimeType: image.mimeType
    };
  }
  deleteImage(id) {
    return this.images.delete(id);
  }
  getStats() {
    return {
      totalImages: this.images.size,
      totalSizeKB: Array.from(this.images.values()).reduce((sum4, img) => sum4 + img.buffer.length, 0) / 1024
    };
  }
  stopCleanup() {
    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval);
      this.cleanupInterval = null;
    }
  }
};
var tempImageStorage = new TempImageStorage();

// server/routes/ai-look.routes.ts
import multer from "multer";
var router = Router();
var aiAnalysisLimiter = rateLimit({
  windowMs: 15 * 60 * 1e3,
  // 15 minutes
  max: 10,
  // Limit each user to 10 requests per window
  message: "Too many AI analysis requests. Please try again in 15 minutes.",
  standardHeaders: true,
  legacyHeaders: false,
  keyGenerator: (req) => {
    return req.user?.id || "anonymous";
  }
});
var MAX_IMAGE_SIZE_MB = 10;
var MAX_IMAGE_SIZE_BYTES = MAX_IMAGE_SIZE_MB * 1024 * 1024;
var analyzeImageSchema = z2.object({
  imageBase64: z2.string().min(100).max(MAX_IMAGE_SIZE_BYTES, `Image too large. Maximum size is ${MAX_IMAGE_SIZE_MB}MB`),
  customerName: z2.string().min(1).max(200),
  gender: z2.enum(["male", "female", "prefer_not"]).optional(),
  eventType: z2.string().optional(),
  weather: z2.string().optional(),
  location: z2.string().optional(),
  skinTone: z2.string().optional(),
  hairType: z2.string().optional(),
  salonId: z2.string().uuid(),
  preferredBrands: z2.array(z2.string()).optional()
});
var saveSessionSchema = z2.object({
  salonId: z2.string().uuid(),
  customerName: z2.string().min(1),
  gender: z2.enum(["male", "female", "prefer_not"]).optional(),
  customerPhotoUrl: z2.string().optional(),
  eventType: z2.string().optional(),
  weather: z2.string().optional(),
  location: z2.string().optional(),
  skinTone: z2.string().optional(),
  hairType: z2.string().optional(),
  selectedLookIndex: z2.number().int().min(0),
  looks: z2.array(z2.object({
    lookName: z2.string(),
    description: z2.string(),
    confidenceScore: z2.number(),
    presetIds: z2.array(z2.string()),
    products: z2.array(z2.object({
      productId: z2.string(),
      applicationArea: z2.string().optional(),
      quantityNeeded: z2.string().optional(),
      isInStock: z2.boolean(),
      substituteProductId: z2.string().optional()
    }))
  }))
});
var markProductsUsedSchema = z2.object({
  sessionId: z2.string().uuid(),
  products: z2.array(z2.object({
    productId: z2.string().uuid(),
    quantity: z2.number().int().min(1).default(1)
  }))
});
router.post("/analyze", aiAnalysisLimiter, async (req, res) => {
  try {
    const validatedData = analyzeImageSchema.parse(req.body);
    if (!req.user) {
      return res.status(401).json({ message: "Authentication required" });
    }
    const salon = await storage.getSalonById(validatedData.salonId);
    if (!salon) {
      return res.status(404).json({ message: "Salon not found" });
    }
    const allowedRoles = ["owner", "manager", "staff"];
    const hasAccess = req.user.orgMemberships?.some(
      (membership) => membership.orgId === salon.orgId && allowedRoles.includes(membership.orgRole)
    );
    if (!hasAccess) {
      return res.status(403).json({ message: "Access denied: You do not have permission to use AI Look for this salon" });
    }
    const analysisInput = {
      imageBase64: validatedData.imageBase64,
      customerName: validatedData.customerName,
      salonId: validatedData.salonId,
      gender: validatedData.gender || "prefer_not",
      eventType: validatedData.eventType,
      weather: validatedData.weather,
      location: validatedData.location,
      skinTone: validatedData.skinTone,
      hairType: validatedData.hairType,
      preferredBrands: validatedData.preferredBrands
    };
    console.log(`[AI Look] Starting analysis for ${validatedData.customerName} at salon ${salon.name}`);
    const aiResponse = await analyzeBeautyImageWithFallback(analysisInput);
    console.log(`[AI Look] AI provider (${aiResponse.provider}) returned ${aiResponse.looks.length} looks`);
    const matchedLooks = [];
    for (const look of aiResponse.looks) {
      console.log(`[AI Look] Processing look: "${look.lookName}" with presetCategories:`, look.presetCategories);
      const presetIds = await resolvePresetsToEffects(look.presetCategories);
      console.log(`[AI Look] Resolved presetIds for "${look.lookName}":`, presetIds);
      const matchedProductsWithContext = await matchProductsForLook(
        validatedData.salonId,
        look.products,
        validatedData.gender || "prefer_not"
      );
      const productsWithDetails = matchedProductsWithContext.map(({ product, recommendation }) => ({
        product,
        applicationArea: recommendation.category || "",
        reason: recommendation.reason || "",
        quantityNeeded: "1 unit"
      }));
      matchedLooks.push({
        lookName: look.lookName,
        description: look.description,
        confidenceScore: look.confidenceScore,
        presetIds,
        products: productsWithDetails
      });
    }
    return res.json({
      success: true,
      customerAnalysis: aiResponse.customerAnalysis,
      looks: matchedLooks,
      provider: aiResponse.provider
    });
  } catch (error) {
    console.error("[AI Look] Analysis error:", error);
    if (error.name === "ZodError") {
      return res.status(400).json({
        message: "Invalid request data",
        errors: error.errors
      });
    }
    return res.status(500).json({
      message: "AI analysis failed",
      error: error.message
    });
  }
});
router.post("/save-session", async (req, res) => {
  try {
    const validatedData = saveSessionSchema.parse(req.body);
    if (!req.user) {
      return res.status(401).json({ message: "Authentication required" });
    }
    const salon = await storage.getSalonById(validatedData.salonId);
    if (!salon) {
      return res.status(404).json({ message: "Salon not found" });
    }
    const allowedRoles = ["owner", "manager", "staff"];
    const hasAccess = req.user.orgMemberships?.some(
      (membership) => membership.orgId === salon.orgId && allowedRoles.includes(membership.orgRole)
    );
    if (!hasAccess) {
      return res.status(403).json({ message: "Access denied: You do not have permission to save sessions for this salon" });
    }
    const allProductIds = validatedData.looks.flatMap(
      (look) => look.products.map((p) => p.productId)
    );
    if (allProductIds.length > 0) {
      const existingProducts = await db.select({ id: beautyProducts.id }).from(beautyProducts).where(
        sql6`${beautyProducts.id} = ANY(${allProductIds}::text[])`
      );
      const existingProductIds = new Set(existingProducts.map((p) => p.id));
      const invalidProductIds = allProductIds.filter((id) => !existingProductIds.has(id));
      if (invalidProductIds.length > 0) {
        return res.status(400).json({
          message: "Invalid product IDs detected",
          invalidIds: invalidProductIds.slice(0, 5)
          // Show first 5 for debugging
        });
      }
    }
    const result = await db.transaction(async (tx) => {
      const sessionResult = await tx.insert(aiLookSessions).values({
        salonId: validatedData.salonId,
        customerName: validatedData.customerName,
        gender: validatedData.gender || "prefer_not",
        customerPhotoUrl: validatedData.customerPhotoUrl,
        eventType: validatedData.eventType,
        weather: validatedData.weather,
        location: validatedData.location,
        skinTone: validatedData.skinTone,
        hairType: validatedData.hairType,
        staffUserId: req.user?.id
      }).returning();
      const session2 = sessionResult[0];
      for (let i = 0; i < validatedData.looks.length; i++) {
        const look = validatedData.looks[i];
        const isSelected = i === validatedData.selectedLookIndex;
        const lookOptionResult = await tx.insert(aiLookOptions).values({
          sessionId: session2.id,
          lookName: look.lookName,
          description: look.description,
          presetIds: JSON.stringify(look.presetIds),
          aiConfidenceScore: look.confidenceScore.toString(),
          isSelected: isSelected ? 1 : 0
        }).returning();
        const lookOption = lookOptionResult[0];
        for (const product of look.products) {
          await tx.insert(aiLookProducts).values({
            lookOptionId: lookOption.id,
            productId: product.productId,
            applicationArea: product.applicationArea,
            quantityNeeded: product.quantityNeeded,
            isInStock: product.isInStock ? 1 : 0,
            substituteProductId: product.substituteProductId
          });
        }
        if (isSelected) {
          const productDetails = await tx.select({
            productId: aiLookProducts.productId,
            productName: beautyProducts.name,
            brand: beautyProducts.brand,
            category: aiLookProducts.applicationArea
          }).from(aiLookProducts).innerJoin(beautyProducts, eq6(beautyProducts.id, aiLookProducts.productId)).where(eq6(aiLookProducts.lookOptionId, lookOption.id));
          const instructions = await generateApplicationInstructions(
            look.description,
            productDetails.map((p) => ({
              category: p.category || "",
              productName: p.productName,
              brand: p.brand,
              attributes: {}
            }))
          );
          await tx.update(aiLookOptions).set({ description: `${look.description}

**Application Instructions:**
${instructions}` }).where(eq6(aiLookOptions.id, lookOption.id));
        }
      }
      return { sessionId: session2.id };
    });
    return res.json({
      success: true,
      sessionId: result.sessionId,
      message: "Session saved successfully"
    });
  } catch (error) {
    console.error("[AI Look] Save session error:", error);
    if (error.name === "ZodError") {
      return res.status(400).json({
        message: "Invalid request data",
        errors: error.errors
      });
    }
    return res.status(500).json({
      message: "Failed to save session",
      error: error.message
    });
  }
});
router.get("/sessions/:salonId", async (req, res) => {
  try {
    const { salonId } = req.params;
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 20;
    const offset = (page - 1) * limit;
    const sessions2 = await db.select().from(aiLookSessions).where(eq6(aiLookSessions.salonId, salonId)).orderBy(desc2(aiLookSessions.createdAt)).limit(limit).offset(offset);
    const sessionsWithLooks = await Promise.all(
      sessions2.map(async (session2) => {
        const looks = await db.select().from(aiLookOptions).where(eq6(aiLookOptions.sessionId, session2.id));
        const selectedLook = looks.find((l) => l.isSelected === 1);
        return {
          ...session2,
          selectedLookName: selectedLook?.lookName || null,
          totalLooks: looks.length
        };
      })
    );
    return res.json({
      success: true,
      sessions: sessionsWithLooks,
      pagination: {
        page,
        limit,
        hasMore: sessions2.length === limit
      }
    });
  } catch (error) {
    console.error("[AI Look] Get sessions error:", error);
    return res.status(500).json({
      message: "Failed to retrieve sessions",
      error: error.message
    });
  }
});
router.get("/session/:sessionId", async (req, res) => {
  try {
    const { sessionId } = req.params;
    const sessionData = await db.select().from(aiLookSessions).where(eq6(aiLookSessions.id, sessionId)).limit(1);
    if (sessionData.length === 0) {
      return res.status(404).json({ message: "Session not found" });
    }
    const session2 = sessionData[0];
    const looks = await db.select().from(aiLookOptions).where(eq6(aiLookOptions.sessionId, sessionId));
    const looksWithProducts = await Promise.all(
      looks.map(async (look) => {
        const products2 = await db.select({
          id: aiLookProducts.id,
          applicationArea: aiLookProducts.applicationArea,
          applicationInstructions: aiLookProducts.applicationInstructions,
          quantityNeeded: aiLookProducts.quantityNeeded,
          isInStock: aiLookProducts.isInStock,
          product: beautyProducts
        }).from(aiLookProducts).innerJoin(beautyProducts, eq6(beautyProducts.id, aiLookProducts.productId)).where(eq6(aiLookProducts.lookOptionId, look.id));
        return {
          ...look,
          presetIds: look.presetIds ? JSON.parse(look.presetIds) : [],
          products: products2
        };
      })
    );
    return res.json({
      success: true,
      session: {
        ...session2,
        looks: looksWithProducts
      }
    });
  } catch (error) {
    console.error("[AI Look] Get session detail error:", error);
    return res.status(500).json({
      message: "Failed to retrieve session details",
      error: error.message
    });
  }
});
router.post("/mark-products-used", async (req, res) => {
  try {
    const validatedData = markProductsUsedSchema.parse(req.body);
    const session2 = await db.select().from(aiLookSessions).where(eq6(aiLookSessions.id, validatedData.sessionId)).limit(1);
    if (session2.length === 0) {
      return res.status(404).json({ message: "Session not found" });
    }
    const salonId = session2[0].salonId;
    for (const item of validatedData.products) {
      try {
        await decrementInventory(salonId, item.productId, item.quantity);
      } catch (error) {
        console.warn(`Could not decrement inventory for product ${item.productId}:`, error.message);
      }
    }
    return res.json({
      success: true,
      message: "Inventory updated successfully"
    });
  } catch (error) {
    console.error("[AI Look] Mark products used error:", error);
    if (error.name === "ZodError") {
      return res.status(400).json({
        message: "Invalid request data",
        errors: error.errors
      });
    }
    return res.status(500).json({
      message: "Failed to update inventory",
      error: error.message
    });
  }
});
router.get("/inventory/:salonId", async (req, res) => {
  try {
    const { salonId } = req.params;
    const products2 = await getProductsBySalon(salonId);
    return res.json({
      success: true,
      products: products2
    });
  } catch (error) {
    console.error("[AI Look] Get inventory error:", error);
    return res.status(500).json({
      message: "Failed to retrieve inventory",
      error: error.message
    });
  }
});
var upload = multer({
  storage: multer.memoryStorage(),
  limits: {
    fileSize: 10 * 1024 * 1024
    // 10MB limit
  },
  fileFilter: (req, file, cb) => {
    const allowedMimes = ["image/jpeg", "image/png", "image/webp"];
    if (allowedMimes.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error("Invalid file type. Only JPEG, PNG, and WebP are allowed."));
    }
  }
});
router.post("/uploads", aiAnalysisLimiter, upload.single("image"), async (req, res) => {
  try {
    if (!req.user) {
      return res.status(401).json({ message: "Authentication required to upload images." });
    }
    if (!req.file) {
      return res.status(400).json({ message: "No image file provided" });
    }
    const protocol = req.get("x-forwarded-proto") || (req.secure ? "https" : "http");
    const host = req.get("host");
    const baseUrl = `${protocol}://${host}`;
    const { publicUrl, imageId, expiresAt } = tempImageStorage.uploadImage(
      req.file.buffer,
      req.file.mimetype,
      baseUrl
    );
    console.log("[Upload] Image uploaded successfully:", imageId, "by user:", req.user.id, "public URL:", publicUrl);
    return res.status(201).json({
      success: true,
      publicUrl,
      imageId,
      expiresAt
    });
  } catch (error) {
    console.error("[Upload] Error:", error);
    return res.status(500).json({
      message: "Image upload failed",
      error: error.message
    });
  }
});
var delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
async function runLightXJob(apiUrl, apiKey, payload, jobType) {
  const POLL_INTERVAL_MS = 5e3;
  const MAX_RETRIES = 12;
  const REQUEST_TIMEOUT_MS = 15e3;
  try {
    console.log(`[${jobType}] Submitting job with prompt:`, payload.textPrompt);
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), REQUEST_TIMEOUT_MS);
    const submitResponse = await fetch(apiUrl, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "x-api-key": apiKey
      },
      body: JSON.stringify(payload),
      signal: controller.signal
    });
    clearTimeout(timeoutId);
    if (!submitResponse.ok) {
      const errorText = await submitResponse.text();
      console.error(`[${jobType}] LightX API submission error:`, submitResponse.status, errorText);
      return {
        success: false,
        message: `${jobType} transformation failed: ${errorText}`,
        statusCode: submitResponse.status
      };
    }
    const submitResult = await submitResponse.json();
    console.log(`[${jobType}] Raw API response:`, JSON.stringify(submitResult));
    const immediateOutputUrl = submitResult.body?.output_url || submitResult.output_url;
    if (immediateOutputUrl) {
      console.log(`[${jobType}] Job completed synchronously, output_url:`, immediateOutputUrl);
      return {
        success: true,
        output_url: immediateOutputUrl,
        orderId: submitResult.body?.orderId || submitResult.orderId || "sync-response"
      };
    }
    const orderId = submitResult.body?.orderId || submitResult.orderId;
    if (!orderId) {
      console.error(`[${jobType}] No orderId in response:`, JSON.stringify(submitResult));
      return {
        success: false,
        message: `${jobType} transformation failed: No order ID received`,
        statusCode: 502
      };
    }
    console.log(`[${jobType}] Job submitted async, orderId: ${orderId}, polling for completion...`);
    const statusUrl = apiUrl.includes("/v2/") ? `https://api.lightxeditor.com/external/api/v2/orders/${orderId}` : `https://api.lightxeditor.com/external/api/v1/orders/${orderId}`;
    for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
      await delay(POLL_INTERVAL_MS);
      console.log(`[${jobType}] Polling attempt ${attempt}/${MAX_RETRIES} for orderId: ${orderId}`);
      const statusController = new AbortController();
      const statusTimeoutId = setTimeout(() => statusController.abort(), REQUEST_TIMEOUT_MS);
      try {
        const statusResponse = await fetch(statusUrl, {
          method: "GET",
          headers: {
            "x-api-key": apiKey
          },
          signal: statusController.signal
        });
        clearTimeout(statusTimeoutId);
        if (!statusResponse.ok) {
          console.error(`[${jobType}] Status check failed:`, statusResponse.status);
          continue;
        }
        const statusResult = await statusResponse.json();
        const status = statusResult.body?.status || statusResult.status;
        const outputUrl = statusResult.body?.output_url || statusResult.output_url;
        console.log(`[${jobType}] Status check result:`, { status, hasOutputUrl: !!outputUrl });
        if (status === "completed" && outputUrl) {
          console.log(`[${jobType}] Job completed successfully after ${attempt} attempts`);
          return {
            success: true,
            output_url: outputUrl,
            orderId
          };
        }
        if (status === "failed") {
          console.error(`[${jobType}] Job failed, orderId: ${orderId}`);
          return {
            success: false,
            message: `${jobType} transformation failed: Processing error`,
            orderId,
            statusCode: 502
          };
        }
        console.log(`[${jobType}] Job still processing (status: ${status}), will retry...`);
      } catch (pollError) {
        clearTimeout(statusTimeoutId);
        console.error(`[${jobType}] Polling error on attempt ${attempt}:`, pollError.message);
      }
    }
    console.error(`[${jobType}] Timeout: Job did not complete within ${MAX_RETRIES * POLL_INTERVAL_MS / 1e3}s`);
    return {
      success: false,
      message: `${jobType} transformation timed out. Please try again with a different image or simpler prompt.`,
      orderId,
      statusCode: 504
    };
  } catch (error) {
    console.error(`[${jobType}] Unexpected error:`, error);
    if (error.name === "AbortError") {
      return {
        success: false,
        message: `${jobType} transformation request timed out`,
        statusCode: 504
      };
    }
    return {
      success: false,
      message: `${jobType} transformation failed: ${error.message}`,
      statusCode: 500
    };
  }
}
var hairColorSchema = z2.object({
  imageUrl: z2.string().url(),
  textPrompt: z2.string().min(1).max(200)
});
var hairstyleSchema = z2.object({
  imageUrl: z2.string().url(),
  textPrompt: z2.string().min(1).max(200)
});
router.post("/hair-color", aiAnalysisLimiter, async (req, res) => {
  try {
    const validatedData = hairColorSchema.parse(req.body);
    if (!req.user) {
      return res.status(401).json({ message: "Authentication required. Please login to use hair transformations." });
    }
    const apiKey = process.env.LIGHTX_API_KEY;
    if (!apiKey) {
      return res.status(500).json({ message: "LightX API key not configured" });
    }
    const result = await runLightXJob(
      "https://api.lightxeditor.com/external/api/v2/haircolor/",
      apiKey,
      {
        imageUrl: validatedData.imageUrl,
        textPrompt: validatedData.textPrompt
      },
      "Hair Color"
    );
    if (!result.success) {
      return res.status(result.statusCode).json({
        message: result.message,
        orderId: result.orderId
      });
    }
    return res.json({
      success: true,
      output_url: result.output_url,
      orderId: result.orderId
    });
  } catch (error) {
    console.error("[Hair Color] Error:", error);
    if (error.name === "ZodError") {
      return res.status(400).json({
        message: "Invalid request data",
        errors: error.errors
      });
    }
    return res.status(500).json({
      message: "Hair color transformation failed",
      error: error.message
    });
  }
});
router.post("/hairstyle", aiAnalysisLimiter, async (req, res) => {
  try {
    const validatedData = hairstyleSchema.parse(req.body);
    if (!req.user) {
      return res.status(401).json({ message: "Authentication required. Please login to use hairstyle transformations." });
    }
    const apiKey = process.env.LIGHTX_API_KEY;
    if (!apiKey) {
      return res.status(500).json({ message: "LightX API key not configured" });
    }
    const result = await runLightXJob(
      "https://api.lightxeditor.com/external/api/v1/hairstyle/",
      apiKey,
      {
        imageUrl: validatedData.imageUrl,
        textPrompt: validatedData.textPrompt
      },
      "Hairstyle"
    );
    if (!result.success) {
      return res.status(result.statusCode).json({
        message: result.message,
        orderId: result.orderId
      });
    }
    return res.json({
      success: true,
      output_url: result.output_url,
      orderId: result.orderId
    });
  } catch (error) {
    console.error("[Hairstyle] Error:", error);
    if (error.name === "ZodError") {
      return res.status(400).json({
        message: "Invalid request data",
        errors: error.errors
      });
    }
    return res.status(500).json({
      message: "Hairstyle transformation failed",
      error: error.message
    });
  }
});
var ai_look_routes_default = router;

// server/routes/events.routes.ts
init_db();
init_schema();
import { Router as Router2 } from "express";
import { eq as eq8, and as and8, desc as desc3, asc as asc2, sql as sql7, gte as gte2, lte as lte2, like as like2, inArray as inArray4, count, or as or3 } from "drizzle-orm";
import crypto3 from "crypto";
import Razorpay from "razorpay";
function requireAuthenticatedUser(req, res, next) {
  if (!req.user?.id) {
    return res.status(401).json({ message: "Authentication required" });
  }
  next();
}
var router2 = Router2();
var razorpay = new Razorpay({
  key_id: process.env.RAZORPAY_KEY_ID || "",
  key_secret: process.env.RAZORPAY_KEY_SECRET || ""
});
async function verifyEventOwnership(userId, eventId) {
  const event = await db.select({ salonId: events.salonId }).from(events).where(eq8(events.id, eventId)).limit(1);
  if (!event.length) return false;
  const salon = await db.select({ id: salons.id }).from(salons).where(and8(eq8(salons.id, event[0].salonId), eq8(salons.ownerId, userId))).limit(1);
  return salon.length > 0;
}
function signQRCode(registrationId, eventId, attendeeEmail) {
  const data = JSON.stringify({
    registrationId,
    eventId,
    attendeeEmail,
    issuedAt: Date.now(),
    nonce: crypto3.randomBytes(8).toString("hex")
  });
  const signature = crypto3.createHmac("sha256", process.env.QR_SIGNING_SECRET || "default-qr-secret-CHANGE-IN-PRODUCTION").update(data).digest("hex");
  return Buffer.from(`${data}.${signature}`).toString("base64");
}
function verifyQRCode(qrCode) {
  try {
    const decoded = Buffer.from(qrCode, "base64").toString("utf8");
    const [dataStr, providedSignature] = decoded.split(".");
    if (!dataStr || !providedSignature) {
      return { valid: false, error: "Invalid QR code format" };
    }
    const expectedSignature = crypto3.createHmac("sha256", process.env.QR_SIGNING_SECRET || "default-qr-secret-CHANGE-IN-PRODUCTION").update(dataStr).digest("hex");
    if (expectedSignature !== providedSignature) {
      return { valid: false, error: "QR code signature verification failed" };
    }
    const data = JSON.parse(dataStr);
    if (!data.registrationId || !data.eventId || !data.attendeeEmail || typeof data.issuedAt !== "number" || !data.nonce) {
      return { valid: false, error: "QR code payload is incomplete" };
    }
    const QR_EXPIRY_MS = 7 * 24 * 60 * 60 * 1e3;
    const age = Date.now() - data.issuedAt;
    if (age > QR_EXPIRY_MS) {
      return { valid: false, error: "QR code has expired" };
    }
    if (age < 0) {
      return { valid: false, error: "QR code timestamp is invalid" };
    }
    return { valid: true, data };
  } catch (error) {
    return { valid: false, error: "QR code parsing failed" };
  }
}
function generateBookingId() {
  const year = (/* @__PURE__ */ new Date()).getFullYear();
  const random = crypto3.randomBytes(4).toString("hex").toUpperCase();
  return `EVT-${year}-${random}`;
}
function generateQRCode() {
  return crypto3.randomBytes(16).toString("hex").toUpperCase();
}
function generateSlug(title) {
  return title.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/(^-|-$)/g, "") + "-" + crypto3.randomBytes(4).toString("hex");
}
router2.get("/types", async (req, res) => {
  try {
    const types = await db.select().from(eventTypes).where(eq8(eventTypes.isActive, 1)).orderBy(asc2(eventTypes.orderIndex));
    res.json(types);
  } catch (error) {
    console.error("Error fetching event types:", error);
    res.status(500).json({ message: "Failed to fetch event types" });
  }
});
router2.get("/public", async (req, res) => {
  try {
    const { city, type, search, sort = "date", page = "1", limit = "12" } = req.query;
    const pageNum = parseInt(page) || 1;
    const limitNum = Math.min(parseInt(limit) || 12, 50);
    const offset = (pageNum - 1) * limitNum;
    const whereConditions = [
      eq8(events.status, "published"),
      eq8(events.visibility, "public"),
      gte2(events.startDate, (/* @__PURE__ */ new Date()).toISOString().split("T")[0])
    ];
    if (city) {
      whereConditions.push(eq8(events.venueCity, city));
    }
    if (type) {
      whereConditions.push(eq8(events.eventTypeId, type));
    }
    if (search) {
      const searchTerm = `%${search}%`;
      whereConditions.push(
        or3(
          like2(events.title, searchTerm),
          like2(events.shortDescription, searchTerm),
          like2(events.description, searchTerm)
        )
      );
    }
    let orderByClause = asc2(events.startDate);
    if (sort === "popular") {
      orderByClause = desc3(events.currentRegistrations);
    }
    let query = db.select({
      id: events.id,
      title: events.title,
      slug: events.slug,
      shortDescription: events.shortDescription,
      startDate: events.startDate,
      endDate: events.endDate,
      startTime: events.startTime,
      endTime: events.endTime,
      venueCity: events.venueCity,
      venueName: events.venueName,
      maxCapacity: events.maxCapacity,
      currentRegistrations: events.currentRegistrations,
      coverImageUrl: events.coverImageUrl,
      isFeatured: events.isFeatured,
      eventTypeId: events.eventTypeId,
      salonId: events.salonId
    }).from(events).where(and8(...whereConditions)).orderBy(orderByClause).limit(limitNum).offset(offset);
    const eventList = await query;
    const eventIds = eventList.map((e) => e.id);
    let ticketPrices = [];
    if (eventIds.length > 0) {
      const ticketData = await db.select({
        eventId: eventTicketTypes.eventId,
        minPrice: sql7`MIN(${eventTicketTypes.basePricePaisa})`.as("min_price")
      }).from(eventTicketTypes).where(and8(
        inArray4(eventTicketTypes.eventId, eventIds),
        eq8(eventTicketTypes.isActive, 1)
      )).groupBy(eventTicketTypes.eventId);
      ticketPrices = ticketData;
    }
    const priceMap = new Map(ticketPrices.map((t) => [t.eventId, t.minPrice]));
    const eventsWithPrice = eventList.map((event) => ({
      ...event,
      startingPricePaisa: priceMap.get(event.id) || 0,
      spotsLeft: event.maxCapacity - (event.currentRegistrations || 0)
    }));
    const totalResult = await db.select({ count: count() }).from(events).where(and8(...whereConditions));
    const total = totalResult[0]?.count || 0;
    res.json({
      events: eventsWithPrice,
      pagination: {
        page: pageNum,
        limit: limitNum,
        total,
        totalPages: Math.ceil(total / limitNum)
      }
    });
  } catch (error) {
    console.error("Error fetching public events:", error);
    res.status(500).json({ message: "Failed to fetch events" });
  }
});
router2.get("/:idOrSlug/tickets", async (req, res) => {
  try {
    const { idOrSlug } = req.params;
    const event = await db.select().from(events).where(and8(
      sql7`(${events.id} = ${idOrSlug} OR ${events.slug} = ${idOrSlug})`,
      eq8(events.status, "published")
    )).limit(1);
    if (!event.length) {
      return res.status(404).json({ message: "Event not found" });
    }
    const eventId = event[0].id;
    const tickets = await db.select({
      id: eventTicketTypes.id,
      name: eventTicketTypes.name,
      description: eventTicketTypes.description,
      price: eventTicketTypes.basePricePaisa,
      quantity: eventTicketTypes.quantityAvailable,
      quantitySold: eventTicketTypes.quantitySold,
      discountPercentage: eventTicketTypes.discountPercentage,
      discountLabel: eventTicketTypes.discountLabel,
      includes: eventTicketTypes.includes
    }).from(eventTicketTypes).where(and8(
      eq8(eventTicketTypes.eventId, eventId),
      eq8(eventTicketTypes.isActive, 1)
    )).orderBy(asc2(eventTicketTypes.orderIndex));
    const ticketsWithAvailability = tickets.map((ticket) => ({
      ...ticket,
      price: ticket.price / 100,
      // Convert paisa to rupees for frontend
      quantityAvailable: ticket.quantity ? ticket.quantity - (ticket.quantitySold || 0) : 999999,
      maxPerUser: 10
      // Default limit per user
    }));
    res.json(ticketsWithAvailability);
  } catch (error) {
    console.error("Error fetching tickets:", error);
    res.status(500).json({ message: "Failed to fetch tickets" });
  }
});
router2.get("/public/:idOrSlug", async (req, res) => {
  try {
    const { idOrSlug } = req.params;
    const event = await db.select().from(events).where(and8(
      sql7`(${events.id} = ${idOrSlug} OR ${events.slug} = ${idOrSlug})`,
      eq8(events.status, "published")
    )).limit(1);
    if (!event.length) {
      return res.status(404).json({ message: "Event not found" });
    }
    const eventData = event[0];
    const [speakers, schedules, tickets, reviews, salon] = await Promise.all([
      db.select().from(eventSpeakers).where(eq8(eventSpeakers.eventId, eventData.id)).orderBy(asc2(eventSpeakers.orderIndex)),
      db.select().from(eventSchedules).where(eq8(eventSchedules.eventId, eventData.id)).orderBy(asc2(eventSchedules.orderIndex)),
      db.select().from(eventTicketTypes).where(and8(eq8(eventTicketTypes.eventId, eventData.id), eq8(eventTicketTypes.isActive, 1))).orderBy(asc2(eventTicketTypes.orderIndex)),
      db.select({
        id: eventReviews.id,
        overallRating: eventReviews.overallRating,
        reviewText: eventReviews.reviewText,
        createdAt: eventReviews.createdAt,
        userName: users.firstName
      }).from(eventReviews).leftJoin(users, eq8(eventReviews.userId, users.id)).where(and8(eq8(eventReviews.eventId, eventData.id), eq8(eventReviews.status, "approved"))).limit(10),
      db.select({ id: salons.id, name: salons.name, address: salons.address }).from(salons).where(eq8(salons.id, eventData.salonId)).limit(1)
    ]);
    const avgRating = reviews.length > 0 ? reviews.reduce((sum4, r) => sum4 + r.overallRating, 0) / reviews.length : 0;
    await db.insert(eventViews).values({
      eventId: eventData.id,
      sessionId: req.headers["x-session-id"] || null,
      source: req.query.source || "direct",
      platform: req.headers["x-platform"] || "web",
      referrer: req.headers.referer || null,
      deviceType: req.headers["x-device-type"] || "desktop"
    });
    res.json({
      ...eventData,
      speakers,
      schedules,
      tickets,
      reviews,
      averageRating: Math.round(avgRating * 10) / 10,
      reviewCount: reviews.length,
      salon: salon[0] || null,
      spotsLeft: eventData.maxCapacity - (eventData.currentRegistrations || 0)
    });
  } catch (error) {
    console.error("Error fetching event details:", error);
    res.status(500).json({ message: "Failed to fetch event details" });
  }
});
router2.get("/business/dashboard", populateUserFromSession, requireAuthenticatedUser, async (req, res) => {
  try {
    const userId = req.user?.id;
    if (!userId) return res.status(401).json({ message: "Unauthorized" });
    const userSalons = await db.select({ id: salons.id }).from(salons).where(eq8(salons.ownerId, userId));
    const salonIds = userSalons.map((s) => s.id);
    if (salonIds.length === 0) {
      return res.json({
        activeEvents: 0,
        totalRegistrations: 0,
        totalRevenue: 0,
        averageRating: 0,
        upcomingEvents: [],
        draftCount: 0
      });
    }
    const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
    const [activeEventsResult, registrationsResult, revenueResult, ratingsResult, upcomingEvents, draftCountResult] = await Promise.all([
      db.select({ count: count() }).from(events).where(and8(
        inArray4(events.salonId, salonIds),
        eq8(events.status, "published"),
        gte2(events.startDate, today)
      )),
      db.select({ total: sql7`COALESCE(SUM(1), 0)` }).from(eventRegistrations).innerJoin(events, eq8(eventRegistrations.eventId, events.id)).where(and8(
        inArray4(events.salonId, salonIds),
        eq8(eventRegistrations.status, "confirmed")
      )),
      db.select({ total: sql7`COALESCE(SUM(${eventRegistrations.totalAmountPaisa}), 0)` }).from(eventRegistrations).innerJoin(events, eq8(eventRegistrations.eventId, events.id)).where(and8(
        inArray4(events.salonId, salonIds),
        eq8(eventRegistrations.paymentStatus, "paid")
      )),
      db.select({ avg: sql7`COALESCE(AVG(${eventReviews.overallRating}), 0)` }).from(eventReviews).innerJoin(events, eq8(eventReviews.eventId, events.id)).where(inArray4(events.salonId, salonIds)),
      db.select({
        id: events.id,
        title: events.title,
        startDate: events.startDate,
        startTime: events.startTime,
        maxCapacity: events.maxCapacity,
        currentRegistrations: events.currentRegistrations,
        coverImageUrl: events.coverImageUrl
      }).from(events).where(and8(
        inArray4(events.salonId, salonIds),
        eq8(events.status, "published"),
        gte2(events.startDate, today)
      )).orderBy(asc2(events.startDate)).limit(5),
      db.select({ count: count() }).from(events).where(and8(
        inArray4(events.salonId, salonIds),
        eq8(events.status, "draft")
      ))
    ]);
    res.json({
      activeEvents: activeEventsResult[0]?.count || 0,
      totalRegistrations: registrationsResult[0]?.total || 0,
      totalRevenue: revenueResult[0]?.total || 0,
      averageRating: Math.round((ratingsResult[0]?.avg || 0) * 10) / 10,
      upcomingEvents: upcomingEvents.map((e) => ({
        ...e,
        spotsLeft: e.maxCapacity - (e.currentRegistrations || 0)
      })),
      draftCount: draftCountResult[0]?.count || 0
    });
  } catch (error) {
    console.error("Error fetching dashboard:", error);
    res.status(500).json({ message: "Failed to fetch dashboard data" });
  }
});
router2.get("/business/list", populateUserFromSession, requireAuthenticatedUser, async (req, res) => {
  try {
    const userId = req.user?.id;
    if (!userId) return res.status(401).json({ message: "Unauthorized" });
    const { status, salonId, page = "1", limit = "20" } = req.query;
    const pageNum = parseInt(page) || 1;
    const limitNum = Math.min(parseInt(limit) || 20, 100);
    const offset = (pageNum - 1) * limitNum;
    let salonIds = [];
    if (salonId) {
      salonIds = [salonId];
    } else {
      const userSalons = await db.select({ id: salons.id }).from(salons).where(eq8(salons.ownerId, userId));
      salonIds = userSalons.map((s) => s.id);
    }
    if (salonIds.length === 0) {
      return res.json({ events: [], pagination: { page: pageNum, limit: limitNum, total: 0, totalPages: 0 } });
    }
    let whereConditions = [inArray4(events.salonId, salonIds)];
    if (status) {
      whereConditions.push(eq8(events.status, status));
    }
    const eventList = await db.select().from(events).where(and8(...whereConditions)).orderBy(desc3(events.createdAt)).limit(limitNum).offset(offset);
    const totalResult = await db.select({ count: count() }).from(events).where(and8(...whereConditions));
    const total = totalResult[0]?.count || 0;
    res.json({
      events: eventList,
      pagination: {
        page: pageNum,
        limit: limitNum,
        total,
        totalPages: Math.ceil(total / limitNum)
      }
    });
  } catch (error) {
    console.error("Error fetching business events:", error);
    res.status(500).json({ message: "Failed to fetch events" });
  }
});
router2.get("/business/drafts", populateUserFromSession, requireAuthenticatedUser, async (req, res) => {
  try {
    const userId = req.user?.id;
    if (!userId) return res.status(401).json({ message: "Unauthorized" });
    const userSalons = await db.select({ id: salons.id }).from(salons).where(eq8(salons.ownerId, userId));
    const salonIds = userSalons.map((s) => s.id);
    if (salonIds.length === 0) {
      return res.json({ drafts: [], stats: { total: 0, ready: 0, needsAttention: 0 } });
    }
    const drafts = await db.select().from(events).where(and8(inArray4(events.salonId, salonIds), eq8(events.status, "draft"))).orderBy(desc3(events.updatedAt));
    const draftsWithStatus = drafts.map((draft) => {
      const missingFields = [];
      if (!draft.description) missingFields.push("description");
      if (!draft.coverImageUrl) missingFields.push("cover_image");
      return {
        ...draft,
        completionStatus: missingFields.length === 0 ? "ready" : "incomplete",
        missingFields
      };
    });
    const ready = draftsWithStatus.filter((d) => d.completionStatus === "ready").length;
    const needsAttention = draftsWithStatus.filter((d) => d.completionStatus === "incomplete").length;
    res.json({
      drafts: draftsWithStatus,
      stats: {
        total: drafts.length,
        ready,
        needsAttention
      }
    });
  } catch (error) {
    console.error("Error fetching drafts:", error);
    res.status(500).json({ message: "Failed to fetch drafts" });
  }
});
router2.get("/business/past", populateUserFromSession, requireAuthenticatedUser, async (req, res) => {
  try {
    const userId = req.user?.id;
    if (!userId) return res.status(401).json({ message: "Unauthorized" });
    const userSalons = await db.select({ id: salons.id }).from(salons).where(eq8(salons.ownerId, userId));
    const salonIds = userSalons.map((s) => s.id);
    if (salonIds.length === 0) {
      return res.json({ events: [], stats: { totalEvents: 0, totalRegistrations: 0, totalRevenue: 0 } });
    }
    const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
    const [pastEvents, statsResult] = await Promise.all([
      db.select().from(events).where(and8(
        inArray4(events.salonId, salonIds),
        lte2(events.endDate, today)
      )).orderBy(desc3(events.startDate)).limit(50),
      db.select({
        count: count(),
        registrations: sql7`COALESCE(SUM(${events.currentRegistrations}), 0)`
      }).from(events).where(and8(inArray4(events.salonId, salonIds), lte2(events.endDate, today)))
    ]);
    res.json({
      events: pastEvents,
      stats: {
        totalEvents: statsResult[0]?.count || 0,
        totalRegistrations: statsResult[0]?.registrations || 0
      }
    });
  } catch (error) {
    console.error("Error fetching past events:", error);
    res.status(500).json({ message: "Failed to fetch past events" });
  }
});
router2.get("/business/:eventId", populateUserFromSession, requireAuthenticatedUser, async (req, res) => {
  try {
    const userId = req.user?.id;
    if (!userId) return res.status(401).json({ message: "Unauthorized" });
    const { eventId } = req.params;
    if (!await verifyEventOwnership(userId, eventId)) {
      return res.status(403).json({ message: "Access denied" });
    }
    const event = await db.select().from(events).where(eq8(events.id, eventId)).limit(1);
    if (!event.length) {
      return res.status(404).json({ message: "Event not found" });
    }
    const eventData = event[0];
    const [speakers, schedules, tickets, groupDiscounts, registrations, reviews] = await Promise.all([
      db.select().from(eventSpeakers).where(eq8(eventSpeakers.eventId, eventId)).orderBy(asc2(eventSpeakers.orderIndex)),
      db.select().from(eventSchedules).where(eq8(eventSchedules.eventId, eventId)).orderBy(asc2(eventSchedules.orderIndex)),
      db.select().from(eventTicketTypes).where(eq8(eventTicketTypes.eventId, eventId)).orderBy(asc2(eventTicketTypes.orderIndex)),
      db.select().from(eventGroupDiscounts).where(eq8(eventGroupDiscounts.eventId, eventId)),
      db.select().from(eventRegistrations).where(eq8(eventRegistrations.eventId, eventId)).orderBy(desc3(eventRegistrations.createdAt)).limit(100),
      db.select().from(eventReviews).where(eq8(eventReviews.eventId, eventId)).orderBy(desc3(eventReviews.createdAt)).limit(50)
    ]);
    const confirmedRegistrations = registrations.filter((r) => r.status === "confirmed");
    const totalRevenue = confirmedRegistrations.reduce((sum4, r) => sum4 + r.totalAmountPaisa, 0);
    const checkedInCount = confirmedRegistrations.filter((r) => r.checkedInAt).length;
    res.json({
      event: eventData,
      speakers,
      schedules,
      tickets,
      groupDiscounts,
      registrations,
      reviews,
      metrics: {
        totalRegistrations: confirmedRegistrations.length,
        totalRevenue,
        checkedInCount,
        averageRating: reviews.length > 0 ? Math.round(reviews.reduce((sum4, r) => sum4 + r.overallRating, 0) / reviews.length * 10) / 10 : 0
      }
    });
  } catch (error) {
    console.error("Error fetching event details:", error);
    res.status(500).json({ message: "Failed to fetch event details" });
  }
});
router2.post("/", populateUserFromSession, requireAuthenticatedUser, async (req, res) => {
  try {
    const userId = req.user?.id;
    if (!userId) return res.status(401).json({ message: "Unauthorized" });
    const validated = createEventSchema.parse(req.body);
    const salonCheck = await db.select({ id: salons.id, orgId: salons.orgId }).from(salons).where(and8(eq8(salons.id, validated.salonId), eq8(salons.ownerId, userId)));
    if (!salonCheck.length) {
      return res.status(403).json({ message: "Access denied to this salon" });
    }
    const slug = generateSlug(validated.title);
    const [newEvent] = await db.insert(events).values({
      salonId: validated.salonId,
      createdBy: userId,
      organizationId: salonCheck[0].orgId || null,
      title: validated.title,
      description: validated.description,
      shortDescription: validated.shortDescription,
      eventTypeId: validated.eventTypeId,
      startDate: validated.startDate,
      endDate: validated.endDate,
      startTime: validated.startTime,
      endTime: validated.endTime,
      venueType: validated.venueType,
      venueName: validated.venueName,
      venueAddress: validated.venueAddress,
      venueCity: validated.venueCity,
      venueState: validated.venueState,
      venuePincode: validated.venuePincode,
      venueLatitude: validated.venueLatitude?.toString(),
      venueLongitude: validated.venueLongitude?.toString(),
      maxCapacity: validated.maxCapacity,
      minCapacity: validated.minCapacity,
      visibility: validated.visibility,
      coverImageUrl: validated.coverImageUrl,
      cancellationPolicy: validated.cancellationPolicy,
      slug,
      status: "draft"
    }).returning();
    res.status(201).json(newEvent);
  } catch (error) {
    console.error("Error creating event:", error);
    if (error.name === "ZodError") {
      return res.status(400).json({ message: "Validation error", errors: error.errors });
    }
    res.status(500).json({ message: "Failed to create event" });
  }
});
router2.put("/:eventId", populateUserFromSession, requireAuthenticatedUser, async (req, res) => {
  try {
    const userId = req.user?.id;
    if (!userId) return res.status(401).json({ message: "Unauthorized" });
    const { eventId } = req.params;
    const validated = updateEventSchema.parse(req.body);
    const event = await db.select().from(events).where(eq8(events.id, eventId)).limit(1);
    if (!event.length) {
      return res.status(404).json({ message: "Event not found" });
    }
    const ownerCheck = await db.select({ id: salons.id }).from(salons).where(and8(eq8(salons.id, event[0].salonId), eq8(salons.ownerId, userId)));
    if (!ownerCheck.length) {
      return res.status(403).json({ message: "Access denied" });
    }
    const updateData = { updatedAt: /* @__PURE__ */ new Date() };
    if (validated.title) updateData.title = validated.title;
    if (validated.description) updateData.description = validated.description;
    if (validated.shortDescription) updateData.shortDescription = validated.shortDescription;
    if (validated.eventTypeId) updateData.eventTypeId = validated.eventTypeId;
    if (validated.startDate) updateData.startDate = validated.startDate;
    if (validated.endDate) updateData.endDate = validated.endDate;
    if (validated.startTime) updateData.startTime = validated.startTime;
    if (validated.endTime) updateData.endTime = validated.endTime;
    if (validated.venueType) updateData.venueType = validated.venueType;
    if (validated.venueName) updateData.venueName = validated.venueName;
    if (validated.venueAddress) updateData.venueAddress = validated.venueAddress;
    if (validated.venueCity) updateData.venueCity = validated.venueCity;
    if (validated.venueState) updateData.venueState = validated.venueState;
    if (validated.venuePincode) updateData.venuePincode = validated.venuePincode;
    if (validated.venueLatitude) updateData.venueLatitude = validated.venueLatitude.toString();
    if (validated.venueLongitude) updateData.venueLongitude = validated.venueLongitude.toString();
    if (validated.maxCapacity) updateData.maxCapacity = validated.maxCapacity;
    if (validated.minCapacity) updateData.minCapacity = validated.minCapacity;
    if (validated.visibility) updateData.visibility = validated.visibility;
    if (validated.coverImageUrl) updateData.coverImageUrl = validated.coverImageUrl;
    if (validated.galleryImages) updateData.galleryImages = validated.galleryImages;
    if (validated.cancellationPolicy) updateData.cancellationPolicy = validated.cancellationPolicy;
    const [updated] = await db.update(events).set(updateData).where(eq8(events.id, eventId)).returning();
    res.json(updated);
  } catch (error) {
    console.error("Error updating event:", error);
    if (error.name === "ZodError") {
      return res.status(400).json({ message: "Validation error", errors: error.errors });
    }
    res.status(500).json({ message: "Failed to update event" });
  }
});
router2.post("/:eventId/publish", populateUserFromSession, requireAuthenticatedUser, async (req, res) => {
  try {
    const userId = req.user?.id;
    if (!userId) return res.status(401).json({ message: "Unauthorized" });
    const { eventId } = req.params;
    const event = await db.select().from(events).where(eq8(events.id, eventId)).limit(1);
    if (!event.length) {
      return res.status(404).json({ message: "Event not found" });
    }
    const ownerCheck = await db.select({ id: salons.id }).from(salons).where(and8(eq8(salons.id, event[0].salonId), eq8(salons.ownerId, userId)));
    if (!ownerCheck.length) {
      return res.status(403).json({ message: "Access denied" });
    }
    const tickets = await db.select().from(eventTicketTypes).where(eq8(eventTicketTypes.eventId, eventId));
    if (tickets.length === 0) {
      return res.status(400).json({ message: "Cannot publish event without at least one ticket type" });
    }
    const [updated] = await db.update(events).set({ status: "published", publishedAt: /* @__PURE__ */ new Date(), updatedAt: /* @__PURE__ */ new Date() }).where(eq8(events.id, eventId)).returning();
    res.json(updated);
  } catch (error) {
    console.error("Error publishing event:", error);
    res.status(500).json({ message: "Failed to publish event" });
  }
});
router2.put("/business/:eventId/publish", populateUserFromSession, requireAuthenticatedUser, async (req, res) => {
  try {
    const userId = req.user?.id;
    if (!userId) return res.status(401).json({ message: "Unauthorized" });
    const { eventId } = req.params;
    if (!await verifyEventOwnership(userId, eventId)) {
      return res.status(403).json({ message: "Access denied" });
    }
    const tickets = await db.select().from(eventTicketTypes).where(eq8(eventTicketTypes.eventId, eventId));
    if (tickets.length === 0) {
      return res.status(400).json({ message: "Cannot publish event without at least one ticket type" });
    }
    const [updated] = await db.update(events).set({ status: "published", publishedAt: /* @__PURE__ */ new Date(), updatedAt: /* @__PURE__ */ new Date() }).where(eq8(events.id, eventId)).returning();
    res.json(updated);
  } catch (error) {
    console.error("Error publishing event:", error);
    res.status(500).json({ message: "Failed to publish event" });
  }
});
router2.delete("/:eventId", populateUserFromSession, requireAuthenticatedUser, async (req, res) => {
  try {
    const userId = req.user?.id;
    if (!userId) return res.status(401).json({ message: "Unauthorized" });
    const { eventId } = req.params;
    const event = await db.select().from(events).where(eq8(events.id, eventId)).limit(1);
    if (!event.length) {
      return res.status(404).json({ message: "Event not found" });
    }
    const ownerCheck = await db.select({ id: salons.id }).from(salons).where(and8(eq8(salons.id, event[0].salonId), eq8(salons.ownerId, userId)));
    if (!ownerCheck.length) {
      return res.status(403).json({ message: "Access denied" });
    }
    const registrations = await db.select({ id: eventRegistrations.id }).from(eventRegistrations).where(and8(eq8(eventRegistrations.eventId, eventId), eq8(eventRegistrations.status, "confirmed")));
    if (registrations.length > 0) {
      return res.status(400).json({ message: "Cannot delete event with confirmed registrations" });
    }
    await db.update(events).set({ status: "cancelled", updatedAt: /* @__PURE__ */ new Date() }).where(eq8(events.id, eventId));
    res.json({ message: "Event cancelled successfully" });
  } catch (error) {
    console.error("Error deleting event:", error);
    res.status(500).json({ message: "Failed to delete event" });
  }
});
router2.post("/:eventId/tickets", populateUserFromSession, requireAuthenticatedUser, async (req, res) => {
  try {
    const userId = req.user?.id;
    if (!userId) return res.status(401).json({ message: "Unauthorized" });
    const { eventId } = req.params;
    const validated = createTicketTypeSchema.parse({ ...req.body, eventId });
    const event = await db.select().from(events).where(eq8(events.id, eventId)).limit(1);
    if (!event.length) {
      return res.status(404).json({ message: "Event not found" });
    }
    const ownerCheck = await db.select({ id: salons.id }).from(salons).where(and8(eq8(salons.id, event[0].salonId), eq8(salons.ownerId, userId)));
    if (!ownerCheck.length) {
      return res.status(403).json({ message: "Access denied" });
    }
    const ticketData = {
      eventId: validated.eventId,
      name: validated.name,
      description: validated.description,
      basePricePaisa: validated.basePricePaisa,
      gstPercentage: validated.gstPercentage,
      discountPercentage: validated.discountPercentage,
      quantityAvailable: validated.quantityAvailable,
      saleStartDate: validated.saleStartDate,
      saleEndDate: validated.saleEndDate,
      includes: validated.includes || [],
      discountLabel: validated.discountLabel
    };
    const [newTicket] = await db.insert(eventTicketTypes).values(ticketData).returning();
    res.status(201).json(newTicket);
  } catch (error) {
    console.error("Error creating ticket type:", error);
    if (error.name === "ZodError") {
      return res.status(400).json({ message: "Validation error", errors: error.errors });
    }
    res.status(500).json({ message: "Failed to create ticket type" });
  }
});
router2.post("/:eventId/register", populateUserFromSession, async (req, res) => {
  try {
    const userId = req.user?.id;
    const { eventId } = req.params;
    const validated = eventRegistrationSchema.parse({ ...req.body, eventId });
    const event = await db.select().from(events).where(and8(
      eq8(events.id, eventId),
      eq8(events.status, "published")
    )).limit(1);
    if (!event.length) {
      return res.status(404).json({ message: "Event not found or not available for registration" });
    }
    const eventData = event[0];
    const registrationCounts = await db.select({
      count: sql7`CAST(COUNT(*) AS INTEGER)`
    }).from(eventRegistrations).where(and8(
      eq8(eventRegistrations.eventId, eventId),
      sql7`(${eventRegistrations.status} = 'confirmed' OR (${eventRegistrations.status} = 'pending' AND (${eventRegistrations.expiresAt} IS NULL OR ${eventRegistrations.expiresAt} > NOW())))`
    ));
    const currentOccupancy = registrationCounts[0]?.count || 0;
    if (currentOccupancy >= eventData.maxCapacity) {
      return res.status(400).json({ message: "Event is fully booked" });
    }
    const ticket = await db.select().from(eventTicketTypes).where(and8(
      eq8(eventTicketTypes.id, validated.ticketTypeId),
      eq8(eventTicketTypes.eventId, eventId),
      eq8(eventTicketTypes.isActive, 1)
    )).limit(1);
    if (!ticket.length) {
      return res.status(404).json({ message: "Ticket type not found" });
    }
    const ticketData = ticket[0];
    let ticketPrice = ticketData.basePricePaisa;
    let discountAmount = 0;
    let promoCodeId = null;
    if (validated.promoCode) {
      const promo = await db.select().from(eventPromoCodes).where(and8(
        eq8(eventPromoCodes.code, validated.promoCode),
        eq8(eventPromoCodes.isActive, 1),
        sql7`(${eventPromoCodes.eventId} IS NULL OR ${eventPromoCodes.eventId} = ${eventId})`
      )).limit(1);
      if (promo.length && (!promo[0].maxUses || promo[0].currentUses < promo[0].maxUses)) {
        const promoData = promo[0];
        if (promoData.discountType === "percentage") {
          discountAmount = Math.floor(ticketPrice * Number(promoData.discountValue) / 100);
        } else {
          discountAmount = Math.min(Number(promoData.discountValue) * 100, ticketPrice);
        }
        promoCodeId = promoData.id;
      }
    }
    const priceAfterDiscount = ticketPrice - discountAmount;
    const gstAmount = Math.floor(priceAfterDiscount * Number(ticketData.gstPercentage) / 100);
    const totalAmount = priceAfterDiscount + gstAmount;
    const bookingId = generateBookingId();
    const qrCodeData = generateQRCode();
    const paymentWindowMinutes = 30;
    const expiresAt = new Date(Date.now() + paymentWindowMinutes * 60 * 1e3);
    const [registration] = await db.insert(eventRegistrations).values({
      eventId,
      userId,
      ticketTypeId: validated.ticketTypeId,
      bookingId,
      attendeeName: validated.attendeeName,
      attendeeEmail: validated.attendeeEmail,
      attendeePhone: validated.attendeePhone,
      attendeeAgeGroup: validated.attendeeAgeGroup,
      experienceLevel: validated.experienceLevel,
      dietaryPreference: validated.dietaryPreference,
      specialRequirements: validated.specialRequirements,
      ticketPricePaisa: ticketPrice,
      discountAmountPaisa: discountAmount,
      promoCodeId,
      gstAmountPaisa: gstAmount,
      totalAmountPaisa: totalAmount,
      qrCodeData,
      status: "pending",
      paymentStatus: "pending",
      expiresAt
    }).returning();
    res.status(201).json({
      registration,
      payment: {
        orderId: registration.id,
        amount: totalAmount,
        currency: "INR",
        description: `${eventData.title} - ${ticketData.name}`
      }
    });
  } catch (error) {
    console.error("Error creating registration:", error);
    if (error.name === "ZodError") {
      return res.status(400).json({ message: "Validation error", errors: error.errors });
    }
    res.status(500).json({ message: "Failed to create registration" });
  }
});
router2.post("/registrations/:registrationId/confirm-payment", populateUserFromSession, async (req, res) => {
  try {
    const { registrationId } = req.params;
    const { paymentId, providerId, signature, method } = req.body;
    const registration = await db.select().from(eventRegistrations).where(eq8(eventRegistrations.id, registrationId)).limit(1);
    if (!registration.length) {
      return res.status(404).json({ message: "Registration not found" });
    }
    const regData = registration[0];
    await db.insert(eventRegistrationPayments).values({
      registrationId,
      amountPaisa: regData.totalAmountPaisa,
      paymentMethod: method || "razorpay",
      paymentProvider: "razorpay",
      providerOrderId: paymentId,
      providerPaymentId: providerId,
      providerSignature: signature,
      status: "completed"
    });
    const [updatedReg] = await db.update(eventRegistrations).set({ status: "confirmed", paymentStatus: "paid", updatedAt: /* @__PURE__ */ new Date() }).where(eq8(eventRegistrations.id, registrationId)).returning();
    await db.update(events).set({ currentRegistrations: sql7`${events.currentRegistrations} + 1` }).where(eq8(events.id, regData.eventId));
    if (regData.promoCodeId) {
      await db.update(eventPromoCodes).set({ currentUses: sql7`${eventPromoCodes.currentUses} + 1` }).where(eq8(eventPromoCodes.id, regData.promoCodeId));
    }
    res.json(updatedReg);
  } catch (error) {
    console.error("Error confirming payment:", error);
    res.status(500).json({ message: "Failed to confirm payment" });
  }
});
router2.get("/registrations/:bookingId", async (req, res) => {
  try {
    const { bookingId } = req.params;
    const registration = await db.select({
      registration: eventRegistrations,
      event: events,
      ticket: eventTicketTypes
    }).from(eventRegistrations).innerJoin(events, eq8(eventRegistrations.eventId, events.id)).innerJoin(eventTicketTypes, eq8(eventRegistrations.ticketTypeId, eventTicketTypes.id)).where(eq8(eventRegistrations.bookingId, bookingId)).limit(1);
    if (!registration.length) {
      return res.status(404).json({ message: "Registration not found" });
    }
    const data = registration[0];
    res.json({
      ...data.registration,
      event: {
        id: data.event.id,
        title: data.event.title,
        startDate: data.event.startDate,
        startTime: data.event.startTime,
        endTime: data.event.endTime,
        venueName: data.event.venueName,
        venueAddress: data.event.venueAddress,
        venueCity: data.event.venueCity,
        venueLatitude: data.event.venueLatitude,
        venueLongitude: data.event.venueLongitude,
        coverImageUrl: data.event.coverImageUrl
      },
      ticket: {
        name: data.ticket.name,
        description: data.ticket.description
      }
    });
  } catch (error) {
    console.error("Error fetching registration:", error);
    res.status(500).json({ message: "Failed to fetch registration" });
  }
});
router2.post("/registrations/:registrationId/cancel", populateUserFromSession, async (req, res) => {
  try {
    const userId = req.user?.id;
    if (!userId) return res.status(401).json({ message: "Unauthorized" });
    const { registrationId } = req.params;
    const { reason } = cancelRegistrationSchema.parse(req.body);
    const registration = await db.select().from(eventRegistrations).where(and8(
      eq8(eventRegistrations.id, registrationId),
      eq8(eventRegistrations.userId, userId),
      eq8(eventRegistrations.status, "confirmed")
    )).limit(1);
    if (!registration.length) {
      return res.status(404).json({ message: "Registration not found or already cancelled" });
    }
    const regData = registration[0];
    const event = await db.select().from(events).where(eq8(events.id, regData.eventId)).limit(1);
    if (!event.length) {
      return res.status(404).json({ message: "Event not found" });
    }
    const eventData = event[0];
    const eventDate = new Date(eventData.startDate);
    const today = /* @__PURE__ */ new Date();
    const daysUntilEvent = Math.ceil((eventDate.getTime() - today.getTime()) / (1e3 * 60 * 60 * 24));
    let refundPercentage = 0;
    const policy = eventData.cancellationPolicy;
    if (daysUntilEvent >= 7) {
      refundPercentage = policy["7_plus_days"] || 100;
    } else if (daysUntilEvent >= 3) {
      refundPercentage = policy["3_to_6_days"] || 75;
    } else if (daysUntilEvent >= 1) {
      refundPercentage = policy["1_to_2_days"] || 50;
    } else {
      refundPercentage = policy["same_day"] || 0;
    }
    const refundAmount = Math.floor(regData.totalAmountPaisa * refundPercentage / 100);
    const [updated] = await db.update(eventRegistrations).set({
      status: "cancelled",
      cancelledAt: /* @__PURE__ */ new Date(),
      cancellationReason: reason,
      refundAmountPaisa: refundAmount,
      refundStatus: refundAmount > 0 ? "pending" : "not_applicable",
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq8(eventRegistrations.id, registrationId)).returning();
    await db.update(events).set({ currentRegistrations: sql7`GREATEST(${events.currentRegistrations} - 1, 0)` }).where(eq8(events.id, regData.eventId));
    res.json({
      registration: updated,
      refund: {
        percentage: refundPercentage,
        amount: refundAmount,
        daysUntilEvent
      }
    });
  } catch (error) {
    console.error("Error cancelling registration:", error);
    if (error.name === "ZodError") {
      return res.status(400).json({ message: "Validation error", errors: error.errors });
    }
    res.status(500).json({ message: "Failed to cancel registration" });
  }
});
router2.post("/:eventId/reviews", populateUserFromSession, async (req, res) => {
  try {
    const userId = req.user?.id;
    if (!userId) return res.status(401).json({ message: "Unauthorized" });
    const { eventId } = req.params;
    const validated = eventReviewSchema.parse({ ...req.body, eventId });
    const registration = await db.select().from(eventRegistrations).where(and8(
      eq8(eventRegistrations.id, validated.registrationId),
      eq8(eventRegistrations.userId, userId),
      eq8(eventRegistrations.eventId, eventId),
      eq8(eventRegistrations.status, "confirmed")
    )).limit(1);
    if (!registration.length) {
      return res.status(403).json({ message: "You must have attended this event to leave a review" });
    }
    const existingReview = await db.select().from(eventReviews).where(and8(
      eq8(eventReviews.registrationId, validated.registrationId)
    )).limit(1);
    if (existingReview.length) {
      return res.status(400).json({ message: "You have already reviewed this event" });
    }
    const [newReview] = await db.insert(eventReviews).values({
      eventId,
      registrationId: validated.registrationId,
      userId,
      overallRating: validated.overallRating,
      instructorRating: validated.instructorRating,
      contentRating: validated.contentRating,
      venueRating: validated.venueRating,
      valueRating: validated.valueRating,
      organizationRating: validated.organizationRating,
      likedAspects: validated.likedAspects || [],
      reviewText: validated.reviewText,
      reviewPhotos: validated.reviewPhotos || [],
      status: "pending"
    }).returning();
    res.status(201).json(newReview);
  } catch (error) {
    console.error("Error creating review:", error);
    if (error.name === "ZodError") {
      return res.status(400).json({ message: "Validation error", errors: error.errors });
    }
    res.status(500).json({ message: "Failed to create review" });
  }
});
router2.get("/business/notifications", populateUserFromSession, requireAuthenticatedUser, async (req, res) => {
  try {
    const userId = req.user?.id;
    if (!userId) return res.status(401).json({ message: "Unauthorized" });
    const notifications = await db.select().from(eventNotifications).where(eq8(eventNotifications.userId, userId)).orderBy(desc3(eventNotifications.createdAt)).limit(50);
    const unreadCount = notifications.filter((n) => !n.isRead).length;
    res.json({
      notifications,
      unreadCount
    });
  } catch (error) {
    console.error("Error fetching notifications:", error);
    res.status(500).json({ message: "Failed to fetch notifications" });
  }
});
router2.put("/business/notifications/:notificationId/read", populateUserFromSession, requireAuthenticatedUser, async (req, res) => {
  try {
    const userId = req.user?.id;
    if (!userId) return res.status(401).json({ message: "Unauthorized" });
    const { notificationId } = req.params;
    await db.update(eventNotifications).set({ isRead: 1, readAt: /* @__PURE__ */ new Date() }).where(and8(eq8(eventNotifications.id, notificationId), eq8(eventNotifications.userId, userId)));
    res.json({ success: true });
  } catch (error) {
    console.error("Error marking notification as read:", error);
    res.status(500).json({ message: "Failed to mark notification as read" });
  }
});
router2.get("/business/analytics", populateUserFromSession, requireAuthenticatedUser, async (req, res) => {
  try {
    const userId = req.user?.id;
    if (!userId) return res.status(401).json({ message: "Unauthorized" });
    const { startDate, endDate } = req.query;
    const start = startDate || new Date(Date.now() - 30 * 24 * 60 * 60 * 1e3).toISOString().split("T")[0];
    const end = endDate || (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
    const userSalons = await db.select({ id: salons.id }).from(salons).where(eq8(salons.ownerId, userId));
    const salonIds = userSalons.map((s) => s.id);
    if (salonIds.length === 0) {
      return res.json({ dailyStats: [], summary: { totalRevenue: 0, totalRegistrations: 0, totalViews: 0 } });
    }
    const eventIds = await db.select({ id: events.id }).from(events).where(inArray4(events.salonId, salonIds));
    const eventIdList = eventIds.map((e) => e.id);
    if (eventIdList.length === 0) {
      return res.json({ dailyStats: [], summary: { totalRevenue: 0, totalRegistrations: 0, totalViews: 0 } });
    }
    const dailyStats = await db.select().from(eventAnalyticsDaily).where(and8(
      inArray4(eventAnalyticsDaily.eventId, eventIdList),
      gte2(eventAnalyticsDaily.date, start),
      lte2(eventAnalyticsDaily.date, end)
    )).orderBy(asc2(eventAnalyticsDaily.date));
    const summary = dailyStats.reduce((acc, day) => ({
      totalRevenue: acc.totalRevenue + (day.totalRevenuePaisa || 0),
      totalRegistrations: acc.totalRegistrations + (day.newRegistrations || 0),
      totalViews: acc.totalViews + (day.pageViews || 0)
    }), { totalRevenue: 0, totalRegistrations: 0, totalViews: 0 });
    res.json({
      dailyStats,
      summary
    });
  } catch (error) {
    console.error("Error fetching analytics:", error);
    res.status(500).json({ message: "Failed to fetch analytics" });
  }
});
router2.post("/business/:eventId/check-in", populateUserFromSession, requireAuthenticatedUser, async (req, res) => {
  try {
    const userId = req.user?.id;
    if (!userId) return res.status(401).json({ message: "Unauthorized" });
    const { eventId } = req.params;
    const { qrCode, bookingId } = req.body;
    const event = await db.select().from(events).where(eq8(events.id, eventId)).limit(1);
    if (!event.length) {
      return res.status(404).json({ message: "Event not found" });
    }
    const ownerCheck = await db.select({ id: salons.id }).from(salons).where(and8(eq8(salons.id, event[0].salonId), eq8(salons.ownerId, userId)));
    if (!ownerCheck.length) {
      return res.status(403).json({ message: "Access denied" });
    }
    let registration;
    if (qrCode) {
      const verification = verifyQRCode(qrCode);
      if (!verification.valid || !verification.data) {
        return res.status(400).json({
          message: verification.error || "Invalid or tampered QR code"
        });
      }
      if (verification.data.eventId !== eventId) {
        return res.status(400).json({ message: "QR code does not match this event" });
      }
      registration = await db.select().from(eventRegistrations).where(and8(
        eq8(eventRegistrations.id, verification.data.registrationId),
        eq8(eventRegistrations.eventId, eventId),
        eq8(eventRegistrations.status, "confirmed")
      )).limit(1);
      if (registration.length === 0) {
        return res.status(404).json({ message: "Registration not found or not confirmed" });
      }
      if (registration[0].attendeeEmail !== verification.data.attendeeEmail) {
        return res.status(400).json({ message: "QR code data does not match registration" });
      }
      if (registration[0].checkedInAt) {
        return res.status(400).json({
          message: "Already checked in",
          checkedInAt: registration[0].checkedInAt
        });
      }
    } else if (bookingId) {
      registration = await db.select().from(eventRegistrations).where(and8(
        eq8(eventRegistrations.eventId, eventId),
        eq8(eventRegistrations.bookingId, bookingId),
        eq8(eventRegistrations.status, "confirmed")
      )).limit(1);
    } else {
      return res.status(400).json({ message: "QR code or booking ID required" });
    }
    if (!registration || !registration.length) {
      return res.status(404).json({ message: "Registration not found or not confirmed" });
    }
    if (registration[0].checkedInAt) {
      return res.status(400).json({ message: "Already checked in", checkedInAt: registration[0].checkedInAt });
    }
    const [updated] = await db.update(eventRegistrations).set({ checkedInAt: /* @__PURE__ */ new Date(), checkedInBy: userId, updatedAt: /* @__PURE__ */ new Date() }).where(and8(
      eq8(eventRegistrations.id, registration[0].id),
      sql7`${eventRegistrations.checkedInAt} IS NULL`
      // Ensure not already checked in
    )).returning();
    if (!updated) {
      return res.status(409).json({ message: "Registration was just checked in by another user" });
    }
    res.json({
      success: true,
      registration: updated
    });
  } catch (error) {
    console.error("Error checking in:", error);
    res.status(500).json({ message: "Failed to check in" });
  }
});
router2.get("/my-registrations", async (req, res) => {
  try {
    const userId = req.user?.id;
    if (!userId) return res.status(401).json({ message: "Unauthorized" });
    const registrations = await db.select({
      registration: eventRegistrations,
      event: {
        id: events.id,
        title: events.title,
        startDate: events.startDate,
        startTime: events.startTime,
        venueName: events.venueName,
        venueCity: events.venueCity,
        coverImageUrl: events.coverImageUrl,
        status: events.status
      }
    }).from(eventRegistrations).innerJoin(events, eq8(eventRegistrations.eventId, events.id)).where(eq8(eventRegistrations.userId, userId)).orderBy(desc3(eventRegistrations.createdAt));
    res.json(registrations);
  } catch (error) {
    console.error("Error fetching my registrations:", error);
    res.status(500).json({ message: "Failed to fetch registrations" });
  }
});
router2.get("/razorpay-key", (req, res) => {
  res.json({ key: process.env.RAZORPAY_KEY_ID || "" });
});
router2.post("/registrations/:registrationId/create-payment-order", populateUserFromSession, requireAuthenticatedUser, async (req, res) => {
  try {
    const { registrationId } = req.params;
    const userId = req.user?.id;
    const registration = await db.select().from(eventRegistrations).where(eq8(eventRegistrations.id, registrationId)).limit(1);
    if (!registration.length) {
      return res.status(404).json({ message: "Registration not found" });
    }
    const regData = registration[0];
    if (!regData.userId) {
      return res.status(403).json({ message: "Guest registrations are not supported for payment. Please log in and create a new registration." });
    }
    if (regData.userId !== userId) {
      return res.status(403).json({ message: "Access denied - not your registration" });
    }
    if (regData.paymentStatus === "paid" || regData.status === "confirmed") {
      return res.status(400).json({ message: "Registration already paid" });
    }
    if (regData.paymentOrderId) {
      return res.status(400).json({ message: "Payment order already created", orderId: regData.paymentOrderId });
    }
    if (regData.expiresAt && /* @__PURE__ */ new Date() > new Date(regData.expiresAt)) {
      await db.update(eventRegistrations).set({
        status: "cancelled",
        cancelledAt: /* @__PURE__ */ new Date(),
        cancellationReason: "Payment window expired (30 minutes)",
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq8(eventRegistrations.id, registrationId));
      return res.status(400).json({
        message: "Registration expired. Payment window was 30 minutes. Please register again."
      });
    }
    const revalidationResult = await db.transaction(async (tx) => {
      const event = await tx.select().from(events).where(eq8(events.id, regData.eventId)).for("update").limit(1);
      if (!event.length || event[0].status !== "published") {
        throw new Error("EVENT_NOT_AVAILABLE");
      }
      const eventData2 = event[0];
      const registrationCounts = await tx.select({
        count: sql7`CAST(COUNT(*) AS INTEGER)`
      }).from(eventRegistrations).where(and8(
        eq8(eventRegistrations.eventId, regData.eventId),
        sql7`(${eventRegistrations.status} = 'confirmed' OR (${eventRegistrations.status} = 'pending' AND (${eventRegistrations.expiresAt} IS NULL OR ${eventRegistrations.expiresAt} > NOW())))`
      ));
      const currentOccupancy = registrationCounts[0]?.count || 0;
      if (currentOccupancy > eventData2.maxCapacity) {
        throw new Error("EVENT_FULLY_BOOKED");
      }
      return { eventData: eventData2, currentOccupancy };
    }).catch((error) => {
      if (error.message === "EVENT_NOT_AVAILABLE") {
        return { error: "Event no longer available for registration" };
      }
      if (error.message === "EVENT_FULLY_BOOKED") {
        return { error: "Event is now fully booked" };
      }
      throw error;
    });
    if ("error" in revalidationResult) {
      return res.status(400).json({ message: revalidationResult.error });
    }
    const { eventData } = revalidationResult;
    const ticket = await db.select().from(eventTicketTypes).where(and8(
      eq8(eventTicketTypes.id, regData.ticketTypeId),
      eq8(eventTicketTypes.isActive, 1)
    )).limit(1);
    if (!ticket.length) {
      return res.status(400).json({ message: "Ticket type no longer available" });
    }
    const currentTicketPrice = ticket[0].basePricePaisa;
    if (currentTicketPrice !== regData.ticketPricePaisa) {
      return res.status(400).json({
        message: "Ticket price has changed since registration. Please register again with current pricing.",
        oldPrice: regData.ticketPricePaisa / 100,
        newPrice: currentTicketPrice / 100
      });
    }
    let finalDiscountAmount = 0;
    if (regData.promoCodeId) {
      const promo = await db.select().from(eventPromoCodes).where(and8(
        eq8(eventPromoCodes.id, regData.promoCodeId),
        eq8(eventPromoCodes.isActive, 1)
      )).limit(1);
      if (!promo.length) {
        return res.status(400).json({
          message: "Promo code is no longer valid. Please register again without the promo code or with a valid code."
        });
      }
      const promoData = promo[0];
      if (promoData.maxUses && promoData.currentUses >= promoData.maxUses) {
        return res.status(400).json({
          message: "Promo code has reached its usage limit. Please register again without the promo code."
        });
      }
      if (promoData.discountType === "percentage") {
        finalDiscountAmount = Math.floor(currentTicketPrice * Number(promoData.discountValue) / 100);
      } else {
        finalDiscountAmount = Math.min(Number(promoData.discountValue) * 100, currentTicketPrice);
      }
    }
    const finalPriceAfterDiscount = currentTicketPrice - finalDiscountAmount;
    const finalGstAmount = Math.floor(finalPriceAfterDiscount * Number(ticket[0].gstPercentage) / 100);
    const finalTotalAmount = finalPriceAfterDiscount + finalGstAmount;
    const reservationId = `PENDING_${Date.now()}_${registrationId}`;
    const reservationResult = await db.update(eventRegistrations).set({
      paymentOrderId: reservationId,
      ticketPricePaisa: currentTicketPrice,
      discountAmountPaisa: finalDiscountAmount,
      gstAmountPaisa: finalGstAmount,
      totalAmountPaisa: finalTotalAmount,
      updatedAt: /* @__PURE__ */ new Date()
    }).where(and8(
      eq8(eventRegistrations.id, registrationId),
      sql7`${eventRegistrations.paymentOrderId} IS NULL`
      // Only if no order exists
    )).returning();
    if (!reservationResult.length) {
      return res.status(409).json({ message: "Payment order already exists or registration modified concurrently" });
    }
    let razorpayOrder;
    try {
      const options = {
        amount: finalTotalAmount,
        // Use recalculated amount, not stored amount
        currency: "INR",
        receipt: `reg_${registrationId}`,
        notes: {
          registrationId,
          eventId: regData.eventId,
          attendeeEmail: regData.attendeeEmail
        }
      };
      razorpayOrder = await razorpay.orders.create(options);
    } catch (razorpayError) {
      console.error("Razorpay order creation failed:", razorpayError);
      await db.update(eventRegistrations).set({ paymentOrderId: null, updatedAt: /* @__PURE__ */ new Date() }).where(eq8(eventRegistrations.id, registrationId));
      return res.status(500).json({ message: "Failed to create payment order. Please try again." });
    }
    await db.update(eventRegistrations).set({ paymentOrderId: razorpayOrder.id, updatedAt: /* @__PURE__ */ new Date() }).where(eq8(eventRegistrations.id, registrationId));
    res.json({
      orderId: razorpayOrder.id,
      amount: razorpayOrder.amount,
      currency: razorpayOrder.currency,
      registrationId
    });
  } catch (error) {
    console.error("Error creating payment order:", error);
    res.status(500).json({ message: "Failed to create payment order" });
  }
});
router2.post("/registrations/:registrationId/verify-payment", populateUserFromSession, requireAuthenticatedUser, async (req, res) => {
  try {
    const { registrationId } = req.params;
    const { razorpay_order_id, razorpay_payment_id, razorpay_signature } = req.body;
    const userId = req.user?.id;
    const registration = await db.select().from(eventRegistrations).where(eq8(eventRegistrations.id, registrationId)).limit(1);
    if (!registration.length) {
      return res.status(404).json({ message: "Registration not found" });
    }
    const regData = registration[0];
    if (!regData.userId) {
      return res.status(403).json({ message: "Guest registrations are not supported for payment. Please log in and create a new registration." });
    }
    if (regData.userId !== userId) {
      return res.status(403).json({ message: "Access denied - not your registration" });
    }
    if (regData.paymentStatus === "paid" || regData.status === "confirmed") {
      return res.status(400).json({ message: "Registration already confirmed" });
    }
    if (regData.expiresAt && /* @__PURE__ */ new Date() > new Date(regData.expiresAt)) {
      await db.update(eventRegistrations).set({
        status: "cancelled",
        cancelledAt: /* @__PURE__ */ new Date(),
        cancellationReason: "Payment window expired (30 minutes). Payment attempted after expiration.",
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq8(eventRegistrations.id, registrationId));
      return res.status(400).json({
        message: "Registration expired. Payment window was 30 minutes. Please create a new registration with current pricing."
      });
    }
    if (regData.paymentOrderId !== razorpay_order_id) {
      return res.status(400).json({ message: "Order ID mismatch" });
    }
    const sign = razorpay_order_id + "|" + razorpay_payment_id;
    const expectedSignature = crypto3.createHmac("sha256", process.env.RAZORPAY_KEY_SECRET || "").update(sign).digest("hex");
    if (expectedSignature !== razorpay_signature) {
      return res.status(400).json({ message: "Payment signature verification failed" });
    }
    const existingPayment = await db.select().from(eventRegistrationPayments).where(eq8(eventRegistrationPayments.providerPaymentId, razorpay_payment_id)).limit(1);
    if (existingPayment.length) {
      return res.status(400).json({ message: "Payment already processed" });
    }
    let razorpayOrder;
    try {
      razorpayOrder = await razorpay.orders.fetch(razorpay_order_id);
    } catch (error) {
      console.error("Error fetching Razorpay order:", error);
      return res.status(400).json({ message: "Invalid payment order" });
    }
    const ticket = await db.select().from(eventTicketTypes).where(and8(
      eq8(eventTicketTypes.id, regData.ticketTypeId),
      eq8(eventTicketTypes.isActive, 1)
    )).limit(1);
    if (!ticket.length) {
      return res.status(400).json({
        message: "Ticket type no longer available. Payment cannot be accepted."
      });
    }
    const currentTicketPrice = ticket[0].basePricePaisa;
    let expectedDiscountAmount = 0;
    if (regData.promoCodeId) {
      const promo = await db.select().from(eventPromoCodes).where(and8(
        eq8(eventPromoCodes.id, regData.promoCodeId),
        eq8(eventPromoCodes.isActive, 1)
      )).limit(1);
      if (!promo.length) {
        return res.status(400).json({
          message: "Promo code is no longer valid. Payment cannot be accepted. Please register again."
        });
      }
      const promoData = promo[0];
      if (promoData.maxUses && promoData.currentUses >= promoData.maxUses) {
        return res.status(400).json({
          message: "Promo code has reached its usage limit. Payment cannot be accepted. Please register again."
        });
      }
      if (promoData.discountType === "percentage") {
        expectedDiscountAmount = Math.floor(currentTicketPrice * Number(promoData.discountValue) / 100);
      } else {
        expectedDiscountAmount = Math.min(Number(promoData.discountValue) * 100, currentTicketPrice);
      }
    }
    const priceAfterDiscount = currentTicketPrice - expectedDiscountAmount;
    const expectedGstAmount = Math.floor(priceAfterDiscount * Number(ticket[0].gstPercentage) / 100);
    const expectedTotalAmount = priceAfterDiscount + expectedGstAmount;
    const razorpayOrderAmount = Number(razorpayOrder.amount);
    if (razorpayOrderAmount !== expectedTotalAmount) {
      return res.status(400).json({
        message: "Payment amount mismatch. Ticket pricing or promo code has changed since payment order was created. Please create a new registration.",
        paidAmount: razorpayOrderAmount / 100,
        currentRequiredAmount: expectedTotalAmount / 100
      });
    }
    const [updatedReg] = await db.update(eventRegistrations).set({
      status: "confirmed",
      paymentStatus: "paid",
      paymentTransactionId: razorpay_payment_id,
      updatedAt: /* @__PURE__ */ new Date()
    }).where(and8(
      eq8(eventRegistrations.id, registrationId),
      eq8(eventRegistrations.paymentStatus, "pending")
      // Only update if still pending
    )).returning();
    if (!updatedReg) {
      return res.status(409).json({ message: "Registration payment already confirmed by another request" });
    }
    await db.insert(eventRegistrationPayments).values({
      registrationId,
      amountPaisa: updatedReg.totalAmountPaisa,
      paymentMethod: "razorpay",
      paymentProvider: "razorpay",
      providerOrderId: razorpay_order_id,
      providerPaymentId: razorpay_payment_id,
      providerSignature: razorpay_signature,
      status: "completed"
    });
    const qrCode = signQRCode(registrationId, updatedReg.eventId, updatedReg.attendeeEmail);
    await db.update(eventRegistrations).set({ qrCodeData: qrCode }).where(eq8(eventRegistrations.id, registrationId));
    res.json({
      success: true,
      registration: { ...updatedReg, qrCodeData: qrCode }
    });
  } catch (error) {
    console.error("Error verifying payment:", error);
    res.status(500).json({ message: "Failed to verify payment" });
  }
});
router2.get("/:eventId/export/attendees", populateUserFromSession, requireAuthenticatedUser, async (req, res) => {
  try {
    const { eventId } = req.params;
    const { format: format6 = "excel" } = req.query;
    if (format6 !== "excel" && format6 !== "pdf" && format6 !== "checkin") {
      return res.status(400).json({ message: "Invalid format. Use excel, pdf, or checkin" });
    }
    const [event] = await db.select({ id: events.id, salonId: events.salonId }).from(events).where(eq8(events.id, eventId)).limit(1);
    if (!event) {
      return res.status(404).json({ message: "Event not found" });
    }
    const isOwner = await verifyEventOwnership(req.user.id, eventId);
    if (!isOwner) {
      return res.status(403).json({ message: "Not authorized to export attendees for this event" });
    }
    const { ExportService: ExportService2 } = await Promise.resolve().then(() => (init_exportService(), exportService_exports));
    const exportService = new ExportService2();
    let buffer;
    let filename;
    let mimeType;
    if (format6 === "excel") {
      buffer = await exportService.exportAttendeesToExcel(eventId);
      filename = `attendees-${eventId}-${Date.now()}.xlsx`;
      mimeType = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
    } else if (format6 === "pdf") {
      buffer = await exportService.exportAttendeesToPDF(eventId);
      filename = `attendees-${eventId}-${Date.now()}.pdf`;
      mimeType = "application/pdf";
    } else {
      buffer = await exportService.exportCheckInSheet(eventId);
      filename = `checkin-sheet-${eventId}-${Date.now()}.pdf`;
      mimeType = "application/pdf";
    }
    res.setHeader("Content-Type", mimeType);
    res.setHeader("Content-Disposition", `attachment; filename="${filename}"`);
    res.send(buffer);
  } catch (error) {
    console.error("Error exporting attendees:", error);
    const err = error;
    const statusCode = err.statusCode || 500;
    const message = err.message || "Failed to export attendee list";
    res.status(statusCode).json({ message });
  }
});
router2.get("/business/:eventId/speakers", populateUserFromSession, requireAuthenticatedUser, async (req, res) => {
  try {
    const { eventId } = req.params;
    const userId = req.user?.id;
    if (!userId) return res.status(401).json({ message: "Unauthorized" });
    if (!await verifyEventOwnership(userId, eventId)) {
      return res.status(403).json({ message: "Access denied" });
    }
    const speakers = await db.select().from(eventSpeakers).where(eq8(eventSpeakers.eventId, eventId)).orderBy(asc2(eventSpeakers.orderIndex));
    res.json(speakers);
  } catch (error) {
    console.error("Error fetching speakers:", error);
    res.status(500).json({ message: "Failed to fetch speakers" });
  }
});
router2.post("/business/:eventId/speakers", populateUserFromSession, requireAuthenticatedUser, async (req, res) => {
  try {
    const { eventId } = req.params;
    const userId = req.user?.id;
    if (!userId) return res.status(401).json({ message: "Unauthorized" });
    if (!await verifyEventOwnership(userId, eventId)) {
      return res.status(403).json({ message: "Access denied" });
    }
    const { name, title, bio, photoUrl, orderIndex } = req.body;
    const [speaker] = await db.insert(eventSpeakers).values({
      eventId,
      name,
      title,
      bio: bio || null,
      photoUrl: photoUrl || null,
      orderIndex: orderIndex || 1
    }).returning();
    res.json(speaker);
  } catch (error) {
    console.error("Error adding speaker:", error);
    res.status(500).json({ message: "Failed to add speaker" });
  }
});
router2.put("/business/:eventId/speakers/:speakerId", populateUserFromSession, requireAuthenticatedUser, async (req, res) => {
  try {
    const { eventId, speakerId } = req.params;
    const userId = req.user?.id;
    if (!userId) return res.status(401).json({ message: "Unauthorized" });
    if (!await verifyEventOwnership(userId, eventId)) {
      return res.status(403).json({ message: "Access denied" });
    }
    const { name, title, bio, photoUrl } = req.body;
    const [speaker] = await db.update(eventSpeakers).set({ name, title, bio: bio || null, photoUrl: photoUrl || null }).where(and8(eq8(eventSpeakers.id, speakerId), eq8(eventSpeakers.eventId, eventId))).returning();
    if (!speaker) return res.status(404).json({ message: "Speaker not found" });
    res.json(speaker);
  } catch (error) {
    console.error("Error updating speaker:", error);
    res.status(500).json({ message: "Failed to update speaker" });
  }
});
router2.delete("/business/:eventId/speakers/:speakerId", populateUserFromSession, requireAuthenticatedUser, async (req, res) => {
  try {
    const { eventId, speakerId } = req.params;
    const userId = req.user?.id;
    if (!userId) return res.status(401).json({ message: "Unauthorized" });
    if (!await verifyEventOwnership(userId, eventId)) {
      return res.status(403).json({ message: "Access denied" });
    }
    await db.delete(eventSpeakers).where(and8(eq8(eventSpeakers.id, speakerId), eq8(eventSpeakers.eventId, eventId)));
    res.json({ message: "Speaker deleted successfully" });
  } catch (error) {
    console.error("Error deleting speaker:", error);
    res.status(500).json({ message: "Failed to delete speaker" });
  }
});
router2.get("/business/:eventId/tickets", populateUserFromSession, requireAuthenticatedUser, async (req, res) => {
  try {
    const { eventId } = req.params;
    const userId = req.user?.id;
    if (!userId) return res.status(401).json({ message: "Unauthorized" });
    if (!await verifyEventOwnership(userId, eventId)) {
      return res.status(403).json({ message: "Access denied" });
    }
    const tickets = await db.select().from(eventTicketTypes).where(eq8(eventTicketTypes.eventId, eventId)).orderBy(asc2(eventTicketTypes.orderIndex));
    res.json(tickets);
  } catch (error) {
    console.error("Error fetching tickets:", error);
    res.status(500).json({ message: "Failed to fetch tickets" });
  }
});
router2.post("/business/:eventId/tickets", populateUserFromSession, requireAuthenticatedUser, async (req, res) => {
  try {
    const { eventId } = req.params;
    const userId = req.user?.id;
    if (!userId) return res.status(401).json({ message: "Unauthorized" });
    if (!await verifyEventOwnership(userId, eventId)) {
      return res.status(403).json({ message: "Access denied" });
    }
    const { name, description, basePricePaisa, quantityAvailable, orderIndex } = req.body;
    const [ticket] = await db.insert(eventTicketTypes).values({
      eventId,
      name,
      description: description || null,
      basePricePaisa,
      quantityAvailable: quantityAvailable || null,
      quantitySold: 0,
      orderIndex: orderIndex || 1
    }).returning();
    res.json(ticket);
  } catch (error) {
    console.error("Error adding ticket:", error);
    res.status(500).json({ message: "Failed to add ticket" });
  }
});
router2.put("/business/:eventId/tickets/:ticketId", populateUserFromSession, requireAuthenticatedUser, async (req, res) => {
  try {
    const { eventId, ticketId } = req.params;
    const userId = req.user?.id;
    if (!userId) return res.status(401).json({ message: "Unauthorized" });
    if (!await verifyEventOwnership(userId, eventId)) {
      return res.status(403).json({ message: "Access denied" });
    }
    const { name, description, basePricePaisa, quantityAvailable } = req.body;
    const [ticket] = await db.update(eventTicketTypes).set({
      name,
      description: description || null,
      basePricePaisa,
      quantityAvailable: quantityAvailable || null
    }).where(and8(eq8(eventTicketTypes.id, ticketId), eq8(eventTicketTypes.eventId, eventId))).returning();
    if (!ticket) return res.status(404).json({ message: "Ticket not found" });
    res.json(ticket);
  } catch (error) {
    console.error("Error updating ticket:", error);
    res.status(500).json({ message: "Failed to update ticket" });
  }
});
router2.delete("/business/:eventId/tickets/:ticketId", populateUserFromSession, requireAuthenticatedUser, async (req, res) => {
  try {
    const { eventId, ticketId } = req.params;
    const userId = req.user?.id;
    if (!userId) return res.status(401).json({ message: "Unauthorized" });
    if (!await verifyEventOwnership(userId, eventId)) {
      return res.status(403).json({ message: "Access denied" });
    }
    await db.delete(eventTicketTypes).where(and8(eq8(eventTicketTypes.id, ticketId), eq8(eventTicketTypes.eventId, eventId)));
    res.json({ message: "Ticket deleted successfully" });
  } catch (error) {
    console.error("Error deleting ticket:", error);
    res.status(500).json({ message: "Failed to delete ticket" });
  }
});
router2.get("/business/:eventId/schedule", populateUserFromSession, requireAuthenticatedUser, async (req, res) => {
  try {
    const { eventId } = req.params;
    const userId = req.user?.id;
    if (!userId) return res.status(401).json({ message: "Unauthorized" });
    if (!await verifyEventOwnership(userId, eventId)) {
      return res.status(403).json({ message: "Access denied" });
    }
    const scheduleItems = await db.select().from(eventSchedules).where(eq8(eventSchedules.eventId, eventId)).orderBy(asc2(eventSchedules.orderIndex));
    res.json(scheduleItems);
  } catch (error) {
    console.error("Error fetching schedule:", error);
    res.status(500).json({ message: "Failed to fetch schedule" });
  }
});
router2.post("/business/:eventId/schedule", populateUserFromSession, requireAuthenticatedUser, async (req, res) => {
  try {
    const { eventId } = req.params;
    const userId = req.user?.id;
    if (!userId) return res.status(401).json({ message: "Unauthorized" });
    if (!await verifyEventOwnership(userId, eventId)) {
      return res.status(403).json({ message: "Access denied" });
    }
    const { title, description, startTime, endTime, orderIndex } = req.body;
    const [scheduleItem] = await db.insert(eventSchedules).values({
      eventId,
      title,
      description: description || null,
      startTime,
      endTime,
      orderIndex: orderIndex || 1
    }).returning();
    res.json(scheduleItem);
  } catch (error) {
    console.error("Error adding schedule item:", error);
    res.status(500).json({ message: "Failed to add schedule item" });
  }
});
router2.put("/business/:eventId/schedule/:scheduleId", populateUserFromSession, requireAuthenticatedUser, async (req, res) => {
  try {
    const { eventId, scheduleId } = req.params;
    const userId = req.user?.id;
    if (!userId) return res.status(401).json({ message: "Unauthorized" });
    if (!await verifyEventOwnership(userId, eventId)) {
      return res.status(403).json({ message: "Access denied" });
    }
    const { title, description, startTime, endTime } = req.body;
    const [scheduleItem] = await db.update(eventSchedules).set({
      title,
      description: description || null,
      startTime,
      endTime
    }).where(and8(eq8(eventSchedules.id, scheduleId), eq8(eventSchedules.eventId, eventId))).returning();
    if (!scheduleItem) return res.status(404).json({ message: "Schedule item not found" });
    res.json(scheduleItem);
  } catch (error) {
    console.error("Error updating schedule item:", error);
    res.status(500).json({ message: "Failed to update schedule item" });
  }
});
router2.delete("/business/:eventId/schedule/:scheduleId", populateUserFromSession, requireAuthenticatedUser, async (req, res) => {
  try {
    const { eventId, scheduleId } = req.params;
    const userId = req.user?.id;
    if (!userId) return res.status(401).json({ message: "Unauthorized" });
    if (!await verifyEventOwnership(userId, eventId)) {
      return res.status(403).json({ message: "Access denied" });
    }
    await db.delete(eventSchedules).where(and8(eq8(eventSchedules.id, scheduleId), eq8(eventSchedules.eventId, eventId)));
    res.json({ message: "Schedule item deleted successfully" });
  } catch (error) {
    console.error("Error deleting schedule item:", error);
    res.status(500).json({ message: "Failed to delete schedule item" });
  }
});
var events_routes_default = router2;

// server/routes/mobile-auth.routes.ts
init_storage();

// server/services/welcomeOfferService.ts
init_db();
init_schema();
import { eq as eq9, and as and9, sql as sql8, desc as desc4, count as count2 } from "drizzle-orm";

// server/services/twilioService.ts
import twilio from "twilio";
var accountSid = process.env.TWILIO_ACCOUNT_SID;
var authToken = process.env.TWILIO_AUTH_TOKEN;
var messagingServiceSid = process.env.TWILIO_MESSAGING_SERVICE_SID;
var twilioPhoneNumber = process.env.TWILIO_PHONE_NUMBER;
var twilioClient = null;
function getClient() {
  if (!twilioClient) {
    if (!accountSid || !authToken) {
      throw new Error("Twilio credentials not configured. Please set TWILIO_ACCOUNT_SID and TWILIO_AUTH_TOKEN.");
    }
    twilioClient = twilio(accountSid, authToken);
  }
  return twilioClient;
}
function normalizePhoneNumber2(phone, defaultCountryCode = "+91") {
  let cleaned = phone.replace(/\D/g, "");
  if (cleaned.startsWith("91") && cleaned.length === 12) {
    return "+" + cleaned;
  }
  if (cleaned.startsWith("0") && cleaned.length === 11) {
    return "+91" + cleaned.substring(1);
  }
  if (cleaned.length === 10) {
    return "+91" + cleaned;
  }
  if (cleaned.length > 10) {
    return "+" + cleaned;
  }
  throw new Error(`Invalid phone number: ${phone}`);
}
async function sendMessage(options) {
  try {
    const client = getClient();
    const normalizedTo = normalizePhoneNumber2(options.to);
    const toNumber = options.channel === "whatsapp" ? `whatsapp:${normalizedTo}` : normalizedTo;
    let fromNumber;
    if (options.channel === "whatsapp") {
      fromNumber = process.env.TWILIO_WHATSAPP_NUMBER || `whatsapp:${twilioPhoneNumber}`;
    } else {
      fromNumber = twilioPhoneNumber || "";
    }
    const messageOptions = {
      to: toNumber,
      body: options.message
    };
    if (messagingServiceSid && options.channel === "sms") {
      messageOptions.messagingServiceSid = messagingServiceSid;
    } else {
      messageOptions.from = fromNumber;
    }
    const result = await client.messages.create(messageOptions);
    return {
      success: true,
      messageSid: result.sid,
      status: result.status
    };
  } catch (error) {
    console.error("Twilio send error:", error);
    return {
      success: false,
      error: error.message || "Failed to send message"
    };
  }
}
function generateOfferCode(prefix = "WELCOME") {
  const chars = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789";
  let code = "";
  for (let i = 0; i < 6; i++) {
    code += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return `${prefix}-${code}`;
}
function replaceTemplateVariables(template, variables) {
  let result = template;
  for (const [key, value] of Object.entries(variables)) {
    result = result.replace(new RegExp(`{{${key}}}`, "g"), value);
  }
  return result;
}
function parseStatusCallback(body) {
  if (!body || !body.MessageSid || !body.MessageStatus) {
    return null;
  }
  return {
    messageSid: body.MessageSid,
    status: body.MessageStatus,
    errorCode: body.ErrorCode,
    errorMessage: body.ErrorMessage
  };
}

// server/services/welcomeOfferService.ts
async function createWelcomeOffer(input) {
  const [offer] = await db.insert(welcomeOffers).values({
    salonId: input.salonId,
    name: input.name,
    discountType: input.discountType,
    discountValue: input.discountValue,
    maxDiscountInPaisa: input.maxDiscountInPaisa ?? null,
    minimumPurchaseInPaisa: input.minimumPurchaseInPaisa ?? null,
    validityDays: input.validityDays ?? 30,
    usageLimit: input.usageLimit ?? 1,
    isActive: 1,
    totalRedemptions: 0
  }).returning();
  return offer;
}
async function getWelcomeOffer(offerId) {
  const [offer] = await db.select().from(welcomeOffers).where(eq9(welcomeOffers.id, offerId)).limit(1);
  return offer || null;
}
async function getWelcomeOffersBySalon(salonId) {
  const offers = await db.select().from(welcomeOffers).where(eq9(welcomeOffers.salonId, salonId)).orderBy(desc4(welcomeOffers.createdAt));
  return offers;
}
async function getActiveWelcomeOffersBySalon(salonId) {
  const offers = await db.select().from(welcomeOffers).where(
    and9(
      eq9(welcomeOffers.salonId, salonId),
      eq9(welcomeOffers.isActive, 1)
    )
  ).orderBy(desc4(welcomeOffers.createdAt));
  return offers;
}
async function updateWelcomeOffer(offerId, updates) {
  const [offer] = await db.update(welcomeOffers).set({
    ...updates,
    updatedAt: /* @__PURE__ */ new Date()
  }).where(eq9(welcomeOffers.id, offerId)).returning();
  return offer || null;
}
async function deleteWelcomeOffer(offerId) {
  const offer = await getWelcomeOffer(offerId);
  if (!offer) {
    return { success: false, error: "Offer not found" };
  }
  if (offer.totalRedemptions > 0) {
    return {
      success: false,
      error: "Cannot delete offer that has been redeemed. Deactivate it instead."
    };
  }
  await db.delete(welcomeOffers).where(eq9(welcomeOffers.id, offerId));
  return { success: true };
}
async function toggleWelcomeOfferActive(offerId) {
  const offer = await getWelcomeOffer(offerId);
  if (!offer) {
    return null;
  }
  return updateWelcomeOffer(offerId, { isActive: offer.isActive === 1 ? 0 : 1 });
}
async function getUserOfferRedemption(userId, offerId) {
  const [redemption] = await db.select().from(welcomeOfferRedemptions).where(
    and9(
      eq9(welcomeOfferRedemptions.userId, userId),
      eq9(welcomeOfferRedemptions.welcomeOfferId, offerId)
    )
  ).limit(1);
  return redemption || null;
}
async function getUserOfferUsageCount(userId, offerId) {
  const [result] = await db.select({ count: count2() }).from(welcomeOfferRedemptions).where(
    and9(
      eq9(welcomeOfferRedemptions.userId, userId),
      eq9(welcomeOfferRedemptions.welcomeOfferId, offerId),
      eq9(welcomeOfferRedemptions.status, "redeemed")
    )
  );
  return result?.count || 0;
}
async function validateWelcomeOffer(offerId, userId, bookingAmountInPaisa) {
  const offer = await getWelcomeOffer(offerId);
  if (!offer) {
    return { valid: false, discount: 0, reason: "Offer not found" };
  }
  if (!offer.isActive) {
    return { valid: false, discount: 0, reason: "Offer is not active" };
  }
  const redemption = await getUserOfferRedemption(userId, offerId);
  if (redemption) {
    if (redemption.status === "expired") {
      return { valid: false, discount: 0, reason: "Offer has expired" };
    }
    if (/* @__PURE__ */ new Date() > redemption.expiresAt) {
      await db.update(welcomeOfferRedemptions).set({ status: "expired" }).where(eq9(welcomeOfferRedemptions.id, redemption.id));
      return { valid: false, discount: 0, reason: "Offer has expired" };
    }
  }
  const usageCount = await getUserOfferUsageCount(userId, offerId);
  if (usageCount >= offer.usageLimit) {
    return { valid: false, discount: 0, reason: "Offer usage limit exceeded" };
  }
  if (offer.minimumPurchaseInPaisa && bookingAmountInPaisa < offer.minimumPurchaseInPaisa) {
    const minAmount = offer.minimumPurchaseInPaisa / 100;
    return {
      valid: false,
      discount: 0,
      reason: `Minimum purchase of \u20B9${minAmount} required`
    };
  }
  let discount = 0;
  if (offer.discountType === "percentage") {
    discount = Math.floor(bookingAmountInPaisa * offer.discountValue / 100);
    if (offer.maxDiscountInPaisa && discount > offer.maxDiscountInPaisa) {
      discount = offer.maxDiscountInPaisa;
    }
  } else {
    discount = offer.discountValue;
  }
  discount = Math.min(discount, bookingAmountInPaisa);
  return { valid: true, discount, offer };
}
async function createOfferRedemption(offerId, userId, importedCustomerId) {
  const offer = await getWelcomeOffer(offerId);
  if (!offer) {
    throw new Error("Offer not found");
  }
  const expiresAt = /* @__PURE__ */ new Date();
  expiresAt.setDate(expiresAt.getDate() + offer.validityDays);
  const [redemption] = await db.insert(welcomeOfferRedemptions).values({
    welcomeOfferId: offerId,
    userId,
    importedCustomerId: importedCustomerId ?? null,
    discountAppliedInPaisa: 0,
    expiresAt,
    status: "active"
  }).returning();
  return redemption;
}
async function redeemWelcomeOffer(offerId, userId, bookingId, bookingAmountInPaisa) {
  const validation = await validateWelcomeOffer(offerId, userId, bookingAmountInPaisa);
  if (!validation.valid) {
    return { success: false, error: validation.reason };
  }
  const existingRedemption = await getUserOfferRedemption(userId, offerId);
  let redemption;
  if (existingRedemption && existingRedemption.status === "active") {
    [redemption] = await db.update(welcomeOfferRedemptions).set({
      bookingId,
      discountAppliedInPaisa: validation.discount,
      redeemedAt: /* @__PURE__ */ new Date(),
      status: "redeemed"
    }).where(eq9(welcomeOfferRedemptions.id, existingRedemption.id)).returning();
  } else {
    const offer = validation.offer;
    const expiresAt = /* @__PURE__ */ new Date();
    expiresAt.setDate(expiresAt.getDate() + offer.validityDays);
    [redemption] = await db.insert(welcomeOfferRedemptions).values({
      welcomeOfferId: offerId,
      userId,
      bookingId,
      discountAppliedInPaisa: validation.discount,
      expiresAt,
      redeemedAt: /* @__PURE__ */ new Date(),
      status: "redeemed"
    }).returning();
  }
  await db.update(welcomeOffers).set({
    totalRedemptions: sql8`${welcomeOffers.totalRedemptions} + 1`,
    updatedAt: /* @__PURE__ */ new Date()
  }).where(eq9(welcomeOffers.id, offerId));
  return { success: true, redemption };
}
async function getOfferRedemptions(offerId, options) {
  const limit = options?.limit ?? 50;
  const offset = options?.offset ?? 0;
  const [countResult] = await db.select({ total: count2() }).from(welcomeOfferRedemptions).where(eq9(welcomeOfferRedemptions.welcomeOfferId, offerId));
  const redemptions = await db.select().from(welcomeOfferRedemptions).where(eq9(welcomeOfferRedemptions.welcomeOfferId, offerId)).orderBy(desc4(welcomeOfferRedemptions.createdAt)).limit(limit).offset(offset);
  return {
    redemptions,
    total: countResult?.total || 0
  };
}
async function checkImportedCustomerByPhone(phone) {
  let normalizedPhone;
  try {
    normalizedPhone = normalizePhoneNumber2(phone);
  } catch {
    return { found: false, importedCustomers: [] };
  }
  const customers = await db.select({
    id: importedCustomers.id,
    salonId: importedCustomers.salonId,
    customerName: importedCustomers.customerName,
    status: importedCustomers.status
  }).from(importedCustomers).where(eq9(importedCustomers.normalizedPhone, normalizedPhone));
  return {
    found: customers.length > 0,
    importedCustomers: customers
  };
}
async function linkImportedCustomerToUser(importedCustomerId, userId) {
  await db.update(importedCustomers).set({
    linkedUserId: userId,
    status: "registered",
    registeredAt: /* @__PURE__ */ new Date(),
    updatedAt: /* @__PURE__ */ new Date()
  }).where(eq9(importedCustomers.id, importedCustomerId));
}
async function autoApplyWelcomeOfferOnRegistration(userId, phone) {
  const { found, importedCustomers: customers } = await checkImportedCustomerByPhone(phone);
  if (!found) {
    return { offersApplied: [] };
  }
  const offersApplied = [];
  for (const customer of customers) {
    await linkImportedCustomerToUser(customer.id, userId);
    const activeOffers = await getActiveWelcomeOffersBySalon(customer.salonId);
    for (const offer of activeOffers) {
      try {
        const redemption = await createOfferRedemption(offer.id, userId, customer.id);
        offersApplied.push({
          offerId: offer.id,
          offerName: offer.name,
          salonId: customer.salonId,
          expiresAt: redemption.expiresAt
        });
      } catch (error) {
        console.error(`Failed to apply welcome offer ${offer.id} for user ${userId}:`, error);
      }
    }
  }
  return { offersApplied };
}
async function getUserActiveOffers(userId) {
  const redemptions = await db.select().from(welcomeOfferRedemptions).where(
    and9(
      eq9(welcomeOfferRedemptions.userId, userId),
      eq9(welcomeOfferRedemptions.status, "active")
    )
  );
  const result = [];
  for (const redemption of redemptions) {
    if (/* @__PURE__ */ new Date() > redemption.expiresAt) {
      await db.update(welcomeOfferRedemptions).set({ status: "expired" }).where(eq9(welcomeOfferRedemptions.id, redemption.id));
      continue;
    }
    const offer = await getWelcomeOffer(redemption.welcomeOfferId);
    if (offer && offer.isActive) {
      result.push({ redemption, offer });
    }
  }
  return result;
}
function formatOfferAmount(offer) {
  if (offer.discountType === "percentage") {
    return `${offer.discountValue}%`;
  }
  return `\u20B9${offer.discountValue / 100}`;
}

// server/routes/mobile-auth.routes.ts
var otpStorage = /* @__PURE__ */ new Map();
function registerMobileAuthRoutes(app2) {
  app2.post("/api/auth/mobile/request-otp", async (req, res) => {
    try {
      const { phoneNumber } = req.body;
      if (!phoneNumber || !/^[6-9]\d{9}$/.test(phoneNumber)) {
        return res.status(400).json({
          error: "Invalid phone number. Must be a 10-digit Indian number starting with 6-9."
        });
      }
      const otp = Math.floor(1e3 + Math.random() * 9e3).toString();
      otpStorage.set(phoneNumber, {
        otp,
        expiresAt: Date.now() + 5 * 60 * 1e3,
        attempts: 0
      });
      if (process.env.NODE_ENV === "development") {
        console.log(`\u{1F4F1} [DEV MODE] OTP for ${phoneNumber}: ${otp}`);
      }
      res.json({
        success: true,
        message: "OTP sent successfully",
        expiresIn: 300
      });
    } catch (error) {
      console.error("Mobile OTP request error:", error);
      res.status(500).json({ error: "Failed to send OTP. Please try again." });
    }
  });
  app2.post("/api/auth/mobile/verify-otp", async (req, res) => {
    try {
      const { phoneNumber, otp } = req.body;
      if (!phoneNumber || !otp) {
        return res.status(400).json({ error: "Phone number and OTP are required" });
      }
      const storedOTP = otpStorage.get(phoneNumber);
      if (!storedOTP) {
        return res.status(400).json({ error: "OTP expired or not found. Please request a new OTP." });
      }
      if (storedOTP.expiresAt < Date.now()) {
        otpStorage.delete(phoneNumber);
        return res.status(400).json({ error: "OTP expired. Please request a new OTP." });
      }
      if (storedOTP.attempts >= 5) {
        otpStorage.delete(phoneNumber);
        return res.status(429).json({ error: "Too many attempts. Please request a new OTP." });
      }
      if (storedOTP.otp !== otp) {
        storedOTP.attempts += 1;
        return res.status(400).json({ error: "Invalid OTP. Please try again." });
      }
      otpStorage.delete(phoneNumber);
      let user = await storage.getUserByPhone(phoneNumber);
      let isNewUser = false;
      let welcomeOffersApplied = [];
      if (!user) {
        user = await storage.createUser({
          phone: phoneNumber,
          role: "customer"
        });
        const customerRole = await storage.getRoleByName("customer");
        if (customerRole) {
          await storage.assignUserRole(user.id, customerRole.id);
        }
        isNewUser = true;
        console.log(`\u{1F4F1} [Mobile Auth] New user created: ${user.id}`);
        try {
          const offerResult = await autoApplyWelcomeOfferOnRegistration(user.id, phoneNumber);
          welcomeOffersApplied = offerResult.offersApplied;
          if (welcomeOffersApplied.length > 0) {
            console.log(`\u{1F4F1} [Mobile Auth] Applied ${welcomeOffersApplied.length} welcome offer(s) for user: ${user.id}`);
          }
        } catch (offerError) {
          console.error(`\u{1F4F1} [Mobile Auth] Failed to apply welcome offers:`, offerError);
        }
      }
      const accessToken = generateAccessToken(user.id, user.email || "");
      const deviceInfo = req.headers["user-agent"];
      const ipAddress = req.ip || req.connection.remoteAddress;
      const { token: refreshToken } = await generateRefreshToken(
        user.id,
        deviceInfo,
        ipAddress
      );
      const { password: _, ...userResponse } = user;
      console.log(`\u{1F4F1} [Mobile Auth] User authenticated: ${user.id}`);
      res.json({
        success: true,
        user: userResponse,
        accessToken,
        refreshToken,
        message: "OTP verified successfully",
        isNewUser,
        welcomeOffers: welcomeOffersApplied
      });
    } catch (error) {
      console.error("Mobile OTP verification error:", error);
      res.status(500).json({ error: "Verification failed. Please try again." });
    }
  });
  app2.post("/api/auth/mobile/resend-otp", async (req, res) => {
    try {
      const { phoneNumber } = req.body;
      if (!phoneNumber) {
        return res.status(400).json({ error: "Phone number is required" });
      }
      const otp = Math.floor(1e3 + Math.random() * 9e3).toString();
      otpStorage.set(phoneNumber, {
        otp,
        expiresAt: Date.now() + 5 * 60 * 1e3,
        attempts: 0
      });
      if (process.env.NODE_ENV === "development") {
        console.log(`\u{1F4F1} [DEV MODE] Resent OTP for ${phoneNumber}: ${otp}`);
      }
      res.json({
        success: true,
        message: "OTP resent successfully",
        expiresIn: 300
      });
    } catch (error) {
      console.error("Mobile OTP resend error:", error);
      res.status(500).json({ error: "Failed to resend OTP. Please try again." });
    }
  });
  app2.post("/api/auth/mobile/refresh", async (req, res) => {
    try {
      const { refreshToken } = req.body;
      if (!refreshToken) {
        return res.status(401).json({ error: "No refresh token provided" });
      }
      const decoded = await verifyRefreshToken(refreshToken);
      const user = await storage.getUserById(decoded.userId);
      if (!user) {
        return res.status(401).json({ error: "User not found" });
      }
      const newAccessToken = generateAccessToken(user.id, user.email || "");
      const deviceInfo = req.headers["user-agent"];
      const ipAddress = req.ip || req.connection.remoteAddress;
      const { token: newRefreshToken } = await generateRefreshToken(
        user.id,
        deviceInfo,
        ipAddress
      );
      await revokeRefreshToken(decoded.tokenId);
      console.log(`\u{1F4F1} [Mobile Auth] Token refreshed for user: ${user.id}`);
      res.json({
        success: true,
        accessToken: newAccessToken,
        refreshToken: newRefreshToken,
        message: "Token refreshed successfully"
      });
    } catch (error) {
      console.error("Mobile token refresh error:", error);
      res.status(401).json({
        error: error.message || "Invalid or expired refresh token"
      });
    }
  });
  app2.post("/api/auth/mobile/logout", async (req, res) => {
    try {
      const { refreshToken } = req.body;
      if (refreshToken) {
        try {
          const decoded = await verifyRefreshToken(refreshToken);
          await revokeRefreshToken(decoded.tokenId);
          console.log(`\u{1F4F1} [Mobile Auth] User logged out: ${decoded.userId}`);
        } catch (error) {
          console.warn("Error revoking refresh token during mobile logout:", error);
        }
      }
      res.json({
        success: true,
        message: "Logged out successfully"
      });
    } catch (error) {
      console.error("Mobile logout error:", error);
      res.status(500).json({ error: "Logout failed. Please try again." });
    }
  });
  console.log("\u2705 Mobile authentication routes registered");
}

// server/routes/shop.routes.ts
init_db();
init_schema();
import { eq as eq10, and as and10, desc as desc5, asc as asc3, sql as sql9, inArray as inArray5, like as like3, or as or4 } from "drizzle-orm";

// server/middleware/authMobile.ts
async function authenticateMobileUser(req, res, next) {
  try {
    const token = extractBearerToken(req.headers.authorization);
    if (!token) {
      res.status(401).json({ error: "Authentication required" });
      return;
    }
    const decoded = await verifyAccessToken(token);
    req.user = { id: decoded.userId };
    next();
  } catch (error) {
    console.error("Authentication error:", error);
    res.status(401).json({ error: "Invalid or expired token" });
  }
}

// server/routes/shop.routes.ts
import Razorpay2 from "razorpay";
import crypto4 from "crypto";
var razorpay2 = new Razorpay2({
  key_id: process.env.RAZORPAY_KEY_ID || "",
  key_secret: process.env.RAZORPAY_KEY_SECRET || ""
});
function registerShopRoutes(app2) {
  app2.get("/api/shop/categories", async (req, res) => {
    try {
      const categories = await db.select().from(productCategories).where(eq10(productCategories.isActive, 1)).orderBy(asc3(productCategories.sortOrder));
      res.json({ success: true, categories });
    } catch (error) {
      console.error("Get categories error:", error);
      res.status(500).json({ error: "Failed to fetch categories" });
    }
  });
  app2.get("/api/shop/products", async (req, res) => {
    try {
      const {
        categoryId,
        salonId,
        search,
        minPrice,
        maxPrice,
        sortBy = "newest",
        limit = "20",
        offset = "0"
      } = req.query;
      let query = db.select({
        id: products.id,
        salonId: products.salonId,
        categoryId: products.categoryId,
        name: products.name,
        description: products.description,
        brand: products.brand,
        pricePaisa: products.retailPriceInPaisa,
        originalPricePaisa: products.sellingPriceInPaisa,
        stockQuantity: products.currentStock,
        size: products.size,
        unit: products.unit,
        metadata: products.metadata,
        tags: products.tags,
        isActive: products.isActive,
        availableForRetail: products.availableForRetail,
        createdAt: products.createdAt,
        salon: {
          id: salons.id,
          name: salons.name,
          imageUrl: salons.imageUrl
        }
      }).from(products).leftJoin(salons, eq10(products.salonId, salons.id)).where(
        and10(
          eq10(products.isActive, 1),
          eq10(products.availableForRetail, 1),
          categoryId ? eq10(products.categoryId, categoryId) : void 0,
          salonId ? eq10(products.salonId, salonId) : void 0,
          search ? or4(
            like3(products.name, `%${search}%`),
            like3(products.description, `%${search}%`),
            like3(products.brand, `%${search}%`)
          ) : void 0,
          minPrice ? sql9`${products.retailPriceInPaisa} >= ${parseInt(minPrice)}` : void 0,
          maxPrice ? sql9`${products.retailPriceInPaisa} <= ${parseInt(maxPrice)}` : void 0
        )
      ).$dynamic();
      switch (sortBy) {
        case "price_low":
          query = query.orderBy(asc3(products.retailPriceInPaisa));
          break;
        case "price_high":
          query = query.orderBy(desc5(products.retailPriceInPaisa));
          break;
        default:
          query = query.orderBy(desc5(products.createdAt));
      }
      const limitNum = parseInt(limit);
      const offsetNum = parseInt(offset);
      query = query.limit(limitNum).offset(offsetNum);
      const productList = await query;
      res.json({ success: true, products: productList, limit: limitNum, offset: offsetNum });
    } catch (error) {
      console.error("Get products error:", error);
      res.status(500).json({ error: "Failed to fetch products" });
    }
  });
  app2.get("/api/shop/products/:id", async (req, res) => {
    try {
      const { id } = req.params;
      const product = await db.select().from(products).leftJoin(salons, eq10(products.salonId, salons.id)).where(
        and10(
          eq10(products.id, id),
          eq10(products.isActive, 1),
          eq10(products.availableForRetail, 1)
        )
      ).limit(1);
      if (!product || product.length === 0) {
        return res.status(404).json({ error: "Product not found" });
      }
      const reviews = await db.select().from(productReviews).leftJoin(users, eq10(productReviews.userId, users.id)).where(
        and10(
          eq10(productReviews.productId, id),
          eq10(productReviews.isVisible, 1)
        )
      ).orderBy(desc5(productReviews.createdAt));
      res.json({ success: true, product: product[0], reviews });
    } catch (error) {
      console.error("Get product error:", error);
      res.status(500).json({ error: "Failed to fetch product" });
    }
  });
  app2.get("/api/shop/cart", authenticateMobileUser, async (req, res) => {
    try {
      const userId = req.user.id;
      const userCarts = await db.select().from(shoppingCarts).where(
        and10(
          eq10(shoppingCarts.userId, userId),
          eq10(shoppingCarts.status, "active")
        )
      );
      if (!userCarts || userCarts.length === 0) {
        return res.json({ success: true, cart: [] });
      }
      const cartIds = userCarts.map((c) => c.id);
      const cart2 = await db.select().from(cartItems).leftJoin(products, eq10(cartItems.productId, products.id)).leftJoin(salons, eq10(products.salonId, salons.id)).where(inArray5(cartItems.cartId, cartIds)).orderBy(desc5(cartItems.addedAt));
      res.json({ success: true, cart: cart2 });
    } catch (error) {
      console.error("Get cart error:", error);
      res.status(500).json({ error: "Failed to fetch cart" });
    }
  });
  app2.post("/api/shop/cart", authenticateMobileUser, async (req, res) => {
    try {
      const userId = req.user.id;
      const validated = addToCartSchema.parse(req.body);
      const { salonId, productId, quantity } = validated;
      const product = await db.select().from(products).where(
        and10(
          eq10(products.id, productId),
          eq10(products.isActive, 1),
          eq10(products.availableForRetail, 1)
        )
      ).limit(1);
      if (!product || product.length === 0) {
        return res.status(404).json({ error: "Product not found or not available" });
      }
      if (parseFloat(product[0].currentStock) < quantity) {
        return res.status(400).json({ error: "Insufficient stock" });
      }
      let cart2 = await db.select().from(shoppingCarts).where(
        and10(
          eq10(shoppingCarts.userId, userId),
          eq10(shoppingCarts.salonId, salonId),
          eq10(shoppingCarts.status, "active")
        )
      ).limit(1);
      if (!cart2 || cart2.length === 0) {
        const newCart = await db.insert(shoppingCarts).values({ userId, salonId, status: "active" }).returning();
        cart2 = newCart;
      }
      const cartId = cart2[0].id;
      const price = product[0].retailPriceInPaisa || 0;
      const existingCartItem = await db.select().from(cartItems).where(
        and10(
          eq10(cartItems.cartId, cartId),
          eq10(cartItems.productId, productId)
        )
      ).limit(1);
      if (existingCartItem && existingCartItem.length > 0) {
        await db.update(cartItems).set({
          quantity: existingCartItem[0].quantity + quantity,
          currentPricePaisa: price
        }).where(eq10(cartItems.id, existingCartItem[0].id));
        res.json({ success: true, message: "Cart updated successfully" });
      } else {
        await db.insert(cartItems).values({
          cartId,
          productId,
          quantity,
          priceAtAddPaisa: price,
          currentPricePaisa: price
        }).returning();
        res.json({ success: true, message: "Added to cart" });
      }
    } catch (error) {
      console.error("Add to cart error:", error);
      if (error.name === "ZodError") {
        return res.status(400).json({ error: "Invalid input", details: error.errors });
      }
      res.status(500).json({ error: "Failed to add to cart" });
    }
  });
  app2.patch("/api/shop/cart/:id", authenticateMobileUser, async (req, res) => {
    try {
      const userId = req.user.id;
      const { id } = req.params;
      const validated = updateCartItemSchema.parse(req.body);
      const { quantity } = validated;
      const cartItem = await db.select().from(cartItems).innerJoin(shoppingCarts, eq10(cartItems.cartId, shoppingCarts.id)).where(
        and10(
          eq10(cartItems.id, id),
          eq10(shoppingCarts.userId, userId)
        )
      ).limit(1);
      if (!cartItem || cartItem.length === 0) {
        return res.status(404).json({ error: "Cart item not found" });
      }
      if (quantity === 0) {
        await db.delete(cartItems).where(eq10(cartItems.id, id));
        return res.json({ success: true, message: "Item removed from cart" });
      }
      await db.update(cartItems).set({ quantity }).where(eq10(cartItems.id, id));
      res.json({ success: true, message: "Cart updated successfully" });
    } catch (error) {
      console.error("Update cart error:", error);
      if (error.name === "ZodError") {
        return res.status(400).json({ error: "Invalid input", details: error.errors });
      }
      res.status(500).json({ error: "Failed to update cart" });
    }
  });
  app2.delete("/api/shop/cart/:id", authenticateMobileUser, async (req, res) => {
    try {
      const userId = req.user.id;
      const { id } = req.params;
      const cartItem = await db.select().from(cartItems).innerJoin(shoppingCarts, eq10(cartItems.cartId, shoppingCarts.id)).where(
        and10(
          eq10(cartItems.id, id),
          eq10(shoppingCarts.userId, userId)
        )
      ).limit(1);
      if (!cartItem || cartItem.length === 0) {
        return res.status(404).json({ error: "Cart item not found" });
      }
      await db.delete(cartItems).where(eq10(cartItems.id, id));
      res.json({ success: true, message: "Item removed from cart" });
    } catch (error) {
      console.error("Remove from cart error:", error);
      res.status(500).json({ error: "Failed to remove from cart" });
    }
  });
  app2.delete("/api/shop/cart", authenticateMobileUser, async (req, res) => {
    try {
      const userId = req.user.id;
      const userCarts = await db.select().from(shoppingCarts).where(
        and10(
          eq10(shoppingCarts.userId, userId),
          eq10(shoppingCarts.status, "active")
        )
      );
      if (userCarts && userCarts.length > 0) {
        const cartIds = userCarts.map((c) => c.id);
        await db.delete(cartItems).where(inArray5(cartItems.cartId, cartIds));
      }
      res.json({ success: true, message: "Cart cleared successfully" });
    } catch (error) {
      console.error("Clear cart error:", error);
      res.status(500).json({ error: "Failed to clear cart" });
    }
  });
  app2.get("/api/shop/wishlist", authenticateMobileUser, async (req, res) => {
    try {
      const userId = req.user.id;
      const wishlist = await db.select().from(wishlists).leftJoin(products, eq10(wishlists.productId, products.id)).leftJoin(salons, eq10(products.salonId, salons.id)).where(eq10(wishlists.userId, userId)).orderBy(desc5(wishlists.addedAt));
      res.json({ success: true, wishlist });
    } catch (error) {
      console.error("Get wishlist error:", error);
      res.status(500).json({ error: "Failed to fetch wishlist" });
    }
  });
  app2.post("/api/shop/wishlist", authenticateMobileUser, async (req, res) => {
    try {
      const userId = req.user.id;
      const { productId } = req.body;
      if (!productId) {
        return res.status(400).json({ error: "Product ID is required" });
      }
      const product = await db.select().from(products).where(eq10(products.id, productId)).limit(1);
      if (!product || product.length === 0) {
        return res.status(404).json({ error: "Product not found" });
      }
      const price = product[0].retailPriceInPaisa || 0;
      await db.insert(wishlists).values({
        userId,
        productId,
        priceAtAddPaisa: price
      }).returning();
      res.json({ success: true, message: "Added to wishlist" });
    } catch (error) {
      if (error.code === "23505") {
        return res.status(400).json({ error: "Product already in wishlist" });
      }
      console.error("Add to wishlist error:", error);
      res.status(500).json({ error: "Failed to add to wishlist" });
    }
  });
  app2.delete("/api/shop/wishlist/:id", authenticateMobileUser, async (req, res) => {
    try {
      const userId = req.user.id;
      const { id } = req.params;
      await db.delete(wishlists).where(
        and10(
          eq10(wishlists.id, id),
          eq10(wishlists.userId, userId)
        )
      );
      res.json({ success: true, message: "Removed from wishlist" });
    } catch (error) {
      console.error("Remove from wishlist error:", error);
      res.status(500).json({ error: "Failed to remove from wishlist" });
    }
  });
  app2.post("/api/shop/orders", authenticateMobileUser, async (req, res) => {
    try {
      const userId = req.user.id;
      const validated = createProductOrderSchema.parse(req.body);
      const { salonId, fulfillmentType, deliveryAddress, paymentMethod, razorpayPaymentId, razorpayOrderId, razorpaySignature } = validated;
      const userCarts = await db.select().from(shoppingCarts).where(
        and10(
          eq10(shoppingCarts.userId, userId),
          eq10(shoppingCarts.status, "active"),
          salonId ? eq10(shoppingCarts.salonId, salonId) : void 0
        )
      );
      if (!userCarts || userCarts.length === 0) {
        return res.status(400).json({ error: "No active cart found" });
      }
      const cartIds = userCarts.map((c) => c.id);
      const items = await db.select().from(cartItems).leftJoin(products, eq10(cartItems.productId, products.id)).where(inArray5(cartItems.cartId, cartIds));
      if (items.length === 0) {
        return res.status(400).json({ error: "Cart is empty" });
      }
      let subtotalPaisa = 0;
      let taxPaisa = 0;
      const orderItemsData = [];
      for (const item of items) {
        if (!item.products) continue;
        const quantity = item.cart_items.quantity;
        const unitPrice = item.products.retailPriceInPaisa || 0;
        const itemSubtotal = unitPrice * quantity;
        const itemTax = Math.round(itemSubtotal * 0.18);
        subtotalPaisa += itemSubtotal;
        taxPaisa += itemTax;
        orderItemsData.push({
          productId: item.cart_items.productId,
          quantity,
          unitPricePaisa: unitPrice,
          discountPerItemPaisa: 0,
          subtotalPaisa: itemSubtotal + itemTax
        });
      }
      const deliveryChargePaisa = fulfillmentType === "delivery" ? 5e3 : 0;
      const totalPaisa = subtotalPaisa + taxPaisa + deliveryChargePaisa;
      let verifiedPaymentStatus = "pending";
      let verifiedPaymentId;
      if (paymentMethod === "razorpay") {
        if (!razorpayPaymentId || !razorpayOrderId || !razorpaySignature) {
          return res.status(400).json({
            error: "Razorpay payment requires paymentId, orderId, and signature"
          });
        }
        const existingOrder = await db.select().from(productOrders).where(eq10(productOrders.paymentTransactionId, razorpayPaymentId)).limit(1);
        if (existingOrder.length > 0) {
          return res.status(400).json({
            error: "Payment already used",
            details: "This payment has already been used for another order"
          });
        }
        try {
          const sign = razorpayOrderId + "|" + razorpayPaymentId;
          const expectedSign = crypto4.createHmac("sha256", process.env.RAZORPAY_KEY_SECRET || "").update(sign).digest("hex");
          if (razorpaySignature !== expectedSign) {
            return res.status(400).json({ error: "Invalid payment signature" });
          }
          const razorpayOrder = await razorpay2.orders.fetch(razorpayOrderId);
          const payment = await razorpay2.payments.fetch(razorpayPaymentId);
          if (payment.order_id !== razorpayOrderId) {
            return res.status(400).json({ error: "Payment does not match order" });
          }
          if (payment.status !== "captured" && payment.status !== "authorized") {
            return res.status(400).json({ error: "Payment not completed" });
          }
          if (razorpayOrder.amount !== totalPaisa) {
            return res.status(400).json({
              error: "Payment amount mismatch",
              details: `Expected ${totalPaisa}, got ${razorpayOrder.amount}`
            });
          }
          const orderNotes = razorpayOrder.notes || {};
          if (orderNotes.userId && orderNotes.userId !== userId) {
            return res.status(400).json({ error: "Payment belongs to different user" });
          }
          verifiedPaymentStatus = "paid";
          verifiedPaymentId = razorpayPaymentId;
        } catch (error) {
          console.error("Razorpay verification error:", error);
          return res.status(400).json({
            error: "Payment verification failed",
            message: error.message
          });
        }
      }
      const orderNumber = `ORD${Date.now()}${Math.random().toString(36).substr(2, 4).toUpperCase()}`;
      const finalSalonId = salonId || userCarts[0].salonId;
      await db.transaction(async (tx) => {
        const order = await tx.insert(productOrders).values({
          orderNumber,
          customerId: userId,
          salonId: finalSalonId,
          status: "pending",
          fulfillmentType,
          deliveryAddress: typeof deliveryAddress === "string" ? deliveryAddress : JSON.stringify(deliveryAddress),
          paymentMethod: paymentMethod || "pay_at_salon",
          paymentStatus: verifiedPaymentStatus,
          paymentTransactionId: verifiedPaymentId,
          subtotalPaisa,
          discountPaisa: 0,
          deliveryChargePaisa,
          taxPaisa,
          totalPaisa,
          currency: "INR"
        }).returning();
        for (const itemData of orderItemsData) {
          await tx.insert(productOrderItems).values({
            orderId: order[0].id,
            ...itemData
          });
        }
        await tx.delete(cartItems).where(inArray5(cartItems.cartId, cartIds));
        await tx.update(shoppingCarts).set({ status: "converted" }).where(inArray5(shoppingCarts.id, cartIds));
      });
      const createdOrder = await db.select().from(productOrders).where(eq10(productOrders.orderNumber, orderNumber)).limit(1);
      console.log(`\u{1F6CD}\uFE0F [Shop] Order created: ${orderNumber} for user: ${userId} (Payment: ${paymentMethod})`);
      res.json({
        success: true,
        order: createdOrder[0],
        orderNumber,
        message: "Order created successfully"
      });
    } catch (error) {
      console.error("Create order error:", error);
      if (error.name === "ZodError") {
        return res.status(400).json({ error: "Invalid input", details: error.errors });
      }
      res.status(500).json({ error: "Failed to create order" });
    }
  });
  app2.get("/api/shop/orders", authenticateMobileUser, async (req, res) => {
    try {
      const userId = req.user.id;
      const { status, limit = "20", offset = "0" } = req.query;
      const orders = await db.select().from(productOrders).leftJoin(salons, eq10(productOrders.salonId, salons.id)).where(
        and10(
          eq10(productOrders.customerId, userId),
          status ? eq10(productOrders.status, status) : void 0
        )
      ).orderBy(desc5(productOrders.createdAt)).limit(parseInt(limit)).offset(parseInt(offset));
      res.json({ success: true, orders });
    } catch (error) {
      console.error("Get orders error:", error);
      res.status(500).json({ error: "Failed to fetch orders" });
    }
  });
  app2.get("/api/shop/orders/:id", authenticateMobileUser, async (req, res) => {
    try {
      const userId = req.user.id;
      const { id } = req.params;
      const order = await db.select().from(productOrders).where(
        and10(
          eq10(productOrders.id, id),
          eq10(productOrders.customerId, userId)
        )
      ).limit(1);
      if (!order || order.length === 0) {
        return res.status(404).json({ error: "Order not found" });
      }
      const items = await db.select().from(productOrderItems).where(eq10(productOrderItems.orderId, id));
      const salon = await db.select().from(salons).where(eq10(salons.id, order[0].salonId)).limit(1);
      res.json({ success: true, order: { ...order[0], items, salon: salon[0] } });
    } catch (error) {
      console.error("Get order error:", error);
      res.status(500).json({ error: "Failed to fetch order" });
    }
  });
  app2.post("/api/shop/reviews", authenticateMobileUser, async (req, res) => {
    try {
      const userId = req.user.id;
      const { productId, orderId, rating, title, comment, imageUrls } = req.body;
      if (!productId || !orderId || !rating || rating < 1 || rating > 5) {
        return res.status(400).json({ error: "Product ID, Order ID, and valid rating (1-5) are required" });
      }
      const order = await db.select().from(productOrders).where(
        and10(
          eq10(productOrders.id, orderId),
          eq10(productOrders.customerId, userId)
        )
      ).limit(1);
      if (!order || order.length === 0) {
        return res.status(400).json({ error: "Order not found or not owned by user" });
      }
      const orderItem = await db.select().from(productOrderItems).where(
        and10(
          eq10(productOrderItems.orderId, orderId),
          eq10(productOrderItems.productId, productId)
        )
      ).limit(1);
      if (!orderItem || orderItem.length === 0) {
        return res.status(400).json({ error: "Product not found in this order" });
      }
      const product = await db.select().from(products).where(eq10(products.id, productId)).limit(1);
      if (!product || product.length === 0) {
        return res.status(404).json({ error: "Product not found" });
      }
      await db.insert(productReviews).values({
        productId,
        orderId,
        userId,
        salonId: product[0].salonId,
        rating,
        title,
        comment,
        imageUrls,
        verifiedPurchase: 1,
        isVisible: 1,
        moderationStatus: "approved"
      }).returning();
      res.json({ success: true, message: "Review submitted successfully" });
    } catch (error) {
      if (error.code === "23505") {
        return res.status(400).json({ error: "You have already reviewed this product from this order" });
      }
      console.error("Create review error:", error);
      res.status(500).json({ error: "Failed to submit review" });
    }
  });
  console.log("\u2705 Shop routes registered");
}

// server/routes/payment.routes.ts
import express from "express";
import Razorpay3 from "razorpay";
import crypto5 from "crypto";
init_db();
init_schema();
import { eq as eq11, and as and11, inArray as inArray6 } from "drizzle-orm";
var router3 = express.Router();
var razorpay3 = new Razorpay3({
  key_id: process.env.RAZORPAY_KEY_ID || "",
  key_secret: process.env.RAZORPAY_KEY_SECRET || ""
});
router3.post("/create-razorpay-order", authenticateMobileUser, async (req, res) => {
  try {
    const userId = req.user.id;
    const { salonId, fulfillmentType } = req.body;
    const userCarts = await db.select().from(shoppingCarts).where(
      and11(
        eq11(shoppingCarts.userId, userId),
        eq11(shoppingCarts.status, "active"),
        salonId ? eq11(shoppingCarts.salonId, salonId) : void 0
      )
    );
    if (!userCarts || userCarts.length === 0) {
      return res.status(400).json({ error: "No active cart found" });
    }
    const cartIds = userCarts.map((c) => c.id);
    const items = await db.select().from(cartItems).leftJoin(products, eq11(cartItems.productId, products.id)).where(inArray6(cartItems.cartId, cartIds));
    if (items.length === 0) {
      return res.status(400).json({ error: "Cart is empty" });
    }
    let subtotalPaisa = 0;
    let taxPaisa = 0;
    for (const item of items) {
      if (!item.products) continue;
      const quantity = item.cart_items.quantity;
      const unitPrice = item.products.retailPriceInPaisa || 0;
      const itemSubtotal = unitPrice * quantity;
      const itemTax = Math.round(itemSubtotal * 0.18);
      subtotalPaisa += itemSubtotal;
      taxPaisa += itemTax;
    }
    const deliveryChargePaisa = fulfillmentType === "delivery" ? 5e3 : 0;
    const totalPaisa = subtotalPaisa + taxPaisa + deliveryChargePaisa;
    if (totalPaisa <= 0) {
      return res.status(400).json({ error: "Invalid cart total" });
    }
    const orderNumber = `RZP${Date.now()}${Math.random().toString(36).substr(2, 4).toUpperCase()}`;
    const options = {
      amount: totalPaisa,
      currency: "INR",
      receipt: orderNumber,
      notes: {
        userId,
        salonId: salonId || userCarts[0].salonId,
        fulfillmentType
      }
    };
    const order = await razorpay3.orders.create(options);
    res.json({
      success: true,
      order: {
        id: order.id,
        amount: order.amount,
        currency: order.currency,
        receipt: order.receipt
      },
      keyId: process.env.RAZORPAY_KEY_ID
    });
  } catch (error) {
    console.error("Razorpay order creation error:", error);
    res.status(500).json({
      error: "Failed to create payment order",
      message: error.message
    });
  }
});
router3.post("/verify-payment", authenticateMobileUser, async (req, res) => {
  try {
    const {
      razorpay_order_id,
      razorpay_payment_id,
      razorpay_signature
    } = req.body;
    if (!razorpay_order_id || !razorpay_payment_id || !razorpay_signature) {
      return res.status(400).json({ error: "Missing payment verification parameters" });
    }
    const sign = razorpay_order_id + "|" + razorpay_payment_id;
    const expectedSign = crypto5.createHmac("sha256", process.env.RAZORPAY_KEY_SECRET || "").update(sign).digest("hex");
    if (razorpay_signature !== expectedSign) {
      return res.status(400).json({
        success: false,
        error: "Invalid payment signature"
      });
    }
    const razorpayOrder = await razorpay3.orders.fetch(razorpay_order_id);
    const payment = await razorpay3.payments.fetch(razorpay_payment_id);
    if (payment.order_id !== razorpay_order_id) {
      return res.status(400).json({
        success: false,
        error: "Payment does not match order"
      });
    }
    if (payment.status !== "captured" && payment.status !== "authorized") {
      return res.status(400).json({
        success: false,
        error: "Payment not completed"
      });
    }
    res.json({
      success: true,
      message: "Payment verified successfully",
      payment: {
        id: razorpay_payment_id,
        orderId: razorpay_order_id,
        amount: razorpayOrder.amount,
        status: payment.status
      }
    });
  } catch (error) {
    console.error("Payment verification error:", error);
    res.status(500).json({
      error: "Payment verification failed",
      message: error.message
    });
  }
});
var payment_routes_default = router3;

// server/routes/wallet.routes.ts
init_db();
init_schema();
import { eq as eq12, desc as desc6, and as and12 } from "drizzle-orm";
import Razorpay4 from "razorpay";
import crypto6 from "crypto";
var razorpay4 = new Razorpay4({
  key_id: process.env.RAZORPAY_KEY_ID || "",
  key_secret: process.env.RAZORPAY_KEY_SECRET || ""
});
function registerWalletRoutes(app2) {
  app2.get("/api/mobile/wallet", authenticateMobileUser, async (req, res) => {
    try {
      const userId = req.user.id;
      let wallet = await db.query.userWallets.findFirst({
        where: eq12(userWallets.userId, userId)
      });
      if (!wallet) {
        const [newWallet] = await db.insert(userWallets).values({
          userId,
          balanceInPaisa: 0,
          lifetimeEarnedInPaisa: 0,
          lifetimeSpentInPaisa: 0
        }).returning();
        wallet = newWallet;
      }
      res.json({
        success: true,
        wallet: {
          id: wallet.id,
          balance: wallet.balanceInPaisa,
          lifetimeEarned: wallet.lifetimeEarnedInPaisa,
          lifetimeSpent: wallet.lifetimeSpentInPaisa
        }
      });
    } catch (error) {
      console.error("Error fetching wallet:", error);
      res.status(500).json({ error: "Failed to fetch wallet" });
    }
  });
  app2.get("/api/mobile/wallet/transactions", authenticateMobileUser, async (req, res) => {
    try {
      const userId = req.user.id;
      const limit = parseInt(req.query.limit) || 20;
      const offset = parseInt(req.query.offset) || 0;
      const transactions = await db.query.walletTransactions.findMany({
        where: eq12(walletTransactions.userId, userId),
        orderBy: [desc6(walletTransactions.createdAt)],
        limit,
        offset
      });
      res.json({
        success: true,
        transactions: transactions.map((t) => ({
          id: t.id,
          type: t.type,
          amount: t.amountInPaisa,
          reason: t.reason,
          bookingId: t.bookingId,
          offerId: t.offerId,
          createdAt: t.createdAt
        }))
      });
    } catch (error) {
      console.error("Error fetching wallet transactions:", error);
      res.status(500).json({ error: "Failed to fetch transactions" });
    }
  });
  app2.post("/api/mobile/wallet/add-money/create-order", authenticateMobileUser, async (req, res) => {
    try {
      if (!razorpay4) {
        return res.status(503).json({ error: "Payment service unavailable" });
      }
      const userId = req.user.id;
      const { amountInPaisa } = req.body;
      if (!amountInPaisa || amountInPaisa < 100) {
        return res.status(400).json({ error: "Minimum amount is \u20B91" });
      }
      if (amountInPaisa > 1e6) {
        return res.status(400).json({ error: "Maximum amount is \u20B910,000" });
      }
      const order = await razorpay4.orders.create({
        amount: amountInPaisa,
        currency: "INR",
        receipt: `wallet_${userId}_${Date.now()}`,
        notes: {
          userId,
          type: "wallet_topup"
        }
      });
      res.json({
        success: true,
        orderId: order.id,
        amount: amountInPaisa,
        currency: "INR",
        keyId: process.env.RAZORPAY_KEY_ID
      });
    } catch (error) {
      console.error("Error creating wallet order:", error);
      res.status(500).json({ error: "Failed to create payment order" });
    }
  });
  app2.post("/api/mobile/wallet/add-money/verify", authenticateMobileUser, async (req, res) => {
    try {
      const userId = req.user.id;
      const { razorpay_order_id, razorpay_payment_id, razorpay_signature, amountInPaisa } = req.body;
      if (!razorpay_order_id || !razorpay_payment_id || !razorpay_signature) {
        return res.status(400).json({ error: "Missing payment details" });
      }
      const body = razorpay_order_id + "|" + razorpay_payment_id;
      const expectedSignature = crypto6.createHmac("sha256", process.env.RAZORPAY_KEY_SECRET || "").update(body.toString()).digest("hex");
      if (expectedSignature !== razorpay_signature) {
        return res.status(400).json({ error: "Invalid payment signature" });
      }
      let wallet = await db.query.userWallets.findFirst({
        where: eq12(userWallets.userId, userId)
      });
      if (!wallet) {
        const [newWallet] = await db.insert(userWallets).values({
          userId,
          balanceInPaisa: 0,
          lifetimeEarnedInPaisa: 0,
          lifetimeSpentInPaisa: 0
        }).returning();
        wallet = newWallet;
      }
      await db.update(userWallets).set({
        balanceInPaisa: wallet.balanceInPaisa + amountInPaisa,
        lifetimeEarnedInPaisa: wallet.lifetimeEarnedInPaisa + amountInPaisa,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq12(userWallets.id, wallet.id));
      await db.insert(walletTransactions).values({
        walletId: wallet.id,
        userId,
        type: "credit",
        amountInPaisa,
        reason: "wallet_topup"
      });
      const updatedWallet = await db.query.userWallets.findFirst({
        where: eq12(userWallets.userId, userId)
      });
      res.json({
        success: true,
        message: "Money added successfully",
        wallet: {
          balance: updatedWallet?.balanceInPaisa || 0,
          lifetimeEarned: updatedWallet?.lifetimeEarnedInPaisa || 0
        }
      });
    } catch (error) {
      console.error("Error verifying wallet payment:", error);
      res.status(500).json({ error: "Failed to verify payment" });
    }
  });
  app2.post("/api/mobile/wallet/use", authenticateMobileUser, async (req, res) => {
    try {
      const userId = req.user.id;
      const { amountInPaisa, bookingId, reason } = req.body;
      if (!amountInPaisa || amountInPaisa < 0) {
        return res.status(400).json({ error: "Invalid amount" });
      }
      const wallet = await db.query.userWallets.findFirst({
        where: eq12(userWallets.userId, userId)
      });
      if (!wallet) {
        return res.status(404).json({ error: "Wallet not found" });
      }
      if (wallet.balanceInPaisa < amountInPaisa) {
        return res.status(400).json({ error: "Insufficient wallet balance" });
      }
      await db.update(userWallets).set({
        balanceInPaisa: wallet.balanceInPaisa - amountInPaisa,
        lifetimeSpentInPaisa: wallet.lifetimeSpentInPaisa + amountInPaisa,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq12(userWallets.id, wallet.id));
      await db.insert(walletTransactions).values({
        walletId: wallet.id,
        userId,
        type: "debit",
        amountInPaisa,
        reason: reason || "payment",
        bookingId
      });
      const updatedWallet = await db.query.userWallets.findFirst({
        where: eq12(userWallets.userId, userId)
      });
      res.json({
        success: true,
        message: "Wallet payment successful",
        wallet: {
          balance: updatedWallet?.balanceInPaisa || 0
        }
      });
    } catch (error) {
      console.error("Error using wallet:", error);
      res.status(500).json({ error: "Failed to process wallet payment" });
    }
  });
  app2.get("/api/mobile/payment-methods", authenticateMobileUser, async (req, res) => {
    try {
      const userId = req.user.id;
      const cards = await db.query.customerSavedCards.findMany({
        where: and12(
          eq12(customerSavedCards.customerId, userId),
          eq12(customerSavedCards.isActive, 1)
        ),
        orderBy: [desc6(customerSavedCards.createdAt)]
      });
      res.json({
        success: true,
        cards: cards.map((card) => ({
          id: card.id,
          last4: card.cardLast4,
          cardType: card.cardNetwork || card.cardType || "card",
          expiryMonth: String(card.expiryMonth || "").padStart(2, "0"),
          expiryYear: String(card.expiryYear || "").slice(-2),
          cardholderName: card.nickname || "",
          isDefault: card.isDefault === 1,
          createdAt: card.createdAt
        }))
      });
    } catch (error) {
      console.error("Error fetching saved cards:", error);
      res.status(500).json({ error: "Failed to fetch saved cards" });
    }
  });
  app2.delete("/api/mobile/payment-methods/:cardId", authenticateMobileUser, async (req, res) => {
    try {
      const userId = req.user.id;
      const { cardId } = req.params;
      const card = await db.query.customerSavedCards.findFirst({
        where: and12(
          eq12(customerSavedCards.id, cardId),
          eq12(customerSavedCards.customerId, userId)
        )
      });
      if (!card) {
        return res.status(404).json({ error: "Card not found" });
      }
      await db.update(customerSavedCards).set({ isActive: 0, updatedAt: /* @__PURE__ */ new Date() }).where(eq12(customerSavedCards.id, cardId));
      res.json({
        success: true,
        message: "Card removed successfully"
      });
    } catch (error) {
      console.error("Error deleting saved card:", error);
      res.status(500).json({ error: "Failed to remove card" });
    }
  });
  app2.post("/api/mobile/payment-methods/:cardId/set-default", authenticateMobileUser, async (req, res) => {
    try {
      const userId = req.user.id;
      const { cardId } = req.params;
      const card = await db.query.customerSavedCards.findFirst({
        where: and12(
          eq12(customerSavedCards.id, cardId),
          eq12(customerSavedCards.customerId, userId),
          eq12(customerSavedCards.isActive, 1)
        )
      });
      if (!card) {
        return res.status(404).json({ error: "Card not found" });
      }
      await db.update(customerSavedCards).set({ isDefault: 0, updatedAt: /* @__PURE__ */ new Date() }).where(and12(
        eq12(customerSavedCards.customerId, userId),
        eq12(customerSavedCards.isActive, 1)
      ));
      await db.update(customerSavedCards).set({ isDefault: 1, updatedAt: /* @__PURE__ */ new Date() }).where(eq12(customerSavedCards.id, cardId));
      res.json({
        success: true,
        message: "Default card updated"
      });
    } catch (error) {
      console.error("Error setting default card:", error);
      res.status(500).json({ error: "Failed to set default card" });
    }
  });
  console.log("\u2705 Mobile wallet routes registered");
}

// server/routes/notification.routes.ts
init_db();
init_schema();
import { eq as eq13, desc as desc7, and as and13, sql as sql10 } from "drizzle-orm";
function registerNotificationRoutes(app2) {
  app2.get("/api/mobile/notifications", authenticateMobileUser, async (req, res) => {
    try {
      const userId = req.user.id;
      const limit = parseInt(req.query.limit) || 20;
      const offset = parseInt(req.query.offset) || 0;
      const unreadOnly = req.query.unreadOnly === "true";
      let whereCondition = eq13(userNotifications.userId, userId);
      if (unreadOnly) {
        whereCondition = and13(
          eq13(userNotifications.userId, userId),
          eq13(userNotifications.isRead, 0)
        );
      }
      const notifications = await db.query.userNotifications.findMany({
        where: whereCondition,
        orderBy: [desc7(userNotifications.createdAt)],
        limit,
        offset
      });
      res.json({
        success: true,
        notifications: notifications.map((n) => ({
          id: n.id,
          title: n.title,
          message: n.message,
          type: n.type,
          referenceId: n.referenceId,
          referenceType: n.referenceType,
          isRead: n.isRead === 1,
          readAt: n.readAt,
          imageUrl: n.imageUrl,
          actionUrl: n.actionUrl,
          createdAt: n.createdAt
        }))
      });
    } catch (error) {
      console.error("Error fetching notifications:", error);
      res.status(500).json({ error: "Failed to fetch notifications" });
    }
  });
  app2.get("/api/mobile/notifications/count", authenticateMobileUser, async (req, res) => {
    try {
      const userId = req.user.id;
      const result = await db.select({ count: sql10`count(*)` }).from(userNotifications).where(and13(
        eq13(userNotifications.userId, userId),
        eq13(userNotifications.isRead, 0)
      ));
      res.json({
        success: true,
        unreadCount: result[0]?.count || 0
      });
    } catch (error) {
      console.error("Error fetching notification count:", error);
      res.status(500).json({ error: "Failed to fetch notification count" });
    }
  });
  app2.post("/api/mobile/notifications/:id/read", authenticateMobileUser, async (req, res) => {
    try {
      const userId = req.user.id;
      const notificationId = req.params.id;
      const notification = await db.query.userNotifications.findFirst({
        where: and13(
          eq13(userNotifications.id, notificationId),
          eq13(userNotifications.userId, userId)
        )
      });
      if (!notification) {
        return res.status(404).json({ error: "Notification not found" });
      }
      await db.update(userNotifications).set({
        isRead: 1,
        readAt: /* @__PURE__ */ new Date()
      }).where(eq13(userNotifications.id, notificationId));
      res.json({
        success: true,
        message: "Notification marked as read"
      });
    } catch (error) {
      console.error("Error marking notification as read:", error);
      res.status(500).json({ error: "Failed to mark notification as read" });
    }
  });
  app2.post("/api/mobile/notifications/read-all", authenticateMobileUser, async (req, res) => {
    try {
      const userId = req.user.id;
      await db.update(userNotifications).set({
        isRead: 1,
        readAt: /* @__PURE__ */ new Date()
      }).where(and13(
        eq13(userNotifications.userId, userId),
        eq13(userNotifications.isRead, 0)
      ));
      res.json({
        success: true,
        message: "All notifications marked as read"
      });
    } catch (error) {
      console.error("Error marking all notifications as read:", error);
      res.status(500).json({ error: "Failed to mark notifications as read" });
    }
  });
  app2.delete("/api/mobile/notifications/:id", authenticateMobileUser, async (req, res) => {
    try {
      const userId = req.user.id;
      const notificationId = req.params.id;
      const notification = await db.query.userNotifications.findFirst({
        where: and13(
          eq13(userNotifications.id, notificationId),
          eq13(userNotifications.userId, userId)
        )
      });
      if (!notification) {
        return res.status(404).json({ error: "Notification not found" });
      }
      await db.delete(userNotifications).where(eq13(userNotifications.id, notificationId));
      res.json({
        success: true,
        message: "Notification deleted"
      });
    } catch (error) {
      console.error("Error deleting notification:", error);
      res.status(500).json({ error: "Failed to delete notification" });
    }
  });
  app2.post("/api/mobile/notifications/register-token", authenticateMobileUser, async (req, res) => {
    try {
      const userId = req.user.id;
      const { token, platform, deviceId, deviceName } = req.body;
      if (!token) {
        return res.status(400).json({ error: "Token is required" });
      }
      const effectiveDeviceId = deviceId || `device_${token.substring(0, 32)}`;
      const existingTokenRecord = await db.query.userPushTokens.findFirst({
        where: and13(
          eq13(userPushTokens.userId, userId),
          eq13(userPushTokens.token, token)
        )
      });
      if (existingTokenRecord) {
        await db.update(userPushTokens).set({
          platform: platform || existingTokenRecord.platform,
          deviceId: effectiveDeviceId,
          deviceName: deviceName || existingTokenRecord.deviceName,
          isActive: 1,
          lastUsedAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq13(userPushTokens.id, existingTokenRecord.id));
      } else {
        await db.update(userPushTokens).set({ isActive: 0, updatedAt: /* @__PURE__ */ new Date() }).where(and13(
          eq13(userPushTokens.userId, userId),
          eq13(userPushTokens.deviceId, effectiveDeviceId)
        ));
        await db.insert(userPushTokens).values({
          userId,
          token,
          platform: platform || "unknown",
          deviceId: effectiveDeviceId,
          deviceName: deviceName || null
        });
      }
      console.log(`Push token registered for user ${userId} (device: ${effectiveDeviceId.substring(0, 20)}...)`);
      res.json({
        success: true,
        message: "Push token registered successfully"
      });
    } catch (error) {
      console.error("Error registering push token:", error);
      res.status(500).json({ error: "Failed to register push token" });
    }
  });
  app2.post("/api/mobile/notifications/unregister-token", authenticateMobileUser, async (req, res) => {
    try {
      const userId = req.user.id;
      const { token } = req.body;
      if (!token) {
        return res.status(400).json({ error: "Token is required" });
      }
      const existingToken = await db.query.userPushTokens.findFirst({
        where: and13(
          eq13(userPushTokens.userId, userId),
          eq13(userPushTokens.token, token)
        )
      });
      if (!existingToken) {
        return res.json({
          success: true,
          message: "Token not found or already unregistered"
        });
      }
      await db.update(userPushTokens).set({
        isActive: 0,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq13(userPushTokens.id, existingToken.id));
      console.log(`Push token unregistered for user ${userId}`);
      res.json({
        success: true,
        message: "Push token unregistered successfully"
      });
    } catch (error) {
      console.error("Error unregistering push token:", error);
      res.status(500).json({ error: "Failed to unregister push token" });
    }
  });
  console.log("\u2705 Mobile notification routes registered");
}

// server/middleware/authChat.ts
init_storage();
async function authenticateChatUser(req, res, next) {
  try {
    if (req.session?.userId) {
      const user = await storage.getUser(req.session.userId);
      if (user) {
        req.user = { id: user.id };
        return next();
      }
    }
    const token = extractBearerToken(req.headers.authorization);
    if (token) {
      try {
        const decoded = await verifyAccessToken(token);
        req.user = { id: decoded.userId };
        return next();
      } catch (tokenError) {
      }
    }
    res.status(401).json({ error: "Authentication required" });
  } catch (error) {
    console.error("Chat authentication error:", error);
    res.status(401).json({ error: "Authentication failed" });
  }
}

// server/routes/loyalty.ts
init_db();
init_schema();
import { Router as Router3 } from "express";
import { eq as eq14, desc as desc8, and as and14, gte as gte3, lte as lte3, sql as sql11, isNull as isNull3, or as or5 } from "drizzle-orm";
var router4 = Router3();
function generateRedemptionCode() {
  const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
  let code = "RWD";
  for (let i = 0; i < 8; i++) {
    code += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return code;
}
async function ensureUserPoints(userId) {
  const existing = await db.select().from(userPoints).where(eq14(userPoints.userId, userId)).limit(1);
  if (existing.length === 0) {
    const bronzeTier = await db.select().from(loyaltyTiers).where(eq14(loyaltyTiers.name, "bronze")).limit(1);
    await db.insert(userPoints).values({
      userId,
      currentPoints: 0,
      lifetimePoints: 0,
      currentTierId: bronzeTier[0]?.id || null
    });
    return (await db.select().from(userPoints).where(eq14(userPoints.userId, userId)).limit(1))[0];
  }
  return existing[0];
}
async function calculateUserTier(lifetimePoints) {
  const tiers = await db.select().from(loyaltyTiers).where(eq14(loyaltyTiers.isActive, 1)).orderBy(desc8(loyaltyTiers.minPoints));
  for (const tier of tiers) {
    if (lifetimePoints >= tier.minPoints) {
      return tier;
    }
  }
  return tiers[tiers.length - 1];
}
router4.get("/tiers", async (req, res) => {
  try {
    const tiers = await db.select().from(loyaltyTiers).where(eq14(loyaltyTiers.isActive, 1)).orderBy(loyaltyTiers.sortOrder);
    res.json({ success: true, tiers });
  } catch (error) {
    console.error("Error fetching loyalty tiers:", error);
    res.status(500).json({ success: false, error: "Failed to fetch loyalty tiers" });
  }
});
router4.get("/points", async (req, res) => {
  try {
    const userId = req.userId;
    if (!userId) {
      return res.status(401).json({ success: false, error: "Unauthorized" });
    }
    const userPointsData = await ensureUserPoints(userId);
    let currentTier = null;
    if (userPointsData.currentTierId) {
      const tierData = await db.select().from(loyaltyTiers).where(eq14(loyaltyTiers.id, userPointsData.currentTierId)).limit(1);
      currentTier = tierData[0] || null;
    }
    const allTiers = await db.select().from(loyaltyTiers).where(eq14(loyaltyTiers.isActive, 1)).orderBy(loyaltyTiers.sortOrder);
    let nextTier = null;
    let pointsToNextTier = 0;
    if (currentTier) {
      const nextTierData = allTiers.find((t) => t.minPoints > (currentTier?.minPoints || 0));
      if (nextTierData) {
        nextTier = nextTierData;
        pointsToNextTier = nextTierData.minPoints - userPointsData.lifetimePoints;
      }
    }
    res.json({
      success: true,
      points: {
        current: userPointsData.currentPoints,
        lifetime: userPointsData.lifetimePoints,
        lastEarnedAt: userPointsData.lastPointsEarnedAt
      },
      tier: currentTier,
      nextTier,
      pointsToNextTier: Math.max(0, pointsToNextTier),
      allTiers
    });
  } catch (error) {
    console.error("Error fetching user points:", error);
    res.status(500).json({ success: false, error: "Failed to fetch user points" });
  }
});
router4.get("/transactions", async (req, res) => {
  try {
    const userId = req.userId;
    if (!userId) {
      return res.status(401).json({ success: false, error: "Unauthorized" });
    }
    const limit = parseInt(req.query.limit) || 20;
    const offset = parseInt(req.query.offset) || 0;
    const type = req.query.type;
    let query = db.select().from(pointTransactions).where(eq14(pointTransactions.userId, userId)).orderBy(desc8(pointTransactions.createdAt)).limit(limit).offset(offset);
    if (type) {
      query = db.select().from(pointTransactions).where(and14(
        eq14(pointTransactions.userId, userId),
        eq14(pointTransactions.type, type)
      )).orderBy(desc8(pointTransactions.createdAt)).limit(limit).offset(offset);
    }
    const transactions = await query;
    res.json({ success: true, transactions });
  } catch (error) {
    console.error("Error fetching transactions:", error);
    res.status(500).json({ success: false, error: "Failed to fetch transactions" });
  }
});
router4.post("/earn", async (req, res) => {
  try {
    const userId = req.userId;
    if (!userId) {
      return res.status(401).json({ success: false, error: "Unauthorized" });
    }
    const { points, source, referenceId, referenceType, description } = req.body;
    if (!points || points <= 0) {
      return res.status(400).json({ success: false, error: "Invalid points amount" });
    }
    const userPointsData = await ensureUserPoints(userId);
    let multiplier = 1;
    if (userPointsData.currentTierId) {
      const tier = await db.select().from(loyaltyTiers).where(eq14(loyaltyTiers.id, userPointsData.currentTierId)).limit(1);
      if (tier[0]) {
        multiplier = parseFloat(tier[0].pointsMultiplier || "1");
      }
    }
    const earnedPoints = Math.floor(points * multiplier);
    const newBalance = userPointsData.currentPoints + earnedPoints;
    const newLifetime = userPointsData.lifetimePoints + earnedPoints;
    const expiresAt = /* @__PURE__ */ new Date();
    expiresAt.setFullYear(expiresAt.getFullYear() + 1);
    await db.insert(pointTransactions).values({
      userId,
      type: "earn",
      points: earnedPoints,
      balanceAfter: newBalance,
      source: source || "booking",
      referenceId,
      referenceType,
      description: description || `Earned ${earnedPoints} points`,
      expiresAt
    });
    const newTier = await calculateUserTier(newLifetime);
    await db.update(userPoints).set({
      currentPoints: newBalance,
      lifetimePoints: newLifetime,
      currentTierId: newTier?.id,
      lastPointsEarnedAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq14(userPoints.userId, userId));
    res.json({
      success: true,
      pointsEarned: earnedPoints,
      newBalance,
      newLifetime,
      tier: newTier
    });
  } catch (error) {
    console.error("Error earning points:", error);
    res.status(500).json({ success: false, error: "Failed to earn points" });
  }
});
router4.get("/rewards", async (req, res) => {
  try {
    const userId = req.userId;
    const category = req.query.category;
    const limit = parseInt(req.query.limit) || 20;
    const offset = parseInt(req.query.offset) || 0;
    const now = /* @__PURE__ */ new Date();
    let conditions = [
      eq14(rewards.isActive, 1),
      or5(isNull3(rewards.startDate), lte3(rewards.startDate, now)),
      or5(isNull3(rewards.endDate), gte3(rewards.endDate, now))
    ];
    if (category) {
      conditions.push(eq14(rewards.category, category));
    }
    const rewardsList = await db.select().from(rewards).where(and14(...conditions)).orderBy(rewards.sortOrder, rewards.pointsCost).limit(limit).offset(offset);
    let userTier = null;
    let userCurrentPoints = 0;
    if (userId) {
      const userPointsData = await ensureUserPoints(userId);
      userCurrentPoints = userPointsData.currentPoints;
      if (userPointsData.currentTierId) {
        const tierData = await db.select().from(loyaltyTiers).where(eq14(loyaltyTiers.id, userPointsData.currentTierId)).limit(1);
        userTier = tierData[0];
      }
    }
    const rewardsWithAvailability = rewardsList.map((reward) => {
      const canAfford = userCurrentPoints >= reward.pointsCost;
      let tierEligible = true;
      if (reward.minTierRequired && userTier) {
        tierEligible = (userTier.sortOrder || 0) >= 0;
      }
      const quantityAvailable = reward.totalQuantity === null ? null : reward.totalQuantity - reward.redeemedCount;
      return {
        ...reward,
        canAfford,
        tierEligible,
        quantityAvailable,
        isAvailable: canAfford && tierEligible && (quantityAvailable === null || quantityAvailable > 0)
      };
    });
    res.json({ success: true, rewards: rewardsWithAvailability, userPoints: userCurrentPoints });
  } catch (error) {
    console.error("Error fetching rewards:", error);
    res.status(500).json({ success: false, error: "Failed to fetch rewards" });
  }
});
router4.post("/rewards/:rewardId/redeem", async (req, res) => {
  try {
    const userId = req.userId;
    if (!userId) {
      return res.status(401).json({ success: false, error: "Unauthorized" });
    }
    const { rewardId } = req.params;
    const reward = await db.select().from(rewards).where(eq14(rewards.id, rewardId)).limit(1);
    if (!reward[0]) {
      return res.status(404).json({ success: false, error: "Reward not found" });
    }
    const rewardData = reward[0];
    if (!rewardData.isActive) {
      return res.status(400).json({ success: false, error: "This reward is no longer available" });
    }
    if (rewardData.totalQuantity !== null && rewardData.redeemedCount >= rewardData.totalQuantity) {
      return res.status(400).json({ success: false, error: "This reward is sold out" });
    }
    const userPointsData = await ensureUserPoints(userId);
    if (userPointsData.currentPoints < rewardData.pointsCost) {
      return res.status(400).json({
        success: false,
        error: "Insufficient points",
        required: rewardData.pointsCost,
        available: userPointsData.currentPoints
      });
    }
    if (rewardData.maxRedemptionsPerUser) {
      const userRedemptions = await db.select({ count: sql11`count(*)` }).from(userRedeemedRewards).where(and14(
        eq14(userRedeemedRewards.userId, userId),
        eq14(userRedeemedRewards.rewardId, rewardId)
      ));
      if (userRedemptions[0].count >= rewardData.maxRedemptionsPerUser) {
        return res.status(400).json({
          success: false,
          error: "You have reached the maximum redemption limit for this reward"
        });
      }
    }
    const redemptionCode = generateRedemptionCode();
    const expiresAt = /* @__PURE__ */ new Date();
    expiresAt.setDate(expiresAt.getDate() + (rewardData.validityDays || 30));
    const newBalance = userPointsData.currentPoints - rewardData.pointsCost;
    await db.insert(pointTransactions).values({
      userId,
      type: "redeem",
      points: -rewardData.pointsCost,
      balanceAfter: newBalance,
      source: "reward",
      referenceId: rewardId,
      referenceType: "reward",
      description: `Redeemed: ${rewardData.name}`
    });
    await db.update(userPoints).set({
      currentPoints: newBalance,
      lastPointsRedeemedAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq14(userPoints.userId, userId));
    const [redeemedReward] = await db.insert(userRedeemedRewards).values({
      userId,
      rewardId,
      pointsSpent: rewardData.pointsCost,
      redemptionCode,
      status: "active",
      expiresAt
    }).returning();
    await db.update(rewards).set({ redeemedCount: rewardData.redeemedCount + 1 }).where(eq14(rewards.id, rewardId));
    res.json({
      success: true,
      redemption: {
        ...redeemedReward,
        reward: rewardData
      },
      newBalance
    });
  } catch (error) {
    console.error("Error redeeming reward:", error);
    res.status(500).json({ success: false, error: "Failed to redeem reward" });
  }
});
router4.get("/my-rewards", async (req, res) => {
  try {
    const userId = req.userId;
    if (!userId) {
      return res.status(401).json({ success: false, error: "Unauthorized" });
    }
    const status = req.query.status;
    const limit = parseInt(req.query.limit) || 20;
    const offset = parseInt(req.query.offset) || 0;
    let conditions = [eq14(userRedeemedRewards.userId, userId)];
    if (status) {
      conditions.push(eq14(userRedeemedRewards.status, status));
    }
    const redeemedRewards = await db.select({
      redemption: userRedeemedRewards,
      reward: rewards
    }).from(userRedeemedRewards).innerJoin(rewards, eq14(userRedeemedRewards.rewardId, rewards.id)).where(and14(...conditions)).orderBy(desc8(userRedeemedRewards.createdAt)).limit(limit).offset(offset);
    const formattedRewards = redeemedRewards.map((r) => ({
      ...r.redemption,
      reward: r.reward
    }));
    res.json({ success: true, rewards: formattedRewards });
  } catch (error) {
    console.error("Error fetching my rewards:", error);
    res.status(500).json({ success: false, error: "Failed to fetch your rewards" });
  }
});
var loyalty_default = router4;

// server/routes/favorites.ts
init_db();
init_schema();
import { Router as Router4 } from "express";
import { eq as eq15, and as and15, desc as desc9, sql as sql12 } from "drizzle-orm";
var router5 = Router4();
router5.get("/salons", async (req, res) => {
  try {
    const userId = req.userId;
    if (!userId) {
      return res.status(401).json({ success: false, error: "Unauthorized" });
    }
    const limit = parseInt(req.query.limit) || 20;
    const offset = parseInt(req.query.offset) || 0;
    const favorites = await db.select({
      favorite: favoriteSalons,
      salon: salons
    }).from(favoriteSalons).innerJoin(salons, eq15(favoriteSalons.salonId, salons.id)).where(eq15(favoriteSalons.userId, userId)).orderBy(desc9(favoriteSalons.createdAt)).limit(limit).offset(offset);
    const formattedSalons = favorites.map((f) => ({
      ...f.salon,
      favoriteId: f.favorite.id,
      favoritedAt: f.favorite.createdAt,
      isFavorite: true
    }));
    res.json({ success: true, salons: formattedSalons });
  } catch (error) {
    console.error("Error fetching favorite salons:", error);
    res.status(500).json({ success: false, error: "Failed to fetch favorite salons" });
  }
});
router5.post("/salons/:salonId", async (req, res) => {
  try {
    const userId = req.userId;
    if (!userId) {
      return res.status(401).json({ success: false, error: "Unauthorized" });
    }
    const { salonId } = req.params;
    const salon = await db.select().from(salons).where(eq15(salons.id, salonId)).limit(1);
    if (!salon[0]) {
      return res.status(404).json({ success: false, error: "Salon not found" });
    }
    const existing = await db.select().from(favoriteSalons).where(and15(
      eq15(favoriteSalons.userId, userId),
      eq15(favoriteSalons.salonId, salonId)
    )).limit(1);
    if (existing[0]) {
      return res.json({ success: true, message: "Already in favorites", favorite: existing[0] });
    }
    const [favorite] = await db.insert(favoriteSalons).values({
      userId,
      salonId
    }).returning();
    res.json({ success: true, message: "Added to favorites", favorite });
  } catch (error) {
    console.error("Error adding salon to favorites:", error);
    res.status(500).json({ success: false, error: "Failed to add to favorites" });
  }
});
router5.delete("/salons/:salonId", async (req, res) => {
  try {
    const userId = req.userId;
    if (!userId) {
      return res.status(401).json({ success: false, error: "Unauthorized" });
    }
    const { salonId } = req.params;
    await db.delete(favoriteSalons).where(and15(
      eq15(favoriteSalons.userId, userId),
      eq15(favoriteSalons.salonId, salonId)
    ));
    res.json({ success: true, message: "Removed from favorites" });
  } catch (error) {
    console.error("Error removing salon from favorites:", error);
    res.status(500).json({ success: false, error: "Failed to remove from favorites" });
  }
});
router5.get("/salons/:salonId/check", async (req, res) => {
  try {
    const userId = req.userId;
    if (!userId) {
      return res.json({ success: true, isFavorite: false });
    }
    const { salonId } = req.params;
    const existing = await db.select().from(favoriteSalons).where(and15(
      eq15(favoriteSalons.userId, userId),
      eq15(favoriteSalons.salonId, salonId)
    )).limit(1);
    res.json({ success: true, isFavorite: !!existing[0] });
  } catch (error) {
    console.error("Error checking favorite status:", error);
    res.status(500).json({ success: false, error: "Failed to check favorite status" });
  }
});
router5.get("/salons/ids", async (req, res) => {
  try {
    const userId = req.userId;
    if (!userId) {
      return res.json({ success: true, salonIds: [] });
    }
    const favorites = await db.select({ salonId: favoriteSalons.salonId }).from(favoriteSalons).where(eq15(favoriteSalons.userId, userId));
    const salonIds = favorites.map((f) => f.salonId);
    res.json({ success: true, salonIds });
  } catch (error) {
    console.error("Error fetching favorite salon IDs:", error);
    res.status(500).json({ success: false, error: "Failed to fetch favorite IDs" });
  }
});
router5.get("/stylists", async (req, res) => {
  try {
    const userId = req.userId;
    if (!userId) {
      return res.status(401).json({ success: false, error: "Unauthorized" });
    }
    const limit = parseInt(req.query.limit) || 20;
    const offset = parseInt(req.query.offset) || 0;
    const favorites = await db.select({
      favorite: favoriteStylists,
      stylist: staff,
      salon: salons
    }).from(favoriteStylists).innerJoin(staff, eq15(favoriteStylists.staffId, staff.id)).innerJoin(salons, eq15(staff.salonId, salons.id)).where(eq15(favoriteStylists.userId, userId)).orderBy(desc9(favoriteStylists.createdAt)).limit(limit).offset(offset);
    const formattedStylists = favorites.map((f) => ({
      ...f.stylist,
      salon: {
        id: f.salon.id,
        name: f.salon.name,
        address: f.salon.address,
        imageUrl: f.salon.imageUrl
      },
      favoriteId: f.favorite.id,
      favoritedAt: f.favorite.createdAt,
      isFavorite: true
    }));
    res.json({ success: true, stylists: formattedStylists });
  } catch (error) {
    console.error("Error fetching favorite stylists:", error);
    res.status(500).json({ success: false, error: "Failed to fetch favorite stylists" });
  }
});
router5.post("/stylists/:staffId", async (req, res) => {
  try {
    const userId = req.userId;
    if (!userId) {
      return res.status(401).json({ success: false, error: "Unauthorized" });
    }
    const { staffId } = req.params;
    const stylist = await db.select().from(staff).where(eq15(staff.id, staffId)).limit(1);
    if (!stylist[0]) {
      return res.status(404).json({ success: false, error: "Stylist not found" });
    }
    const existing = await db.select().from(favoriteStylists).where(and15(
      eq15(favoriteStylists.userId, userId),
      eq15(favoriteStylists.staffId, staffId)
    )).limit(1);
    if (existing[0]) {
      return res.json({ success: true, message: "Already in favorites", favorite: existing[0] });
    }
    const [favorite] = await db.insert(favoriteStylists).values({
      userId,
      staffId
    }).returning();
    res.json({ success: true, message: "Added to favorites", favorite });
  } catch (error) {
    console.error("Error adding stylist to favorites:", error);
    res.status(500).json({ success: false, error: "Failed to add to favorites" });
  }
});
router5.delete("/stylists/:staffId", async (req, res) => {
  try {
    const userId = req.userId;
    if (!userId) {
      return res.status(401).json({ success: false, error: "Unauthorized" });
    }
    const { staffId } = req.params;
    await db.delete(favoriteStylists).where(and15(
      eq15(favoriteStylists.userId, userId),
      eq15(favoriteStylists.staffId, staffId)
    ));
    res.json({ success: true, message: "Removed from favorites" });
  } catch (error) {
    console.error("Error removing stylist from favorites:", error);
    res.status(500).json({ success: false, error: "Failed to remove from favorites" });
  }
});
router5.get("/stylists/:staffId/check", async (req, res) => {
  try {
    const userId = req.userId;
    if (!userId) {
      return res.json({ success: true, isFavorite: false });
    }
    const { staffId } = req.params;
    const existing = await db.select().from(favoriteStylists).where(and15(
      eq15(favoriteStylists.userId, userId),
      eq15(favoriteStylists.staffId, staffId)
    )).limit(1);
    res.json({ success: true, isFavorite: !!existing[0] });
  } catch (error) {
    console.error("Error checking favorite status:", error);
    res.status(500).json({ success: false, error: "Failed to check favorite status" });
  }
});
router5.get("/count", async (req, res) => {
  try {
    const userId = req.userId;
    if (!userId) {
      return res.json({ success: true, salons: 0, stylists: 0 });
    }
    const [salonCount] = await db.select({ count: sql12`count(*)` }).from(favoriteSalons).where(eq15(favoriteSalons.userId, userId));
    const [stylistCount] = await db.select({ count: sql12`count(*)` }).from(favoriteStylists).where(eq15(favoriteStylists.userId, userId));
    res.json({
      success: true,
      salons: salonCount.count,
      stylists: stylistCount.count,
      total: salonCount.count + stylistCount.count
    });
  } catch (error) {
    console.error("Error fetching favorites count:", error);
    res.status(500).json({ success: false, error: "Failed to fetch count" });
  }
});
var favorites_default = router5;

// server/routes/referrals.ts
init_db();
init_schema();
import { Router as Router5 } from "express";
import { eq as eq16, and as and16, desc as desc10, sql as sql13 } from "drizzle-orm";
var router6 = Router5();
function generateReferralCode(userName) {
  const prefix = userName ? userName.substring(0, 4).toUpperCase().replace(/[^A-Z]/g, "X") : "SLHB";
  const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
  let suffix = "";
  for (let i = 0; i < 4; i++) {
    suffix += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return `${prefix}${suffix}`;
}
async function ensureUserReferralCode(userId, userName) {
  const existing = await db.select().from(referralCodes).where(eq16(referralCodes.userId, userId)).limit(1);
  if (existing[0]) {
    return existing[0];
  }
  let code = generateReferralCode(userName);
  let attempts = 0;
  while (attempts < 10) {
    const existingCode = await db.select().from(referralCodes).where(eq16(referralCodes.code, code)).limit(1);
    if (!existingCode[0]) {
      break;
    }
    code = generateReferralCode(userName);
    attempts++;
  }
  const [newCode] = await db.insert(referralCodes).values({
    userId,
    code,
    referrerRewardPoints: 200,
    refereeRewardPoints: 100,
    refereeDiscountPercentage: "10.00"
  }).returning();
  return newCode;
}
async function awardReferralPoints(userId, points, source, description, referenceId) {
  const userPointsData = await db.select().from(userPoints).where(eq16(userPoints.userId, userId)).limit(1);
  let currentPoints = 0;
  let lifetimePoints = 0;
  if (userPointsData[0]) {
    currentPoints = userPointsData[0].currentPoints;
    lifetimePoints = userPointsData[0].lifetimePoints;
  }
  const newBalance = currentPoints + points;
  const newLifetime = lifetimePoints + points;
  await db.insert(pointTransactions).values({
    userId,
    type: "referral",
    points,
    balanceAfter: newBalance,
    source,
    referenceId,
    referenceType: "referral",
    description
  });
  if (userPointsData[0]) {
    await db.update(userPoints).set({
      currentPoints: newBalance,
      lifetimePoints: newLifetime,
      lastPointsEarnedAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq16(userPoints.userId, userId));
  } else {
    await db.insert(userPoints).values({
      userId,
      currentPoints: newBalance,
      lifetimePoints: newLifetime,
      lastPointsEarnedAt: /* @__PURE__ */ new Date()
    });
  }
  return newBalance;
}
router6.get("/my-code", async (req, res) => {
  try {
    const userId = req.userId;
    if (!userId) {
      return res.status(401).json({ success: false, error: "Unauthorized" });
    }
    const user = await db.select({
      firstName: users.firstName,
      lastName: users.lastName
    }).from(users).where(eq16(users.id, userId)).limit(1);
    const userName = user[0]?.firstName || user[0]?.lastName || void 0;
    const referralCode = await ensureUserReferralCode(userId, userName);
    res.json({ success: true, referralCode });
  } catch (error) {
    console.error("Error fetching referral code:", error);
    res.status(500).json({ success: false, error: "Failed to fetch referral code" });
  }
});
router6.get("/stats", async (req, res) => {
  try {
    const userId = req.userId;
    if (!userId) {
      return res.status(401).json({ success: false, error: "Unauthorized" });
    }
    const [totalReferrals] = await db.select({ count: sql13`count(*)` }).from(referrals).where(eq16(referrals.referrerId, userId));
    const [successfulReferrals] = await db.select({ count: sql13`count(*)` }).from(referrals).where(and16(
      eq16(referrals.referrerId, userId),
      eq16(referrals.status, "rewarded")
    ));
    const [pendingReferrals] = await db.select({ count: sql13`count(*)` }).from(referrals).where(and16(
      eq16(referrals.referrerId, userId),
      eq16(referrals.status, "pending")
    ));
    const pointsEarned = await db.select({
      total: sql13`COALESCE(SUM(referrer_points_awarded), 0)`
    }).from(referrals).where(eq16(referrals.referrerId, userId));
    res.json({
      success: true,
      stats: {
        totalReferrals: totalReferrals.count,
        successfulReferrals: successfulReferrals.count,
        pendingReferrals: pendingReferrals.count,
        pointsEarned: pointsEarned[0]?.total || 0
      }
    });
  } catch (error) {
    console.error("Error fetching referral stats:", error);
    res.status(500).json({ success: false, error: "Failed to fetch referral stats" });
  }
});
router6.get("/history", async (req, res) => {
  try {
    const userId = req.userId;
    if (!userId) {
      return res.status(401).json({ success: false, error: "Unauthorized" });
    }
    const limit = parseInt(req.query.limit) || 20;
    const offset = parseInt(req.query.offset) || 0;
    const referralHistory = await db.select({
      referral: referrals,
      referee: {
        id: users.id,
        firstName: users.firstName,
        lastName: users.lastName,
        phone: users.phone,
        createdAt: users.createdAt
      }
    }).from(referrals).innerJoin(users, eq16(referrals.refereeId, users.id)).where(eq16(referrals.referrerId, userId)).orderBy(desc10(referrals.createdAt)).limit(limit).offset(offset);
    const formattedHistory = referralHistory.map((r) => ({
      ...r.referral,
      referee: {
        ...r.referee,
        name: `${r.referee.firstName || ""} ${r.referee.lastName || ""}`.trim() || "Unknown"
      }
    }));
    res.json({ success: true, referrals: formattedHistory });
  } catch (error) {
    console.error("Error fetching referral history:", error);
    res.status(500).json({ success: false, error: "Failed to fetch referral history" });
  }
});
router6.post("/validate", async (req, res) => {
  try {
    const userId = req.userId;
    const { code } = req.body;
    if (!code) {
      return res.status(400).json({ success: false, error: "Referral code is required" });
    }
    const referralCode = await db.select().from(referralCodes).where(and16(
      eq16(referralCodes.code, code.toUpperCase()),
      eq16(referralCodes.isActive, 1)
    )).limit(1);
    if (!referralCode[0]) {
      return res.status(404).json({ success: false, error: "Invalid referral code" });
    }
    const codeData = referralCode[0];
    if (userId && codeData.userId === userId) {
      return res.status(400).json({ success: false, error: "You cannot use your own referral code" });
    }
    if (userId) {
      const existingReferral = await db.select().from(referrals).where(eq16(referrals.refereeId, userId)).limit(1);
      if (existingReferral[0]) {
        return res.status(400).json({
          success: false,
          error: "You have already used a referral code"
        });
      }
    }
    if (codeData.maxUses !== null && codeData.usedCount >= codeData.maxUses) {
      return res.status(400).json({ success: false, error: "This referral code has reached its usage limit" });
    }
    if (codeData.expiresAt && new Date(codeData.expiresAt) < /* @__PURE__ */ new Date()) {
      return res.status(400).json({ success: false, error: "This referral code has expired" });
    }
    const referrer = await db.select({
      id: users.id,
      firstName: users.firstName,
      lastName: users.lastName
    }).from(users).where(eq16(users.id, codeData.userId)).limit(1);
    res.json({
      success: true,
      valid: true,
      referralCode: {
        code: codeData.code,
        refereeRewardPoints: codeData.refereeRewardPoints,
        refereeDiscountPercentage: codeData.refereeDiscountPercentage,
        referrerName: referrer[0] ? `${referrer[0].firstName || ""} ${referrer[0].lastName || ""}`.trim() : "A friend"
      }
    });
  } catch (error) {
    console.error("Error validating referral code:", error);
    res.status(500).json({ success: false, error: "Failed to validate referral code" });
  }
});
router6.post("/apply", async (req, res) => {
  try {
    const userId = req.userId;
    if (!userId) {
      return res.status(401).json({ success: false, error: "Unauthorized" });
    }
    const { code } = req.body;
    if (!code) {
      return res.status(400).json({ success: false, error: "Referral code is required" });
    }
    const existingReferral = await db.select().from(referrals).where(eq16(referrals.refereeId, userId)).limit(1);
    if (existingReferral[0]) {
      return res.status(400).json({
        success: false,
        error: "You have already used a referral code"
      });
    }
    const referralCode = await db.select().from(referralCodes).where(and16(
      eq16(referralCodes.code, code.toUpperCase()),
      eq16(referralCodes.isActive, 1)
    )).limit(1);
    if (!referralCode[0]) {
      return res.status(404).json({ success: false, error: "Invalid referral code" });
    }
    const codeData = referralCode[0];
    if (codeData.userId === userId) {
      return res.status(400).json({ success: false, error: "You cannot use your own referral code" });
    }
    if (codeData.maxUses !== null && codeData.usedCount >= codeData.maxUses) {
      return res.status(400).json({ success: false, error: "This referral code has reached its usage limit" });
    }
    if (codeData.expiresAt && new Date(codeData.expiresAt) < /* @__PURE__ */ new Date()) {
      return res.status(400).json({ success: false, error: "This referral code has expired" });
    }
    const [referral] = await db.insert(referrals).values({
      referrerId: codeData.userId,
      refereeId: userId,
      referralCodeId: codeData.id,
      status: "pending",
      refereePointsAwarded: codeData.refereeRewardPoints
    }).returning();
    await awardReferralPoints(
      userId,
      codeData.refereeRewardPoints,
      "referral_signup",
      `Welcome bonus from referral`,
      referral.id
    );
    await db.update(referralCodes).set({ usedCount: codeData.usedCount + 1 }).where(eq16(referralCodes.id, codeData.id));
    res.json({
      success: true,
      message: "Referral code applied successfully",
      pointsEarned: codeData.refereeRewardPoints,
      discountPercentage: codeData.refereeDiscountPercentage
    });
  } catch (error) {
    console.error("Error applying referral code:", error);
    res.status(500).json({ success: false, error: "Failed to apply referral code" });
  }
});
router6.post("/complete/:referralId", async (req, res) => {
  try {
    const { referralId } = req.params;
    const { bookingId } = req.body;
    const referral = await db.select().from(referrals).where(eq16(referrals.id, referralId)).limit(1);
    if (!referral[0]) {
      return res.status(404).json({ success: false, error: "Referral not found" });
    }
    if (referral[0].status === "rewarded") {
      return res.json({ success: true, message: "Referral already completed" });
    }
    const referralCode = await db.select().from(referralCodes).where(eq16(referralCodes.id, referral[0].referralCodeId)).limit(1);
    if (referralCode[0]) {
      await awardReferralPoints(
        referral[0].referrerId,
        referralCode[0].referrerRewardPoints,
        "referral_complete",
        `Referral reward - friend completed first booking`,
        referralId
      );
      await db.update(referrals).set({
        status: "rewarded",
        referrerPointsAwarded: referralCode[0].referrerRewardPoints,
        refereeFirstBookingId: bookingId,
        refereeFirstBookingAt: /* @__PURE__ */ new Date(),
        rewardedAt: /* @__PURE__ */ new Date()
      }).where(eq16(referrals.id, referralId));
    }
    res.json({ success: true, message: "Referral completed and rewards distributed" });
  } catch (error) {
    console.error("Error completing referral:", error);
    res.status(500).json({ success: false, error: "Failed to complete referral" });
  }
});
var referrals_default = router6;

// server/routes/chat.routes.ts
init_db();
init_schema();
import { Router as Router6 } from "express";
import { eq as eq17, and as and17, desc as desc11, lt as lt3, sql as sql14 } from "drizzle-orm";
import { z as z3 } from "zod";
var router7 = Router6();
var createConversationSchema = z3.object({
  salonId: z3.string(),
  context: z3.enum(["pre_booking", "booking_inquiry", "support"]).optional().default("pre_booking"),
  relatedServiceId: z3.string().optional(),
  relatedBookingId: z3.string().optional()
});
var sendMessageSchema = z3.object({
  body: z3.string().min(1).max(4e3),
  messageType: z3.enum(["text", "image", "file", "system"]).optional().default("text"),
  attachmentUrl: z3.string().optional(),
  attachmentType: z3.string().optional(),
  attachmentName: z3.string().optional(),
  attachmentSize: z3.number().optional()
});
router7.post("/conversations", async (req, res) => {
  try {
    const userId = req.user?.id;
    if (!userId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const validation = createConversationSchema.safeParse(req.body);
    if (!validation.success) {
      return res.status(400).json({ error: validation.error.errors });
    }
    const { salonId, context, relatedServiceId, relatedBookingId } = validation.data;
    const salon = await db.query.salons.findFirst({
      where: eq17(salons.id, salonId)
    });
    if (!salon) {
      return res.status(404).json({ error: "Salon not found" });
    }
    const existingConversation = await db.query.chatConversations.findFirst({
      where: and17(
        eq17(chatConversations.salonId, salonId),
        eq17(chatConversations.customerId, userId),
        eq17(chatConversations.status, "active")
      )
    });
    if (existingConversation) {
      return res.json({
        conversation: existingConversation,
        isNew: false
      });
    }
    const [conversation] = await db.insert(chatConversations).values({
      salonId,
      customerId: userId,
      context,
      relatedServiceId,
      relatedBookingId,
      status: "active"
    }).returning();
    await db.insert(chatParticipants).values({
      conversationId: conversation.id,
      userId,
      role: "customer"
    });
    if (salon.ownerId) {
      await db.insert(chatParticipants).values({
        conversationId: conversation.id,
        userId: salon.ownerId,
        role: "staff"
      }).onConflictDoNothing();
    }
    const salonStaff = await db.query.staff.findMany({
      where: eq17(staff.salonId, salonId),
      limit: 5
    });
    for (const staffMember of salonStaff) {
      if (staffMember.userId) {
        await db.insert(chatParticipants).values({
          conversationId: conversation.id,
          userId: staffMember.userId,
          role: "staff",
          staffId: staffMember.id
        }).onConflictDoNothing();
      }
    }
    const [systemMessage] = await db.insert(chatMessages).values({
      conversationId: conversation.id,
      senderId: userId,
      senderRole: "customer",
      messageType: "system",
      body: `Chat started with ${salon.name}`,
      sentAt: /* @__PURE__ */ new Date()
    }).returning();
    res.status(201).json({
      conversation,
      isNew: true
    });
  } catch (error) {
    console.error("Error creating conversation:", error);
    res.status(500).json({ error: "Failed to create conversation" });
  }
});
router7.get("/conversations", async (req, res) => {
  try {
    const userId = req.user?.id;
    if (!userId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const role = req.query.role;
    const status = req.query.status || "active";
    let conversations;
    if (role === "staff") {
      const requestedSalonId = req.query.salonId;
      let salonIdForQuery = null;
      if (requestedSalonId) {
        const userSalon = await db.query.salons.findFirst({
          where: eq17(salons.id, requestedSalonId)
        });
        if (userSalon && userSalon.ownerId === userId) {
          salonIdForQuery = requestedSalonId;
        } else {
          const userStaff = await db.query.staff.findFirst({
            where: and17(eq17(staff.userId, userId), eq17(staff.salonId, requestedSalonId))
          });
          if (userStaff) {
            salonIdForQuery = requestedSalonId;
          }
        }
      } else {
        const userStaff = await db.query.staff.findFirst({
          where: eq17(staff.userId, userId)
        });
        if (userStaff) {
          salonIdForQuery = userStaff.salonId;
        } else {
          const userSalon = await db.query.salons.findFirst({
            where: eq17(salons.ownerId, userId)
          });
          if (userSalon) {
            salonIdForQuery = userSalon.id;
          }
        }
      }
      if (!salonIdForQuery) {
        return res.json({ conversations: [] });
      }
      conversations = await db.query.chatConversations.findMany({
        where: and17(
          eq17(chatConversations.salonId, salonIdForQuery),
          eq17(chatConversations.status, status)
        ),
        with: {
          customer: {
            columns: {
              id: true,
              firstName: true,
              lastName: true,
              profileImageUrl: true
            }
          },
          salon: {
            columns: {
              id: true,
              name: true,
              imageUrl: true
            }
          }
        },
        orderBy: [desc11(chatConversations.lastMessageAt)]
      });
    } else {
      conversations = await db.query.chatConversations.findMany({
        where: and17(
          eq17(chatConversations.customerId, userId),
          eq17(chatConversations.status, status)
        ),
        with: {
          salon: {
            columns: {
              id: true,
              name: true,
              imageUrl: true,
              phone: true
            }
          },
          assignedStaff: {
            columns: {
              id: true,
              name: true,
              photoUrl: true
            }
          }
        },
        orderBy: [desc11(chatConversations.lastMessageAt)]
      });
    }
    res.json({ conversations });
  } catch (error) {
    console.error("Error fetching conversations:", error);
    res.status(500).json({ error: "Failed to fetch conversations" });
  }
});
router7.get("/conversations/:id", async (req, res) => {
  try {
    const userId = req.user?.id;
    if (!userId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const { id } = req.params;
    const participant = await db.query.chatParticipants.findFirst({
      where: and17(
        eq17(chatParticipants.conversationId, id),
        eq17(chatParticipants.userId, userId)
      )
    });
    if (!participant) {
      return res.status(403).json({ error: "Access denied" });
    }
    const conversation = await db.query.chatConversations.findFirst({
      where: eq17(chatConversations.id, id),
      with: {
        salon: {
          columns: {
            id: true,
            name: true,
            imageUrl: true,
            phone: true,
            address: true
          }
        },
        customer: {
          columns: {
            id: true,
            firstName: true,
            lastName: true,
            profileImageUrl: true
          }
        },
        assignedStaff: {
          columns: {
            id: true,
            name: true,
            photoUrl: true,
            roles: true
          }
        },
        participants: {
          with: {
            user: {
              columns: {
                id: true,
                firstName: true,
                lastName: true,
                profileImageUrl: true
              }
            }
          }
        }
      }
    });
    if (!conversation) {
      return res.status(404).json({ error: "Conversation not found" });
    }
    res.json({ conversation, participantRole: participant.role });
  } catch (error) {
    console.error("Error fetching conversation:", error);
    res.status(500).json({ error: "Failed to fetch conversation" });
  }
});
router7.get("/conversations/:id/messages", async (req, res) => {
  try {
    const userId = req.user?.id;
    if (!userId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const { id } = req.params;
    const cursor = req.query.cursor;
    const limit = Math.min(parseInt(req.query.limit) || 50, 100);
    const conversation = await db.query.chatConversations.findFirst({
      where: eq17(chatConversations.id, id)
    });
    if (!conversation) {
      return res.status(404).json({ error: "Conversation not found" });
    }
    let hasAccess = false;
    const participant = await db.query.chatParticipants.findFirst({
      where: and17(
        eq17(chatParticipants.conversationId, id),
        eq17(chatParticipants.userId, userId)
      )
    });
    if (participant) hasAccess = true;
    if (!hasAccess) {
      const salon = await db.query.salons.findFirst({
        where: eq17(salons.id, conversation.salonId)
      });
      if (salon && salon.ownerId === userId) hasAccess = true;
    }
    if (!hasAccess) {
      const userStaff = await db.query.staff.findFirst({
        where: and17(eq17(staff.userId, userId), eq17(staff.salonId, conversation.salonId))
      });
      if (userStaff) hasAccess = true;
    }
    if (!hasAccess) {
      return res.status(403).json({ error: "Access denied" });
    }
    let messages;
    if (cursor) {
      messages = await db.query.chatMessages.findMany({
        where: and17(
          eq17(chatMessages.conversationId, id),
          lt3(chatMessages.sentAt, new Date(cursor))
        ),
        orderBy: [desc11(chatMessages.sentAt)],
        limit: limit + 1
      });
    } else {
      messages = await db.query.chatMessages.findMany({
        where: eq17(chatMessages.conversationId, id),
        orderBy: [desc11(chatMessages.sentAt)],
        limit: limit + 1
      });
    }
    const hasMore = messages.length > limit;
    if (hasMore) {
      messages.pop();
    }
    messages.reverse();
    const nextCursor = hasMore && messages.length > 0 ? messages[0].sentAt?.toISOString() : null;
    res.json({
      messages,
      nextCursor,
      hasMore
    });
  } catch (error) {
    console.error("Error fetching messages:", error);
    res.status(500).json({ error: "Failed to fetch messages" });
  }
});
router7.post("/conversations/:id/messages", async (req, res) => {
  try {
    const userId = req.user?.id;
    if (!userId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const { id } = req.params;
    const validation = sendMessageSchema.safeParse(req.body);
    if (!validation.success) {
      return res.status(400).json({ error: validation.error.errors });
    }
    const conversation = await db.query.chatConversations.findFirst({
      where: eq17(chatConversations.id, id)
    });
    if (!conversation) {
      return res.status(404).json({ error: "Conversation not found" });
    }
    let hasAccess = false;
    let senderRole = "staff";
    const participant = await db.query.chatParticipants.findFirst({
      where: and17(
        eq17(chatParticipants.conversationId, id),
        eq17(chatParticipants.userId, userId)
      )
    });
    if (participant) {
      hasAccess = true;
      senderRole = participant.role;
    }
    if (!hasAccess) {
      const salon = await db.query.salons.findFirst({
        where: eq17(salons.id, conversation.salonId)
      });
      if (salon && salon.ownerId === userId) {
        hasAccess = true;
        senderRole = "staff";
      }
    }
    if (!hasAccess) {
      const userStaff = await db.query.staff.findFirst({
        where: and17(eq17(staff.userId, userId), eq17(staff.salonId, conversation.salonId))
      });
      if (userStaff) {
        hasAccess = true;
        senderRole = "staff";
      }
    }
    if (!hasAccess) {
      return res.status(403).json({ error: "Access denied" });
    }
    const user = await db.query.users.findFirst({
      where: eq17(users.id, userId),
      columns: {
        id: true,
        firstName: true,
        lastName: true,
        profileImageUrl: true
      }
    });
    const senderName = user ? `${user.firstName || ""} ${user.lastName || ""}`.trim() || "User" : "User";
    const { body, messageType, attachmentUrl, attachmentType, attachmentName, attachmentSize } = validation.data;
    const [message] = await db.insert(chatMessages).values({
      conversationId: id,
      senderId: userId,
      senderRole,
      senderName,
      senderAvatar: user?.profileImageUrl,
      messageType,
      body,
      attachmentUrl,
      attachmentType,
      attachmentName,
      attachmentSize,
      sentAt: /* @__PURE__ */ new Date(),
      deliveredAt: /* @__PURE__ */ new Date()
    }).returning();
    const preview = body?.substring(0, 100) || "";
    await db.update(chatConversations).set({
      lastMessageAt: /* @__PURE__ */ new Date(),
      lastMessagePreview: preview,
      updatedAt: /* @__PURE__ */ new Date(),
      ...senderRole === "customer" ? { staffUnreadCount: sql14`${chatConversations.staffUnreadCount} + 1` } : { customerUnreadCount: sql14`${chatConversations.customerUnreadCount} + 1` }
    }).where(eq17(chatConversations.id, id));
    res.status(201).json({ message });
  } catch (error) {
    console.error("Error sending message:", error);
    res.status(500).json({ error: "Failed to send message" });
  }
});
router7.post("/conversations/:id/read", async (req, res) => {
  try {
    const userId = req.user?.id;
    if (!userId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const { id } = req.params;
    const conversation = await db.query.chatConversations.findFirst({
      where: eq17(chatConversations.id, id)
    });
    if (!conversation) {
      return res.status(404).json({ error: "Conversation not found" });
    }
    let hasAccess = false;
    let isStaff = false;
    const participant = await db.query.chatParticipants.findFirst({
      where: and17(
        eq17(chatParticipants.conversationId, id),
        eq17(chatParticipants.userId, userId)
      )
    });
    if (participant) {
      hasAccess = true;
      isStaff = participant.role === "staff";
    }
    if (!hasAccess) {
      const salon = await db.query.salons.findFirst({
        where: eq17(salons.id, conversation.salonId)
      });
      if (salon && salon.ownerId === userId) {
        hasAccess = true;
        isStaff = true;
      }
    }
    if (!hasAccess) {
      const userStaff = await db.query.staff.findFirst({
        where: and17(eq17(staff.userId, userId), eq17(staff.salonId, conversation.salonId))
      });
      if (userStaff) {
        hasAccess = true;
        isStaff = true;
      }
    }
    if (!hasAccess) {
      return res.status(403).json({ error: "Access denied" });
    }
    if (participant) {
      await db.update(chatParticipants).set({ lastReadAt: /* @__PURE__ */ new Date() }).where(and17(
        eq17(chatParticipants.conversationId, id),
        eq17(chatParticipants.userId, userId)
      ));
    }
    if (!isStaff) {
      await db.update(chatConversations).set({ customerUnreadCount: 0 }).where(eq17(chatConversations.id, id));
    } else {
      await db.update(chatConversations).set({ staffUnreadCount: 0 }).where(eq17(chatConversations.id, id));
    }
    res.json({ success: true });
  } catch (error) {
    console.error("Error marking as read:", error);
    res.status(500).json({ error: "Failed to mark as read" });
  }
});
router7.patch("/conversations/:id/status", async (req, res) => {
  try {
    const userId = req.user?.id;
    if (!userId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const { id } = req.params;
    const { status } = req.body;
    if (!["active", "archived", "closed"].includes(status)) {
      return res.status(400).json({ error: "Invalid status" });
    }
    const participant = await db.query.chatParticipants.findFirst({
      where: and17(
        eq17(chatParticipants.conversationId, id),
        eq17(chatParticipants.userId, userId)
      )
    });
    if (!participant) {
      return res.status(403).json({ error: "Access denied" });
    }
    await db.update(chatConversations).set({ status, updatedAt: /* @__PURE__ */ new Date() }).where(eq17(chatConversations.id, id));
    res.json({ success: true });
  } catch (error) {
    console.error("Error updating conversation status:", error);
    res.status(500).json({ error: "Failed to update status" });
  }
});
router7.get("/salon/:salonId/conversation", async (req, res) => {
  try {
    const userId = req.user?.id;
    if (!userId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const { salonId } = req.params;
    const conversation = await db.query.chatConversations.findFirst({
      where: and17(
        eq17(chatConversations.salonId, salonId),
        eq17(chatConversations.customerId, userId),
        eq17(chatConversations.status, "active")
      )
    });
    if (!conversation) {
      return res.status(404).json({ conversation: null });
    }
    const salon = await db.query.salons.findFirst({
      where: eq17(salons.id, salonId),
      columns: {
        id: true,
        name: true,
        imageUrl: true
      }
    });
    res.json({
      conversation: {
        ...conversation,
        salonName: salon?.name,
        salonLogo: salon?.imageUrl,
        unreadCount: conversation.customerUnreadCount || 0
      }
    });
  } catch (error) {
    console.error("Error fetching salon conversation:", error);
    res.status(500).json({ error: "Failed to fetch conversation" });
  }
});
router7.get("/unread-count", async (req, res) => {
  try {
    const userId = req.user?.id;
    if (!userId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const role = req.query.role;
    let totalUnread = 0;
    if (role === "staff") {
      const userStaff = await db.query.staff.findFirst({
        where: eq17(staff.userId, userId)
      });
      if (userStaff) {
        const conversations = await db.query.chatConversations.findMany({
          where: and17(
            eq17(chatConversations.salonId, userStaff.salonId),
            eq17(chatConversations.status, "active")
          ),
          columns: {
            staffUnreadCount: true
          }
        });
        totalUnread = conversations.reduce((sum4, c) => sum4 + (c.staffUnreadCount || 0), 0);
      }
    } else {
      const conversations = await db.query.chatConversations.findMany({
        where: and17(
          eq17(chatConversations.customerId, userId),
          eq17(chatConversations.status, "active")
        ),
        columns: {
          customerUnreadCount: true
        }
      });
      totalUnread = conversations.reduce((sum4, c) => sum4 + (c.customerUnreadCount || 0), 0);
    }
    res.json({ unreadCount: totalUnread });
  } catch (error) {
    console.error("Error fetching unread count:", error);
    res.status(500).json({ error: "Failed to fetch unread count" });
  }
});
router7.get("/customer-context/:customerId", async (req, res) => {
  try {
    const userId = req.user?.id;
    if (!userId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const { customerId } = req.params;
    const salonId = req.query.salonId;
    if (!salonId) {
      return res.status(400).json({ error: "salonId is required" });
    }
    const userSalon = await db.query.salons.findFirst({
      where: eq17(salons.id, salonId)
    });
    let hasAccess = false;
    if (userSalon && userSalon.ownerId === userId) {
      hasAccess = true;
    } else {
      const userStaff = await db.query.staff.findFirst({
        where: and17(eq17(staff.userId, userId), eq17(staff.salonId, salonId))
      });
      if (userStaff) hasAccess = true;
    }
    if (!hasAccess) {
      return res.status(403).json({ error: "Access denied" });
    }
    const customer = await db.query.users.findFirst({
      where: eq17(users.id, customerId),
      columns: {
        id: true,
        firstName: true,
        lastName: true,
        email: true,
        phone: true,
        profileImageUrl: true,
        createdAt: true
      }
    });
    if (!customer) {
      return res.status(404).json({ error: "Customer not found" });
    }
    const customerBookings = await db.query.bookings.findMany({
      where: and17(
        eq17(bookings.userId, customerId),
        eq17(bookings.salonId, salonId)
      ),
      with: {
        service: {
          columns: {
            name: true,
            priceInPaisa: true
          }
        }
      },
      orderBy: [desc11(bookings.bookingDate)],
      limit: 10
    });
    const bookingData = customerBookings.map((b) => ({
      id: b.id,
      date: b.bookingDate,
      status: b.status,
      services: b.service ? [{ name: b.service.name, price: Number(b.service.priceInPaisa) / 100 }] : [],
      totalAmount: b.totalAmountPaisa ? Number(b.totalAmountPaisa) / 100 : 0
    }));
    const totalBookings = customerBookings.length;
    const totalSpent = customerBookings.reduce((sum4, b) => sum4 + (Number(b.totalAmountPaisa) / 100 || 0), 0);
    res.json({
      customer: {
        ...customer,
        createdAt: customer.createdAt?.toISOString() || null
      },
      bookings: bookingData,
      totalBookings,
      totalSpent
    });
  } catch (error) {
    console.error("Error fetching customer context:", error);
    res.status(500).json({ error: "Failed to fetch customer context" });
  }
});
var chat_routes_default = router7;

// server/routes/ai-consultant.routes.ts
import { Router as Router7 } from "express";
import { z as z4 } from "zod";
import rateLimit2 from "express-rate-limit";

// server/services/beauty-consultant.service.ts
init_db();
init_schema();
import { GoogleGenAI as GoogleGenAI2 } from "@google/genai";
import { eq as eq18, sql as sql15, and as and18, gte as gte4, lte as lte4, ilike, or as or7 } from "drizzle-orm";
var genAI2 = null;
var PRODUCT_KEYWORDS = [
  // Strong product indicators (weight 3)
  { word: "product", weight: 3 },
  { word: "buy product", weight: 3 },
  { word: "recommend product", weight: 3 },
  { word: "skincare product", weight: 3 },
  { word: "haircare product", weight: 3 },
  // Medium product indicators (weight 2)
  { word: "cream", weight: 2 },
  { word: "moisturizer", weight: 2 },
  { word: "serum", weight: 2 },
  { word: "lotion", weight: 2 },
  { word: "shampoo", weight: 2 },
  { word: "conditioner", weight: 2 },
  { word: "sunscreen", weight: 2 },
  { word: "spf", weight: 2 },
  { word: "cleanser", weight: 2 },
  { word: "toner", weight: 2 },
  { word: "face mask", weight: 2 },
  { word: "foundation", weight: 2 },
  { word: "lipstick", weight: 2 },
  { word: "mascara", weight: 2 },
  { word: "concealer", weight: 2 },
  { word: "primer", weight: 2 },
  { word: "powder", weight: 2 },
  { word: "blush", weight: 2 },
  { word: "bronzer", weight: 2 },
  { word: "eyeshadow", weight: 2 },
  { word: "eyeliner", weight: 2 },
  // Weak product indicators (weight 1)
  { word: "buy", weight: 1 },
  { word: "purchase", weight: 1 },
  { word: "shop", weight: 1 },
  { word: "apply", weight: 1 },
  { word: "use on", weight: 1 },
  { word: "oil", weight: 1 },
  { word: "best for oily", weight: 2 },
  { word: "best for dry", weight: 2 },
  { word: "oily skin", weight: 1 },
  { word: "dry skin", weight: 1 },
  { word: "acne", weight: 1 },
  { word: "pimple", weight: 1 },
  { word: "anti-aging", weight: 1 },
  { word: "wrinkle", weight: 1 },
  { word: "dark spot", weight: 1 },
  { word: "pigmentation", weight: 1 }
];
var SALON_KEYWORDS = [
  // Strong salon indicators (weight 3)
  { word: "salon", weight: 3 },
  { word: "parlor", weight: 3 },
  { word: "parlour", weight: 3 },
  { word: "find salon", weight: 3 },
  { word: "best salon", weight: 3 },
  { word: "salon near", weight: 3 },
  { word: "salons near", weight: 3 },
  { word: "nearby salon", weight: 3 },
  // Medium salon indicators (weight 2)  
  { word: "near me", weight: 2 },
  { word: "near by", weight: 2 },
  { word: "nearby", weight: 2 },
  { word: "around me", weight: 2 },
  { word: "close to me", weight: 2 },
  { word: "in my area", weight: 2 },
  { word: "barber", weight: 2 },
  { word: "spa", weight: 2 },
  { word: "beauty center", weight: 2 },
  { word: "stylist", weight: 2 },
  { word: "hair stylist", weight: 2 },
  // Weak salon indicators (weight 1)
  { word: "location", weight: 1 },
  { word: "appointment", weight: 1 },
  { word: "book", weight: 1 },
  { word: "wellness", weight: 1 },
  { word: "visit", weight: 1 },
  { word: "go to", weight: 1 },
  { word: "locate", weight: 1 },
  { word: "where can i find", weight: 1 },
  { word: "show me", weight: 1 }
];
var SERVICE_KEYWORDS = [
  // Strong service indicators (weight 3)
  { word: "service", weight: 3 },
  { word: "treatment", weight: 3 },
  { word: "procedure", weight: 3 },
  // Medium service indicators (weight 2)
  { word: "haircut", weight: 2 },
  { word: "hair cut", weight: 2 },
  { word: "trim", weight: 2 },
  { word: "hair color", weight: 2 },
  { word: "hair dye", weight: 2 },
  { word: "highlight", weight: 2 },
  { word: "balayage", weight: 2 },
  { word: "keratin", weight: 2 },
  { word: "straightening", weight: 2 },
  { word: "perm", weight: 2 },
  { word: "facial", weight: 2 },
  { word: "manicure", weight: 2 },
  { word: "pedicure", weight: 2 },
  { word: "massage", weight: 2 },
  { word: "waxing", weight: 2 },
  { word: "threading", weight: 2 },
  { word: "bridal makeup", weight: 2 },
  { word: "makeover", weight: 2 },
  { word: "hair spa", weight: 2 },
  { word: "head massage", weight: 2 },
  { word: "body massage", weight: 2 },
  // Weak service indicators (weight 1)
  { word: "bridal", weight: 1 },
  { word: "wedding", weight: 1 },
  { word: "how much", weight: 1 },
  { word: "price", weight: 1 },
  { word: "cost", weight: 1 },
  { word: "color", weight: 1 },
  { word: "dye", weight: 1 },
  { word: "bleach", weight: 1 }
];
var LOCATION_PATTERNS = [
  "noida",
  "greater noida",
  "delhi",
  "gurgaon",
  "gurugram",
  "faridabad",
  "ghaziabad",
  "mumbai",
  "bangalore",
  "bengaluru",
  "hyderabad",
  "chennai",
  "pune",
  "kolkata",
  "sector",
  "nirala",
  "supertech",
  "gaur",
  "amrapali",
  "techzone",
  "alpha",
  "beta",
  "gamma"
];
function detectQueryIntent(message, intent) {
  const messageLower = message.toLowerCase().trim();
  if (intent === "find_salon") return "salon";
  if (intent === "skincare_routine" || intent === "recommend_product") return "product";
  let productScore = 0;
  let salonScore = 0;
  let serviceScore = 0;
  for (const { word, weight } of PRODUCT_KEYWORDS) {
    if (messageLower.includes(word)) productScore += weight;
  }
  for (const { word, weight } of SALON_KEYWORDS) {
    if (messageLower.includes(word)) salonScore += weight;
  }
  for (const { word, weight } of SERVICE_KEYWORDS) {
    if (messageLower.includes(word)) serviceScore += weight;
  }
  for (const location of LOCATION_PATTERNS) {
    if (messageLower.includes(location)) {
      salonScore += 2;
      break;
    }
  }
  if (messageLower.match(/salon.*(near|nearby|around|close|in\s)/i)) salonScore += 3;
  if (messageLower.match(/(find|show|list|recommend).*(salon|parlor|parlour)/i)) salonScore += 3;
  if (messageLower.match(/(near|nearby|around).*(me|my|here)/i) && !messageLower.includes("product")) salonScore += 2;
  const maxScore = Math.max(productScore, salonScore, serviceScore);
  if (maxScore < 2) return "general";
  if (salonScore === maxScore && salonScore >= productScore && salonScore >= serviceScore) return "salon";
  if (productScore === maxScore && productScore > salonScore && productScore >= serviceScore) return "product";
  if (serviceScore === maxScore && serviceScore > productScore && serviceScore > salonScore) return "service";
  if (salonScore === productScore || salonScore === serviceScore) {
    for (const location of LOCATION_PATTERNS) {
      if (messageLower.includes(location)) return "salon";
    }
  }
  return "general";
}
async function validateGeminiApiKey() {
  const apiKey = process.env.GEMINI_API_KEY;
  if (!apiKey || apiKey.trim() === "") {
    console.warn("[BeautyConsultant] GEMINI_API_KEY is not configured");
    return false;
  }
  try {
    genAI2 = new GoogleGenAI2({ apiKey });
    const result = await genAI2.models.generateContent({
      model: "gemini-2.5-flash",
      contents: [{ role: "user", parts: [{ text: "Hello" }] }],
      config: { maxOutputTokens: 10 }
    });
    console.log("\u2705 Gemini API key validated successfully");
    return true;
  } catch (error) {
    console.error("[BeautyConsultant] Gemini API key validation failed:", error.message);
    genAI2 = null;
    return false;
  }
}
async function fetchSalonContext(location, limit = 5) {
  try {
    let salons11;
    if (location) {
      const result = await db.execute(sql15`
        SELECT id, name, address, rating, review_count, image_url, image_urls,
               ( 6371 * acos( cos( radians(${location.lat}) ) 
               * cos( radians( CAST(latitude AS FLOAT) ) )
               * cos( radians( CAST(longitude AS FLOAT) ) - radians(${location.lng}) ) 
               + sin( radians(${location.lat}) ) 
               * sin( radians( CAST(latitude AS FLOAT) ) ) ) ) AS distance
        FROM salons
        WHERE approval_status = 'approved' AND is_active = 1 AND latitude IS NOT NULL AND longitude IS NOT NULL
        ORDER BY distance ASC
        LIMIT ${limit}
      `);
      salons11 = result.rows;
    } else {
      salons11 = await db.select({
        id: salons.id,
        name: salons.name,
        address: salons.address,
        rating: salons.rating,
        reviewCount: salons.reviewCount,
        imageUrl: salons.imageUrl,
        imageUrls: salons.imageUrls
      }).from(salons).where(and18(eq18(salons.approvalStatus, "approved"), eq18(salons.isActive, 1))).orderBy(sql15`rating DESC NULLS LAST`).limit(limit);
    }
    return salons11;
  } catch (error) {
    console.error("[BeautyConsultant] Error fetching salons:", error);
    return [];
  }
}
async function fetchServicesContext(limit = 15) {
  try {
    const services6 = await db.select({
      id: services.id,
      name: services.name,
      category: services.category,
      priceInPaisa: services.priceInPaisa,
      durationMinutes: services.durationMinutes,
      description: services.description,
      imageUrl: services.imageUrl
    }).from(services).where(eq18(services.isActive, 1)).orderBy(sql15`RANDOM()`).limit(limit);
    return services6;
  } catch (error) {
    console.error("[BeautyConsultant] Error fetching services:", error);
    return [];
  }
}
async function fetchProductsContext(searchTerms, limit = 10) {
  try {
    let products2;
    if (searchTerms && searchTerms.length > 0) {
      const searchConditions = searchTerms.map(
        (term) => or7(
          ilike(beautyProducts.name, `%${term}%`),
          ilike(beautyProducts.category, `%${term}%`),
          ilike(beautyProducts.description, `%${term}%`),
          ilike(beautyProducts.brand, `%${term}%`)
        )
      );
      products2 = await db.select({
        id: beautyProducts.id,
        name: beautyProducts.name,
        brand: beautyProducts.brand,
        category: beautyProducts.category,
        price: beautyProducts.price,
        imageUrl: beautyProducts.imageUrl,
        description: beautyProducts.description,
        finishType: beautyProducts.finishType,
        skinToneCompatibility: beautyProducts.skinToneCompatibility
      }).from(beautyProducts).where(or7(...searchConditions)).orderBy(sql15`CASE WHEN image_url IS NOT NULL THEN 0 ELSE 1 END`).limit(limit);
    }
    if (!products2 || products2.length === 0) {
      products2 = await db.select({
        id: beautyProducts.id,
        name: beautyProducts.name,
        brand: beautyProducts.brand,
        category: beautyProducts.category,
        price: beautyProducts.price,
        imageUrl: beautyProducts.imageUrl,
        description: beautyProducts.description,
        finishType: beautyProducts.finishType,
        skinToneCompatibility: beautyProducts.skinToneCompatibility
      }).from(beautyProducts).orderBy(sql15`RANDOM()`).limit(limit);
    }
    return products2;
  } catch (error) {
    console.error("[BeautyConsultant] Error fetching products:", error);
    return [];
  }
}
function extractSearchTerms(message) {
  const messageLower = message.toLowerCase();
  const terms = [];
  if (messageLower.includes("oily")) terms.push("oily", "matte", "oil-free", "gel");
  if (messageLower.includes("dry")) terms.push("dry", "hydrating", "moisturizing", "cream");
  if (messageLower.includes("combination")) terms.push("combination", "balancing");
  if (messageLower.includes("sensitive")) terms.push("sensitive", "gentle", "soothing");
  if (messageLower.includes("cream") || messageLower.includes("moisturizer")) terms.push("cream", "moisturizer");
  if (messageLower.includes("serum")) terms.push("serum");
  if (messageLower.includes("cleanser")) terms.push("cleanser", "wash");
  if (messageLower.includes("sunscreen") || messageLower.includes("spf")) terms.push("sunscreen", "spf");
  if (messageLower.includes("foundation")) terms.push("foundation");
  if (messageLower.includes("lipstick") || messageLower.includes("lip")) terms.push("lipstick", "lip");
  if (messageLower.includes("mascara")) terms.push("mascara");
  if (messageLower.includes("eyeshadow")) terms.push("eyeshadow");
  if (messageLower.includes("acne") || messageLower.includes("pimple")) terms.push("acne", "blemish", "salicylic");
  if (messageLower.includes("anti-aging") || messageLower.includes("wrinkle")) terms.push("anti-aging", "retinol");
  if (messageLower.includes("dark spot") || messageLower.includes("pigmentation")) terms.push("brightening", "vitamin c");
  return terms;
}
async function fetchActiveOffers(limit = 5) {
  try {
    const now = /* @__PURE__ */ new Date();
    const offers = await db.select({
      id: platformOffers.id,
      title: platformOffers.title,
      description: platformOffers.description,
      discountType: platformOffers.discountType,
      discountValue: platformOffers.discountValue
    }).from(platformOffers).where(
      and18(
        eq18(platformOffers.isActive, 1),
        eq18(platformOffers.approvalStatus, "approved"),
        lte4(platformOffers.validFrom, now),
        gte4(platformOffers.validUntil, now)
      )
    ).limit(limit);
    return offers;
  } catch (error) {
    console.error("[BeautyConsultant] Error fetching offers:", error);
    return [];
  }
}
async function fetchUserBookingHistory(userId, limit = 5) {
  try {
    const bookings4 = await db.select({
      id: bookings.id,
      serviceName: services.name,
      serviceCategory: services.category,
      salonName: salons.name,
      bookingDate: bookings.bookingDate
    }).from(bookings).leftJoin(services, eq18(bookings.serviceId, services.id)).leftJoin(salons, eq18(bookings.salonId, salons.id)).where(eq18(bookings.userId, userId)).orderBy(sql15`booking_date DESC`).limit(limit);
    return bookings4;
  } catch (error) {
    console.error("[BeautyConsultant] Error fetching booking history:", error);
    return [];
  }
}
function buildSystemPrompt(salons11, services6, offers, userHistory, isGuest = false, products2 = []) {
  const salonContext = salons11.length > 0 ? `

NEARBY/TOP SALONS:
${salons11.map(
    (s) => `- ${s.name} (Rating: ${s.rating || "N/A"}${s.distance ? `, Distance: ${Number(s.distance).toFixed(1)}km` : ""})`
  ).join("\n")}` : "";
  const serviceContext = services6.length > 0 ? `

AVAILABLE SERVICES:
${services6.map(
    (s) => `- ${s.name} (${s.category}): \u20B9${Math.round(s.priceInPaisa / 100)} - ${s.durationMinutes}min`
  ).join("\n")}` : "";
  const productContext = products2.length > 0 ? `

AVAILABLE PRODUCTS IN SHOP:
${products2.map(
    (p) => `- ${p.brand} ${p.name} (${p.category}): \u20B9${Math.round(p.price / 100)}${p.finishType ? ` - ${p.finishType}` : ""}`
  ).join("\n")}` : "";
  const offerContext = offers.length > 0 ? `

CURRENT OFFERS:
${offers.map(
    (o) => `- ${o.title}: ${o.discountType === "percentage" ? o.discountValue + "%" : "\u20B9" + Math.round(o.discountValue / 100)} off`
  ).join("\n")}` : "";
  const historyContext = !isGuest && userHistory.length > 0 ? `

USER'S RECENT BOOKINGS:
${userHistory.map(
    (b) => `- ${b.serviceName} at ${b.salonName} (${b.bookingDate})`
  ).join("\n")}` : "";
  const guestNote = isGuest ? `

NOTE: This user is browsing as a guest. Provide helpful general beauty advice. Gently encourage them to sign up or log in for personalized recommendations based on their preferences and booking history.` : "";
  const personalizedNote = !isGuest && userHistory.length > 0 ? `

NOTE: This is a logged-in user with booking history. Use their past bookings to provide personalized recommendations.` : "";
  return `You are an AI Beauty Consultant for SalonHub, a platform connecting customers with beauty salons and services. Your role is to:

1. Provide ${isGuest ? "general" : "personalized"} beauty advice and recommendations
2. Help users discover services and salons
3. Answer questions about beauty trends, hair care, skincare, makeup, and grooming
4. Suggest services based on ${isGuest ? "general trends" : "user preferences and history"}
5. Help with booking decisions

PLATFORM CAPABILITIES:
- Book appointments at salons (at-salon services)
- Book at-home beauty services (home visits)
- Browse and purchase beauty products in the Shop
- Discover and attend beauty events
- Apply promotional offers and discounts

RESPONSE GUIDELINES:
- Be friendly, helpful, and conversational
- Keep responses concise but informative (2-4 sentences for simple queries)
- Use emojis sparingly for a friendly tone
- When recommending services, mention price ranges if available
- When recommending salons, mention ratings and location
- When recommending products, mention the brand, product name, and price
- If user asks about products/skincare/makeup items they can buy, recommend specific products from our Shop
- Suggest follow-up actions the user can take
- If user asks something outside beauty/salon domain, politely redirect${isGuest ? "\n- Occasionally mention that logging in provides personalized recommendations" : ""}

CONTEXT FROM SALONHUB:${salonContext}${serviceContext}${productContext}${offerContext}${historyContext}${guestNote}${personalizedNote}

Remember: You're helping users discover beauty services and make informed decisions. Always be supportive and encouraging about their beauty journey!`;
}
async function getBeautyConsultantResponse(input) {
  const model = "gemini-2.5-flash";
  const isGuest = input.isGuest ?? !input.userId;
  const queryIntent = detectQueryIntent(input.message, input.intent);
  const searchTerms = extractSearchTerms(input.message);
  const [salons11, services6, offers, userHistory, products2] = await Promise.all([
    fetchSalonContext(input.location, 5),
    fetchServicesContext(15),
    fetchActiveOffers(5),
    input.userId && !isGuest ? fetchUserBookingHistory(input.userId, 5) : Promise.resolve([]),
    queryIntent === "product" || queryIntent === "general" ? fetchProductsContext(searchTerms, 10) : Promise.resolve([])
  ]);
  const systemPrompt = buildSystemPrompt(salons11, services6, offers, userHistory, isGuest, products2);
  const conversationMessages = input.conversationHistory?.map((msg) => ({
    role: msg.role,
    parts: [{ text: msg.content }]
  })) || [];
  const userMessage = input.intent ? `[Intent: ${input.intent}] ${input.message}` : input.message;
  if (!genAI2) {
    throw new Error("AI service is not available. Please try again later.");
  }
  try {
    const result = await genAI2.models.generateContent({
      model,
      contents: [
        {
          role: "user",
          parts: [{ text: systemPrompt }]
        },
        ...conversationMessages.map((msg) => ({
          role: msg.role === "user" ? "user" : "model",
          parts: msg.parts
        })),
        {
          role: "user",
          parts: [{ text: userMessage }]
        }
      ],
      config: {
        temperature: 0.8,
        topP: 0.95,
        maxOutputTokens: 1024
      }
    });
    const reply = result.text || "I'm sorry, I couldn't generate a response. Please try again.";
    const suggestions = generateSuggestions(input.message, input.intent);
    const followUps = generateFollowUps(input.message);
    const relatedServices = services6.slice(0, 3).map((s) => ({
      id: String(s.id),
      name: s.name,
      category: s.category || "General",
      priceRange: `\u20B9${Math.round(s.priceInPaisa / 100)}`,
      imageUrl: s.imageUrl || void 0,
      duration: s.durationMinutes ? `${s.durationMinutes} min` : void 0
    }));
    const relatedSalons = salons11.slice(0, 3).map((s) => ({
      id: String(s.id),
      name: s.name,
      rating: Number(s.rating) || 0,
      distance: s.distance ? `${Number(s.distance).toFixed(1)}km` : void 0,
      imageUrl: s.imageUrl || s.image_url || void 0,
      reviewCount: Number(s.reviewCount || s.review_count) || 0,
      address: s.address || void 0
    }));
    const richMedia = [];
    if (queryIntent === "product") {
      products2.slice(0, 5).forEach((p) => {
        if (p.imageUrl) {
          richMedia.push({
            type: "product",
            id: String(p.id),
            title: p.name,
            subtitle: p.brand || p.category || "Beauty Product",
            imageUrl: p.imageUrl,
            price: `\u20B9${Math.round(p.price / 100)}`,
            ctaLabel: "View Product",
            ctaAction: `/shop/product/${p.id}`
          });
        }
      });
    } else if (queryIntent === "salon") {
      salons11.slice(0, 5).forEach((s) => {
        const imageUrl = s.imageUrl || s.image_url;
        richMedia.push({
          type: "salon",
          id: String(s.id),
          title: s.name,
          subtitle: s.address || "Beauty Salon",
          imageUrl: imageUrl || void 0,
          imageUrls: s.imageUrls || s.image_urls || void 0,
          rating: Number(s.rating) || void 0,
          reviewCount: Number(s.reviewCount || s.review_count) || void 0,
          distance: s.distance ? `${Number(s.distance).toFixed(1)}km` : void 0,
          ctaLabel: "Book Now",
          ctaAction: `/salon/${s.id}`
        });
      });
    } else if (queryIntent === "service") {
      services6.slice(0, 5).forEach((s) => {
        if (s.imageUrl) {
          richMedia.push({
            type: "service",
            id: String(s.id),
            title: s.name,
            subtitle: s.category || "Beauty Service",
            imageUrl: s.imageUrl,
            price: `\u20B9${Math.round(s.priceInPaisa / 100)}`,
            duration: s.durationMinutes ? `${s.durationMinutes} min` : void 0,
            ctaLabel: "Book Now",
            ctaAction: `/booking?service=${s.id}`
          });
        }
      });
    } else {
      products2.slice(0, 2).forEach((p) => {
        if (p.imageUrl) {
          richMedia.push({
            type: "product",
            id: String(p.id),
            title: p.name,
            subtitle: p.brand || p.category || "Beauty Product",
            imageUrl: p.imageUrl,
            price: `\u20B9${Math.round(p.price / 100)}`,
            ctaLabel: "View Product",
            ctaAction: `/shop/product/${p.id}`
          });
        }
      });
      salons11.slice(0, 2).forEach((s) => {
        const imageUrl = s.imageUrl || s.image_url;
        if (imageUrl) {
          richMedia.push({
            type: "salon",
            id: String(s.id),
            title: s.name,
            subtitle: s.address || void 0,
            imageUrl,
            imageUrls: s.imageUrls || s.image_urls || void 0,
            rating: Number(s.rating) || void 0,
            reviewCount: Number(s.reviewCount || s.review_count) || void 0,
            distance: s.distance ? `${Number(s.distance).toFixed(1)}km` : void 0,
            ctaLabel: "View Salon",
            ctaAction: `/salon/${s.id}`
          });
        }
      });
      services6.slice(0, 2).forEach((s) => {
        if (s.imageUrl) {
          richMedia.push({
            type: "service",
            id: String(s.id),
            title: s.name,
            subtitle: s.category || "Beauty Service",
            imageUrl: s.imageUrl,
            price: `\u20B9${Math.round(s.priceInPaisa / 100)}`,
            duration: s.durationMinutes ? `${s.durationMinutes} min` : void 0,
            ctaLabel: "Book Now",
            ctaAction: `/booking?service=${s.id}`
          });
        }
      });
    }
    return {
      reply,
      suggestions,
      followUps,
      richMedia: richMedia.length > 0 ? richMedia : void 0,
      relatedServices: relatedServices.length > 0 ? relatedServices : void 0,
      relatedSalons: relatedSalons.length > 0 ? relatedSalons : void 0
    };
  } catch (error) {
    console.error("[BeautyConsultant] AI generation error:", error);
    if (error.status === 429 || error.message?.includes("quota")) {
      throw new Error("Our AI service is busy right now. Please try again in a moment.");
    }
    throw new Error("Unable to process your request. Please try again.");
  }
}
function generateSuggestions(message, intent) {
  const suggestions = [];
  const messageLower = message.toLowerCase();
  if (messageLower.includes("hair") || intent === "recommend_hairstyle") {
    suggestions.push("What hairstyles suit round faces?", "Best hair color for my skin tone", "How to fix damaged hair?");
  } else if (messageLower.includes("skin") || intent === "skincare_routine") {
    suggestions.push("Morning skincare routine", "Best products for oily skin", "How to reduce dark circles?");
  } else if (messageLower.includes("makeup") || intent === "makeup_tips") {
    suggestions.push("Natural everyday makeup", "Best foundation for beginners", "Bridal makeup tips");
  } else if (messageLower.includes("salon") || intent === "find_salon") {
    suggestions.push("Best rated salons near me", "Salons with bridal packages", "Budget-friendly salons");
  } else {
    suggestions.push("Recommend a hairstyle for me", "Skincare routine for my skin type", "Find salons near me");
  }
  return suggestions.slice(0, 3);
}
function generateFollowUps(message) {
  return [
    "Would you like to book an appointment?",
    "Want me to find salons offering this service?",
    "Should I show you related offers?"
  ];
}
function getQuickActionChips() {
  return [
    { id: "recommend_hairstyle", label: "Hairstyle Ideas", icon: "scissors" },
    { id: "skincare_routine", label: "Skincare Tips", icon: "sparkles" },
    { id: "makeup_tips", label: "Makeup Guide", icon: "palette" },
    { id: "find_salon", label: "Find Salons", icon: "map-pin" },
    { id: "trending_looks", label: "Trending Now", icon: "trending-up" },
    { id: "bridal_beauty", label: "Bridal Beauty", icon: "heart" },
    { id: "men_grooming", label: "Men's Grooming", icon: "user" },
    { id: "nail_art", label: "Nail Art", icon: "brush" }
  ];
}

// server/routes/ai-consultant.routes.ts
var router8 = Router7();
var geminiAvailable = false;
async function initializeAIConsultantRoutes() {
  geminiAvailable = await validateGeminiApiKey();
  if (!geminiAvailable) {
    console.warn("\u26A0\uFE0F  AI Beauty Consultant routes will return service unavailable - GEMINI_API_KEY not configured or invalid");
  }
  return geminiAvailable;
}
var aiConsultantRateLimit = rateLimit2({
  windowMs: 60 * 1e3,
  max: 10,
  message: { error: "Too many requests. Please wait a moment before trying again." },
  standardHeaders: true,
  legacyHeaders: false,
  validate: { xForwardedForHeader: false, ip: false, trustProxy: false }
});
var chatRequestSchema = z4.object({
  message: z4.string().min(1).max(1e3),
  intent: z4.string().optional(),
  location: z4.object({
    lat: z4.number(),
    lng: z4.number()
  }).optional(),
  conversationHistory: z4.array(z4.object({
    role: z4.enum(["user", "assistant"]),
    content: z4.string()
  })).max(10).optional()
});
function checkGeminiAvailable(req, res, next) {
  if (!geminiAvailable) {
    res.status(503).json({ error: "AI Beauty Consultant is currently unavailable. Please try again later." });
    return;
  }
  next();
}
async function optionalAuthenticateUser(req, res, next) {
  if (req.headers.authorization) {
    return authenticateMobileUser(req, res, next);
  }
  if (req.session?.userId) {
    req.user = { id: req.session.userId };
    req.isGuest = false;
    return next();
  }
  req.user = null;
  req.isGuest = true;
  next();
}
router8.get("/chips", optionalAuthenticateUser, (req, res) => {
  try {
    const chips = getQuickActionChips();
    const isGuest = req.isGuest;
    res.json({ chips, isGuest });
  } catch (error) {
    console.error("[AI Consultant] Error fetching chips:", error);
    res.status(500).json({ error: "Failed to fetch quick action chips" });
  }
});
router8.post("/chat", optionalAuthenticateUser, checkGeminiAvailable, aiConsultantRateLimit, async (req, res) => {
  try {
    const validationResult = chatRequestSchema.safeParse(req.body);
    if (!validationResult.success) {
      res.status(400).json({
        error: "Invalid request",
        details: validationResult.error.errors
      });
      return;
    }
    const { message, intent, location, conversationHistory } = validationResult.data;
    const userId = req.user?.id;
    const isGuest = req.isGuest;
    const input = {
      message,
      intent,
      userId: userId || void 0,
      location,
      conversationHistory,
      isGuest
    };
    const response = await getBeautyConsultantResponse(input);
    res.json({ ...response, isGuest });
  } catch (error) {
    console.error("[AI Consultant] Chat error:", error);
    if (error.message?.includes("busy") || error.message?.includes("quota")) {
      res.status(503).json({ error: error.message });
      return;
    }
    if (error.message?.includes("API key") || error.message?.includes("authentication")) {
      res.status(503).json({ error: "AI service is temporarily unavailable. Please try again later." });
      return;
    }
    res.status(500).json({ error: "Failed to process your request. Please try again." });
  }
});
router8.post("/quick-query", optionalAuthenticateUser, checkGeminiAvailable, aiConsultantRateLimit, async (req, res) => {
  try {
    const { intent, location } = req.body;
    if (!intent || typeof intent !== "string") {
      res.status(400).json({ error: "Intent is required" });
      return;
    }
    const userId = req.user?.id;
    const isGuest = req.isGuest;
    const intentPrompts = {
      recommend_hairstyle: "What hairstyles would look good on me? I'm looking for something trendy and easy to maintain.",
      skincare_routine: "Can you suggest a basic skincare routine for everyday use?",
      makeup_tips: "What are some essential makeup tips for beginners?",
      find_salon: "Can you help me find the best rated salons near me?",
      trending_looks: "What beauty trends are popular right now?",
      hair_care: "How can I take better care of my hair?",
      nail_art: "What are some popular nail art designs right now?",
      bridal_beauty: "What should I know about bridal makeup and beauty preparation?",
      men_grooming: "What grooming tips would you recommend for men?"
    };
    const message = intentPrompts[intent] || `Tell me about ${intent.replace(/_/g, " ")}`;
    const input = {
      message,
      intent,
      userId: userId || void 0,
      location,
      isGuest
    };
    const response = await getBeautyConsultantResponse(input);
    res.json({ ...response, isGuest });
  } catch (error) {
    console.error("[AI Consultant] Quick query error:", error);
    if (error.message?.includes("busy") || error.message?.includes("quota")) {
      res.status(503).json({ error: error.message });
      return;
    }
    res.status(500).json({ error: "Failed to process your request. Please try again." });
  }
});
var ai_consultant_routes_default = router8;

// server/services/chat.service.ts
init_db();
init_schema();
import { Server as SocketIOServer } from "socket.io";
import { eq as eq19, and as and19, sql as sql16 } from "drizzle-orm";
var connectedUsers = /* @__PURE__ */ new Map();
var typingUsers = /* @__PURE__ */ new Map();
var ioInstance = null;
function getSocketIO() {
  return ioInstance;
}
function initializeChatSocket(httpServer) {
  const io = new SocketIOServer(httpServer, {
    cors: {
      origin: "*",
      methods: ["GET", "POST"],
      credentials: true
    },
    path: "/socket.io",
    transports: ["websocket", "polling"]
  });
  io.use(async (socket, next) => {
    try {
      const token = socket.handshake.auth.token;
      const salonId = socket.handshake.auth.salonId;
      const staffId = socket.handshake.auth.staffId;
      const userRole = socket.handshake.auth.userRole;
      if (!token) {
        return next(new Error("Authentication required - token missing"));
      }
      try {
        const decoded = await verifyAccessToken(token);
        socket.userId = decoded.userId;
        socket.userRole = userRole || "customer";
        socket.salonId = salonId;
        socket.staffId = staffId;
        console.log(`Chat Socket: Authenticated user ${decoded.userId} as ${socket.userRole}`);
        next();
      } catch (tokenError) {
        console.error("Chat Socket: Token verification failed:", tokenError);
        return next(new Error("Invalid or expired token"));
      }
    } catch (error) {
      console.error("Chat Socket: Authentication error:", error);
      next(new Error("Authentication failed"));
    }
  });
  io.on("connection", (socket) => {
    const userId = socket.userId;
    console.log(`Chat: User ${userId} connected (${socket.userRole})`);
    if (!connectedUsers.has(userId)) {
      connectedUsers.set(userId, /* @__PURE__ */ new Set());
    }
    connectedUsers.get(userId).add(socket.id);
    socket.broadcast.emit("presence:update", {
      userId,
      isOnline: true
    });
    socket.on("conversation:join", async (conversationId) => {
      try {
        const participant = await db.query.chatParticipants.findFirst({
          where: and19(
            eq19(chatParticipants.conversationId, conversationId),
            eq19(chatParticipants.userId, userId)
          )
        });
        if (participant) {
          socket.join(`conversation:${conversationId}`);
          console.log(`User ${userId} joined conversation ${conversationId}`);
          return;
        }
        const conversation = await db.query.chatConversations.findFirst({
          where: eq19(chatConversations.id, conversationId)
        });
        if (conversation) {
          const salon = await db.query.salons.findFirst({
            where: eq19(salons.id, conversation.salonId)
          });
          if (salon && salon.ownerId === userId) {
            await db.insert(chatParticipants).values({
              conversationId,
              userId,
              role: "staff"
            }).onConflictDoNothing();
            socket.join(`conversation:${conversationId}`);
            console.log(`User ${userId} (salon owner) joined conversation ${conversationId}`);
            return;
          }
          const userStaff = await db.query.staff.findFirst({
            where: and19(eq19(staff.userId, userId), eq19(staff.salonId, conversation.salonId))
          });
          if (userStaff) {
            await db.insert(chatParticipants).values({
              conversationId,
              userId,
              role: "staff",
              staffId: userStaff.id
            }).onConflictDoNothing();
            socket.join(`conversation:${conversationId}`);
            console.log(`User ${userId} (staff) joined conversation ${conversationId}`);
          }
        }
      } catch (error) {
        console.error("Error joining conversation:", error);
      }
    });
    socket.on("conversation:leave", (conversationId) => {
      socket.leave(`conversation:${conversationId}`);
      console.log(`User ${userId} left conversation ${conversationId}`);
    });
    socket.on("message:send", async (data) => {
      try {
        const { conversationId, body, messageType = "text", tempId } = data;
        let participant = await db.query.chatParticipants.findFirst({
          where: and19(
            eq19(chatParticipants.conversationId, conversationId),
            eq19(chatParticipants.userId, userId)
          )
        });
        let senderRole = "customer";
        if (participant) {
          senderRole = participant.role;
        } else {
          const conversation = await db.query.chatConversations.findFirst({
            where: eq19(chatConversations.id, conversationId)
          });
          if (!conversation) {
            socket.emit("message:error", { tempId, error: "Conversation not found" });
            return;
          }
          const salon = await db.query.salons.findFirst({
            where: eq19(salons.id, conversation.salonId)
          });
          if (salon && salon.ownerId === userId) {
            await db.insert(chatParticipants).values({
              conversationId,
              userId,
              role: "staff"
            }).onConflictDoNothing();
            senderRole = "staff";
          } else {
            const userStaff = await db.query.staff.findFirst({
              where: and19(eq19(staff.userId, userId), eq19(staff.salonId, conversation.salonId))
            });
            if (userStaff) {
              await db.insert(chatParticipants).values({
                conversationId,
                userId,
                role: "staff",
                staffId: userStaff.id
              }).onConflictDoNothing();
              senderRole = "staff";
            } else {
              socket.emit("message:error", { tempId, error: "Not a participant" });
              return;
            }
          }
        }
        const user = await db.query.users.findFirst({
          where: eq19(users.id, userId),
          columns: {
            id: true,
            firstName: true,
            lastName: true,
            profileImageUrl: true
          }
        });
        const senderName = user ? `${user.firstName || ""} ${user.lastName || ""}`.trim() || "User" : "User";
        const [message] = await db.insert(chatMessages).values({
          conversationId,
          senderId: userId,
          senderRole,
          senderName,
          senderAvatar: user?.profileImageUrl,
          messageType,
          body,
          attachmentUrl: data.attachmentUrl,
          attachmentType: data.attachmentType,
          attachmentName: data.attachmentName,
          attachmentSize: data.attachmentSize,
          sentAt: /* @__PURE__ */ new Date(),
          deliveredAt: /* @__PURE__ */ new Date()
        }).returning();
        const preview = body?.substring(0, 100) || "";
        await db.update(chatConversations).set({
          lastMessageAt: /* @__PURE__ */ new Date(),
          lastMessagePreview: preview,
          updatedAt: /* @__PURE__ */ new Date(),
          ...senderRole === "customer" ? { staffUnreadCount: sql16`${chatConversations.staffUnreadCount} + 1` } : { customerUnreadCount: sql16`${chatConversations.customerUnreadCount} + 1` }
        }).where(eq19(chatConversations.id, conversationId));
        socket.emit("message:ack", { tempId, messageId: message.id });
        io.to(`conversation:${conversationId}`).emit("message:new", {
          ...message,
          tempId
        });
        const conversationKey = `typing:${conversationId}`;
        typingUsers.get(conversationKey)?.delete(userId);
      } catch (error) {
        console.error("Error sending message:", error);
        socket.emit("message:error", {
          tempId: data.tempId,
          error: "Failed to send message"
        });
      }
    });
    socket.on("message:read", async (data) => {
      try {
        const { conversationId, messageIds } = data;
        let participant = await db.query.chatParticipants.findFirst({
          where: and19(
            eq19(chatParticipants.conversationId, conversationId),
            eq19(chatParticipants.userId, userId)
          )
        });
        let readerRole = "customer";
        if (participant) {
          readerRole = participant.role;
        } else {
          const conversation = await db.query.chatConversations.findFirst({
            where: eq19(chatConversations.id, conversationId)
          });
          if (!conversation) return;
          const salon = await db.query.salons.findFirst({
            where: eq19(salons.id, conversation.salonId)
          });
          if (salon && salon.ownerId === userId) {
            await db.insert(chatParticipants).values({
              conversationId,
              userId,
              role: "staff"
            }).onConflictDoNothing();
            readerRole = "staff";
          } else {
            const userStaff = await db.query.staff.findFirst({
              where: and19(eq19(staff.userId, userId), eq19(staff.salonId, conversation.salonId))
            });
            if (userStaff) {
              await db.insert(chatParticipants).values({
                conversationId,
                userId,
                role: "staff",
                staffId: userStaff.id
              }).onConflictDoNothing();
              readerRole = "staff";
            } else {
              return;
            }
          }
        }
        await db.update(chatParticipants).set({ lastReadAt: /* @__PURE__ */ new Date() }).where(and19(
          eq19(chatParticipants.conversationId, conversationId),
          eq19(chatParticipants.userId, userId)
        ));
        if (readerRole === "customer") {
          await db.update(chatConversations).set({ customerUnreadCount: 0 }).where(eq19(chatConversations.id, conversationId));
        } else {
          await db.update(chatConversations).set({ staffUnreadCount: 0 }).where(eq19(chatConversations.id, conversationId));
        }
        io.to(`conversation:${conversationId}`).emit("message:read", {
          conversationId,
          userId,
          readAt: /* @__PURE__ */ new Date()
        });
      } catch (error) {
        console.error("Error marking messages as read:", error);
      }
    });
    socket.on("typing:start", (conversationId) => {
      const conversationKey = `typing:${conversationId}`;
      if (!typingUsers.has(conversationKey)) {
        typingUsers.set(conversationKey, /* @__PURE__ */ new Set());
      }
      typingUsers.get(conversationKey).add(userId);
      socket.to(`conversation:${conversationId}`).emit("typing:update", {
        conversationId,
        userId,
        isTyping: true
      });
    });
    socket.on("typing:stop", (conversationId) => {
      const conversationKey = `typing:${conversationId}`;
      typingUsers.get(conversationKey)?.delete(userId);
      socket.to(`conversation:${conversationId}`).emit("typing:update", {
        conversationId,
        userId,
        isTyping: false
      });
    });
    socket.on("disconnect", () => {
      console.log(`Chat: User ${userId} disconnected`);
      const userSockets = connectedUsers.get(userId);
      if (userSockets) {
        userSockets.delete(socket.id);
        if (userSockets.size === 0) {
          connectedUsers.delete(userId);
          socket.broadcast.emit("presence:update", {
            userId,
            isOnline: false,
            lastSeen: /* @__PURE__ */ new Date()
          });
        }
      }
      typingUsers.forEach((users8, key) => {
        users8.delete(userId);
      });
    });
  });
  ioInstance = io;
  console.log("\u2705 Chat Socket.IO server initialized");
  return io;
}

// server/services/queueSocket.service.ts
var queueSocketService = {
  emitSalonQueueUpdate(salonId, queueStatus) {
    const io = getSocketIO();
    if (!io) {
      console.warn("Socket.IO not initialized, cannot emit queue update");
      return;
    }
    io.to(`salon:queue:${salonId}`).emit("queue:salon:update", {
      ...queueStatus,
      updatedAt: (/* @__PURE__ */ new Date()).toISOString()
    });
    console.log(`Queue Socket: Emitted salon queue update for salon ${salonId}`);
  },
  emitStaffQueueUpdate(salonId, staffId, staffStatus) {
    const io = getSocketIO();
    if (!io) {
      console.warn("Socket.IO not initialized, cannot emit staff queue update");
      return;
    }
    io.to(`salon:queue:${salonId}`).emit("queue:staff:update", {
      salonId,
      staff: staffStatus,
      updatedAt: (/* @__PURE__ */ new Date()).toISOString()
    });
    console.log(`Queue Socket: Emitted staff queue update for staff ${staffId} in salon ${salonId}`);
  },
  emitDepartureStatusUpdate(userId, bookingId, status) {
    const io = getSocketIO();
    if (!io) {
      console.warn("Socket.IO not initialized, cannot emit departure status update");
      return;
    }
    io.to(`user:departure:${userId}`).emit("departure:status:update", {
      ...status,
      updatedAt: (/* @__PURE__ */ new Date()).toISOString()
    });
    console.log(`Queue Socket: Emitted departure status update for booking ${bookingId} to user ${userId}`);
  },
  emitDelayAlert(userId, bookingId, data) {
    const io = getSocketIO();
    if (!io) {
      console.warn("Socket.IO not initialized, cannot emit delay alert");
      return;
    }
    io.to(`user:departure:${userId}`).emit("departure:delay:alert", {
      bookingId,
      ...data,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
    console.log(`Queue Socket: Emitted delay alert for booking ${bookingId} to user ${userId}`);
  },
  emitQueueCaughtUp(userId, bookingId, data) {
    const io = getSocketIO();
    if (!io) {
      console.warn("Socket.IO not initialized, cannot emit queue caught up");
      return;
    }
    io.to(`user:departure:${userId}`).emit("departure:queue:caught_up", {
      bookingId,
      ...data,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
    console.log(`Queue Socket: Emitted queue caught up for booking ${bookingId} to user ${userId}`);
  },
  joinSalonQueueRoom(socketId, salonId) {
    const io = getSocketIO();
    if (!io) return;
    const socket = io.sockets.sockets.get(socketId);
    if (socket) {
      socket.join(`salon:queue:${salonId}`);
      console.log(`Queue Socket: Socket ${socketId} joined salon queue room ${salonId}`);
    }
  },
  leaveSalonQueueRoom(socketId, salonId) {
    const io = getSocketIO();
    if (!io) return;
    const socket = io.sockets.sockets.get(socketId);
    if (socket) {
      socket.leave(`salon:queue:${salonId}`);
      console.log(`Queue Socket: Socket ${socketId} left salon queue room ${salonId}`);
    }
  },
  joinUserDepartureRoom(socketId, userId) {
    const io = getSocketIO();
    if (!io) return;
    const socket = io.sockets.sockets.get(socketId);
    if (socket) {
      socket.join(`user:departure:${userId}`);
      console.log(`Queue Socket: Socket ${socketId} joined user departure room ${userId}`);
    }
  },
  leaveUserDepartureRoom(socketId, userId) {
    const io = getSocketIO();
    if (!io) return;
    const socket = io.sockets.sockets.get(socketId);
    if (socket) {
      socket.leave(`user:departure:${userId}`);
      console.log(`Queue Socket: Socket ${socketId} left user departure room ${userId}`);
    }
  }
};
function initializeQueueSocketEvents() {
  const io = getSocketIO();
  if (!io) {
    console.warn("Socket.IO not initialized, cannot setup queue events");
    return;
  }
  io.on("connection", (socket) => {
    const userId = socket.userId;
    socket.on("queue:salon:subscribe", (salonId) => {
      if (!salonId) return;
      socket.join(`salon:queue:${salonId}`);
      console.log(`Queue Socket: User ${userId || "unknown"} subscribed to salon ${salonId} queue updates`);
    });
    socket.on("queue:salon:unsubscribe", (salonId) => {
      if (!salonId) return;
      socket.leave(`salon:queue:${salonId}`);
      console.log(`Queue Socket: User ${userId || "unknown"} unsubscribed from salon ${salonId} queue updates`);
    });
    socket.on("departure:subscribe", () => {
      if (!userId) return;
      socket.join(`user:departure:${userId}`);
      console.log(`Queue Socket: User ${userId} subscribed to departure updates`);
    });
    socket.on("departure:unsubscribe", () => {
      if (!userId) return;
      socket.leave(`user:departure:${userId}`);
      console.log(`Queue Socket: User ${userId} unsubscribed from departure updates`);
    });
  });
  console.log("\u2705 Queue Socket events initialized");
}

// server/routes/client-profiles.routes.ts
init_db();
init_schema();
import { Router as Router8 } from "express";
import { eq as eq20, and as and20, desc as desc13, asc as asc4, sql as sql17, inArray as inArray7, or as or8 } from "drizzle-orm";
import { z as z5 } from "zod";
import multer2 from "multer";
var router9 = Router8();
var upload2 = multer2({
  storage: multer2.memoryStorage(),
  limits: { fileSize: 10 * 1024 * 1024 }
});
var isManagerOrOwner = (staffRoles) => {
  if (!staffRoles) return false;
  return staffRoles.some((r) => r.toLowerCase().includes("manager") || r.toLowerCase().includes("owner"));
};
var sanitizeString = (str) => {
  if (!str) return str;
  return str.replace(/<[^>]*>/g, "").trim().slice(0, 1e3);
};
var sanitizeArray = (arr) => {
  if (!arr) return arr;
  return arr.map((s) => s.replace(/<[^>]*>/g, "").trim().slice(0, 200)).filter((s) => s.length > 0);
};
var createClientProfileSchema = z5.object({
  customerId: z5.string().uuid(),
  hairType: z5.string().max(50).optional().transform(sanitizeString),
  hairCondition: z5.string().max(50).optional().transform(sanitizeString),
  hairLength: z5.string().max(50).optional().transform(sanitizeString),
  hairDensity: z5.string().max(50).optional().transform(sanitizeString),
  scalpCondition: z5.string().max(50).optional().transform(sanitizeString),
  skinType: z5.string().max(50).optional().transform(sanitizeString),
  skinConcerns: z5.array(z5.string().max(100)).max(20).optional().transform(sanitizeArray),
  allergies: z5.array(z5.string().max(100)).max(20).optional().transform(sanitizeArray),
  sensitivities: z5.array(z5.string().max(100)).max(20).optional().transform(sanitizeArray),
  contraindications: z5.string().max(2e3).optional().transform(sanitizeString),
  preferredStylistId: z5.string().uuid().optional(),
  communicationStyle: z5.string().max(50).optional().transform(sanitizeString),
  beveragePreference: z5.string().max(100).optional().transform(sanitizeString),
  musicPreference: z5.string().max(100).optional().transform(sanitizeString),
  specialRequirements: z5.string().max(2e3).optional().transform(sanitizeString),
  preferredProducts: z5.array(z5.string().max(100)).max(20).optional().transform(sanitizeArray),
  dislikedProducts: z5.array(z5.string().max(100)).max(20).optional().transform(sanitizeArray),
  isVip: z5.number().min(0).max(1).optional(),
  vipNotes: z5.string().max(2e3).optional().transform(sanitizeString)
});
var updateClientProfileSchema2 = createClientProfileSchema.partial();
var createClientNoteSchema = z5.object({
  bookingId: z5.string().uuid().optional(),
  serviceId: z5.string().uuid().optional(),
  noteType: z5.enum(["general", "appointment", "formula", "complaint", "compliment"]).optional().default("general"),
  title: z5.string().max(200).optional().transform(sanitizeString),
  content: z5.string().min(1).max(5e3).transform((s) => sanitizeString(s) || ""),
  isPinned: z5.number().min(0).max(1).optional(),
  isAlertNote: z5.number().min(0).max(1).optional(),
  isVisibleToCustomer: z5.number().min(0).max(1).optional()
});
var updateClientNoteSchema = createClientNoteSchema.partial();
var createClientFormulaSchema = z5.object({
  bookingId: z5.string().uuid().optional(),
  formulaType: z5.enum(["hair_color", "highlights", "treatment", "perm", "relaxer", "other"]),
  formulaName: z5.string().min(1).max(200).transform((s) => sanitizeString(s) || ""),
  baseColor: z5.string().max(100).optional().transform(sanitizeString),
  targetColor: z5.string().max(100).optional().transform(sanitizeString),
  developer: z5.string().max(50).optional().transform(sanitizeString),
  mixingRatio: z5.string().max(50).optional().transform(sanitizeString),
  processingTime: z5.number().min(0).max(480).optional(),
  heatUsed: z5.number().min(0).max(1).optional(),
  products: z5.array(z5.object({
    brand: z5.string().max(100).optional(),
    name: z5.string().max(100).optional(),
    shade: z5.string().max(100).optional(),
    amount: z5.string().max(50).optional()
  })).max(20).optional(),
  applicationTechnique: z5.string().max(2e3).optional().transform(sanitizeString),
  sectioning: z5.string().max(1e3).optional().transform(sanitizeString),
  specialInstructions: z5.string().max(2e3).optional().transform(sanitizeString),
  resultNotes: z5.string().max(2e3).optional().transform(sanitizeString),
  resultRating: z5.number().min(1).max(5).optional(),
  isActiveFormula: z5.number().min(0).max(1).optional(),
  isCustomerFavorite: z5.number().min(0).max(1).optional()
});
var updateClientFormulaSchema = createClientFormulaSchema.partial();
var updateVisibilitySettingsSchema = z5.object({
  visibilityMode: z5.enum(["all", "preferences_only", "none", "custom"]).optional(),
  showHairProfile: z5.number().optional(),
  showSkinProfile: z5.number().optional(),
  showAllergies: z5.number().optional(),
  showPreferences: z5.number().optional(),
  showPhotos: z5.number().optional(),
  showNotes: z5.number().optional(),
  showFormulas: z5.number().optional(),
  showVisitHistory: z5.number().optional(),
  showProfileOnBooking: z5.number().optional(),
  highlightAllergies: z5.number().optional(),
  highlightVip: z5.number().optional()
});
router9.get("/:salonId/clients", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId } = req.params;
    const { search, page = "1", limit = "20", sortBy = "lastVisitDate", sortOrder = "desc" } = req.query;
    const pageNum = parseInt(page) || 1;
    const limitNum = Math.min(parseInt(limit) || 20, 100);
    const offset = (pageNum - 1) * limitNum;
    let whereCondition = eq20(clientProfiles.salonId, salonId);
    const profiles = await db.query.clientProfiles.findMany({
      where: whereCondition,
      with: {
        customer: {
          columns: {
            id: true,
            firstName: true,
            lastName: true,
            email: true,
            phone: true,
            profileImageUrl: true
          }
        },
        preferredStylist: {
          columns: {
            id: true,
            name: true
          }
        }
      },
      orderBy: sortOrder === "asc" ? asc4(clientProfiles.lastVisitDate) : desc13(clientProfiles.lastVisitDate),
      limit: limitNum,
      offset
    });
    let filteredProfiles = profiles;
    if (search) {
      const searchLower = search.toLowerCase();
      filteredProfiles = profiles.filter(
        (p) => p.customer?.firstName?.toLowerCase().includes(searchLower) || p.customer?.lastName?.toLowerCase().includes(searchLower) || p.customer?.email?.toLowerCase().includes(searchLower) || p.customer?.phone?.includes(search)
      );
    }
    const totalCount = await db.select({ count: sql17`count(*)` }).from(clientProfiles).where(eq20(clientProfiles.salonId, salonId));
    res.json({
      profiles: filteredProfiles,
      pagination: {
        page: pageNum,
        limit: limitNum,
        total: Number(totalCount[0]?.count || 0),
        totalPages: Math.ceil(Number(totalCount[0]?.count || 0) / limitNum)
      }
    });
  } catch (error) {
    console.error("Error fetching client profiles:", error);
    res.status(500).json({ error: "Failed to fetch client profiles" });
  }
});
router9.get("/:salonId/clients/:customerId", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId, customerId } = req.params;
    const profile = await db.query.clientProfiles.findFirst({
      where: and20(
        eq20(clientProfiles.salonId, salonId),
        eq20(clientProfiles.customerId, customerId)
      ),
      with: {
        customer: {
          columns: {
            id: true,
            firstName: true,
            lastName: true,
            email: true,
            phone: true,
            profileImageUrl: true
          }
        },
        preferredStylist: {
          columns: {
            id: true,
            name: true
          }
        },
        notes: {
          orderBy: [desc13(clientNotes.isPinned), desc13(clientNotes.createdAt)],
          limit: 50
        },
        formulas: {
          orderBy: [desc13(clientFormulas.isActiveFormula), desc13(clientFormulas.createdAt)],
          limit: 20
        },
        photos: {
          orderBy: desc13(clientPhotos.createdAt),
          limit: 50
        }
      }
    });
    if (!profile) {
      const customer = await db.query.users.findFirst({
        where: eq20(users.id, customerId),
        columns: {
          id: true,
          firstName: true,
          lastName: true,
          email: true,
          phone: true,
          profileImageUrl: true
        }
      });
      if (!customer) {
        return res.status(404).json({ error: "Customer not found" });
      }
      return res.json({
        profile: null,
        customer,
        notes: [],
        formulas: [],
        photos: [],
        isNew: true
      });
    }
    res.json({
      profile,
      customer: profile.customer,
      notes: profile.notes,
      formulas: profile.formulas,
      photos: profile.photos,
      isNew: false
    });
  } catch (error) {
    console.error("Error fetching client profile:", error);
    res.status(500).json({ error: "Failed to fetch client profile" });
  }
});
router9.post("/:salonId/clients", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId } = req.params;
    const userId = req.user?.id;
    const validation = createClientProfileSchema.safeParse(req.body);
    if (!validation.success) {
      return res.status(400).json({ error: validation.error.errors });
    }
    const existingProfile = await db.query.clientProfiles.findFirst({
      where: and20(
        eq20(clientProfiles.salonId, salonId),
        eq20(clientProfiles.customerId, validation.data.customerId)
      )
    });
    if (existingProfile) {
      return res.status(400).json({ error: "Client profile already exists for this customer" });
    }
    const customer = await db.query.users.findFirst({
      where: eq20(users.id, validation.data.customerId)
    });
    if (!customer) {
      return res.status(404).json({ error: "Customer not found" });
    }
    const [profile] = await db.insert(clientProfiles).values({
      salonId,
      ...validation.data,
      createdBy: userId,
      updatedBy: userId
    }).returning();
    res.status(201).json({ profile });
  } catch (error) {
    console.error("Error creating client profile:", error);
    res.status(500).json({ error: "Failed to create client profile" });
  }
});
router9.put("/:salonId/clients/:profileId", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId, profileId } = req.params;
    const userId = req.user?.id;
    const validation = updateClientProfileSchema2.safeParse(req.body);
    if (!validation.success) {
      return res.status(400).json({ error: validation.error.errors });
    }
    const existingProfile = await db.query.clientProfiles.findFirst({
      where: and20(
        eq20(clientProfiles.id, profileId),
        eq20(clientProfiles.salonId, salonId)
      )
    });
    if (!existingProfile) {
      return res.status(404).json({ error: "Client profile not found" });
    }
    const [updatedProfile] = await db.update(clientProfiles).set({
      ...validation.data,
      updatedAt: /* @__PURE__ */ new Date(),
      updatedBy: userId
    }).where(eq20(clientProfiles.id, profileId)).returning();
    res.json({ profile: updatedProfile });
  } catch (error) {
    console.error("Error updating client profile:", error);
    res.status(500).json({ error: "Failed to update client profile" });
  }
});
router9.post("/:salonId/clients/:profileId/notes", requireStaffAccess, async (req, res) => {
  try {
    const { salonId, profileId } = req.params;
    const userId = req.user?.id;
    const validation = createClientNoteSchema.safeParse(req.body);
    if (!validation.success) {
      return res.status(400).json({ error: validation.error.errors });
    }
    const profile = await db.query.clientProfiles.findFirst({
      where: and20(
        eq20(clientProfiles.id, profileId),
        eq20(clientProfiles.salonId, salonId)
      )
    });
    if (!profile) {
      return res.status(404).json({ error: "Client profile not found" });
    }
    const staffMember = await db.query.staff.findFirst({
      where: and20(
        eq20(staff.salonId, salonId),
        eq20(staff.userId, userId)
      )
    });
    const [note] = await db.insert(clientNotes).values({
      clientProfileId: profileId,
      authorId: userId,
      authorStaffId: staffMember?.id,
      ...validation.data
    }).returning();
    res.status(201).json({ note });
  } catch (error) {
    console.error("Error creating client note:", error);
    res.status(500).json({ error: "Failed to create client note" });
  }
});
router9.put("/:salonId/clients/:profileId/notes/:noteId", requireStaffAccess, async (req, res) => {
  try {
    const { salonId, profileId, noteId } = req.params;
    const userId = req.user?.id;
    const validation = createClientNoteSchema.partial().safeParse(req.body);
    if (!validation.success) {
      return res.status(400).json({ error: validation.error.errors });
    }
    const note = await db.query.clientNotes.findFirst({
      where: and20(
        eq20(clientNotes.id, noteId),
        eq20(clientNotes.clientProfileId, profileId)
      ),
      with: {
        clientProfile: true
      }
    });
    if (!note || note.clientProfile.salonId !== salonId) {
      return res.status(404).json({ error: "Note not found" });
    }
    const staffMember = await db.query.staff.findFirst({
      where: and20(
        eq20(staff.salonId, salonId),
        eq20(staff.userId, userId)
      )
    });
    const isAuthorOrManager = note.authorId === userId || isManagerOrOwner(staffMember?.roles ?? null);
    if (!isAuthorOrManager) {
      return res.status(403).json({ error: "Only the author or manager can edit this note" });
    }
    const [updatedNote] = await db.update(clientNotes).set({
      ...validation.data,
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq20(clientNotes.id, noteId)).returning();
    res.json({ note: updatedNote });
  } catch (error) {
    console.error("Error updating client note:", error);
    res.status(500).json({ error: "Failed to update client note" });
  }
});
router9.delete("/:salonId/clients/:profileId/notes/:noteId", requireStaffAccess, async (req, res) => {
  try {
    const { salonId, profileId, noteId } = req.params;
    const userId = req.user?.id;
    const note = await db.query.clientNotes.findFirst({
      where: and20(
        eq20(clientNotes.id, noteId),
        eq20(clientNotes.clientProfileId, profileId)
      ),
      with: {
        clientProfile: true
      }
    });
    if (!note || note.clientProfile.salonId !== salonId) {
      return res.status(404).json({ error: "Note not found" });
    }
    const staffMember = await db.query.staff.findFirst({
      where: and20(
        eq20(staff.salonId, salonId),
        eq20(staff.userId, userId)
      )
    });
    const isManager = isManagerOrOwner(staffMember?.roles ?? null);
    if (!isManager) {
      return res.status(403).json({ error: "Only manager or owner can delete notes" });
    }
    await db.delete(clientNotes).where(eq20(clientNotes.id, noteId));
    res.json({ success: true });
  } catch (error) {
    console.error("Error deleting client note:", error);
    res.status(500).json({ error: "Failed to delete client note" });
  }
});
router9.post("/:salonId/clients/:profileId/formulas", requireStaffAccess, async (req, res) => {
  try {
    const { salonId, profileId } = req.params;
    const userId = req.user?.id;
    const validation = createClientFormulaSchema.safeParse(req.body);
    if (!validation.success) {
      return res.status(400).json({ error: validation.error.errors });
    }
    const profile = await db.query.clientProfiles.findFirst({
      where: and20(
        eq20(clientProfiles.id, profileId),
        eq20(clientProfiles.salonId, salonId)
      )
    });
    if (!profile) {
      return res.status(404).json({ error: "Client profile not found" });
    }
    const [formula] = await db.insert(clientFormulas).values({
      clientProfileId: profileId,
      createdBy: userId,
      updatedBy: userId,
      ...validation.data
    }).returning();
    res.status(201).json({ formula });
  } catch (error) {
    console.error("Error creating client formula:", error);
    res.status(500).json({ error: "Failed to create client formula" });
  }
});
router9.put("/:salonId/clients/:profileId/formulas/:formulaId", requireStaffAccess, async (req, res) => {
  try {
    const { salonId, profileId, formulaId } = req.params;
    const userId = req.user?.id;
    const validation = createClientFormulaSchema.partial().safeParse(req.body);
    if (!validation.success) {
      return res.status(400).json({ error: validation.error.errors });
    }
    const formula = await db.query.clientFormulas.findFirst({
      where: and20(
        eq20(clientFormulas.id, formulaId),
        eq20(clientFormulas.clientProfileId, profileId)
      ),
      with: {
        clientProfile: true
      }
    });
    if (!formula || formula.clientProfile.salonId !== salonId) {
      return res.status(404).json({ error: "Formula not found" });
    }
    const staffMember = await db.query.staff.findFirst({
      where: and20(
        eq20(staff.salonId, salonId),
        eq20(staff.userId, userId)
      )
    });
    const isAuthorOrManager = formula.createdBy === userId || isManagerOrOwner(staffMember?.roles ?? null);
    if (!isAuthorOrManager) {
      return res.status(403).json({ error: "Only the author or manager can edit this formula" });
    }
    const [updatedFormula] = await db.update(clientFormulas).set({
      ...validation.data,
      updatedAt: /* @__PURE__ */ new Date(),
      updatedBy: userId
    }).where(eq20(clientFormulas.id, formulaId)).returning();
    res.json({ formula: updatedFormula });
  } catch (error) {
    console.error("Error updating client formula:", error);
    res.status(500).json({ error: "Failed to update client formula" });
  }
});
router9.delete("/:salonId/clients/:profileId/formulas/:formulaId", requireStaffAccess, async (req, res) => {
  try {
    const { salonId, profileId, formulaId } = req.params;
    const userId = req.user?.id;
    const formula = await db.query.clientFormulas.findFirst({
      where: and20(
        eq20(clientFormulas.id, formulaId),
        eq20(clientFormulas.clientProfileId, profileId)
      ),
      with: {
        clientProfile: true
      }
    });
    if (!formula || formula.clientProfile.salonId !== salonId) {
      return res.status(404).json({ error: "Formula not found" });
    }
    const staffMember = await db.query.staff.findFirst({
      where: and20(
        eq20(staff.salonId, salonId),
        eq20(staff.userId, userId)
      )
    });
    const isManager = isManagerOrOwner(staffMember?.roles ?? null);
    if (!isManager) {
      return res.status(403).json({ error: "Only manager or owner can delete formulas" });
    }
    await db.delete(clientFormulas).where(eq20(clientFormulas.id, formulaId));
    res.json({ success: true });
  } catch (error) {
    console.error("Error deleting client formula:", error);
    res.status(500).json({ error: "Failed to delete client formula" });
  }
});
var ALLOWED_IMAGE_TYPES = ["image/jpeg", "image/jpg", "image/png", "image/webp", "image/heic", "image/heif"];
var MAX_PHOTO_SIZE = 10 * 1024 * 1024;
router9.post("/:salonId/clients/:profileId/photos", requireStaffAccess, upload2.single("photo"), async (req, res) => {
  try {
    const { salonId, profileId } = req.params;
    const userId = req.user?.id;
    const { photoType, caption, serviceType, bookingId, formulaId, isVisibleToCustomer, isPortfolioPhoto, consentGiven } = req.body;
    if (!req.file) {
      return res.status(400).json({ error: "No photo file provided" });
    }
    if (!ALLOWED_IMAGE_TYPES.includes(req.file.mimetype.toLowerCase())) {
      return res.status(400).json({
        error: "Invalid file type. Allowed types: JPEG, PNG, WebP, HEIC"
      });
    }
    if (req.file.size > MAX_PHOTO_SIZE) {
      return res.status(400).json({
        error: "File too large. Maximum size is 10MB"
      });
    }
    const validPhotoTypes = ["before", "after", "reference", "inspiration", "result", "other"];
    const sanitizedPhotoType = validPhotoTypes.includes(photoType) ? photoType : "after";
    const sanitizedCaption = caption ? String(caption).replace(/<[^>]*>/g, "").trim().slice(0, 500) : void 0;
    const profile = await db.query.clientProfiles.findFirst({
      where: and20(
        eq20(clientProfiles.id, profileId),
        eq20(clientProfiles.salonId, salonId)
      )
    });
    if (!profile) {
      return res.status(404).json({ error: "Client profile not found" });
    }
    const { publicUrl: photoUrl } = tempImageStorage.uploadImage(req.file.buffer, req.file.mimetype);
    const [photo] = await db.insert(clientPhotos).values({
      clientProfileId: profileId,
      photoType: sanitizedPhotoType,
      photoUrl,
      caption: sanitizedCaption,
      serviceType: serviceType ? String(serviceType).slice(0, 100) : void 0,
      bookingId: bookingId || null,
      formulaId: formulaId || null,
      isVisibleToCustomer: parseInt(isVisibleToCustomer) === 0 ? 0 : 1,
      isPortfolioPhoto: parseInt(isPortfolioPhoto) === 1 ? 1 : 0,
      consentGiven: parseInt(consentGiven) === 1 ? 1 : 0,
      uploadedBy: userId,
      takenAt: /* @__PURE__ */ new Date()
    }).returning();
    res.status(201).json({ photo });
  } catch (error) {
    console.error("Error uploading client photo:", error);
    res.status(500).json({ error: "Failed to upload client photo" });
  }
});
router9.delete("/:salonId/clients/:profileId/photos/:photoId", requireStaffAccess, async (req, res) => {
  try {
    const { salonId, profileId, photoId } = req.params;
    const userId = req.user?.id;
    const photo = await db.query.clientPhotos.findFirst({
      where: and20(
        eq20(clientPhotos.id, photoId),
        eq20(clientPhotos.clientProfileId, profileId)
      ),
      with: {
        clientProfile: true
      }
    });
    if (!photo || photo.clientProfile.salonId !== salonId) {
      return res.status(404).json({ error: "Photo not found" });
    }
    const staffMember = await db.query.staff.findFirst({
      where: and20(
        eq20(staff.salonId, salonId),
        eq20(staff.userId, userId)
      )
    });
    const isUploaderOrManager = photo.uploadedBy === userId || isManagerOrOwner(staffMember?.roles ?? null);
    if (!isUploaderOrManager) {
      return res.status(403).json({ error: "Only the uploader or manager can delete this photo" });
    }
    await db.delete(clientPhotos).where(eq20(clientPhotos.id, photoId));
    res.json({ success: true });
  } catch (error) {
    console.error("Error deleting client photo:", error);
    res.status(500).json({ error: "Failed to delete client photo" });
  }
});
router9.get("/:salonId/visibility-settings", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId } = req.params;
    let settings = await db.query.profileVisibilitySettings.findFirst({
      where: eq20(profileVisibilitySettings.salonId, salonId)
    });
    if (!settings) {
      const [newSettings] = await db.insert(profileVisibilitySettings).values({
        salonId
      }).returning();
      settings = newSettings;
    }
    res.json({ settings });
  } catch (error) {
    console.error("Error fetching visibility settings:", error);
    res.status(500).json({ error: "Failed to fetch visibility settings" });
  }
});
router9.put("/:salonId/visibility-settings", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId } = req.params;
    const userId = req.user?.id;
    const validation = updateVisibilitySettingsSchema.safeParse(req.body);
    if (!validation.success) {
      return res.status(400).json({ error: validation.error.errors });
    }
    let settings = await db.query.profileVisibilitySettings.findFirst({
      where: eq20(profileVisibilitySettings.salonId, salonId)
    });
    if (!settings) {
      const [newSettings] = await db.insert(profileVisibilitySettings).values({
        salonId,
        ...validation.data,
        updatedBy: userId
      }).returning();
      return res.json({ settings: newSettings });
    }
    const [updatedSettings] = await db.update(profileVisibilitySettings).set({
      ...validation.data,
      updatedAt: /* @__PURE__ */ new Date(),
      updatedBy: userId
    }).where(eq20(profileVisibilitySettings.salonId, salonId)).returning();
    res.json({ settings: updatedSettings });
  } catch (error) {
    console.error("Error updating visibility settings:", error);
    res.status(500).json({ error: "Failed to update visibility settings" });
  }
});
router9.get("/:salonId/clients/:customerId/booking-popup", requireStaffAccess, async (req, res) => {
  try {
    const { salonId, customerId } = req.params;
    const settings = await db.query.profileVisibilitySettings.findFirst({
      where: eq20(profileVisibilitySettings.salonId, salonId)
    });
    if (!settings?.showProfileOnBooking) {
      return res.json({ showPopup: false });
    }
    const profile = await db.query.clientProfiles.findFirst({
      where: and20(
        eq20(clientProfiles.salonId, salonId),
        eq20(clientProfiles.customerId, customerId)
      ),
      with: {
        customer: {
          columns: {
            id: true,
            firstName: true,
            lastName: true,
            profileImageUrl: true
          }
        },
        preferredStylist: {
          columns: {
            id: true,
            name: true
          }
        },
        notes: {
          where: eq20(clientNotes.isAlertNote, 1),
          orderBy: desc13(clientNotes.createdAt),
          limit: 5
        }
      }
    });
    if (!profile) {
      return res.json({
        showPopup: false,
        isNewClient: true
      });
    }
    const recentNotes = await db.query.clientNotes.findMany({
      where: eq20(clientNotes.clientProfileId, profile.id),
      orderBy: desc13(clientNotes.createdAt),
      limit: 3
    });
    res.json({
      showPopup: true,
      profile: {
        id: profile.id,
        customerName: `${profile.customer?.firstName || ""} ${profile.customer?.lastName || ""}`.trim(),
        customerImage: profile.customer?.profileImageUrl,
        isVip: profile.isVip === 1,
        allergies: profile.allergies || [],
        sensitivities: profile.sensitivities || [],
        specialRequirements: profile.specialRequirements,
        preferredStylist: profile.preferredStylist?.name,
        totalVisits: profile.totalVisits,
        lastVisitDate: profile.lastVisitDate
      },
      alertNotes: profile.notes,
      recentNotes,
      highlightAllergies: settings.highlightAllergies === 1,
      highlightVip: settings.highlightVip === 1
    });
  } catch (error) {
    console.error("Error fetching booking popup data:", error);
    res.status(500).json({ error: "Failed to fetch booking popup data" });
  }
});
router9.get("/:salonId/clients/search", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId } = req.params;
    const { q } = req.query;
    if (!q || q.length < 2) {
      return res.json({ customers: [] });
    }
    const searchTerm = `%${q}%`;
    const customers = await db.select({
      id: users.id,
      firstName: users.firstName,
      lastName: users.lastName,
      email: users.email,
      phone: users.phone,
      profileImageUrl: users.profileImageUrl
    }).from(users).where(
      or8(
        sql17`LOWER(${users.firstName}) LIKE LOWER(${searchTerm})`,
        sql17`LOWER(${users.lastName}) LIKE LOWER(${searchTerm})`,
        sql17`LOWER(${users.email}) LIKE LOWER(${searchTerm})`,
        sql17`${users.phone} LIKE ${searchTerm}`
      )
    ).limit(10);
    const customerIds = customers.map((c) => c.id);
    let existingProfiles = [];
    if (customerIds.length > 0) {
      existingProfiles = await db.select({ customerId: clientProfiles.customerId }).from(clientProfiles).where(and20(
        eq20(clientProfiles.salonId, salonId),
        inArray7(clientProfiles.customerId, customerIds)
      ));
    }
    const existingCustomerIds = new Set(existingProfiles.map((p) => p.customerId));
    const customersWithStatus = customers.map((c) => ({
      ...c,
      hasProfile: existingCustomerIds.has(c.id)
    }));
    res.json({ customers: customersWithStatus });
  } catch (error) {
    console.error("Error searching customers:", error);
    res.status(500).json({ error: "Failed to search customers" });
  }
});
router9.get("/my-beauty-profile", async (req, res) => {
  try {
    const userId = req.user?.id;
    if (!userId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const profiles = await db.query.clientProfiles.findMany({
      where: eq20(clientProfiles.customerId, userId),
      with: {
        salon: {
          columns: {
            id: true,
            name: true,
            imageUrl: true
          }
        },
        preferredStylist: {
          columns: {
            id: true,
            name: true
          }
        }
      }
    });
    if (!profiles || profiles.length === 0) {
      return res.json({
        profiles: [],
        hasProfiles: false,
        message: "No beauty profile found. Your profile will be created when you book an appointment at a salon."
      });
    }
    const profilesWithVisibleData = await Promise.all(profiles.map(async (profile) => {
      const settings = await db.query.profileVisibilitySettings.findFirst({
        where: eq20(profileVisibilitySettings.salonId, profile.salonId)
      });
      const visibilityDefaults = {
        showHairProfile: 1,
        showSkinProfile: 1,
        showAllergies: 1,
        showPreferences: 1,
        showPhotos: 0,
        showNotes: 0,
        showFormulas: 0,
        showVisitHistory: 1
      };
      const visibility = settings || visibilityDefaults;
      let visibleNotes = [];
      if (visibility.showNotes) {
        visibleNotes = await db.query.clientNotes.findMany({
          where: and20(
            eq20(clientNotes.clientProfileId, profile.id),
            eq20(clientNotes.isVisibleToCustomer, 1)
          ),
          orderBy: desc13(clientNotes.createdAt),
          limit: 10
        });
      }
      let visiblePhotos = [];
      if (visibility.showPhotos) {
        visiblePhotos = await db.query.clientPhotos.findMany({
          where: and20(
            eq20(clientPhotos.clientProfileId, profile.id),
            eq20(clientPhotos.isVisibleToCustomer, 1)
          ),
          orderBy: desc13(clientPhotos.createdAt),
          limit: 20
        });
      }
      let visibleFormulas = [];
      if (visibility.showFormulas) {
        visibleFormulas = await db.query.clientFormulas.findMany({
          where: and20(
            eq20(clientFormulas.clientProfileId, profile.id),
            eq20(clientFormulas.isCustomerFavorite, 1)
          ),
          orderBy: desc13(clientFormulas.createdAt),
          limit: 10
        });
      }
      return {
        id: profile.id,
        salonId: profile.salonId,
        salon: profile.salon,
        isVip: profile.isVip === 1,
        hairProfile: visibility.showHairProfile ? {
          hairType: profile.hairType,
          hairCondition: profile.hairCondition,
          hairLength: profile.hairLength,
          hairDensity: profile.hairDensity,
          scalpCondition: profile.scalpCondition
        } : null,
        skinProfile: visibility.showSkinProfile ? {
          skinType: profile.skinType,
          skinConcerns: profile.skinConcerns
        } : null,
        allergies: visibility.showAllergies ? profile.allergies : null,
        sensitivities: visibility.showAllergies ? profile.sensitivities : null,
        preferences: visibility.showPreferences ? {
          preferredStylist: profile.preferredStylist?.name,
          preferredStylistId: profile.preferredStylistId,
          communicationStyle: profile.communicationStyle,
          beveragePreference: profile.beveragePreference,
          musicPreference: profile.musicPreference,
          specialRequirements: profile.specialRequirements,
          preferredProducts: profile.preferredProducts,
          dislikedProducts: profile.dislikedProducts
        } : null,
        visitStats: visibility.showVisitHistory ? {
          totalVisits: profile.totalVisits,
          lastVisitDate: profile.lastVisitDate
        } : null,
        notes: visibleNotes.map((note) => ({
          id: note.id,
          title: note.title,
          content: note.content,
          noteType: note.noteType,
          createdAt: note.createdAt
        })),
        photos: visiblePhotos.map((photo) => ({
          id: photo.id,
          photoUrl: photo.photoUrl,
          thumbnailUrl: photo.thumbnailUrl,
          caption: photo.caption,
          photoType: photo.photoType,
          serviceType: photo.serviceType,
          takenAt: photo.takenAt
        })),
        formulas: visibleFormulas.map((formula) => ({
          id: formula.id,
          formulaName: formula.formulaName,
          formulaType: formula.formulaType,
          targetColor: formula.targetColor,
          resultNotes: formula.resultNotes,
          resultRating: formula.resultRating
        })),
        createdAt: profile.createdAt,
        updatedAt: profile.updatedAt
      };
    }));
    const aggregatedProfile = {
      hairTypes: Array.from(new Set(profilesWithVisibleData.filter((p) => p.hairProfile?.hairType).map((p) => p.hairProfile?.hairType))),
      skinTypes: Array.from(new Set(profilesWithVisibleData.filter((p) => p.skinProfile?.skinType).map((p) => p.skinProfile?.skinType))),
      allAllergies: Array.from(new Set(profilesWithVisibleData.flatMap((p) => p.allergies || []))),
      allSensitivities: Array.from(new Set(profilesWithVisibleData.flatMap((p) => p.sensitivities || []))),
      totalVisitsAcrossSalons: profilesWithVisibleData.reduce((sum4, p) => sum4 + (p.visitStats?.totalVisits || 0), 0),
      isVipAnywhere: profilesWithVisibleData.some((p) => p.isVip)
    };
    res.json({
      profiles: profilesWithVisibleData,
      aggregated: aggregatedProfile,
      hasProfiles: true,
      salonCount: profiles.length
    });
  } catch (error) {
    console.error("Error fetching customer beauty profile:", error);
    res.status(500).json({ error: "Failed to fetch beauty profile" });
  }
});
var customerUpdatePreferencesSchema = z5.object({
  hairType: z5.string().optional(),
  hairCondition: z5.string().optional(),
  hairLength: z5.string().optional(),
  hairDensity: z5.string().optional(),
  scalpCondition: z5.string().optional(),
  skinType: z5.string().optional(),
  skinConcerns: z5.array(z5.string()).optional(),
  allergies: z5.array(z5.string()).optional(),
  sensitivities: z5.array(z5.string()).optional(),
  communicationStyle: z5.string().optional(),
  beveragePreference: z5.string().optional(),
  musicPreference: z5.string().optional(),
  specialRequirements: z5.string().optional(),
  preferredProducts: z5.array(z5.string()).optional(),
  dislikedProducts: z5.array(z5.string()).optional()
});
router9.put("/my-beauty-profile/:profileId", async (req, res) => {
  try {
    const userId = req.user?.id;
    if (!userId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const { profileId } = req.params;
    const profile = await db.query.clientProfiles.findFirst({
      where: and20(
        eq20(clientProfiles.id, profileId),
        eq20(clientProfiles.customerId, userId)
      )
    });
    if (!profile) {
      return res.status(404).json({ error: "Profile not found or access denied" });
    }
    const settings = await db.query.profileVisibilitySettings.findFirst({
      where: eq20(profileVisibilitySettings.salonId, profile.salonId)
    });
    const canEditPreferences = settings?.showPreferences !== 0;
    const canEditHairProfile = settings?.showHairProfile !== 0;
    const canEditSkinProfile = settings?.showSkinProfile !== 0;
    const canEditAllergies = settings?.showAllergies !== 0;
    const validation = customerUpdatePreferencesSchema.safeParse(req.body);
    if (!validation.success) {
      return res.status(400).json({ error: "Invalid input", details: validation.error.errors });
    }
    const updateData = { updatedAt: /* @__PURE__ */ new Date() };
    if (canEditHairProfile) {
      if (validation.data.hairType !== void 0) updateData.hairType = validation.data.hairType;
      if (validation.data.hairCondition !== void 0) updateData.hairCondition = validation.data.hairCondition;
      if (validation.data.hairLength !== void 0) updateData.hairLength = validation.data.hairLength;
      if (validation.data.hairDensity !== void 0) updateData.hairDensity = validation.data.hairDensity;
      if (validation.data.scalpCondition !== void 0) updateData.scalpCondition = validation.data.scalpCondition;
    }
    if (canEditSkinProfile) {
      if (validation.data.skinType !== void 0) updateData.skinType = validation.data.skinType;
      if (validation.data.skinConcerns !== void 0) updateData.skinConcerns = validation.data.skinConcerns;
    }
    if (canEditAllergies) {
      if (validation.data.allergies !== void 0) updateData.allergies = validation.data.allergies;
      if (validation.data.sensitivities !== void 0) updateData.sensitivities = validation.data.sensitivities;
    }
    if (canEditPreferences) {
      if (validation.data.communicationStyle !== void 0) updateData.communicationStyle = validation.data.communicationStyle;
      if (validation.data.beveragePreference !== void 0) updateData.beveragePreference = validation.data.beveragePreference;
      if (validation.data.musicPreference !== void 0) updateData.musicPreference = validation.data.musicPreference;
      if (validation.data.specialRequirements !== void 0) updateData.specialRequirements = validation.data.specialRequirements;
      if (validation.data.preferredProducts !== void 0) updateData.preferredProducts = validation.data.preferredProducts;
      if (validation.data.dislikedProducts !== void 0) updateData.dislikedProducts = validation.data.dislikedProducts;
    }
    if (Object.keys(updateData).length === 1) {
      return res.status(400).json({ error: "No editable fields provided or salon has restricted editing" });
    }
    await db.update(clientProfiles).set(updateData).where(eq20(clientProfiles.id, profileId));
    const updatedProfile = await db.query.clientProfiles.findFirst({
      where: eq20(clientProfiles.id, profileId),
      with: {
        salon: { columns: { id: true, name: true, imageUrl: true } },
        preferredStylist: { columns: { id: true, name: true } }
      }
    });
    res.json({
      success: true,
      message: "Profile updated successfully",
      profile: updatedProfile
    });
  } catch (error) {
    console.error("Error updating customer beauty profile:", error);
    res.status(500).json({ error: "Failed to update beauty profile" });
  }
});
router9.get("/my-beauty-profile/:profileId/photos", async (req, res) => {
  try {
    const userId = req.user?.id;
    if (!userId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const { profileId } = req.params;
    const { page = "1", limit = "20" } = req.query;
    const profile = await db.query.clientProfiles.findFirst({
      where: and20(
        eq20(clientProfiles.id, profileId),
        eq20(clientProfiles.customerId, userId)
      )
    });
    if (!profile) {
      return res.status(404).json({ error: "Profile not found or access denied" });
    }
    const settings = await db.query.profileVisibilitySettings.findFirst({
      where: eq20(profileVisibilitySettings.salonId, profile.salonId)
    });
    if (settings?.showPhotos === 0) {
      return res.json({
        photos: [],
        message: "Photos are not visible for this salon"
      });
    }
    const pageNum = parseInt(page) || 1;
    const limitNum = Math.min(parseInt(limit) || 20, 50);
    const offset = (pageNum - 1) * limitNum;
    const photos = await db.select().from(clientPhotos).where(and20(
      eq20(clientPhotos.clientProfileId, profileId),
      eq20(clientPhotos.isVisibleToCustomer, 1)
    )).orderBy(desc13(clientPhotos.createdAt)).limit(limitNum).offset(offset);
    const [{ count: count11 }] = await db.select({ count: sql17`count(*)::int` }).from(clientPhotos).where(and20(
      eq20(clientPhotos.clientProfileId, profileId),
      eq20(clientPhotos.isVisibleToCustomer, 1)
    ));
    res.json({
      photos,
      pagination: {
        page: pageNum,
        limit: limitNum,
        total: count11,
        totalPages: Math.ceil(count11 / limitNum)
      }
    });
  } catch (error) {
    console.error("Error fetching customer photos:", error);
    res.status(500).json({ error: "Failed to fetch photos" });
  }
});
router9.get("/booking-summary/:salonId", async (req, res) => {
  try {
    const userId = req.user?.id;
    if (!userId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const { salonId } = req.params;
    const profile = await db.query.clientProfiles.findFirst({
      where: and20(
        eq20(clientProfiles.salonId, salonId),
        eq20(clientProfiles.customerId, userId)
      ),
      with: {
        preferredStylist: {
          columns: {
            id: true,
            name: true
          }
        }
      }
    });
    if (!profile) {
      return res.status(404).json({ profile: null });
    }
    const settings = await db.query.profileVisibilitySettings.findFirst({
      where: eq20(profileVisibilitySettings.salonId, salonId)
    });
    const showPreferences = settings?.showPreferences !== 0;
    const showHairProfile = settings?.showHairProfile !== 0;
    const showSkinProfile = settings?.showSkinProfile !== 0;
    const showAllergies = settings?.showAllergies !== 0;
    res.json({
      profile: {
        id: profile.id,
        hairType: showHairProfile ? profile.hairType : void 0,
        hairCondition: showHairProfile ? profile.hairCondition : void 0,
        skinType: showSkinProfile ? profile.skinType : void 0,
        allergies: showAllergies ? profile.allergies : void 0,
        sensitivities: showAllergies ? profile.sensitivities : void 0,
        communicationStyle: showPreferences ? profile.communicationStyle : void 0,
        beveragePreference: showPreferences ? profile.beveragePreference : void 0,
        musicPreference: showPreferences ? profile.musicPreference : void 0,
        specialRequirements: showPreferences ? profile.specialRequirements : void 0,
        isVip: profile.isVip === 1,
        preferredStylist: profile.preferredStylist
      }
    });
  } catch (error) {
    console.error("Error fetching booking summary profile:", error);
    res.status(500).json({ error: "Failed to fetch booking summary" });
  }
});
router9.get("/:salonId/clients/by-email/:email", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId, email } = req.params;
    const customer = await db.query.users.findFirst({
      where: eq20(users.email, email),
      columns: {
        id: true,
        firstName: true,
        lastName: true,
        email: true,
        phone: true,
        profileImageUrl: true
      }
    });
    if (!customer) {
      return res.status(404).json({ error: "Customer not found" });
    }
    const profile = await db.query.clientProfiles.findFirst({
      where: and20(
        eq20(clientProfiles.salonId, salonId),
        eq20(clientProfiles.customerId, customer.id)
      ),
      with: {
        preferredStylist: {
          columns: {
            id: true,
            name: true
          }
        },
        notes: {
          where: eq20(clientNotes.isAlertNote, 1),
          orderBy: [desc13(clientNotes.isPinned), desc13(clientNotes.createdAt)],
          limit: 10
        }
      }
    });
    res.json({
      customer,
      profile: profile || null,
      alertNotes: profile?.notes || []
    });
  } catch (error) {
    console.error("Error fetching client profile by email:", error);
    res.status(500).json({ error: "Failed to fetch client profile" });
  }
});
router9.get("/:salonId/clients/:profileId/notes-with-authors", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId, profileId } = req.params;
    const { page = "1", limit = "50" } = req.query;
    const profile = await db.query.clientProfiles.findFirst({
      where: and20(
        eq20(clientProfiles.id, profileId),
        eq20(clientProfiles.salonId, salonId)
      )
    });
    if (!profile) {
      return res.status(404).json({ error: "Client profile not found" });
    }
    const pageNum = parseInt(page) || 1;
    const limitNum = Math.min(parseInt(limit) || 50, 100);
    const offset = (pageNum - 1) * limitNum;
    const notes = await db.query.clientNotes.findMany({
      where: eq20(clientNotes.clientProfileId, profileId),
      with: {
        author: {
          columns: {
            id: true,
            firstName: true,
            lastName: true
          }
        },
        authorStaff: {
          columns: {
            id: true,
            name: true
          }
        },
        service: {
          columns: {
            id: true,
            name: true
          }
        }
      },
      orderBy: [desc13(clientNotes.isPinned), desc13(clientNotes.createdAt)],
      limit: limitNum,
      offset
    });
    const notesWithAuthorInfo = notes.map((note) => ({
      ...note,
      authorName: note.authorStaff?.name || (note.author ? `${note.author.firstName || ""} ${note.author.lastName || ""}`.trim() : "Unknown"),
      serviceName: note.service?.name
    }));
    const [{ count: count11 }] = await db.select({ count: sql17`count(*)::int` }).from(clientNotes).where(eq20(clientNotes.clientProfileId, profileId));
    res.json({
      notes: notesWithAuthorInfo,
      pagination: {
        page: pageNum,
        limit: limitNum,
        total: count11,
        totalPages: Math.ceil(count11 / limitNum)
      }
    });
  } catch (error) {
    console.error("Error fetching notes with authors:", error);
    res.status(500).json({ error: "Failed to fetch notes" });
  }
});
router9.get("/mobile/my-profiles", authenticateMobileUser, async (req, res) => {
  try {
    const customerId = req.user?.id;
    if (!customerId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const profiles = await db.query.clientProfiles.findMany({
      where: eq20(clientProfiles.customerId, customerId),
      with: {
        salon: {
          columns: {
            id: true,
            name: true,
            address: true,
            imageUrl: true
          }
        },
        preferredStylist: {
          columns: {
            id: true,
            name: true
          }
        }
      },
      orderBy: desc13(clientProfiles.lastVisitDate)
    });
    res.json({ profiles });
  } catch (error) {
    console.error("Error fetching customer profiles:", error);
    res.status(500).json({ error: "Failed to fetch profiles" });
  }
});
router9.get("/mobile/my-profiles/:profileId", authenticateMobileUser, async (req, res) => {
  try {
    const customerId = req.user?.id;
    const { profileId } = req.params;
    if (!customerId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const profile = await db.query.clientProfiles.findFirst({
      where: and20(
        eq20(clientProfiles.id, profileId),
        eq20(clientProfiles.customerId, customerId)
      ),
      with: {
        salon: {
          columns: {
            id: true,
            name: true,
            address: true,
            imageUrl: true
          }
        },
        preferredStylist: {
          columns: {
            id: true,
            name: true
          }
        }
      }
    });
    if (!profile) {
      return res.status(404).json({ error: "Profile not found" });
    }
    res.json({ profile });
  } catch (error) {
    console.error("Error fetching customer profile:", error);
    res.status(500).json({ error: "Failed to fetch profile" });
  }
});
var mobileUpdatePreferencesSchema = z5.object({
  communicationStyle: z5.string().max(50).optional().transform(sanitizeString),
  beveragePreference: z5.string().max(100).optional().transform(sanitizeString),
  musicPreference: z5.string().max(100).optional().transform(sanitizeString),
  specialRequirements: z5.string().max(2e3).optional().transform(sanitizeString),
  preferredProducts: z5.array(z5.string().max(100)).max(20).optional().transform(sanitizeArray),
  dislikedProducts: z5.array(z5.string().max(100)).max(20).optional().transform(sanitizeArray)
});
router9.put("/mobile/my-profiles/:profileId/preferences", authenticateMobileUser, async (req, res) => {
  try {
    const customerId = req.user?.id;
    const { profileId } = req.params;
    if (!customerId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const validation = mobileUpdatePreferencesSchema.safeParse(req.body);
    if (!validation.success) {
      return res.status(400).json({ error: validation.error.errors });
    }
    const existingProfile = await db.query.clientProfiles.findFirst({
      where: and20(
        eq20(clientProfiles.id, profileId),
        eq20(clientProfiles.customerId, customerId)
      )
    });
    if (!existingProfile) {
      return res.status(404).json({ error: "Profile not found or access denied" });
    }
    const [updatedProfile] = await db.update(clientProfiles).set({
      ...validation.data,
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq20(clientProfiles.id, profileId)).returning();
    res.json({ profile: updatedProfile });
  } catch (error) {
    console.error("Error updating customer preferences:", error);
    res.status(500).json({ error: "Failed to update preferences" });
  }
});
router9.get("/mobile/my-profiles/:profileId/notes", authenticateMobileUser, async (req, res) => {
  try {
    const customerId = req.user?.id;
    const { profileId } = req.params;
    const { page = "1", limit = "20" } = req.query;
    if (!customerId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const profile = await db.query.clientProfiles.findFirst({
      where: and20(
        eq20(clientProfiles.id, profileId),
        eq20(clientProfiles.customerId, customerId)
      )
    });
    if (!profile) {
      return res.status(404).json({ error: "Profile not found or access denied" });
    }
    const pageNum = parseInt(page) || 1;
    const limitNum = Math.min(parseInt(limit) || 20, 50);
    const offset = (pageNum - 1) * limitNum;
    const notes = await db.query.clientNotes.findMany({
      where: and20(
        eq20(clientNotes.clientProfileId, profileId),
        eq20(clientNotes.isVisibleToCustomer, 1)
      ),
      with: {
        service: {
          columns: {
            id: true,
            name: true
          }
        }
      },
      orderBy: [desc13(clientNotes.isPinned), desc13(clientNotes.createdAt)],
      limit: limitNum,
      offset
    });
    const [{ count: count11 }] = await db.select({ count: sql17`count(*)::int` }).from(clientNotes).where(and20(
      eq20(clientNotes.clientProfileId, profileId),
      eq20(clientNotes.isVisibleToCustomer, 1)
    ));
    res.json({
      notes: notes.map((note) => ({
        id: note.id,
        noteType: note.noteType,
        title: note.title,
        content: note.content,
        serviceName: note.service?.name,
        createdAt: note.createdAt
      })),
      pagination: {
        page: pageNum,
        limit: limitNum,
        total: count11,
        totalPages: Math.ceil(count11 / limitNum)
      }
    });
  } catch (error) {
    console.error("Error fetching customer notes:", error);
    res.status(500).json({ error: "Failed to fetch notes" });
  }
});
router9.get("/mobile/my-profiles/:profileId/photos", authenticateMobileUser, async (req, res) => {
  try {
    const customerId = req.user?.id;
    const { profileId } = req.params;
    const { page = "1", limit = "20" } = req.query;
    if (!customerId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const profile = await db.query.clientProfiles.findFirst({
      where: and20(
        eq20(clientProfiles.id, profileId),
        eq20(clientProfiles.customerId, customerId)
      )
    });
    if (!profile) {
      return res.status(404).json({ error: "Profile not found or access denied" });
    }
    const pageNum = parseInt(page) || 1;
    const limitNum = Math.min(parseInt(limit) || 20, 50);
    const offset = (pageNum - 1) * limitNum;
    const photos = await db.query.clientPhotos.findMany({
      where: and20(
        eq20(clientPhotos.clientProfileId, profileId),
        eq20(clientPhotos.isVisibleToCustomer, 1)
      ),
      orderBy: desc13(clientPhotos.createdAt),
      limit: limitNum,
      offset
    });
    const [{ count: count11 }] = await db.select({ count: sql17`count(*)::int` }).from(clientPhotos).where(and20(
      eq20(clientPhotos.clientProfileId, profileId),
      eq20(clientPhotos.isVisibleToCustomer, 1)
    ));
    res.json({
      photos: photos.map((photo) => ({
        id: photo.id,
        photoType: photo.photoType,
        photoUrl: photo.photoUrl,
        caption: photo.caption,
        serviceType: photo.serviceType,
        takenAt: photo.takenAt,
        createdAt: photo.createdAt
      })),
      pagination: {
        page: pageNum,
        limit: limitNum,
        total: count11,
        totalPages: Math.ceil(count11 / limitNum)
      }
    });
  } catch (error) {
    console.error("Error fetching customer photos:", error);
    res.status(500).json({ error: "Failed to fetch photos" });
  }
});
var client_profiles_routes_default = router9;

// server/routes/deposits.routes.ts
init_db();
init_schema();
import { Router as Router9 } from "express";
import { eq as eq22, and as and22, desc as desc14, sql as sql19, inArray as inArray8 } from "drizzle-orm";
import { z as z6 } from "zod";
import Razorpay5 from "razorpay";
import crypto7 from "crypto";
var razorpay5 = new Razorpay5({
  key_id: process.env.RAZORPAY_KEY_ID || "",
  key_secret: process.env.RAZORPAY_KEY_SECRET || ""
});
var router10 = Router9();
var updateDepositSettingsSchema2 = z6.object({
  isEnabled: z6.number().min(0).max(1).optional(),
  depositPercentage: z6.number().min(5).max(100).optional(),
  usePriceThreshold: z6.number().min(0).max(1).optional(),
  priceThresholdPaisa: z6.number().optional().nullable(),
  useCategoryBased: z6.number().min(0).max(1).optional(),
  protectedCategories: z6.array(z6.string()).optional().nullable(),
  useManualToggle: z6.number().min(0).max(1).optional(),
  allowTrustedCustomerBypass: z6.number().min(0).max(1).optional(),
  requireCardOnFile: z6.number().min(0).max(1).optional()
});
var updateCancellationPolicySchema2 = z6.object({
  cancellationWindowHours: z6.number().min(1).max(168).optional(),
  withinWindowAction: z6.enum(["forfeit_full", "forfeit_partial", "no_penalty"]).optional(),
  partialForfeitPercentage: z6.number().min(0).max(100).optional(),
  noShowAction: z6.enum(["forfeit_full", "forfeit_partial", "charge_full_service"]).optional(),
  noShowChargeFull: z6.number().min(0).max(1).optional(),
  noShowGraceMinutes: z6.number().min(0).max(60).optional(),
  policyText: z6.string().max(2e3).optional().nullable()
});
var serviceDepositRuleSchema = z6.object({
  serviceId: z6.string(),
  requiresDeposit: z6.number().min(0).max(1),
  customPercentage: z6.number().min(5).max(100).optional().nullable(),
  minimumDepositPaisa: z6.number().optional().nullable(),
  maximumDepositPaisa: z6.number().optional().nullable()
});
var trustedCustomerSchema = z6.object({
  customerId: z6.string(),
  trustLevel: z6.enum(["trusted", "vip", "blacklisted"]).optional(),
  reason: z6.string().max(500).optional().nullable(),
  canBypassDeposit: z6.number().min(0).max(1).optional()
});
var depositTransactionSchema = z6.object({
  bookingId: z6.string(),
  transactionType: z6.enum(["deposit_collected", "deposit_refunded", "deposit_forfeited", "no_show_charged", "deposit_applied"]),
  amountPaisa: z6.number().min(0),
  serviceAmountPaisa: z6.number().min(0),
  depositPercentage: z6.number().min(0).max(100),
  razorpayPaymentId: z6.string().optional(),
  razorpayOrderId: z6.string().optional(),
  reason: z6.string().optional(),
  notes: z6.string().optional()
});
router10.get("/:salonId/deposit-settings", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId } = req.params;
    let settings = await db.query.depositSettings.findFirst({
      where: eq22(depositSettings.salonId, salonId)
    });
    if (!settings) {
      const [newSettings] = await db.insert(depositSettings).values({
        salonId,
        isEnabled: 0,
        depositPercentage: 25,
        usePriceThreshold: 0,
        useCategoryBased: 0,
        useManualToggle: 1,
        allowTrustedCustomerBypass: 1,
        requireCardOnFile: 1
      }).returning();
      settings = newSettings;
    }
    res.json(settings);
  } catch (error) {
    console.error("Error fetching deposit settings:", error);
    res.status(500).json({ error: "Failed to fetch deposit settings" });
  }
});
router10.put("/:salonId/deposit-settings", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId } = req.params;
    const userId = req.user?.id;
    const parsed = updateDepositSettingsSchema2.safeParse(req.body);
    if (!parsed.success) {
      return res.status(400).json({ error: "Invalid request body", details: parsed.error.errors });
    }
    let existing = await db.query.depositSettings.findFirst({
      where: eq22(depositSettings.salonId, salonId)
    });
    if (!existing) {
      const [newSettings] = await db.insert(depositSettings).values({
        salonId,
        ...parsed.data,
        updatedBy: userId
      }).returning();
      return res.json(newSettings);
    }
    const [updated] = await db.update(depositSettings).set({
      ...parsed.data,
      updatedAt: /* @__PURE__ */ new Date(),
      updatedBy: userId
    }).where(eq22(depositSettings.salonId, salonId)).returning();
    res.json(updated);
  } catch (error) {
    console.error("Error updating deposit settings:", error);
    res.status(500).json({ error: "Failed to update deposit settings" });
  }
});
router10.get("/:salonId/cancellation-policy", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId } = req.params;
    let policy = await db.query.cancellationPolicies.findFirst({
      where: eq22(cancellationPolicies.salonId, salonId)
    });
    if (!policy) {
      const [newPolicy] = await db.insert(cancellationPolicies).values({
        salonId,
        cancellationWindowHours: 24,
        withinWindowAction: "forfeit_full",
        partialForfeitPercentage: 50,
        noShowAction: "forfeit_full",
        noShowChargeFull: 0,
        noShowGraceMinutes: 15
      }).returning();
      policy = newPolicy;
    }
    res.json(policy);
  } catch (error) {
    console.error("Error fetching cancellation policy:", error);
    res.status(500).json({ error: "Failed to fetch cancellation policy" });
  }
});
router10.put("/:salonId/cancellation-policy", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId } = req.params;
    const userId = req.user?.id;
    const parsed = updateCancellationPolicySchema2.safeParse(req.body);
    if (!parsed.success) {
      return res.status(400).json({ error: "Invalid request body", details: parsed.error.errors });
    }
    let existing = await db.query.cancellationPolicies.findFirst({
      where: eq22(cancellationPolicies.salonId, salonId)
    });
    if (!existing) {
      const [newPolicy] = await db.insert(cancellationPolicies).values({
        salonId,
        ...parsed.data,
        updatedBy: userId
      }).returning();
      return res.json(newPolicy);
    }
    const [updated] = await db.update(cancellationPolicies).set({
      ...parsed.data,
      updatedAt: /* @__PURE__ */ new Date(),
      updatedBy: userId
    }).where(eq22(cancellationPolicies.salonId, salonId)).returning();
    res.json(updated);
  } catch (error) {
    console.error("Error updating cancellation policy:", error);
    res.status(500).json({ error: "Failed to update cancellation policy" });
  }
});
router10.get("/:salonId/service-deposit-rules", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId } = req.params;
    const rules = await db.select({
      id: serviceDepositRules.id,
      salonId: serviceDepositRules.salonId,
      serviceId: serviceDepositRules.serviceId,
      requiresDeposit: serviceDepositRules.requiresDeposit,
      customPercentage: serviceDepositRules.customPercentage,
      minimumDepositPaisa: serviceDepositRules.minimumDepositPaisa,
      maximumDepositPaisa: serviceDepositRules.maximumDepositPaisa,
      serviceName: services.name,
      serviceCategory: services.category,
      servicePriceInPaisa: services.priceInPaisa
    }).from(serviceDepositRules).leftJoin(services, eq22(serviceDepositRules.serviceId, services.id)).where(eq22(serviceDepositRules.salonId, salonId));
    res.json(rules);
  } catch (error) {
    console.error("Error fetching service deposit rules:", error);
    res.status(500).json({ error: "Failed to fetch service deposit rules" });
  }
});
router10.post("/:salonId/service-deposit-rules", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId } = req.params;
    const parsed = serviceDepositRuleSchema.safeParse(req.body);
    if (!parsed.success) {
      return res.status(400).json({ error: "Invalid request body", details: parsed.error.errors });
    }
    const service = await db.query.services.findFirst({
      where: and22(
        eq22(services.id, parsed.data.serviceId),
        eq22(services.salonId, salonId)
      )
    });
    if (!service) {
      return res.status(400).json({ error: "Service does not belong to this salon" });
    }
    const existing = await db.query.serviceDepositRules.findFirst({
      where: and22(
        eq22(serviceDepositRules.salonId, salonId),
        eq22(serviceDepositRules.serviceId, parsed.data.serviceId)
      )
    });
    if (existing) {
      const [updated] = await db.update(serviceDepositRules).set({
        requiresDeposit: parsed.data.requiresDeposit,
        customPercentage: parsed.data.customPercentage,
        minimumDepositPaisa: parsed.data.minimumDepositPaisa,
        maximumDepositPaisa: parsed.data.maximumDepositPaisa,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq22(serviceDepositRules.id, existing.id)).returning();
      return res.json(updated);
    }
    const [newRule] = await db.insert(serviceDepositRules).values({
      salonId,
      ...parsed.data
    }).returning();
    res.status(201).json(newRule);
  } catch (error) {
    console.error("Error creating/updating service deposit rule:", error);
    res.status(500).json({ error: "Failed to create/update service deposit rule" });
  }
});
router10.delete("/:salonId/service-deposit-rules/:ruleId", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId, ruleId } = req.params;
    const existing = await db.query.serviceDepositRules.findFirst({
      where: and22(
        eq22(serviceDepositRules.id, ruleId),
        eq22(serviceDepositRules.salonId, salonId)
      )
    });
    if (!existing) {
      return res.status(404).json({ error: "Service deposit rule not found" });
    }
    await db.delete(serviceDepositRules).where(eq22(serviceDepositRules.id, ruleId));
    res.json({ success: true });
  } catch (error) {
    console.error("Error deleting service deposit rule:", error);
    res.status(500).json({ error: "Failed to delete service deposit rule" });
  }
});
router10.post("/:salonId/service-deposit-rules/bulk", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId } = req.params;
    const { rules } = req.body;
    if (!Array.isArray(rules)) {
      return res.status(400).json({ error: "rules must be an array" });
    }
    const validatedRules = [];
    const invalidServiceIds = [];
    for (const rule of rules) {
      const parsed = serviceDepositRuleSchema.safeParse(rule);
      if (!parsed.success) continue;
      const service = await db.query.services.findFirst({
        where: and22(
          eq22(services.id, parsed.data.serviceId),
          eq22(services.salonId, salonId)
        )
      });
      if (!service) {
        invalidServiceIds.push(parsed.data.serviceId);
      } else {
        validatedRules.push(parsed.data);
      }
    }
    if (invalidServiceIds.length > 0) {
      return res.status(400).json({
        error: "Some services do not belong to this salon",
        invalidServiceIds
      });
    }
    const results = [];
    for (const rule of validatedRules) {
      const existing = await db.query.serviceDepositRules.findFirst({
        where: and22(
          eq22(serviceDepositRules.salonId, salonId),
          eq22(serviceDepositRules.serviceId, rule.serviceId)
        )
      });
      if (existing) {
        const [updated] = await db.update(serviceDepositRules).set({
          requiresDeposit: rule.requiresDeposit,
          customPercentage: rule.customPercentage,
          minimumDepositPaisa: rule.minimumDepositPaisa,
          maximumDepositPaisa: rule.maximumDepositPaisa,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq22(serviceDepositRules.id, existing.id)).returning();
        results.push(updated);
      } else {
        const [newRule] = await db.insert(serviceDepositRules).values({
          salonId,
          ...rule
        }).returning();
        results.push(newRule);
      }
    }
    res.json({ updated: results.length, rules: results });
  } catch (error) {
    console.error("Error bulk updating service deposit rules:", error);
    res.status(500).json({ error: "Failed to bulk update service deposit rules" });
  }
});
router10.get("/:salonId/trusted-customers", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId } = req.params;
    const { trustLevel, page = "1", limit = "20" } = req.query;
    const pageNum = parseInt(page) || 1;
    const limitNum = Math.min(parseInt(limit) || 20, 100);
    const offset = (pageNum - 1) * limitNum;
    let whereCondition = eq22(trustedCustomers.salonId, salonId);
    if (trustLevel && ["trusted", "vip", "blacklisted"].includes(trustLevel)) {
      whereCondition = and22(
        eq22(trustedCustomers.salonId, salonId),
        eq22(trustedCustomers.trustLevel, trustLevel)
      );
    }
    const customers = await db.select({
      id: trustedCustomers.id,
      salonId: trustedCustomers.salonId,
      customerId: trustedCustomers.customerId,
      trustLevel: trustedCustomers.trustLevel,
      reason: trustedCustomers.reason,
      canBypassDeposit: trustedCustomers.canBypassDeposit,
      hasCardOnFile: trustedCustomers.hasCardOnFile,
      cardLast4: trustedCustomers.cardLast4,
      cardBrand: trustedCustomers.cardBrand,
      totalBookings: trustedCustomers.totalBookings,
      completedBookings: trustedCustomers.completedBookings,
      noShowCount: trustedCustomers.noShowCount,
      lateCancellationCount: trustedCustomers.lateCancellationCount,
      addedAt: trustedCustomers.addedAt,
      customerFirstName: users.firstName,
      customerLastName: users.lastName,
      customerEmail: users.email,
      customerPhone: users.phone
    }).from(trustedCustomers).leftJoin(users, eq22(trustedCustomers.customerId, users.id)).where(whereCondition).orderBy(desc14(trustedCustomers.addedAt)).limit(limitNum).offset(offset);
    const [countResult] = await db.select({ count: sql19`count(*)::int` }).from(trustedCustomers).where(whereCondition);
    res.json({
      customers,
      pagination: {
        page: pageNum,
        limit: limitNum,
        total: countResult.count,
        totalPages: Math.ceil(countResult.count / limitNum)
      }
    });
  } catch (error) {
    console.error("Error fetching trusted customers:", error);
    res.status(500).json({ error: "Failed to fetch trusted customers" });
  }
});
router10.post("/:salonId/trusted-customers", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId } = req.params;
    const userId = req.user?.id;
    const parsed = trustedCustomerSchema.safeParse(req.body);
    if (!parsed.success) {
      return res.status(400).json({ error: "Invalid request body", details: parsed.error.errors });
    }
    const existing = await db.query.trustedCustomers.findFirst({
      where: and22(
        eq22(trustedCustomers.salonId, salonId),
        eq22(trustedCustomers.customerId, parsed.data.customerId)
      )
    });
    if (existing) {
      const [updated] = await db.update(trustedCustomers).set({
        trustLevel: parsed.data.trustLevel || existing.trustLevel,
        reason: parsed.data.reason,
        canBypassDeposit: parsed.data.canBypassDeposit ?? existing.canBypassDeposit,
        lastUpdatedAt: /* @__PURE__ */ new Date(),
        lastUpdatedBy: userId
      }).where(eq22(trustedCustomers.id, existing.id)).returning();
      return res.json(updated);
    }
    const [newCustomer] = await db.insert(trustedCustomers).values({
      salonId,
      customerId: parsed.data.customerId,
      trustLevel: parsed.data.trustLevel || "trusted",
      reason: parsed.data.reason,
      canBypassDeposit: parsed.data.canBypassDeposit ?? 1,
      addedBy: userId
    }).returning();
    res.status(201).json(newCustomer);
  } catch (error) {
    console.error("Error adding trusted customer:", error);
    res.status(500).json({ error: "Failed to add trusted customer" });
  }
});
router10.put("/:salonId/trusted-customers/:trustedCustomerId", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId, trustedCustomerId } = req.params;
    const userId = req.user?.id;
    const parsed = trustedCustomerSchema.partial().safeParse(req.body);
    if (!parsed.success) {
      return res.status(400).json({ error: "Invalid request body", details: parsed.error.errors });
    }
    const existing = await db.query.trustedCustomers.findFirst({
      where: and22(
        eq22(trustedCustomers.id, trustedCustomerId),
        eq22(trustedCustomers.salonId, salonId)
      )
    });
    if (!existing) {
      return res.status(404).json({ error: "Trusted customer not found" });
    }
    const [updated] = await db.update(trustedCustomers).set({
      ...parsed.data,
      lastUpdatedAt: /* @__PURE__ */ new Date(),
      lastUpdatedBy: userId
    }).where(eq22(trustedCustomers.id, trustedCustomerId)).returning();
    res.json(updated);
  } catch (error) {
    console.error("Error updating trusted customer:", error);
    res.status(500).json({ error: "Failed to update trusted customer" });
  }
});
router10.delete("/:salonId/trusted-customers/:trustedCustomerId", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId, trustedCustomerId } = req.params;
    const existing = await db.query.trustedCustomers.findFirst({
      where: and22(
        eq22(trustedCustomers.id, trustedCustomerId),
        eq22(trustedCustomers.salonId, salonId)
      )
    });
    if (!existing) {
      return res.status(404).json({ error: "Trusted customer not found" });
    }
    await db.delete(trustedCustomers).where(eq22(trustedCustomers.id, trustedCustomerId));
    res.json({ success: true });
  } catch (error) {
    console.error("Error removing trusted customer:", error);
    res.status(500).json({ error: "Failed to remove trusted customer" });
  }
});
router10.get("/:salonId/check-deposit/:serviceId/:customerId", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId, serviceId, customerId } = req.params;
    const settings = await db.query.depositSettings.findFirst({
      where: eq22(depositSettings.salonId, salonId)
    });
    if (!settings || settings.isEnabled !== 1) {
      return res.json({
        requiresDeposit: false,
        reason: "deposits_disabled"
      });
    }
    const trustedCustomer = await db.query.trustedCustomers.findFirst({
      where: and22(
        eq22(trustedCustomers.salonId, salonId),
        eq22(trustedCustomers.customerId, customerId)
      )
    });
    if (trustedCustomer && trustedCustomer.trustLevel === "blacklisted") {
      return res.json({
        requiresDeposit: true,
        depositPercentage: 100,
        reason: "customer_blacklisted",
        forceFullPayment: true
      });
    }
    if (settings.allowTrustedCustomerBypass === 1 && trustedCustomer) {
      if (trustedCustomer.canBypassDeposit === 1) {
        if (settings.requireCardOnFile === 0 || trustedCustomer.hasCardOnFile === 1) {
          return res.json({
            requiresDeposit: false,
            reason: "trusted_customer",
            hasCardOnFile: trustedCustomer.hasCardOnFile === 1
          });
        }
      }
    }
    const service = await db.query.services.findFirst({
      where: eq22(services.id, serviceId)
    });
    if (!service) {
      return res.status(404).json({ error: "Service not found" });
    }
    const serviceRule = await db.query.serviceDepositRules.findFirst({
      where: and22(
        eq22(serviceDepositRules.salonId, salonId),
        eq22(serviceDepositRules.serviceId, serviceId)
      )
    });
    let requiresDeposit = false;
    let depositPercentage = settings.depositPercentage;
    let reason = "";
    if (settings.useManualToggle === 1 && serviceRule?.requiresDeposit === 1) {
      requiresDeposit = true;
      reason = "manual_toggle";
      if (serviceRule.customPercentage) {
        depositPercentage = serviceRule.customPercentage;
      }
    } else if (settings.useCategoryBased === 1 && settings.protectedCategories?.includes(service.category || "")) {
      requiresDeposit = true;
      reason = "protected_category";
    } else if (settings.usePriceThreshold === 1 && settings.priceThresholdPaisa && service.priceInPaisa >= settings.priceThresholdPaisa) {
      requiresDeposit = true;
      reason = "price_threshold";
    }
    if (!requiresDeposit) {
      return res.json({
        requiresDeposit: false,
        reason: "no_trigger"
      });
    }
    let depositAmountPaisa = Math.round(service.priceInPaisa * depositPercentage / 100);
    if (serviceRule?.minimumDepositPaisa && depositAmountPaisa < serviceRule.minimumDepositPaisa) {
      depositAmountPaisa = serviceRule.minimumDepositPaisa;
    }
    if (serviceRule?.maximumDepositPaisa && depositAmountPaisa > serviceRule.maximumDepositPaisa) {
      depositAmountPaisa = serviceRule.maximumDepositPaisa;
    }
    const policy = await db.query.cancellationPolicies.findFirst({
      where: eq22(cancellationPolicies.salonId, salonId)
    });
    res.json({
      requiresDeposit: true,
      depositPercentage,
      depositAmountPaisa,
      serviceAmountPaisa: service.priceInPaisa,
      reason,
      cancellationPolicy: policy ? {
        windowHours: policy.cancellationWindowHours,
        withinWindowAction: policy.withinWindowAction,
        noShowAction: policy.noShowAction,
        policyText: policy.policyText
      } : null
    });
  } catch (error) {
    console.error("Error checking deposit requirement:", error);
    res.status(500).json({ error: "Failed to check deposit requirement" });
  }
});
router10.get("/:salonId/deposit-transactions", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId } = req.params;
    const {
      status,
      transactionType,
      startDate,
      endDate,
      page = "1",
      limit = "20"
    } = req.query;
    const pageNum = parseInt(page) || 1;
    const limitNum = Math.min(parseInt(limit) || 20, 100);
    const offset = (pageNum - 1) * limitNum;
    let conditions = [eq22(depositTransactions.salonId, salonId)];
    if (status) {
      conditions.push(eq22(depositTransactions.status, status));
    }
    if (transactionType) {
      conditions.push(eq22(depositTransactions.transactionType, transactionType));
    }
    if (startDate) {
      conditions.push(sql19`${depositTransactions.createdAt} >= ${new Date(startDate)}`);
    }
    if (endDate) {
      conditions.push(sql19`${depositTransactions.createdAt} <= ${new Date(endDate)}`);
    }
    const transactions = await db.select({
      id: depositTransactions.id,
      salonId: depositTransactions.salonId,
      customerId: depositTransactions.customerId,
      bookingId: depositTransactions.bookingId,
      transactionType: depositTransactions.transactionType,
      amountPaisa: depositTransactions.amountPaisa,
      currency: depositTransactions.currency,
      serviceAmountPaisa: depositTransactions.serviceAmountPaisa,
      depositPercentage: depositTransactions.depositPercentage,
      status: depositTransactions.status,
      reason: depositTransactions.reason,
      wasNoShow: depositTransactions.wasNoShow,
      createdAt: depositTransactions.createdAt,
      customerFirstName: users.firstName,
      customerLastName: users.lastName,
      customerEmail: users.email
    }).from(depositTransactions).leftJoin(users, eq22(depositTransactions.customerId, users.id)).where(and22(...conditions)).orderBy(desc14(depositTransactions.createdAt)).limit(limitNum).offset(offset);
    const [countResult] = await db.select({ count: sql19`count(*)::int` }).from(depositTransactions).where(and22(...conditions));
    const [stats] = await db.select({
      totalCollected: sql19`COALESCE(SUM(CASE WHEN ${depositTransactions.transactionType} = 'deposit_collected' AND ${depositTransactions.status} = 'completed' THEN ${depositTransactions.amountPaisa} ELSE 0 END), 0)::int`,
      totalRefunded: sql19`COALESCE(SUM(CASE WHEN ${depositTransactions.transactionType} = 'deposit_refunded' THEN ${depositTransactions.amountPaisa} ELSE 0 END), 0)::int`,
      totalForfeited: sql19`COALESCE(SUM(CASE WHEN ${depositTransactions.transactionType} = 'deposit_forfeited' THEN ${depositTransactions.amountPaisa} ELSE 0 END), 0)::int`,
      noShowCount: sql19`COUNT(CASE WHEN ${depositTransactions.wasNoShow} = 1 THEN 1 END)::int`
    }).from(depositTransactions).where(eq22(depositTransactions.salonId, salonId));
    res.json({
      transactions,
      stats,
      pagination: {
        page: pageNum,
        limit: limitNum,
        total: countResult.count,
        totalPages: Math.ceil(countResult.count / limitNum)
      }
    });
  } catch (error) {
    console.error("Error fetching deposit transactions:", error);
    res.status(500).json({ error: "Failed to fetch deposit transactions" });
  }
});
router10.post("/:salonId/deposit-transactions", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId } = req.params;
    const { customerId } = req.body;
    const parsed = depositTransactionSchema.safeParse(req.body);
    if (!parsed.success) {
      return res.status(400).json({ error: "Invalid request body", details: parsed.error.errors });
    }
    if (!customerId) {
      return res.status(400).json({ error: "customerId is required" });
    }
    const policy = await db.query.cancellationPolicies.findFirst({
      where: eq22(cancellationPolicies.salonId, salonId)
    });
    const [transaction] = await db.insert(depositTransactions).values({
      salonId,
      customerId,
      bookingId: parsed.data.bookingId,
      transactionType: parsed.data.transactionType,
      amountPaisa: parsed.data.amountPaisa,
      serviceAmountPaisa: parsed.data.serviceAmountPaisa,
      depositPercentage: parsed.data.depositPercentage,
      razorpayPaymentId: parsed.data.razorpayPaymentId,
      razorpayOrderId: parsed.data.razorpayOrderId,
      status: parsed.data.transactionType === "deposit_collected" ? "completed" : "pending",
      reason: parsed.data.reason,
      notes: parsed.data.notes,
      cancellationWindowHours: policy?.cancellationWindowHours,
      collectedAt: parsed.data.transactionType === "deposit_collected" ? /* @__PURE__ */ new Date() : null
    }).returning();
    res.status(201).json(transaction);
  } catch (error) {
    console.error("Error creating deposit transaction:", error);
    res.status(500).json({ error: "Failed to create deposit transaction" });
  }
});
router10.put("/:salonId/deposit-transactions/:transactionId/refund", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId, transactionId } = req.params;
    const userId = req.user?.id;
    const { razorpayRefundId, reason } = req.body;
    const existing = await db.query.depositTransactions.findFirst({
      where: and22(
        eq22(depositTransactions.id, transactionId),
        eq22(depositTransactions.salonId, salonId)
      )
    });
    if (!existing) {
      return res.status(404).json({ error: "Transaction not found" });
    }
    if (existing.status === "refunded") {
      return res.status(400).json({ error: "Transaction already refunded" });
    }
    const [updated] = await db.update(depositTransactions).set({
      status: "refunded",
      razorpayRefundId,
      reason: reason || existing.reason,
      refundedAt: /* @__PURE__ */ new Date(),
      processedAt: /* @__PURE__ */ new Date(),
      processedBy: userId,
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq22(depositTransactions.id, transactionId)).returning();
    res.json(updated);
  } catch (error) {
    console.error("Error processing refund:", error);
    res.status(500).json({ error: "Failed to process refund" });
  }
});
router10.put("/:salonId/deposit-transactions/:transactionId/forfeit", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId, transactionId } = req.params;
    const userId = req.user?.id;
    const { reason, wasNoShow = false, cancelledWithinWindow = false } = req.body;
    const existing = await db.query.depositTransactions.findFirst({
      where: and22(
        eq22(depositTransactions.id, transactionId),
        eq22(depositTransactions.salonId, salonId)
      )
    });
    if (!existing) {
      return res.status(404).json({ error: "Transaction not found" });
    }
    if (existing.status === "refunded") {
      return res.status(400).json({ error: "Cannot forfeit refunded transaction" });
    }
    const [updated] = await db.update(depositTransactions).set({
      transactionType: "deposit_forfeited",
      status: "completed",
      reason,
      wasNoShow: wasNoShow ? 1 : 0,
      cancelledWithinWindow: cancelledWithinWindow ? 1 : 0,
      forfeitedAt: /* @__PURE__ */ new Date(),
      processedAt: /* @__PURE__ */ new Date(),
      processedBy: userId,
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq22(depositTransactions.id, transactionId)).returning();
    if (wasNoShow) {
      const trustedCustomer = await db.query.trustedCustomers.findFirst({
        where: and22(
          eq22(trustedCustomers.salonId, salonId),
          eq22(trustedCustomers.customerId, existing.customerId)
        )
      });
      if (trustedCustomer) {
        await db.update(trustedCustomers).set({
          noShowCount: sql19`${trustedCustomers.noShowCount} + 1`,
          lastUpdatedAt: /* @__PURE__ */ new Date()
        }).where(eq22(trustedCustomers.id, trustedCustomer.id));
      }
    }
    if (cancelledWithinWindow) {
      const trustedCustomer = await db.query.trustedCustomers.findFirst({
        where: and22(
          eq22(trustedCustomers.salonId, salonId),
          eq22(trustedCustomers.customerId, existing.customerId)
        )
      });
      if (trustedCustomer) {
        await db.update(trustedCustomers).set({
          lateCancellationCount: sql19`${trustedCustomers.lateCancellationCount} + 1`,
          lastUpdatedAt: /* @__PURE__ */ new Date()
        }).where(eq22(trustedCustomers.id, trustedCustomer.id));
      }
    }
    res.json(updated);
  } catch (error) {
    console.error("Error forfeiting deposit:", error);
    res.status(500).json({ error: "Failed to forfeit deposit" });
  }
});
router10.post("/:salonId/bookings/:bookingId/mark-no-show", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId, bookingId } = req.params;
    const userId = req.user?.id;
    const { noShowService: noShowService2 } = await Promise.resolve().then(() => (init_noshow_service(), noshow_service_exports));
    const result = await noShowService2.markBookingAsNoShow(bookingId, salonId, userId);
    if (!result.success) {
      return res.status(400).json({
        error: result.error,
        bookingId: result.bookingId,
        previousStatus: result.previousStatus
      });
    }
    res.json({
      success: true,
      message: "Booking marked as no-show",
      bookingId: result.bookingId,
      previousStatus: result.previousStatus,
      depositAction: result.depositAction,
      depositAmountPaisa: result.depositAmountPaisa
    });
  } catch (error) {
    console.error("Error marking booking as no-show:", error);
    res.status(500).json({ error: "Failed to mark booking as no-show" });
  }
});
router10.get("/:salonId/no-show-statistics", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId } = req.params;
    const { days = "30" } = req.query;
    const { noShowService: noShowService2 } = await Promise.resolve().then(() => (init_noshow_service(), noshow_service_exports));
    const stats = await noShowService2.getNoShowStatistics(salonId, parseInt(days) || 30);
    res.json(stats);
  } catch (error) {
    console.error("Error fetching no-show statistics:", error);
    res.status(500).json({ error: "Failed to fetch no-show statistics" });
  }
});
router10.get("/:salonId/customers", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId } = req.params;
    const { search = "", page = "1", limit = "20" } = req.query;
    const pageNum = parseInt(page) || 1;
    const limitNum = Math.min(parseInt(limit) || 20, 100);
    const offset = (pageNum - 1) * limitNum;
    const searchTerm = search.toLowerCase();
    const customersWithBookings = await db.select({
      id: users.id,
      firstName: users.firstName,
      lastName: users.lastName,
      email: users.email,
      phone: users.phone,
      bookingCount: sql19`COUNT(${bookings.id})::int`,
      lastVisit: sql19`MAX(${bookings.bookingDate})`
    }).from(users).innerJoin(bookings, eq22(bookings.userId, users.id)).where(and22(
      eq22(bookings.salonId, salonId),
      searchTerm ? sql19`(LOWER(${users.firstName}) LIKE ${`%${searchTerm}%`} OR LOWER(${users.lastName}) LIKE ${`%${searchTerm}%`} OR LOWER(${users.email}) LIKE ${`%${searchTerm}%`})` : sql19`1=1`
    )).groupBy(users.id, users.firstName, users.lastName, users.email, users.phone).orderBy(sql19`MAX(${bookings.bookingDate}) DESC NULLS LAST`).limit(limitNum).offset(offset);
    const [countResult] = await db.select({
      count: sql19`COUNT(DISTINCT ${users.id})::int`
    }).from(users).innerJoin(bookings, eq22(bookings.userId, users.id)).where(and22(
      eq22(bookings.salonId, salonId),
      searchTerm ? sql19`(LOWER(${users.firstName}) LIKE ${`%${searchTerm}%`} OR LOWER(${users.lastName}) LIKE ${`%${searchTerm}%`} OR LOWER(${users.email}) LIKE ${`%${searchTerm}%`})` : sql19`1=1`
    ));
    res.json({
      customers: customersWithBookings,
      pagination: {
        page: pageNum,
        limit: limitNum,
        total: countResult.count,
        totalPages: Math.ceil(countResult.count / limitNum)
      }
    });
  } catch (error) {
    console.error("Error fetching customers:", error);
    res.status(500).json({ error: "Failed to fetch customers" });
  }
});
router10.get("/:salonId/deposit-analytics", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId } = req.params;
    const { period = "30" } = req.query;
    const daysAgo = parseInt(period) || 30;
    const startDate = /* @__PURE__ */ new Date();
    startDate.setDate(startDate.getDate() - daysAgo);
    const [stats] = await db.select({
      totalDepositsCollected: sql19`COALESCE(SUM(CASE WHEN ${depositTransactions.transactionType} = 'deposit_collected' AND ${depositTransactions.status} = 'completed' THEN ${depositTransactions.amountPaisa} ELSE 0 END), 0)::int`,
      totalRefunded: sql19`COALESCE(SUM(CASE WHEN ${depositTransactions.transactionType} = 'deposit_refunded' THEN ${depositTransactions.amountPaisa} ELSE 0 END), 0)::int`,
      totalForfeited: sql19`COALESCE(SUM(CASE WHEN ${depositTransactions.transactionType} = 'deposit_forfeited' THEN ${depositTransactions.amountPaisa} ELSE 0 END), 0)::int`,
      depositsCount: sql19`COUNT(CASE WHEN ${depositTransactions.transactionType} = 'deposit_collected' THEN 1 END)::int`,
      refundsCount: sql19`COUNT(CASE WHEN ${depositTransactions.transactionType} = 'deposit_refunded' THEN 1 END)::int`,
      forfeitsCount: sql19`COUNT(CASE WHEN ${depositTransactions.transactionType} = 'deposit_forfeited' THEN 1 END)::int`,
      noShowsCount: sql19`COUNT(CASE WHEN ${depositTransactions.wasNoShow} = 1 THEN 1 END)::int`
    }).from(depositTransactions).where(and22(
      eq22(depositTransactions.salonId, salonId),
      sql19`${depositTransactions.createdAt} >= ${startDate}`
    ));
    const [trustedStats] = await db.select({
      totalTrusted: sql19`COUNT(CASE WHEN ${trustedCustomers.trustLevel} = 'trusted' THEN 1 END)::int`,
      totalVip: sql19`COUNT(CASE WHEN ${trustedCustomers.trustLevel} = 'vip' THEN 1 END)::int`,
      totalBlacklisted: sql19`COUNT(CASE WHEN ${trustedCustomers.trustLevel} = 'blacklisted' THEN 1 END)::int`,
      customersWithCards: sql19`COUNT(CASE WHEN ${trustedCustomers.hasCardOnFile} = 1 THEN 1 END)::int`
    }).from(trustedCustomers).where(eq22(trustedCustomers.salonId, salonId));
    res.json({
      period: daysAgo,
      deposits: {
        totalCollectedPaisa: stats.totalDepositsCollected,
        totalRefundedPaisa: stats.totalRefunded,
        totalForfeitedPaisa: stats.totalForfeited,
        netRevenuePaisa: stats.totalDepositsCollected - stats.totalRefunded,
        count: {
          collected: stats.depositsCount,
          refunded: stats.refundsCount,
          forfeited: stats.forfeitsCount
        },
        noShowsCount: stats.noShowsCount
      },
      customers: {
        trusted: trustedStats.totalTrusted,
        vip: trustedStats.totalVip,
        blacklisted: trustedStats.totalBlacklisted,
        withSavedCards: trustedStats.customersWithCards
      }
    });
  } catch (error) {
    console.error("Error fetching deposit analytics:", error);
    res.status(500).json({ error: "Failed to fetch deposit analytics" });
  }
});
var publicDepositsRouter = Router9();
publicDepositsRouter.post("/check-booking-deposit", async (req, res) => {
  try {
    const { salonId, serviceIds, customerId } = req.body;
    if (!salonId || !serviceIds || !Array.isArray(serviceIds) || serviceIds.length === 0) {
      return res.status(400).json({ error: "salonId and serviceIds are required" });
    }
    const settings = await db.query.depositSettings.findFirst({
      where: eq22(depositSettings.salonId, salonId)
    });
    if (!settings || settings.isEnabled !== 1) {
      return res.json({
        requiresDeposit: false,
        reason: "deposits_disabled",
        totalDepositPaisa: 0,
        serviceDeposits: []
      });
    }
    let trustedCustomer = null;
    if (customerId) {
      trustedCustomer = await db.query.trustedCustomers.findFirst({
        where: and22(
          eq22(trustedCustomers.salonId, salonId),
          eq22(trustedCustomers.customerId, customerId)
        )
      });
      if (trustedCustomer && trustedCustomer.trustLevel === "blacklisted") {
        const allServices2 = await db.query.services.findMany({
          where: inArray8(services.id, serviceIds)
        });
        const totalServiceAmount = allServices2.reduce((sum4, s) => sum4 + s.priceInPaisa, 0);
        const policy2 = await db.query.cancellationPolicies.findFirst({
          where: eq22(cancellationPolicies.salonId, salonId)
        });
        return res.json({
          requiresDeposit: true,
          depositPercentage: 100,
          totalDepositPaisa: totalServiceAmount,
          totalServicePaisa: totalServiceAmount,
          reason: "customer_blacklisted",
          forceFullPayment: true,
          serviceDeposits: allServices2.map((s) => ({
            serviceId: s.id,
            serviceName: s.name,
            servicePriceInPaisa: s.priceInPaisa,
            depositAmountPaisa: s.priceInPaisa,
            depositPercentage: 100
          })),
          cancellationPolicy: policy2 ? {
            windowHours: policy2.cancellationWindowHours,
            withinWindowAction: policy2.withinWindowAction,
            noShowAction: policy2.noShowAction,
            policyText: policy2.policyText
          } : null
        });
      }
      if (settings.allowTrustedCustomerBypass === 1 && trustedCustomer) {
        if (trustedCustomer.canBypassDeposit === 1) {
          if (settings.requireCardOnFile === 0 || trustedCustomer.hasCardOnFile === 1) {
            return res.json({
              requiresDeposit: false,
              reason: "trusted_customer",
              totalDepositPaisa: 0,
              totalServicePaisa: 0,
              balanceDuePaisa: 0,
              serviceDeposits: []
            });
          }
        }
      }
    }
    const allServices = await db.query.services.findMany({
      where: inArray8(services.id, serviceIds)
    });
    const serviceRules = await db.select().from(serviceDepositRules).where(and22(
      eq22(serviceDepositRules.salonId, salonId),
      inArray8(serviceDepositRules.serviceId, serviceIds)
    ));
    const rulesMap = new Map(serviceRules.map((r) => [r.serviceId, r]));
    let totalDepositPaisa = 0;
    let totalServicePaisa = 0;
    let anyServiceRequiresDeposit = false;
    const serviceDeposits = [];
    for (const service of allServices) {
      const serviceRule = rulesMap.get(service.id);
      let requiresDeposit = false;
      let depositPercentage = settings.depositPercentage;
      let reason = "";
      if (settings.useManualToggle === 1 && serviceRule?.requiresDeposit === 1) {
        requiresDeposit = true;
        reason = "manual_toggle";
        if (serviceRule.customPercentage) {
          depositPercentage = serviceRule.customPercentage;
        }
      } else if (settings.useCategoryBased === 1 && settings.protectedCategories?.includes(service.category || "")) {
        requiresDeposit = true;
        reason = "protected_category";
      } else if (settings.usePriceThreshold === 1 && settings.priceThresholdPaisa && service.priceInPaisa >= settings.priceThresholdPaisa) {
        requiresDeposit = true;
        reason = "price_threshold";
      }
      let depositAmountPaisa = 0;
      if (requiresDeposit) {
        anyServiceRequiresDeposit = true;
        depositAmountPaisa = Math.round(service.priceInPaisa * depositPercentage / 100);
        if (serviceRule?.minimumDepositPaisa && depositAmountPaisa < serviceRule.minimumDepositPaisa) {
          depositAmountPaisa = serviceRule.minimumDepositPaisa;
        }
        if (serviceRule?.maximumDepositPaisa && depositAmountPaisa > serviceRule.maximumDepositPaisa) {
          depositAmountPaisa = serviceRule.maximumDepositPaisa;
        }
        totalDepositPaisa += depositAmountPaisa;
      }
      totalServicePaisa += service.priceInPaisa;
      serviceDeposits.push({
        serviceId: service.id,
        serviceName: service.name,
        servicePriceInPaisa: service.priceInPaisa,
        depositAmountPaisa,
        depositPercentage: requiresDeposit ? depositPercentage : 0,
        requiresDeposit,
        reason: reason || "no_trigger"
      });
    }
    if (!anyServiceRequiresDeposit) {
      return res.json({
        requiresDeposit: false,
        reason: "no_services_require_deposit",
        totalDepositPaisa: 0,
        totalServicePaisa,
        serviceDeposits
      });
    }
    const policy = await db.query.cancellationPolicies.findFirst({
      where: eq22(cancellationPolicies.salonId, salonId)
    });
    res.json({
      requiresDeposit: true,
      totalDepositPaisa,
      totalServicePaisa,
      balanceDuePaisa: totalServicePaisa - totalDepositPaisa,
      serviceDeposits,
      cancellationPolicy: policy ? {
        windowHours: policy.cancellationWindowHours,
        withinWindowAction: policy.withinWindowAction,
        partialForfeitPercentage: policy.partialForfeitPercentage,
        noShowAction: policy.noShowAction,
        noShowGraceMinutes: policy.noShowGraceMinutes,
        policyText: policy.policyText
      } : null
    });
  } catch (error) {
    console.error("Error checking booking deposit:", error);
    res.status(500).json({ error: "Failed to check deposit requirement" });
  }
});
publicDepositsRouter.get("/cancellation-policy/:salonId", async (req, res) => {
  try {
    const { salonId } = req.params;
    const policy = await db.query.cancellationPolicies.findFirst({
      where: eq22(cancellationPolicies.salonId, salonId)
    });
    if (!policy) {
      return res.json({
        cancellationWindowHours: 24,
        withinWindowAction: "forfeit_full",
        noShowAction: "forfeit_full",
        policyText: "Standard cancellation policy applies. Please cancel at least 24 hours in advance to avoid losing your deposit."
      });
    }
    res.json({
      cancellationWindowHours: policy.cancellationWindowHours,
      withinWindowAction: policy.withinWindowAction,
      partialForfeitPercentage: policy.partialForfeitPercentage,
      noShowAction: policy.noShowAction,
      noShowGraceMinutes: policy.noShowGraceMinutes,
      policyText: policy.policyText
    });
  } catch (error) {
    console.error("Error fetching cancellation policy:", error);
    res.status(500).json({ error: "Failed to fetch cancellation policy" });
  }
});
var createDepositOrderSchema = z6.object({
  salonId: z6.string(),
  serviceIds: z6.array(z6.string()).min(1),
  amountPaisa: z6.number().min(100),
  paymentType: z6.enum(["deposit", "full_payment"]),
  customerEmail: z6.string().email().optional(),
  customerPhone: z6.string().optional(),
  bookingDate: z6.string(),
  bookingTime: z6.string(),
  staffId: z6.string().optional().nullable()
});
publicDepositsRouter.post("/create-deposit-order", async (req, res) => {
  try {
    const parsed = createDepositOrderSchema.safeParse(req.body);
    if (!parsed.success) {
      return res.status(400).json({ error: "Invalid request", details: parsed.error.errors });
    }
    const { salonId, serviceIds, amountPaisa, paymentType, customerEmail, bookingDate, bookingTime, staffId } = parsed.data;
    const salon = await db.query.salons.findFirst({
      where: eq22(salons.id, salonId)
    });
    if (!salon) {
      return res.status(404).json({ error: "Salon not found" });
    }
    const allServices = await db.query.services.findMany({
      where: inArray8(services.id, serviceIds)
    });
    if (allServices.length === 0) {
      return res.status(400).json({ error: "No valid services found" });
    }
    const totalServicePaisa = allServices.reduce((sum4, s) => sum4 + s.priceInPaisa, 0);
    if (paymentType === "full_payment" && amountPaisa !== totalServicePaisa) {
      return res.status(400).json({
        error: "Amount mismatch for full payment",
        expected: totalServicePaisa,
        received: amountPaisa
      });
    }
    if (amountPaisa > totalServicePaisa) {
      return res.status(400).json({ error: "Payment amount cannot exceed service total" });
    }
    const orderNumber = `DEP${Date.now()}${Math.random().toString(36).substr(2, 4).toUpperCase()}`;
    const options = {
      amount: amountPaisa,
      currency: "INR",
      receipt: orderNumber,
      notes: {
        salonId,
        serviceIds: serviceIds.join(","),
        paymentType,
        bookingDate,
        bookingTime,
        staffId: staffId || "",
        customerEmail: customerEmail || "",
        totalServicePaisa: totalServicePaisa.toString()
      }
    };
    const order = await razorpay5.orders.create(options);
    res.json({
      success: true,
      order: {
        id: order.id,
        amount: order.amount,
        currency: order.currency,
        receipt: order.receipt
      },
      keyId: process.env.RAZORPAY_KEY_ID,
      salonName: salon.name,
      serviceNames: allServices.map((s) => s.name)
    });
  } catch (error) {
    console.error("Deposit order creation error:", error);
    res.status(500).json({
      error: "Failed to create deposit order",
      message: error.message
    });
  }
});
var verifyDepositPaymentSchema = z6.object({
  razorpay_order_id: z6.string(),
  razorpay_payment_id: z6.string(),
  razorpay_signature: z6.string(),
  salonId: z6.string(),
  serviceIds: z6.array(z6.string()).min(1),
  bookingDate: z6.string(),
  bookingTime: z6.string(),
  staffId: z6.string().optional().nullable(),
  customerEmail: z6.string().email(),
  customerPhone: z6.string().optional(),
  customerName: z6.string().optional(),
  paymentType: z6.enum(["deposit", "full_payment"])
});
publicDepositsRouter.post("/verify-deposit-payment", async (req, res) => {
  try {
    const parsed = verifyDepositPaymentSchema.safeParse(req.body);
    if (!parsed.success) {
      return res.status(400).json({ error: "Invalid request", details: parsed.error.errors });
    }
    const {
      razorpay_order_id,
      razorpay_payment_id,
      razorpay_signature,
      salonId,
      serviceIds,
      bookingDate,
      bookingTime,
      staffId,
      customerEmail,
      customerPhone,
      customerName,
      paymentType
    } = parsed.data;
    const sign = razorpay_order_id + "|" + razorpay_payment_id;
    const expectedSign = crypto7.createHmac("sha256", process.env.RAZORPAY_KEY_SECRET || "").update(sign).digest("hex");
    if (razorpay_signature !== expectedSign) {
      return res.status(400).json({
        success: false,
        error: "Invalid payment signature"
      });
    }
    const razorpayOrder = await razorpay5.orders.fetch(razorpay_order_id);
    const payment = await razorpay5.payments.fetch(razorpay_payment_id);
    if (payment.order_id !== razorpay_order_id) {
      return res.status(400).json({
        success: false,
        error: "Payment does not match order"
      });
    }
    if (payment.status !== "captured" && payment.status !== "authorized") {
      return res.status(400).json({
        success: false,
        error: "Payment not completed",
        paymentStatus: payment.status
      });
    }
    const amountPaidPaisa = typeof razorpayOrder.amount === "number" ? razorpayOrder.amount : parseInt(razorpayOrder.amount);
    const allServices = await db.query.services.findMany({
      where: inArray8(services.id, serviceIds)
    });
    const totalServicePaisa = allServices.reduce((sum4, s) => sum4 + s.priceInPaisa, 0);
    const totalDuration = allServices.reduce((sum4, s) => sum4 + s.durationMinutes, 0);
    let customer = await db.query.users.findFirst({
      where: eq22(users.email, customerEmail)
    });
    if (!customer) {
      const [newUser] = await db.insert(users).values({
        email: customerEmail,
        firstName: customerName || "",
        lastName: "",
        phone: customerPhone || null,
        role: "customer"
      }).returning();
      customer = newUser;
    }
    const bookingId = `BK${Date.now()}${Math.random().toString(36).substr(2, 6).toUpperCase()}`;
    const [booking] = await db.insert(bookings).values({
      id: bookingId,
      salonId,
      userId: customer.id,
      staffId: staffId || null,
      serviceId: serviceIds[0],
      customerName: customerName || customer.firstName || "",
      customerEmail,
      customerPhone: customerPhone || "",
      bookingDate,
      bookingTime,
      status: "confirmed",
      totalAmountPaisa: totalServicePaisa,
      paymentMethod: paymentType === "deposit" ? "deposit" : "pay_now",
      notes: serviceIds.length > 1 ? `Multiple services: ${allServices.map((s) => s.name).join(", ")}. Payment: ${razorpay_payment_id}` : `Payment: ${razorpay_payment_id}`
    }).returning();
    await db.insert(depositTransactions).values({
      salonId,
      bookingId: booking.id,
      customerId: customer.id,
      transactionType: paymentType === "deposit" ? "deposit_collected" : "deposit_collected",
      amountPaisa: amountPaidPaisa,
      serviceAmountPaisa: totalServicePaisa,
      depositPercentage: paymentType === "deposit" ? Math.round(amountPaidPaisa / totalServicePaisa * 100) : 100,
      razorpayPaymentId: razorpay_payment_id,
      razorpayOrderId: razorpay_order_id,
      status: "completed",
      notes: paymentType === "full_payment" ? "Full payment collected at booking" : "Deposit collected at booking"
    });
    res.json({
      success: true,
      message: "Payment verified and booking created",
      booking: {
        id: booking.id,
        date: booking.bookingDate,
        time: booking.bookingTime,
        status: booking.status,
        paymentMethod: booking.paymentMethod,
        totalAmount: totalServicePaisa,
        amountPaid: amountPaidPaisa,
        balanceDue: paymentType === "deposit" ? totalServicePaisa - amountPaidPaisa : 0
      },
      payment: {
        id: razorpay_payment_id,
        orderId: razorpay_order_id,
        amount: amountPaidPaisa,
        status: payment.status
      }
    });
  } catch (error) {
    console.error("Deposit payment verification error:", error);
    res.status(500).json({
      error: "Payment verification failed",
      message: error.message
    });
  }
});
router10.get("/my-deposits", async (req, res) => {
  try {
    const userId = req.user?.id;
    if (!userId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const transactions = await db.select({
      id: depositTransactions.id,
      salonId: depositTransactions.salonId,
      salonName: salons.name,
      salonImageUrl: salons.imageUrl,
      bookingId: depositTransactions.bookingId,
      transactionType: depositTransactions.transactionType,
      amountPaisa: depositTransactions.amountPaisa,
      currency: depositTransactions.currency,
      serviceAmountPaisa: depositTransactions.serviceAmountPaisa,
      depositPercentage: depositTransactions.depositPercentage,
      status: depositTransactions.status,
      reason: depositTransactions.reason,
      notes: depositTransactions.notes,
      createdAt: depositTransactions.createdAt,
      bookingDate: bookings.bookingDate,
      bookingTime: bookings.bookingTime,
      serviceName: services.name
    }).from(depositTransactions).leftJoin(salons, eq22(depositTransactions.salonId, salons.id)).leftJoin(bookings, eq22(depositTransactions.bookingId, bookings.id)).leftJoin(services, eq22(bookings.serviceId, services.id)).where(eq22(depositTransactions.customerId, userId)).orderBy(desc14(depositTransactions.createdAt)).limit(100);
    const stats = {
      totalDeposits: 0,
      totalRefunded: 0,
      totalForfeited: 0,
      activeDeposits: 0
    };
    transactions.forEach((tx) => {
      const amount = tx.amountPaisa || 0;
      switch (tx.transactionType) {
        case "deposit_collected":
          stats.totalDeposits += amount;
          if (tx.status === "completed" || tx.status === "pending") {
            stats.activeDeposits += amount;
          }
          break;
        case "deposit_refunded":
          stats.totalRefunded += amount;
          break;
        case "deposit_forfeited":
        case "no_show_charged":
          stats.totalForfeited += amount;
          break;
        case "deposit_applied":
          stats.activeDeposits -= amount;
          break;
      }
    });
    res.json({
      transactions,
      stats,
      count: transactions.length
    });
  } catch (error) {
    console.error("Error fetching customer deposits:", error);
    res.status(500).json({ error: "Failed to fetch deposit history" });
  }
});
router10.get("/my-deposits/:transactionId", async (req, res) => {
  try {
    const userId = req.user?.id;
    const { transactionId } = req.params;
    if (!userId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const [transaction] = await db.select({
      id: depositTransactions.id,
      salonId: depositTransactions.salonId,
      salonName: salons.name,
      salonAddress: salons.address,
      salonCity: salons.city,
      salonImageUrl: salons.imageUrl,
      bookingId: depositTransactions.bookingId,
      transactionType: depositTransactions.transactionType,
      amountPaisa: depositTransactions.amountPaisa,
      currency: depositTransactions.currency,
      serviceAmountPaisa: depositTransactions.serviceAmountPaisa,
      depositPercentage: depositTransactions.depositPercentage,
      razorpayPaymentId: depositTransactions.razorpayPaymentId,
      razorpayRefundId: depositTransactions.razorpayRefundId,
      status: depositTransactions.status,
      reason: depositTransactions.reason,
      notes: depositTransactions.notes,
      createdAt: depositTransactions.createdAt,
      updatedAt: depositTransactions.updatedAt,
      bookingDate: bookings.bookingDate,
      bookingTime: bookings.bookingTime,
      bookingStatus: bookings.status,
      serviceName: services.name,
      serviceDuration: services.durationMinutes
    }).from(depositTransactions).leftJoin(salons, eq22(depositTransactions.salonId, salons.id)).leftJoin(bookings, eq22(depositTransactions.bookingId, bookings.id)).leftJoin(services, eq22(bookings.serviceId, services.id)).where(
      and22(
        eq22(depositTransactions.id, transactionId),
        eq22(depositTransactions.customerId, userId)
      )
    );
    if (!transaction) {
      return res.status(404).json({ error: "Transaction not found" });
    }
    res.json(transaction);
  } catch (error) {
    console.error("Error fetching deposit transaction:", error);
    res.status(500).json({ error: "Failed to fetch transaction details" });
  }
});
var savedCardSchema = z6.object({
  razorpayTokenId: z6.string().min(1),
  razorpayCustomerId: z6.string().optional(),
  cardNetwork: z6.string().optional(),
  cardType: z6.string().optional(),
  cardLast4: z6.string().length(4).optional(),
  cardIssuer: z6.string().optional(),
  cardBrand: z6.string().optional(),
  expiryMonth: z6.number().min(1).max(12).optional(),
  expiryYear: z6.number().min(2024).optional(),
  nickname: z6.string().max(50).optional(),
  isDefault: z6.number().min(0).max(1).optional()
});
router10.get("/my-cards", async (req, res) => {
  try {
    const userId = req.user?.id;
    if (!userId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const cards = await db.query.customerSavedCards.findMany({
      where: and22(
        eq22(customerSavedCards.customerId, userId),
        eq22(customerSavedCards.isActive, 1)
      ),
      orderBy: [desc14(customerSavedCards.isDefault), desc14(customerSavedCards.createdAt)]
    });
    const formattedCards = cards.map((card) => ({
      id: card.id,
      cardNetwork: card.cardNetwork,
      cardType: card.cardType,
      cardLast4: card.cardLast4,
      cardIssuer: card.cardIssuer,
      cardBrand: card.cardBrand,
      expiryMonth: card.expiryMonth,
      expiryYear: card.expiryYear,
      nickname: card.nickname,
      isDefault: card.isDefault === 1,
      lastUsedAt: card.lastUsedAt,
      createdAt: card.createdAt
    }));
    res.json({
      cards: formattedCards,
      count: formattedCards.length
    });
  } catch (error) {
    console.error("Error fetching saved cards:", error);
    res.status(500).json({ error: "Failed to fetch saved cards" });
  }
});
router10.post("/my-cards", async (req, res) => {
  try {
    const userId = req.user?.id;
    if (!userId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const parsed = savedCardSchema.safeParse(req.body);
    if (!parsed.success) {
      return res.status(400).json({ error: "Invalid card data", details: parsed.error.errors });
    }
    const existingCard = await db.query.customerSavedCards.findFirst({
      where: eq22(customerSavedCards.razorpayTokenId, parsed.data.razorpayTokenId)
    });
    if (existingCard) {
      return res.status(409).json({ error: "Card already saved" });
    }
    if (parsed.data.isDefault === 1) {
      await db.update(customerSavedCards).set({ isDefault: 0, updatedAt: /* @__PURE__ */ new Date() }).where(eq22(customerSavedCards.customerId, userId));
    }
    const [newCard] = await db.insert(customerSavedCards).values({
      customerId: userId,
      razorpayTokenId: parsed.data.razorpayTokenId,
      razorpayCustomerId: parsed.data.razorpayCustomerId || null,
      cardNetwork: parsed.data.cardNetwork || null,
      cardType: parsed.data.cardType || null,
      cardLast4: parsed.data.cardLast4 || null,
      cardIssuer: parsed.data.cardIssuer || null,
      cardBrand: parsed.data.cardBrand || null,
      expiryMonth: parsed.data.expiryMonth || null,
      expiryYear: parsed.data.expiryYear || null,
      nickname: parsed.data.nickname || null,
      isDefault: parsed.data.isDefault ?? 0,
      consentTimestamp: /* @__PURE__ */ new Date()
    }).returning();
    res.status(201).json({
      id: newCard.id,
      cardNetwork: newCard.cardNetwork,
      cardType: newCard.cardType,
      cardLast4: newCard.cardLast4,
      cardIssuer: newCard.cardIssuer,
      nickname: newCard.nickname,
      isDefault: newCard.isDefault === 1,
      createdAt: newCard.createdAt
    });
  } catch (error) {
    console.error("Error saving card:", error);
    res.status(500).json({ error: "Failed to save card" });
  }
});
router10.put("/my-cards/:cardId", async (req, res) => {
  try {
    const userId = req.user?.id;
    const { cardId } = req.params;
    if (!userId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const existingCard = await db.query.customerSavedCards.findFirst({
      where: and22(
        eq22(customerSavedCards.id, cardId),
        eq22(customerSavedCards.customerId, userId)
      )
    });
    if (!existingCard) {
      return res.status(404).json({ error: "Card not found" });
    }
    const { nickname, isDefault } = req.body;
    if (isDefault === 1 || isDefault === true) {
      await db.update(customerSavedCards).set({ isDefault: 0, updatedAt: /* @__PURE__ */ new Date() }).where(eq22(customerSavedCards.customerId, userId));
    }
    const [updatedCard] = await db.update(customerSavedCards).set({
      nickname: nickname !== void 0 ? nickname : existingCard.nickname,
      isDefault: isDefault !== void 0 ? isDefault ? 1 : 0 : existingCard.isDefault,
      updatedAt: /* @__PURE__ */ new Date()
    }).where(and22(
      eq22(customerSavedCards.id, cardId),
      eq22(customerSavedCards.customerId, userId)
    )).returning();
    res.json({
      id: updatedCard.id,
      nickname: updatedCard.nickname,
      isDefault: updatedCard.isDefault === 1,
      updatedAt: updatedCard.updatedAt
    });
  } catch (error) {
    console.error("Error updating card:", error);
    res.status(500).json({ error: "Failed to update card" });
  }
});
router10.delete("/my-cards/:cardId", async (req, res) => {
  try {
    const userId = req.user?.id;
    const { cardId } = req.params;
    if (!userId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const existingCard = await db.query.customerSavedCards.findFirst({
      where: and22(
        eq22(customerSavedCards.id, cardId),
        eq22(customerSavedCards.customerId, userId)
      )
    });
    if (!existingCard) {
      return res.status(404).json({ error: "Card not found" });
    }
    await db.update(customerSavedCards).set({ isActive: 0, updatedAt: /* @__PURE__ */ new Date() }).where(and22(
      eq22(customerSavedCards.id, cardId),
      eq22(customerSavedCards.customerId, userId)
    ));
    res.json({ success: true, message: "Card removed successfully" });
  } catch (error) {
    console.error("Error removing card:", error);
    res.status(500).json({ error: "Failed to remove card" });
  }
});
router10.post("/my-cards/:cardId/set-default", async (req, res) => {
  try {
    const userId = req.user?.id;
    const { cardId } = req.params;
    if (!userId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const existingCard = await db.query.customerSavedCards.findFirst({
      where: and22(
        eq22(customerSavedCards.id, cardId),
        eq22(customerSavedCards.customerId, userId),
        eq22(customerSavedCards.isActive, 1)
      )
    });
    if (!existingCard) {
      return res.status(404).json({ error: "Card not found" });
    }
    await db.update(customerSavedCards).set({ isDefault: 0, updatedAt: /* @__PURE__ */ new Date() }).where(eq22(customerSavedCards.customerId, userId));
    await db.update(customerSavedCards).set({ isDefault: 1, updatedAt: /* @__PURE__ */ new Date() }).where(and22(
      eq22(customerSavedCards.id, cardId),
      eq22(customerSavedCards.customerId, userId)
    ));
    res.json({ success: true, message: "Default card updated" });
  } catch (error) {
    console.error("Error setting default card:", error);
    res.status(500).json({ error: "Failed to set default card" });
  }
});
function registerMobileDepositRoutes(app2) {
  app2.get("/api/mobile/deposits/my-deposits", authenticateMobileUser, async (req, res) => {
    try {
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ error: "Authentication required" });
      }
      const transactions = await db.select({
        id: depositTransactions.id,
        salonId: depositTransactions.salonId,
        salonName: salons.name,
        salonImageUrl: salons.imageUrl,
        bookingId: depositTransactions.bookingId,
        transactionType: depositTransactions.transactionType,
        amountPaisa: depositTransactions.amountPaisa,
        currency: depositTransactions.currency,
        serviceAmountPaisa: depositTransactions.serviceAmountPaisa,
        depositPercentage: depositTransactions.depositPercentage,
        status: depositTransactions.status,
        reason: depositTransactions.reason,
        notes: depositTransactions.notes,
        wasNoShow: depositTransactions.wasNoShow,
        createdAt: depositTransactions.createdAt,
        bookingDate: bookings.bookingDate,
        bookingTime: bookings.bookingTime,
        serviceName: services.name
      }).from(depositTransactions).leftJoin(salons, eq22(depositTransactions.salonId, salons.id)).leftJoin(bookings, eq22(depositTransactions.bookingId, bookings.id)).leftJoin(services, eq22(bookings.serviceId, services.id)).where(eq22(depositTransactions.customerId, userId)).orderBy(desc14(depositTransactions.createdAt)).limit(100);
      const stats = {
        totalDeposits: 0,
        totalRefunded: 0,
        totalForfeited: 0,
        activeDeposits: 0
      };
      transactions.forEach((tx) => {
        const amount = tx.amountPaisa || 0;
        switch (tx.transactionType) {
          case "deposit_collected":
            stats.totalDeposits += amount;
            if (tx.status === "completed" || tx.status === "pending") {
              stats.activeDeposits += amount;
            }
            break;
          case "deposit_refunded":
            stats.totalRefunded += amount;
            break;
          case "deposit_forfeited":
          case "no_show_charged":
            stats.totalForfeited += amount;
            break;
          case "deposit_applied":
            stats.activeDeposits -= amount;
            break;
        }
      });
      res.json({
        transactions,
        stats,
        count: transactions.length
      });
    } catch (error) {
      console.error("Error fetching mobile deposits:", error);
      res.status(500).json({ error: "Failed to fetch deposit history" });
    }
  });
  app2.post("/api/mobile/deposits/check-booking-deposit", authenticateMobileUser, async (req, res) => {
    try {
      const userId = req.user?.id;
      const { salonId, serviceIds } = req.body;
      if (!salonId || !serviceIds || !Array.isArray(serviceIds) || serviceIds.length === 0) {
        return res.status(400).json({ error: "salonId and serviceIds are required" });
      }
      const settings = await db.query.depositSettings.findFirst({
        where: eq22(depositSettings.salonId, salonId)
      });
      if (!settings || settings.isEnabled !== 1) {
        return res.json({
          requiresDeposit: false,
          reason: "deposits_disabled",
          totalDepositPaisa: 0,
          serviceDeposits: []
        });
      }
      let trustedCustomer = null;
      if (userId) {
        trustedCustomer = await db.query.trustedCustomers.findFirst({
          where: and22(
            eq22(trustedCustomers.salonId, salonId),
            eq22(trustedCustomers.customerId, userId)
          )
        });
        if (trustedCustomer && trustedCustomer.trustLevel === "blacklisted") {
          const allServices2 = await db.query.services.findMany({
            where: inArray8(services.id, serviceIds)
          });
          const totalServiceAmount = allServices2.reduce((sum4, s) => sum4 + s.priceInPaisa, 0);
          return res.json({
            requiresDeposit: true,
            depositPercentage: 100,
            totalDepositPaisa: totalServiceAmount,
            totalServicePaisa: totalServiceAmount,
            reason: "customer_blacklisted",
            forceFullPayment: true
          });
        }
        if (settings.allowTrustedCustomerBypass === 1 && trustedCustomer) {
          if (trustedCustomer.canBypassDeposit === 1) {
            if (settings.requireCardOnFile === 0 || trustedCustomer.hasCardOnFile === 1) {
              return res.json({
                requiresDeposit: false,
                reason: "trusted_customer",
                totalDepositPaisa: 0
              });
            }
          }
        }
      }
      const allServices = await db.query.services.findMany({
        where: inArray8(services.id, serviceIds)
      });
      const serviceRules = await db.select().from(serviceDepositRules).where(and22(
        eq22(serviceDepositRules.salonId, salonId),
        inArray8(serviceDepositRules.serviceId, serviceIds)
      ));
      const rulesMap = new Map(serviceRules.map((r) => [r.serviceId, r]));
      let totalDepositPaisa = 0;
      let totalServicePaisa = 0;
      let anyServiceRequiresDeposit = false;
      for (const service of allServices) {
        const serviceRule = rulesMap.get(service.id);
        let requiresDeposit = false;
        let depositPercentage = settings.depositPercentage;
        if (settings.useManualToggle === 1 && serviceRule?.requiresDeposit === 1) {
          requiresDeposit = true;
          if (serviceRule.customPercentage) {
            depositPercentage = serviceRule.customPercentage;
          }
        } else if (settings.useCategoryBased === 1 && settings.protectedCategories?.includes(service.category || "")) {
          requiresDeposit = true;
        } else if (settings.usePriceThreshold === 1 && settings.priceThresholdPaisa && service.priceInPaisa >= settings.priceThresholdPaisa) {
          requiresDeposit = true;
        }
        if (requiresDeposit) {
          anyServiceRequiresDeposit = true;
          let depositAmountPaisa = Math.round(service.priceInPaisa * depositPercentage / 100);
          if (serviceRule?.minimumDepositPaisa && depositAmountPaisa < serviceRule.minimumDepositPaisa) {
            depositAmountPaisa = serviceRule.minimumDepositPaisa;
          }
          if (serviceRule?.maximumDepositPaisa && depositAmountPaisa > serviceRule.maximumDepositPaisa) {
            depositAmountPaisa = serviceRule.maximumDepositPaisa;
          }
          totalDepositPaisa += depositAmountPaisa;
        }
        totalServicePaisa += service.priceInPaisa;
      }
      if (!anyServiceRequiresDeposit) {
        return res.json({
          requiresDeposit: false,
          reason: "no_services_require_deposit",
          totalDepositPaisa: 0,
          totalServicePaisa
        });
      }
      const policy = await db.query.cancellationPolicies.findFirst({
        where: eq22(cancellationPolicies.salonId, salonId)
      });
      res.json({
        requiresDeposit: true,
        totalDepositPaisa,
        totalServicePaisa,
        balanceDuePaisa: totalServicePaisa - totalDepositPaisa,
        cancellationPolicy: policy ? {
          windowHours: policy.cancellationWindowHours,
          noShowAction: policy.noShowAction,
          noShowGraceMinutes: policy.noShowGraceMinutes,
          policyText: policy.policyText
        } : null
      });
    } catch (error) {
      console.error("Error checking mobile booking deposit:", error);
      res.status(500).json({ error: "Failed to check deposit requirement" });
    }
  });
  app2.get("/api/mobile/deposits/cancellation-policy/:salonId", authenticateMobileUser, async (req, res) => {
    try {
      const { salonId } = req.params;
      const policy = await db.query.cancellationPolicies.findFirst({
        where: eq22(cancellationPolicies.salonId, salonId)
      });
      if (!policy) {
        return res.json({
          cancellationWindowHours: 24,
          withinWindowAction: "forfeit_full",
          noShowAction: "forfeit_full",
          noShowGraceMinutes: 15,
          policyText: "Standard cancellation policy applies. Please cancel at least 24 hours in advance to avoid losing your deposit."
        });
      }
      res.json({
        cancellationWindowHours: policy.cancellationWindowHours,
        withinWindowAction: policy.withinWindowAction,
        partialForfeitPercentage: policy.partialForfeitPercentage,
        noShowAction: policy.noShowAction,
        noShowGraceMinutes: policy.noShowGraceMinutes,
        policyText: policy.policyText
      });
    } catch (error) {
      console.error("Error fetching mobile cancellation policy:", error);
      res.status(500).json({ error: "Failed to fetch cancellation policy" });
    }
  });
  app2.post("/api/deposits/create-deposit-order", authenticateMobileUser, async (req, res) => {
    try {
      const userId = req.user?.id;
      const { salonId, bookingId, amountPaisa, serviceAmountPaisa, depositPercentage, serviceIds } = req.body;
      if (!salonId || !amountPaisa || amountPaisa < 100) {
        return res.status(400).json({ error: "salonId and amountPaisa (minimum 100) are required" });
      }
      const settings = await db.query.depositSettings.findFirst({
        where: eq22(depositSettings.salonId, salonId)
      });
      if (!settings || settings.isEnabled !== 1) {
        return res.status(400).json({ error: "Deposits are not enabled for this salon" });
      }
      const amountInr = amountPaisa / 100;
      const receiptId = `dep_${Date.now()}_${userId?.substring(0, 8) || "guest"}`;
      const order = await razorpay5.orders.create({
        amount: amountPaisa,
        currency: "INR",
        receipt: receiptId,
        notes: {
          type: "deposit",
          userId: userId || "guest",
          salonId,
          bookingId: bookingId || "",
          serviceIds: JSON.stringify(serviceIds || []),
          depositPercentage: String(depositPercentage || settings.depositPercentage),
          serviceAmountPaisa: String(serviceAmountPaisa || 0)
        }
      });
      res.json({
        success: true,
        order: {
          id: order.id,
          amount: order.amount,
          currency: order.currency,
          receipt: order.receipt
        },
        keyId: process.env.RAZORPAY_KEY_ID
      });
    } catch (error) {
      console.error("Error creating deposit order:", error);
      res.status(500).json({ error: error.message || "Failed to create deposit order" });
    }
  });
  app2.post("/api/deposits/verify-deposit-payment", authenticateMobileUser, async (req, res) => {
    try {
      const userId = req.user?.id;
      const {
        razorpayOrderId,
        razorpayPaymentId,
        razorpaySignature,
        salonId,
        bookingId,
        amountPaisa,
        serviceAmountPaisa,
        depositPercentage,
        serviceIds
      } = req.body;
      if (!razorpayOrderId || !razorpayPaymentId || !razorpaySignature) {
        return res.status(400).json({ error: "Missing payment verification parameters" });
      }
      if (!salonId || !amountPaisa) {
        return res.status(400).json({ error: "salonId and amountPaisa are required" });
      }
      const body = razorpayOrderId + "|" + razorpayPaymentId;
      const expectedSignature = crypto7.createHmac("sha256", process.env.RAZORPAY_KEY_SECRET || "").update(body.toString()).digest("hex");
      if (expectedSignature !== razorpaySignature) {
        console.error("Payment signature verification failed");
        return res.status(400).json({ error: "Payment verification failed - invalid signature" });
      }
      const [transaction] = await db.insert(depositTransactions).values({
        salonId,
        customerId: userId,
        bookingId: bookingId || null,
        transactionType: "deposit_collected",
        amountPaisa,
        currency: "INR",
        serviceAmountPaisa: serviceAmountPaisa || 0,
        depositPercentage: depositPercentage || 0,
        razorpayPaymentId,
        razorpayOrderId,
        status: "completed",
        notes: `Deposit collected via mobile app for services: ${JSON.stringify(serviceIds || [])}`
      }).returning();
      if (bookingId) {
        await db.update(bookings).set({
          notes: sql19`COALESCE(${bookings.notes}, '') || '\n\nDeposit paid: ' || ${amountPaisa / 100}::text || ' (Transaction: ' || ${transaction.id}::text || ')'`
        }).where(eq22(bookings.id, bookingId));
      }
      res.json({
        success: true,
        message: "Deposit payment verified successfully",
        transaction: {
          id: transaction.id,
          amountPaisa: transaction.amountPaisa,
          status: transaction.status,
          createdAt: transaction.createdAt
        }
      });
    } catch (error) {
      console.error("Error verifying deposit payment:", error);
      res.status(500).json({ error: error.message || "Failed to verify deposit payment" });
    }
  });
  console.log("\u2705 Mobile deposit routes registered");
}
var deposits_routes_default = router10;

// server/routes/gift-cards.routes.ts
init_db();
init_schema();
import { Router as Router10 } from "express";
import { eq as eq23, and as and23, sql as sql20, desc as desc15, gte as gte5, lte as lte5, or as or9 } from "drizzle-orm";
import { z as z7 } from "zod";
import crypto8 from "crypto";
import Razorpay6 from "razorpay";
import QRCode from "qrcode";
var router11 = Router10();
var UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
function sanitizeString2(str) {
  if (!str) return "";
  return str.replace(/<[^>]*>/g, "").trim();
}
function isValidUUID(id) {
  if (!id) return false;
  return UUID_REGEX.test(id);
}
function timingSafeCompare(a, b) {
  try {
    const bufA = Buffer.from(a);
    const bufB = Buffer.from(b);
    if (bufA.length !== bufB.length) {
      return false;
    }
    return crypto8.timingSafeEqual(bufA, bufB);
  } catch {
    return false;
  }
}
function getRazorpayConfig() {
  const keyId = process.env.RAZORPAY_KEY_ID;
  const keySecret = process.env.RAZORPAY_KEY_SECRET;
  if (!keyId || !keySecret) {
    throw new Error("Razorpay credentials not configured");
  }
  return { keyId, keySecret };
}
function getRazorpayInstance() {
  const { keyId, keySecret } = getRazorpayConfig();
  return new Razorpay6({ key_id: keyId, key_secret: keySecret });
}
function generateGiftCardCode() {
  const chars = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789";
  let code = "GIFT-";
  for (let i = 0; i < 4; i++) {
    code += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  code += "-";
  for (let i = 0; i < 4; i++) {
    code += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return code;
}
async function generateQRCodeDataUrl(code) {
  try {
    return await QRCode.toDataURL(code, { width: 200, margin: 2 });
  } catch (error) {
    console.error("Error generating QR code:", error);
    return "";
  }
}
var publicGiftCardsRouter = Router10();
publicGiftCardsRouter.get("/templates/:salonId", async (req, res) => {
  try {
    const { salonId } = req.params;
    if (!isValidUUID(salonId)) {
      return res.status(400).json({ error: "Invalid salon ID format" });
    }
    const templates = await db.select().from(giftCardTemplates).where(and23(eq23(giftCardTemplates.salonId, salonId), eq23(giftCardTemplates.isActive, 1))).orderBy(giftCardTemplates.sortOrder);
    res.json({ templates });
  } catch (error) {
    console.error("Error fetching gift card templates:", error);
    res.status(500).json({ error: "Failed to fetch gift card templates" });
  }
});
publicGiftCardsRouter.post("/validate", async (req, res) => {
  try {
    const validation = validateGiftCardSchema.safeParse(req.body);
    if (!validation.success) {
      return res.status(400).json({ error: "Invalid input", details: validation.error.errors });
    }
    const { code, salonId } = validation.data;
    const giftCard = await db.select({
      id: giftCards.id,
      code: giftCards.code,
      balancePaisa: giftCards.balancePaisa,
      originalValuePaisa: giftCards.originalValuePaisa,
      status: giftCards.status,
      expiresAt: giftCards.expiresAt,
      salonId: giftCards.salonId,
      salonName: salons.name
    }).from(giftCards).leftJoin(salons, eq23(giftCards.salonId, salons.id)).where(eq23(giftCards.code, code.toUpperCase())).limit(1);
    if (giftCard.length === 0) {
      return res.status(404).json({ valid: false, error: "Gift card not found" });
    }
    const card = giftCard[0];
    if (card.status === "expired" || card.expiresAt && new Date(card.expiresAt) < /* @__PURE__ */ new Date()) {
      return res.json({ valid: false, error: "Gift card has expired", card: { ...card, status: "expired" } });
    }
    if (card.status === "cancelled" || card.status === "refunded") {
      return res.json({ valid: false, error: "Gift card is no longer valid", card });
    }
    if (card.status === "fully_redeemed" || card.balancePaisa === 0) {
      return res.json({ valid: false, error: "Gift card has been fully redeemed", card });
    }
    if (salonId && card.salonId !== salonId) {
      return res.json({ valid: false, error: "Gift card is not valid at this salon", card });
    }
    res.json({
      valid: true,
      card: {
        id: card.id,
        code: card.code,
        balancePaisa: card.balancePaisa,
        originalValuePaisa: card.originalValuePaisa,
        status: card.status,
        expiresAt: card.expiresAt,
        salonName: card.salonName
      }
    });
  } catch (error) {
    console.error("Error validating gift card:", error);
    res.status(500).json({ error: "Failed to validate gift card" });
  }
});
publicGiftCardsRouter.post("/create-order", async (req, res) => {
  try {
    const validation = purchaseGiftCardSchema.safeParse(req.body);
    if (!validation.success) {
      return res.status(400).json({ error: "Invalid input", details: validation.error.errors });
    }
    const { salonId, valuePaisa, templateId, recipientName, recipientEmail, recipientPhone, personalMessage, deliveryMethod, scheduledDeliveryAt } = validation.data;
    if (!isValidUUID(salonId)) {
      return res.status(400).json({ error: "Invalid salon ID format" });
    }
    if (templateId && !isValidUUID(templateId)) {
      return res.status(400).json({ error: "Invalid template ID format" });
    }
    const sanitizedRecipientName = sanitizeString2(recipientName);
    const sanitizedPersonalMessage = sanitizeString2(personalMessage);
    const salon = await db.select().from(salons).where(eq23(salons.id, salonId)).limit(1);
    if (salon.length === 0) {
      return res.status(404).json({ error: "Salon not found" });
    }
    if (templateId) {
      const template = await db.select().from(giftCardTemplates).where(eq23(giftCardTemplates.id, templateId)).limit(1);
      if (template.length === 0) {
        return res.status(404).json({ error: "Template not found" });
      }
      const t = template[0];
      if (valuePaisa < t.minValuePaisa || valuePaisa > t.maxValuePaisa) {
        return res.status(400).json({ error: `Gift card value must be between \u20B9${t.minValuePaisa / 100} and \u20B9${t.maxValuePaisa / 100}` });
      }
    }
    let razorpay7;
    let razorpayKeyId;
    try {
      const config = getRazorpayConfig();
      razorpayKeyId = config.keyId;
      razorpay7 = getRazorpayInstance();
    } catch (configError) {
      console.error("Razorpay configuration error:", configError);
      return res.status(503).json({ error: "Payment service temporarily unavailable" });
    }
    const order = await razorpay7.orders.create({
      amount: valuePaisa,
      currency: "INR",
      receipt: `gc_${Date.now()}`,
      notes: {
        type: "gift_card_purchase",
        salonId,
        valuePaisa: valuePaisa.toString(),
        templateId: templateId || "",
        recipientEmail: recipientEmail || "",
        recipientPhone: recipientPhone || ""
      }
    });
    const MAX_CODE_ATTEMPTS = 10;
    let code = "";
    let newGiftCard;
    for (let attempt = 0; attempt < MAX_CODE_ATTEMPTS; attempt++) {
      code = generateGiftCardCode();
      const qrCodeUrl = await generateQRCodeDataUrl(code);
      try {
        [newGiftCard] = await db.insert(giftCards).values({
          salonId,
          code,
          originalValuePaisa: valuePaisa,
          balancePaisa: valuePaisa,
          status: "pending_payment",
          recipientName: sanitizedRecipientName || null,
          recipientEmail,
          recipientPhone,
          personalMessage: sanitizedPersonalMessage || null,
          templateId,
          scheduledDeliveryAt: scheduledDeliveryAt ? new Date(scheduledDeliveryAt) : null,
          razorpayOrderId: order.id,
          qrCodeUrl
        }).returning();
        break;
      } catch (insertError) {
        if (insertError.code === "23505" && insertError.constraint?.includes("code")) {
          continue;
        }
        throw insertError;
      }
    }
    if (!newGiftCard) {
      console.error("Failed to generate unique gift card code after max attempts");
      return res.status(500).json({ error: "Failed to create gift card. Please try again." });
    }
    if (deliveryMethod && (recipientEmail || recipientPhone)) {
      await db.insert(giftCardDeliveries).values({
        giftCardId: newGiftCard.id,
        deliveryMethod,
        recipientEmail,
        recipientPhone,
        status: "pending",
        scheduledAt: scheduledDeliveryAt ? new Date(scheduledDeliveryAt) : null
      });
    }
    res.json({
      orderId: order.id,
      giftCardId: newGiftCard.id,
      code: newGiftCard.code,
      amount: valuePaisa,
      keyId: razorpayKeyId
    });
  } catch (error) {
    console.error("Error creating gift card order:", error);
    res.status(500).json({ error: "Failed to create gift card order" });
  }
});
var verifyPaymentSchema2 = z7.object({
  razorpay_order_id: z7.string().min(1).max(100),
  razorpay_payment_id: z7.string().min(1).max(100),
  razorpay_signature: z7.string().min(1).max(200),
  giftCardId: z7.string().uuid(),
  purchasedBy: z7.string().uuid().optional()
});
publicGiftCardsRouter.post("/verify-payment", async (req, res) => {
  try {
    const validation = verifyPaymentSchema2.safeParse(req.body);
    if (!validation.success) {
      return res.status(400).json({ error: "Invalid input", details: validation.error.errors });
    }
    const { razorpay_order_id, razorpay_payment_id, razorpay_signature, giftCardId, purchasedBy } = validation.data;
    let razorpaySecret;
    try {
      const config = getRazorpayConfig();
      razorpaySecret = config.keySecret;
    } catch (configError) {
      console.error("Razorpay configuration error during verification:", configError);
      return res.status(503).json({ error: "Payment service temporarily unavailable" });
    }
    const expectedSignature = crypto8.createHmac("sha256", razorpaySecret).update(`${razorpay_order_id}|${razorpay_payment_id}`).digest("hex");
    if (!timingSafeCompare(expectedSignature, razorpay_signature)) {
      console.warn("Payment signature verification failed for order:", razorpay_order_id);
      return res.status(400).json({ error: "Payment verification failed" });
    }
    const giftCard = await db.select().from(giftCards).where(eq23(giftCards.id, giftCardId)).limit(1);
    if (giftCard.length === 0) {
      return res.status(404).json({ error: "Gift card not found" });
    }
    const card = giftCard[0];
    if (card.razorpayOrderId !== razorpay_order_id) {
      console.warn("Order ID mismatch for gift card:", giftCardId);
      return res.status(400).json({ error: "Order ID mismatch" });
    }
    if (card.status !== "pending_payment") {
      if (card.status === "active" && card.razorpayPaymentId === razorpay_payment_id) {
        const updatedCard2 = await db.select().from(giftCards).where(eq23(giftCards.id, giftCardId)).limit(1);
        return res.json({ success: true, giftCard: updatedCard2[0] });
      }
      return res.status(400).json({ error: "Gift card is not awaiting payment" });
    }
    await db.update(giftCards).set({
      status: "active",
      purchasedBy: purchasedBy || null,
      purchasedAt: /* @__PURE__ */ new Date(),
      razorpayPaymentId: razorpay_payment_id,
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq23(giftCards.id, giftCardId));
    await db.insert(giftCardTransactions).values({
      giftCardId,
      salonId: card.salonId,
      transactionType: "purchase",
      amountPaisa: card.originalValuePaisa,
      balanceBeforePaisa: 0,
      balanceAfterPaisa: card.originalValuePaisa,
      razorpayPaymentId: razorpay_payment_id,
      performedBy: purchasedBy || null,
      performedByType: purchasedBy ? "customer" : "system",
      status: "completed"
    });
    const deliveries = await db.select().from(giftCardDeliveries).where(eq23(giftCardDeliveries.giftCardId, giftCardId));
    if (deliveries.length > 0) {
      const delivery = deliveries[0];
      if (!delivery.scheduledAt || delivery.scheduledAt <= /* @__PURE__ */ new Date()) {
        await db.update(giftCardDeliveries).set({ status: "sent", sentAt: /* @__PURE__ */ new Date(), updatedAt: /* @__PURE__ */ new Date() }).where(eq23(giftCardDeliveries.id, delivery.id));
        await db.update(giftCards).set({ deliveredAt: /* @__PURE__ */ new Date(), updatedAt: /* @__PURE__ */ new Date() }).where(eq23(giftCards.id, giftCardId));
      }
    }
    const updatedCard = await db.select().from(giftCards).where(eq23(giftCards.id, giftCardId)).limit(1);
    res.json({ success: true, giftCard: updatedCard[0] });
  } catch (error) {
    console.error("Error verifying gift card payment:", error);
    res.status(500).json({ error: "Failed to verify payment" });
  }
});
router11.get("/my-cards", authenticateMobileUser, async (req, res) => {
  try {
    const userId = req.user?.id;
    if (!userId) {
      return res.status(401).json({ error: "Unauthorized" });
    }
    const purchased = await db.select({
      id: giftCards.id,
      code: giftCards.code,
      balancePaisa: giftCards.balancePaisa,
      originalValuePaisa: giftCards.originalValuePaisa,
      status: giftCards.status,
      expiresAt: giftCards.expiresAt,
      recipientName: giftCards.recipientName,
      recipientEmail: giftCards.recipientEmail,
      salonId: giftCards.salonId,
      salonName: salons.name,
      purchasedAt: giftCards.purchasedAt,
      qrCodeUrl: giftCards.qrCodeUrl
    }).from(giftCards).leftJoin(salons, eq23(giftCards.salonId, salons.id)).where(eq23(giftCards.purchasedBy, userId)).orderBy(desc15(giftCards.createdAt));
    const user = await db.select().from(users).where(eq23(users.id, userId)).limit(1);
    const userEmail = user[0]?.email;
    const userPhone = user[0]?.phone;
    let received = [];
    if (userEmail || userPhone) {
      const conditions = [];
      if (userEmail) conditions.push(eq23(giftCards.recipientEmail, userEmail));
      if (userPhone) conditions.push(eq23(giftCards.recipientPhone, userPhone));
      received = await db.select({
        id: giftCards.id,
        code: giftCards.code,
        balancePaisa: giftCards.balancePaisa,
        originalValuePaisa: giftCards.originalValuePaisa,
        status: giftCards.status,
        expiresAt: giftCards.expiresAt,
        personalMessage: giftCards.personalMessage,
        salonId: giftCards.salonId,
        salonName: salons.name,
        deliveredAt: giftCards.deliveredAt,
        qrCodeUrl: giftCards.qrCodeUrl
      }).from(giftCards).leftJoin(salons, eq23(giftCards.salonId, salons.id)).where(and23(or9(...conditions), eq23(giftCards.status, "active"))).orderBy(desc15(giftCards.deliveredAt));
    }
    res.json({ purchased, received });
  } catch (error) {
    console.error("Error fetching user gift cards:", error);
    res.status(500).json({ error: "Failed to fetch gift cards" });
  }
});
router11.get("/:id/transactions", authenticateMobileUser, async (req, res) => {
  try {
    const userId = req.user?.id;
    const { id } = req.params;
    const giftCard = await db.select().from(giftCards).where(eq23(giftCards.id, id)).limit(1);
    if (giftCard.length === 0) {
      return res.status(404).json({ error: "Gift card not found" });
    }
    const card = giftCard[0];
    if (card.purchasedBy !== userId) {
      const user = await db.select().from(users).where(eq23(users.id, userId)).limit(1);
      if (!user[0] || user[0].email !== card.recipientEmail && user[0].phone !== card.recipientPhone) {
        return res.status(403).json({ error: "Unauthorized to view this gift card" });
      }
    }
    const transactions = await db.select().from(giftCardTransactions).where(eq23(giftCardTransactions.giftCardId, id)).orderBy(desc15(giftCardTransactions.createdAt));
    res.json({ transactions });
  } catch (error) {
    console.error("Error fetching gift card transactions:", error);
    res.status(500).json({ error: "Failed to fetch transactions" });
  }
});
router11.post("/:salonId/redeem", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId } = req.params;
    const userId = req.user?.id;
    const validation = redeemGiftCardSchema.safeParse(req.body);
    if (!validation.success) {
      return res.status(400).json({ error: "Invalid input", details: validation.error.errors });
    }
    const { code, bookingId, amountPaisa } = validation.data;
    const giftCard = await db.select().from(giftCards).where(eq23(giftCards.code, code.toUpperCase())).limit(1);
    if (giftCard.length === 0) {
      return res.status(404).json({ error: "Gift card not found" });
    }
    const card = giftCard[0];
    if (card.salonId !== salonId) {
      return res.status(400).json({ error: "Gift card is not valid at this salon" });
    }
    if (card.status !== "active" && card.status !== "partially_used") {
      return res.status(400).json({ error: `Gift card cannot be redeemed (status: ${card.status})` });
    }
    if (card.expiresAt && new Date(card.expiresAt) < /* @__PURE__ */ new Date()) {
      await db.update(giftCards).set({ status: "expired", updatedAt: /* @__PURE__ */ new Date() }).where(eq23(giftCards.id, card.id));
      return res.status(400).json({ error: "Gift card has expired" });
    }
    const booking = await db.select().from(bookings).where(eq23(bookings.id, bookingId)).limit(1);
    if (booking.length === 0) {
      return res.status(404).json({ error: "Booking not found" });
    }
    const redeemAmount = amountPaisa || card.balancePaisa;
    if (redeemAmount > card.balancePaisa) {
      return res.status(400).json({ error: `Insufficient balance. Available: \u20B9${card.balancePaisa / 100}` });
    }
    const newBalance = card.balancePaisa - redeemAmount;
    const newStatus = newBalance === 0 ? "fully_redeemed" : "partially_used";
    await db.update(giftCards).set({
      balancePaisa: newBalance,
      status: newStatus,
      lastUsedAt: /* @__PURE__ */ new Date(),
      lastUsedBookingId: bookingId,
      totalRedemptionsPaisa: card.totalRedemptionsPaisa + redeemAmount,
      redemptionCount: card.redemptionCount + 1,
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq23(giftCards.id, card.id));
    await db.insert(giftCardTransactions).values({
      giftCardId: card.id,
      salonId,
      transactionType: newBalance === 0 ? "redemption" : "partial_redemption",
      amountPaisa: -redeemAmount,
      balanceBeforePaisa: card.balancePaisa,
      balanceAfterPaisa: newBalance,
      bookingId,
      performedBy: userId,
      performedByType: "staff",
      status: "completed"
    });
    res.json({
      success: true,
      redeemedAmount: redeemAmount,
      remainingBalance: newBalance,
      giftCardStatus: newStatus
    });
  } catch (error) {
    console.error("Error redeeming gift card:", error);
    res.status(500).json({ error: "Failed to redeem gift card" });
  }
});
router11.get("/:salonId/templates", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId } = req.params;
    const templates = await db.select().from(giftCardTemplates).where(eq23(giftCardTemplates.salonId, salonId)).orderBy(giftCardTemplates.sortOrder);
    res.json({ templates });
  } catch (error) {
    console.error("Error fetching templates:", error);
    res.status(500).json({ error: "Failed to fetch templates" });
  }
});
router11.post("/:salonId/templates", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId } = req.params;
    const userId = req.user?.id;
    const validation = insertGiftCardTemplateSchema.safeParse({ ...req.body, salonId, createdBy: userId });
    if (!validation.success) {
      return res.status(400).json({ error: "Invalid input", details: validation.error.errors });
    }
    const [template] = await db.insert(giftCardTemplates).values(validation.data).returning();
    res.json({ template });
  } catch (error) {
    console.error("Error creating template:", error);
    res.status(500).json({ error: "Failed to create template" });
  }
});
router11.put("/:salonId/templates/:templateId", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId, templateId } = req.params;
    const existing = await db.select().from(giftCardTemplates).where(eq23(giftCardTemplates.id, templateId)).limit(1);
    if (existing.length === 0 || existing[0].salonId !== salonId) {
      return res.status(404).json({ error: "Template not found" });
    }
    const validation = updateGiftCardTemplateSchema.safeParse(req.body);
    if (!validation.success) {
      return res.status(400).json({ error: "Invalid input", details: validation.error.errors });
    }
    const [updated] = await db.update(giftCardTemplates).set({ ...validation.data, updatedAt: /* @__PURE__ */ new Date() }).where(eq23(giftCardTemplates.id, templateId)).returning();
    res.json({ template: updated });
  } catch (error) {
    console.error("Error updating template:", error);
    res.status(500).json({ error: "Failed to update template" });
  }
});
router11.delete("/:salonId/templates/:templateId", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId, templateId } = req.params;
    const existing = await db.select().from(giftCardTemplates).where(eq23(giftCardTemplates.id, templateId)).limit(1);
    if (existing.length === 0 || existing[0].salonId !== salonId) {
      return res.status(404).json({ error: "Template not found" });
    }
    await db.delete(giftCardTemplates).where(eq23(giftCardTemplates.id, templateId));
    res.json({ success: true });
  } catch (error) {
    console.error("Error deleting template:", error);
    res.status(500).json({ error: "Failed to delete template" });
  }
});
router11.get("/:salonId/cards", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId } = req.params;
    const { status, startDate, endDate, search } = req.query;
    const conditions = [eq23(giftCards.salonId, salonId)];
    if (status && status !== "all" && typeof status === "string") {
      conditions.push(eq23(giftCards.status, status));
    }
    if (startDate && typeof startDate === "string") {
      const start = new Date(startDate);
      if (!isNaN(start.getTime())) {
        conditions.push(gte5(giftCards.purchasedAt, start));
      }
    }
    if (endDate && typeof endDate === "string") {
      const end = new Date(endDate);
      if (!isNaN(end.getTime())) {
        end.setHours(23, 59, 59, 999);
        conditions.push(lte5(giftCards.purchasedAt, end));
      }
    }
    if (search && typeof search === "string" && search.trim()) {
      const searchTerm = `%${search.trim()}%`;
      conditions.push(
        or9(
          sql20`${giftCards.code} ILIKE ${searchTerm}`,
          sql20`${giftCards.recipientName} ILIKE ${searchTerm}`,
          sql20`${giftCards.recipientEmail} ILIKE ${searchTerm}`
        )
      );
    }
    const cards = await db.select({
      id: giftCards.id,
      code: giftCards.code,
      balancePaisa: giftCards.balancePaisa,
      originalValuePaisa: giftCards.originalValuePaisa,
      status: giftCards.status,
      expiresAt: giftCards.expiresAt,
      recipientName: giftCards.recipientName,
      recipientEmail: giftCards.recipientEmail,
      purchasedAt: giftCards.purchasedAt,
      lastUsedAt: giftCards.lastUsedAt,
      redemptionCount: giftCards.redemptionCount,
      totalRedemptionsPaisa: giftCards.totalRedemptionsPaisa,
      purchaserEmail: users.email,
      purchaserName: sql20`CONCAT(${users.firstName}, ' ', ${users.lastName})`
    }).from(giftCards).leftJoin(users, eq23(giftCards.purchasedBy, users.id)).where(and23(...conditions)).orderBy(desc15(giftCards.createdAt));
    res.json({ cards });
  } catch (error) {
    console.error("Error fetching salon gift cards:", error);
    res.status(500).json({ error: "Failed to fetch gift cards" });
  }
});
router11.get("/:salonId/analytics", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId } = req.params;
    const totalSold = await db.select({
      count: sql20`COUNT(*)`,
      totalValue: sql20`COALESCE(SUM(${giftCards.originalValuePaisa}), 0)`
    }).from(giftCards).where(and23(
      eq23(giftCards.salonId, salonId),
      or9(
        eq23(giftCards.status, "active"),
        eq23(giftCards.status, "partially_used"),
        eq23(giftCards.status, "fully_redeemed")
      )
    ));
    const totalRedeemed = await db.select({
      count: sql20`COUNT(*)`,
      totalValue: sql20`COALESCE(SUM(${giftCards.totalRedemptionsPaisa}), 0)`
    }).from(giftCards).where(and23(eq23(giftCards.salonId, salonId), sql20`${giftCards.redemptionCount} > 0`));
    const fullyRedeemed = await db.select({
      count: sql20`COUNT(*)`
    }).from(giftCards).where(and23(eq23(giftCards.salonId, salonId), eq23(giftCards.status, "fully_redeemed")));
    const outstandingBalance = await db.select({
      total: sql20`COALESCE(SUM(${giftCards.balancePaisa}), 0)`
    }).from(giftCards).where(
      and23(
        eq23(giftCards.salonId, salonId),
        or9(eq23(giftCards.status, "active"), eq23(giftCards.status, "partially_used"))
      )
    );
    const expired = await db.select({
      count: sql20`COUNT(*)`,
      lostValue: sql20`COALESCE(SUM(${giftCards.balancePaisa}), 0)`
    }).from(giftCards).where(and23(eq23(giftCards.salonId, salonId), eq23(giftCards.status, "expired")));
    res.json({
      totalSold: {
        count: Number(totalSold[0]?.count || 0),
        valuePaisa: Number(totalSold[0]?.totalValue || 0)
      },
      totalRedeemed: {
        count: Number(totalRedeemed[0]?.count || 0),
        valuePaisa: Number(totalRedeemed[0]?.totalValue || 0)
      },
      fullyRedeemedCount: Number(fullyRedeemed[0]?.count || 0),
      outstandingBalancePaisa: Number(outstandingBalance[0]?.total || 0),
      expired: {
        count: Number(expired[0]?.count || 0),
        lostValuePaisa: Number(expired[0]?.lostValue || 0)
      }
    });
  } catch (error) {
    console.error("Error fetching gift card analytics:", error);
    res.status(500).json({ error: "Failed to fetch analytics" });
  }
});
router11.get("/:salonId/cards/:id", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId, id } = req.params;
    const card = await db.select().from(giftCards).where(and23(eq23(giftCards.id, id), eq23(giftCards.salonId, salonId))).limit(1);
    if (card.length === 0) {
      return res.status(404).json({ error: "Gift card not found" });
    }
    const transactions = await db.select().from(giftCardTransactions).where(eq23(giftCardTransactions.giftCardId, id)).orderBy(desc15(giftCardTransactions.createdAt));
    const deliveries = await db.select().from(giftCardDeliveries).where(eq23(giftCardDeliveries.giftCardId, id));
    res.json({ giftCard: card[0], transactions, deliveries });
  } catch (error) {
    console.error("Error fetching gift card details:", error);
    res.status(500).json({ error: "Failed to fetch gift card" });
  }
});
router11.post("/:salonId/cards/:id/cancel", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId, id } = req.params;
    const userId = req.user?.id;
    const { reason } = req.body;
    const card = await db.select().from(giftCards).where(and23(eq23(giftCards.id, id), eq23(giftCards.salonId, salonId))).limit(1);
    if (card.length === 0) {
      return res.status(404).json({ error: "Gift card not found" });
    }
    if (card[0].status === "fully_redeemed") {
      return res.status(400).json({ error: "Cannot cancel a fully redeemed gift card" });
    }
    const previousBalance = card[0].balancePaisa;
    await db.update(giftCards).set({
      status: "cancelled",
      cancelledAt: /* @__PURE__ */ new Date(),
      cancelledBy: userId,
      cancellationReason: reason,
      balancePaisa: 0,
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq23(giftCards.id, id));
    await db.insert(giftCardTransactions).values({
      giftCardId: id,
      salonId,
      transactionType: "cancellation",
      amountPaisa: -previousBalance,
      balanceBeforePaisa: previousBalance,
      balanceAfterPaisa: 0,
      performedBy: userId,
      performedByType: "staff",
      notes: reason,
      status: "completed"
    });
    res.json({ success: true });
  } catch (error) {
    console.error("Error cancelling gift card:", error);
    res.status(500).json({ error: "Failed to cancel gift card" });
  }
});
var gift_cards_routes_default = router11;

// server/routes/rebooking.routes.ts
init_storage();
import { Router as Router11 } from "express";

// server/services/rebooking.service.ts
init_storage();
init_communicationService();
var RebookingService = class {
  async calculateNextRebookingDate(lastBookingDate, serviceCycle, salonSettings) {
    const recommendedDays = serviceCycle?.recommendedDays || salonSettings?.defaultRecommendedDays || 30;
    const minDays = serviceCycle?.minDays || salonSettings?.defaultMinDays || 14;
    const nextDueDate = new Date(lastBookingDate);
    nextDueDate.setDate(nextDueDate.getDate() + recommendedDays);
    const now = /* @__PURE__ */ new Date();
    const daysUntilDue = Math.floor((nextDueDate.getTime() - now.getTime()) / (1e3 * 60 * 60 * 24));
    let status = "not_due";
    if (daysUntilDue < 0) {
      status = "overdue";
    } else if (daysUntilDue <= 7) {
      status = "due";
    } else if (daysUntilDue <= minDays) {
      status = "approaching";
    }
    return { nextDueDate, status, daysUntilDue };
  }
  async updateCustomerStatsAfterBooking(booking) {
    if (!booking.salonId || !booking.customerId) return;
    const bookingServices2 = await storage.getBookingServicesByBookingId(booking.id);
    if (!bookingServices2 || bookingServices2.length === 0) return;
    const salonSettings = await storage.getRebookingSettings(booking.salonId);
    for (const bs of bookingServices2) {
      const serviceCycle = await storage.getServiceRebookingCycleBySalonAndService(
        booking.salonId,
        bs.serviceId
      );
      const existingStat = await storage.getCustomerRebookingStatByKeys(
        booking.salonId,
        booking.customerId,
        bs.serviceId
      );
      const bookingDate = booking.bookingDate ? new Date(booking.bookingDate) : /* @__PURE__ */ new Date();
      const { nextDueDate, status } = await this.calculateNextRebookingDate(
        bookingDate,
        serviceCycle || null,
        salonSettings || null
      );
      let avgDaysBetweenBookings = null;
      if (existingStat?.lastBookingDate) {
        const daysSinceLast = Math.floor(
          (bookingDate.getTime() - new Date(existingStat.lastBookingDate).getTime()) / (1e3 * 60 * 60 * 24)
        );
        const totalBookings = (existingStat.totalBookings || 0) + 1;
        const currentAvg = existingStat.avgDaysBetweenBookings ? parseFloat(existingStat.avgDaysBetweenBookings) : daysSinceLast;
        avgDaysBetweenBookings = ((currentAvg * (totalBookings - 1) + daysSinceLast) / totalBookings).toFixed(2);
      }
      const preferredDayOfWeek = bookingDate.getDay();
      const hour = parseInt(booking.bookingTime?.split(":")[0] || "12");
      const preferredTimeSlot = hour < 12 ? "morning" : hour < 17 ? "afternoon" : "evening";
      const statData = {
        salonId: booking.salonId,
        customerId: booking.customerId,
        serviceId: bs.serviceId,
        totalBookings: (existingStat?.totalBookings || 0) + 1,
        lastBookingId: booking.id,
        lastBookingDate: bookingDate,
        nextRebookingDue: nextDueDate,
        rebookingStatus: status,
        avgDaysBetweenBookings,
        preferredDayOfWeek,
        preferredTimeSlot,
        preferredStaffId: booking.staffId || existingStat?.preferredStaffId || null,
        rebookingsFromReminders: existingStat?.rebookingsFromReminders || 0
      };
      await storage.upsertCustomerRebookingStat(statData);
      if (existingStat?.lastReminderSentAt) {
        const recentReminders = await storage.getRebookingRemindersBySalonId(booking.salonId, {
          status: "sent"
        });
        for (const reminder of recentReminders) {
          if (reminder.customerId === booking.customerId && reminder.serviceId === bs.serviceId && !reminder.convertedAt) {
            await storage.markReminderConverted(reminder.id, booking.id);
            if (existingStat) {
              await storage.updateCustomerRebookingStat(existingStat.id, {
                rebookingsFromReminders: (existingStat.rebookingsFromReminders || 0) + 1
              });
            }
            break;
          }
        }
      }
    }
  }
  async identifyDueRebookings(salonId) {
    const settings = await storage.getRebookingSettings(salonId);
    if (!settings?.isEnabled) return [];
    const dueStats = await storage.getDueRebookings(salonId);
    return dueStats.filter((stat) => {
      if (stat.dismissUntil && new Date(stat.dismissUntil) > /* @__PURE__ */ new Date()) {
        return false;
      }
      const maxReminders = settings.maxRemindersPerService || 2;
      if ((stat.remindersReceived || 0) >= maxReminders) {
        return false;
      }
      return true;
    });
  }
  async scheduleReminders(salonId) {
    const dueStats = await this.identifyDueRebookings(salonId);
    const settings = await storage.getOrCreateRebookingSettings(salonId);
    let scheduledCount = 0;
    for (const stat of dueStats) {
      try {
        const serviceCycle = await storage.getServiceRebookingCycleBySalonAndService(
          salonId,
          stat.serviceId
        );
        if (serviceCycle && !serviceCycle.reminderEnabled) continue;
        const channels = serviceCycle?.reminderChannels || settings.defaultReminderChannels || ["email"];
        const customer = await storage.getUserById(stat.customerId);
        const service = await storage.getService(stat.serviceId);
        const salon = await storage.getSalon(salonId);
        if (!customer || !service || !salon) continue;
        const reminderType = (stat.remindersReceived || 0) === 0 ? "first" : "second";
        let scheduledAt = /* @__PURE__ */ new Date();
        if (settings.quietHoursStart && settings.quietHoursEnd) {
          scheduledAt = this.adjustForQuietHours(scheduledAt, settings.quietHoursStart, settings.quietHoursEnd);
        }
        for (const channel of channels) {
          if (channel === "email" && !customer.email) continue;
          if (channel === "sms" && !customer.phone) continue;
          const existingReminder = await this.findExistingPendingReminder(
            salonId,
            stat.customerId,
            stat.serviceId,
            channel
          );
          if (existingReminder) continue;
          const { subject, body } = this.generateReminderContent(
            customer,
            service,
            salon,
            stat,
            serviceCycle,
            settings,
            channel
          );
          const reminder = {
            salonId,
            customerId: stat.customerId,
            serviceId: stat.serviceId,
            customerStatId: stat.id,
            reminderType,
            channel,
            subject,
            messageBody: body,
            scheduledAt,
            status: "scheduled"
          };
          await storage.createRebookingReminder(reminder);
          scheduledCount++;
        }
      } catch (error) {
        console.error(`Error scheduling reminder for stat ${stat.id}:`, error);
      }
    }
    return scheduledCount;
  }
  async sendReminder(reminderId) {
    const reminder = await storage.getRebookingReminder(reminderId);
    if (!reminder || reminder.status !== "scheduled") return false;
    try {
      const customer = await storage.getUserById(reminder.customerId);
      if (!customer) {
        await storage.markReminderFailed(reminderId, "Customer not found");
        return false;
      }
      const recipient = reminder.channel === "email" ? customer.email : customer.phone;
      if (!recipient) {
        await storage.markReminderFailed(reminderId, `No ${reminder.channel} contact available`);
        return false;
      }
      const isEmail = reminder.channel === "email";
      const messageBody = reminder.messageBody || "";
      const result = await communicationService.sendMessage({
        to: recipient,
        channel: reminder.channel,
        type: "transactional",
        salonId: reminder.salonId,
        customContent: {
          subject: reminder.subject || "Time for your next appointment!",
          body: isEmail ? this.stripHtmlForPlainText(messageBody) : messageBody,
          html: isEmail ? messageBody : void 0
        }
      });
      if (result.success) {
        await storage.markReminderSent(reminderId, result.messageId);
        await storage.incrementRebookingRemindersReceived(reminder.customerStatId);
        return true;
      } else {
        await storage.markReminderFailed(reminderId, result.error || "Unknown error");
        return false;
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      await storage.markReminderFailed(reminderId, errorMessage);
      return false;
    }
  }
  async processPendingReminders(batchSize = 50) {
    const pendingReminders = await storage.getPendingRebookingReminders(batchSize);
    let sent = 0;
    let failed = 0;
    for (const reminder of pendingReminders) {
      const success = await this.sendReminder(reminder.id);
      if (success) {
        sent++;
      } else {
        failed++;
      }
    }
    return { sent, failed };
  }
  async getCustomerSuggestions(customerId, salonId) {
    const stats = await storage.getCustomerRebookingStatsByCustomerId(customerId, {
      salonId,
      status: void 0
    });
    const suggestions = [];
    for (const stat of stats) {
      if (!["approaching", "due", "overdue"].includes(stat.rebookingStatus)) continue;
      if (stat.dismissUntil && new Date(stat.dismissUntil) > /* @__PURE__ */ new Date()) continue;
      const service = await storage.getService(stat.serviceId);
      if (!service) continue;
      const salon = await storage.getSalon(stat.salonId);
      if (!salon) continue;
      const settings = await storage.getRebookingSettings(stat.salonId);
      const daysOverdue = stat.nextRebookingDue ? Math.floor(((/* @__PURE__ */ new Date()).getTime() - new Date(stat.nextRebookingDue).getTime()) / (1e3 * 60 * 60 * 24)) : 0;
      let staffName;
      if (stat.preferredStaffId) {
        const staff5 = await storage.getStaff(stat.preferredStaffId);
        staffName = staff5?.name || void 0;
      }
      const discountAvailable = settings?.enableRebookingDiscount === 1 && daysOverdue >= 0 && daysOverdue <= (settings.discountValidDays || 7);
      const daysSinceLastBooking = stat.lastBookingDate ? Math.floor(((/* @__PURE__ */ new Date()).getTime() - new Date(stat.lastBookingDate).getTime()) / (1e3 * 60 * 60 * 24)) : 0;
      const serviceCycle = await storage.getServiceRebookingCycleBySalonAndService(stat.salonId, stat.serviceId);
      const recommendedDays = serviceCycle?.rebookingDays || settings?.defaultRebookingDays || 30;
      suggestions.push({
        id: `${stat.salonId}-${stat.serviceId}-${customerId}`,
        serviceId: stat.serviceId,
        serviceName: service.name,
        salonId: stat.salonId,
        salonName: salon.name,
        lastBookingDate: stat.lastBookingDate?.toISOString() || "",
        daysSinceLastBooking,
        recommendedDays,
        dueDate: stat.nextRebookingDue?.toISOString() || "",
        daysOverdue: Math.max(0, daysOverdue),
        status: stat.rebookingStatus,
        preferredStaffId: stat.preferredStaffId || void 0,
        preferredStaffName: staffName,
        preferredDayOfWeek: stat.preferredDayOfWeek || void 0,
        preferredTimeSlot: stat.preferredTimeSlot || void 0,
        discountAvailable,
        discountPercent: discountAvailable ? parseFloat(settings?.rebookingDiscountPercent || "0") : void 0
      });
    }
    return suggestions.sort((a, b) => b.daysOverdue - a.daysOverdue);
  }
  async dismissRebooking(customerId, serviceId, salonId, reason, snoozeDays) {
    const stat = await storage.getCustomerRebookingStatByKeys(salonId, customerId, serviceId);
    if (!stat) return;
    let dismissUntil;
    if (reason === "snooze" && snoozeDays) {
      dismissUntil = /* @__PURE__ */ new Date();
      dismissUntil.setDate(dismissUntil.getDate() + snoozeDays);
    }
    await storage.dismissCustomerRebooking(stat.id, dismissUntil);
    const pendingReminders = await storage.getRebookingRemindersBySalonId(salonId, {
      status: "scheduled"
    });
    for (const reminder of pendingReminders) {
      if (reminder.customerId === customerId && reminder.serviceId === serviceId) {
        await storage.dismissRebookingReminder(reminder.id, reason);
      }
    }
  }
  async updateRebookingStatuses(salonId) {
    const stats = await storage.getCustomerRebookingStatsBySalonId(salonId);
    let updatedCount = 0;
    for (const stat of stats) {
      if (stat.rebookingStatus === "dismissed" || stat.rebookingStatus === "booked") continue;
      const settings = await storage.getRebookingSettings(salonId);
      const serviceCycle = await storage.getServiceRebookingCycleBySalonAndService(salonId, stat.serviceId);
      if (!stat.lastBookingDate) continue;
      const { status } = await this.calculateNextRebookingDate(
        new Date(stat.lastBookingDate),
        serviceCycle || null,
        settings || null
      );
      if (status !== stat.rebookingStatus) {
        await storage.updateCustomerRebookingStatus(stat.id, status);
        updatedCount++;
      }
    }
    return updatedCount;
  }
  adjustForQuietHours(date, quietStart, quietEnd) {
    const [startHour, startMin] = quietStart.split(":").map(Number);
    const [endHour, endMin] = quietEnd.split(":").map(Number);
    const hour = date.getHours();
    const minute = date.getMinutes();
    const currentMinutes = hour * 60 + minute;
    const startMinutes = startHour * 60 + startMin;
    const endMinutes = endHour * 60 + endMin;
    if (startMinutes <= endMinutes) {
      if (currentMinutes >= startMinutes && currentMinutes < endMinutes) {
        date.setHours(endHour, endMin, 0, 0);
      }
    } else {
      if (currentMinutes >= startMinutes || currentMinutes < endMinutes) {
        date.setHours(endHour, endMin, 0, 0);
        if (currentMinutes >= startMinutes) {
          date.setDate(date.getDate() + 1);
        }
      }
    }
    return date;
  }
  async findExistingPendingReminder(salonId, customerId, serviceId, channel) {
    const reminders = await storage.getRebookingRemindersBySalonId(salonId, {
      status: "scheduled",
      channel
    });
    return reminders.find(
      (r) => r.customerId === customerId && r.serviceId === serviceId
    ) || null;
  }
  getBaseUrl() {
    if (process.env.REPLIT_DEV_DOMAIN) {
      return `https://${process.env.REPLIT_DEV_DOMAIN}`;
    }
    if (process.env.REPL_SLUG && process.env.REPL_OWNER) {
      return `https://${process.env.REPL_SLUG}.${process.env.REPL_OWNER}.repl.co`;
    }
    return "http://localhost:5000";
  }
  generateBookingUrl(salonId, serviceId, preferredStaffId) {
    const baseUrl = this.getBaseUrl();
    let url = `${baseUrl}/salons/${salonId}/book?serviceId=${serviceId}`;
    if (preferredStaffId) {
      url += `&staffId=${preferredStaffId}`;
    }
    return url;
  }
  generateReminderContent(customer, service, salon, stat, serviceCycle, settings, channel = "email") {
    const customerName = customer.firstName || "Valued Customer";
    const serviceName = service.name;
    const salonName = salon.name;
    const bookingUrl = this.generateBookingUrl(salon.id, service.id, stat.preferredStaffId);
    const daysOverdue = stat.nextRebookingDue ? Math.floor(((/* @__PURE__ */ new Date()).getTime() - new Date(stat.nextRebookingDue).getTime()) / (1e3 * 60 * 60 * 24)) : 0;
    let discountText = "";
    let discountPercent = 0;
    if (settings.enableRebookingDiscount === 1 && parseFloat(settings.rebookingDiscountPercent || "0") > 0) {
      discountPercent = parseFloat(settings.rebookingDiscountPercent || "0");
      discountText = `${discountPercent}% off`;
    }
    if (channel === "sms") {
      return this.generateSMSContent(customerName, serviceName, salonName, bookingUrl, daysOverdue, discountText);
    }
    return this.generateEmailContent(customerName, serviceName, salonName, salon, bookingUrl, daysOverdue, discountPercent, serviceCycle);
  }
  generateSMSContent(customerName, serviceName, salonName, bookingUrl, daysOverdue, discountText) {
    let message = "";
    if (daysOverdue > 14) {
      message = `Hi ${customerName}! We miss you at ${salonName}. Time for your ${serviceName}?`;
    } else if (daysOverdue > 0) {
      message = `Hi ${customerName}! Your ${serviceName} at ${salonName} is due.`;
    } else {
      message = `Hi ${customerName}! It's almost time for your next ${serviceName} at ${salonName}.`;
    }
    if (discountText) {
      message += ` Get ${discountText} when you book now!`;
    }
    message += ` Book now: ${bookingUrl}`;
    return {
      subject: "",
      body: message
    };
  }
  generateEmailContent(customerName, serviceName, salonName, salon, bookingUrl, daysOverdue, discountPercent, serviceCycle) {
    let urgencyHeadline = "";
    let urgencyText = "";
    if (daysOverdue > 14) {
      urgencyHeadline = "We miss you!";
      urgencyText = "It's been a while since your last visit and we'd love to see you again.";
    } else if (daysOverdue > 0) {
      urgencyHeadline = "Time for your next visit";
      urgencyText = "Your next appointment is due. Let's keep you looking and feeling your best!";
    } else {
      urgencyHeadline = "Coming up soon";
      urgencyText = "It's almost time for your next appointment. Book ahead to secure your preferred time slot.";
    }
    if (serviceCycle?.customMessage) {
      const customBody = serviceCycle.customMessage.replace(/\{customerName\}/g, customerName).replace(/\{serviceName\}/g, serviceName).replace(/\{salonName\}/g, salonName).replace(/\{bookingUrl\}/g, bookingUrl);
      return {
        subject: `Time for your next ${serviceName} at ${salonName}`,
        body: this.wrapInEmailTemplate(customBody, salonName, bookingUrl, discountPercent)
      };
    }
    const discountBanner = discountPercent > 0 ? `
      <div style="background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); color: white; padding: 15px 20px; border-radius: 8px; margin-bottom: 25px; text-align: center;">
        <span style="font-size: 18px; font-weight: bold;">Special Offer: ${discountPercent}% OFF your next visit!</span>
      </div>
    ` : "";
    const htmlBody = `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Time for your next ${serviceName}</title>
      </head>
      <body style="margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; background-color: #f8f9fa;">
        <div style="max-width: 600px; margin: 0 auto; background-color: white;">
          <!-- Header -->
          <div style="background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%); padding: 30px 20px; text-align: center;">
            <h1 style="color: white; font-size: 28px; margin: 0; font-weight: 600;">${salonName}</h1>
          </div>
          
          <!-- Main Content -->
          <div style="padding: 40px 30px;">
            <!-- Greeting -->
            <p style="color: #374151; font-size: 16px; margin: 0 0 20px 0;">Hi ${customerName},</p>
            
            <!-- Urgency Banner -->
            <div style="text-align: center; margin-bottom: 30px;">
              <h2 style="color: #1f2937; font-size: 24px; margin: 0 0 10px 0;">${urgencyHeadline}</h2>
              <p style="color: #6b7280; font-size: 16px; margin: 0; line-height: 1.5;">${urgencyText}</p>
            </div>
            
            ${discountBanner}
            
            <!-- Service Card -->
            <div style="background-color: #f3f4f6; border-radius: 12px; padding: 25px; margin-bottom: 30px;">
              <p style="color: #6b7280; font-size: 14px; text-transform: uppercase; letter-spacing: 0.5px; margin: 0 0 8px 0;">Recommended Service</p>
              <h3 style="color: #1f2937; font-size: 20px; margin: 0; font-weight: 600;">${serviceName}</h3>
            </div>
            
            <!-- Book Now Button -->
            <div style="text-align: center; margin: 35px 0;">
              <a href="${bookingUrl}" 
                 style="display: inline-block; background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%); 
                        color: white; text-decoration: none; padding: 16px 40px; border-radius: 8px; 
                        font-size: 18px; font-weight: 600; box-shadow: 0 4px 14px rgba(139, 92, 246, 0.35);">
                Book Now
              </a>
            </div>
            
            <p style="color: #9ca3af; font-size: 14px; text-align: center; margin: 20px 0 0 0;">
              Click the button above or copy this link:<br>
              <a href="${bookingUrl}" style="color: #8b5cf6; word-break: break-all;">${bookingUrl}</a>
            </p>
          </div>
          
          <!-- Footer -->
          <div style="background-color: #f9fafb; padding: 25px 30px; border-top: 1px solid #e5e7eb;">
            <p style="color: #6b7280; font-size: 14px; text-align: center; margin: 0 0 10px 0;">
              You're receiving this because you're a valued customer of ${salonName}.
            </p>
            <p style="color: #9ca3af; font-size: 12px; text-align: center; margin: 0;">
              ${salon.address || ""}<br>
              ${salon.phone || ""}
            </p>
          </div>
        </div>
      </body>
      </html>
    `;
    return {
      subject: `Time for your next ${serviceName} at ${salonName}`,
      body: htmlBody
    };
  }
  stripHtmlForPlainText(html) {
    return html.replace(/<style[^>]*>[\s\S]*?<\/style>/gi, "").replace(/<script[^>]*>[\s\S]*?<\/script>/gi, "").replace(/<[^>]+>/g, "").replace(/&nbsp;/g, " ").replace(/&amp;/g, "&").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&quot;/g, '"').replace(/&#39;/g, "'").replace(/\s+/g, " ").trim();
  }
  wrapInEmailTemplate(content, salonName, bookingUrl, discountPercent) {
    const discountBanner = discountPercent > 0 ? `
      <div style="background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); color: white; padding: 15px 20px; border-radius: 8px; margin-bottom: 25px; text-align: center;">
        <span style="font-size: 18px; font-weight: bold;">Special Offer: ${discountPercent}% OFF your next visit!</span>
      </div>
    ` : "";
    return `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Message from ${salonName}</title>
      </head>
      <body style="margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; background-color: #f8f9fa;">
        <div style="max-width: 600px; margin: 0 auto; background-color: white;">
          <!-- Header -->
          <div style="background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%); padding: 30px 20px; text-align: center;">
            <h1 style="color: white; font-size: 28px; margin: 0; font-weight: 600;">${salonName}</h1>
          </div>
          
          <!-- Main Content -->
          <div style="padding: 40px 30px;">
            ${discountBanner}
            
            <div style="color: #374151; font-size: 16px; line-height: 1.6;">
              ${content.replace(/\n/g, "<br>")}
            </div>
            
            <!-- Book Now Button -->
            <div style="text-align: center; margin: 35px 0;">
              <a href="${bookingUrl}" 
                 style="display: inline-block; background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%); 
                        color: white; text-decoration: none; padding: 16px 40px; border-radius: 8px; 
                        font-size: 18px; font-weight: 600; box-shadow: 0 4px 14px rgba(139, 92, 246, 0.35);">
                Book Now
              </a>
            </div>
          </div>
          
          <!-- Footer -->
          <div style="background-color: #f9fafb; padding: 25px 30px; border-top: 1px solid #e5e7eb;">
            <p style="color: #6b7280; font-size: 14px; text-align: center; margin: 0;">
              You're receiving this because you're a valued customer of ${salonName}.
            </p>
          </div>
        </div>
      </body>
      </html>
    `;
  }
};
var rebookingService = new RebookingService();

// server/routes/rebooking.routes.ts
init_schema();
import { z as z8 } from "zod";
var router12 = Router11();
var requireAuth = (req, res, next) => {
  if (!req.user?.id) {
    return res.status(401).json({ error: "Authentication required" });
  }
  next();
};
var requireSalonAccess2 = async (req, res, next) => {
  const salonId = req.params.salonId || req.body.salonId;
  if (!salonId) {
    return res.status(400).json({ error: "Salon ID required" });
  }
  const salon = await storage.getSalon(salonId);
  if (!salon) {
    return res.status(404).json({ error: "Salon not found" });
  }
  const hasAccess = salon.ownerId === req.user?.id || await storage.isUserStaffOfSalon(req.user?.id || "", salonId);
  if (!hasAccess) {
    return res.status(403).json({ error: "Access denied to this salon" });
  }
  req.salonId = salonId;
  next();
};
router12.get("/settings/:salonId", requireAuth, requireSalonAccess2, async (req, res) => {
  try {
    const settings = await storage.getOrCreateRebookingSettings(req.salonId);
    res.json(settings);
  } catch (error) {
    console.error("Error fetching rebooking settings:", error);
    res.status(500).json({ error: "Failed to fetch settings" });
  }
});
router12.put("/settings/:salonId", requireAuth, requireSalonAccess2, async (req, res) => {
  try {
    const validatedData = updateRebookingSettingsRequestSchema.parse(req.body);
    const updateData = { ...validatedData };
    if (validatedData.isEnabled !== void 0) {
      updateData.isEnabled = validatedData.isEnabled ? 1 : 0;
    }
    if (validatedData.defaultReminderEnabled !== void 0) {
      updateData.defaultReminderEnabled = validatedData.defaultReminderEnabled ? 1 : 0;
    }
    if (validatedData.enableRebookingDiscount !== void 0) {
      updateData.enableRebookingDiscount = validatedData.enableRebookingDiscount ? 1 : 0;
    }
    if (validatedData.respectCustomerOptOut !== void 0) {
      updateData.respectCustomerOptOut = validatedData.respectCustomerOptOut ? 1 : 0;
    }
    if (validatedData.rebookingDiscountPercent !== void 0) {
      updateData.rebookingDiscountPercent = validatedData.rebookingDiscountPercent.toString();
    }
    await storage.updateRebookingSettings(req.salonId, updateData);
    const updated = await storage.getRebookingSettings(req.salonId);
    res.json(updated);
  } catch (error) {
    if (error instanceof z8.ZodError) {
      return res.status(400).json({ error: "Invalid data", details: error.errors });
    }
    console.error("Error updating rebooking settings:", error);
    res.status(500).json({ error: "Failed to update settings" });
  }
});
router12.get("/cycles/:salonId", requireAuth, requireSalonAccess2, async (req, res) => {
  try {
    const isActive = req.query.active === "true" ? true : req.query.active === "false" ? false : void 0;
    const cycles = await storage.getServiceRebookingCyclesBySalonId(req.salonId, { isActive });
    res.json(cycles);
  } catch (error) {
    console.error("Error fetching rebooking cycles:", error);
    res.status(500).json({ error: "Failed to fetch cycles" });
  }
});
router12.post("/cycles/:salonId", requireAuth, requireSalonAccess2, async (req, res) => {
  try {
    const validatedData = createRebookingCycleSchema.parse(req.body);
    const existing = await storage.getServiceRebookingCycleBySalonAndService(
      req.salonId,
      validatedData.serviceId
    );
    if (existing) {
      return res.status(409).json({ error: "Rebooking cycle already exists for this service" });
    }
    const cycle = await storage.createServiceRebookingCycle({
      salonId: req.salonId,
      serviceId: validatedData.serviceId,
      recommendedDays: validatedData.recommendedDays,
      minDays: validatedData.minDays,
      maxDays: validatedData.maxDays,
      reminderEnabled: validatedData.reminderEnabled ? 1 : 0,
      firstReminderDays: validatedData.firstReminderDays,
      secondReminderDays: validatedData.secondReminderDays,
      reminderChannels: validatedData.reminderChannels,
      customMessage: validatedData.customMessage,
      createdBy: req.user?.id
    });
    res.status(201).json(cycle);
  } catch (error) {
    if (error instanceof z8.ZodError) {
      return res.status(400).json({ error: "Invalid data", details: error.errors });
    }
    console.error("Error creating rebooking cycle:", error);
    res.status(500).json({ error: "Failed to create cycle" });
  }
});
router12.put("/cycles/:salonId/:cycleId", requireAuth, requireSalonAccess2, async (req, res) => {
  try {
    const { cycleId } = req.params;
    const validatedData = updateRebookingCycleSchema.parse(req.body);
    const updateData = { ...validatedData };
    if (validatedData.reminderEnabled !== void 0) {
      updateData.reminderEnabled = validatedData.reminderEnabled ? 1 : 0;
    }
    await storage.updateServiceRebookingCycle(cycleId, req.salonId, updateData);
    const updated = await storage.getServiceRebookingCycle(cycleId);
    res.json(updated);
  } catch (error) {
    if (error instanceof z8.ZodError) {
      return res.status(400).json({ error: "Invalid data", details: error.errors });
    }
    console.error("Error updating rebooking cycle:", error);
    res.status(500).json({ error: "Failed to update cycle" });
  }
});
router12.delete("/cycles/:salonId/:cycleId", requireAuth, requireSalonAccess2, async (req, res) => {
  try {
    const { cycleId } = req.params;
    await storage.deleteServiceRebookingCycle(cycleId, req.salonId);
    res.json({ success: true });
  } catch (error) {
    console.error("Error deleting rebooking cycle:", error);
    res.status(500).json({ error: "Failed to delete cycle" });
  }
});
router12.get("/stats/:salonId", requireAuth, requireSalonAccess2, async (req, res) => {
  try {
    const { status } = req.query;
    const stats = await storage.getCustomerRebookingStatsBySalonId(req.salonId, {
      status
    });
    res.json(stats);
  } catch (error) {
    console.error("Error fetching customer stats:", error);
    res.status(500).json({ error: "Failed to fetch stats" });
  }
});
router12.get("/due/:salonId", requireAuth, requireSalonAccess2, async (req, res) => {
  try {
    const limit = req.query.limit ? parseInt(req.query.limit) : void 0;
    const dueRebookings = await rebookingService.identifyDueRebookings(req.salonId);
    const limitedResults = limit ? dueRebookings.slice(0, limit) : dueRebookings;
    const enrichedResults = await Promise.all(
      limitedResults.map(async (stat) => {
        const customer = await storage.getUserById(stat.customerId);
        const service = await storage.getService(stat.serviceId);
        return {
          ...stat,
          customerName: customer ? `${customer.firstName || ""} ${customer.lastName || ""}`.trim() : "Unknown",
          customerEmail: customer?.email,
          customerPhone: customer?.phone,
          serviceName: service?.name || "Unknown Service"
        };
      })
    );
    res.json(enrichedResults);
  } catch (error) {
    console.error("Error fetching due rebookings:", error);
    res.status(500).json({ error: "Failed to fetch due rebookings" });
  }
});
router12.get("/analytics/:salonId", requireAuth, requireSalonAccess2, async (req, res) => {
  try {
    const dashboardAnalytics = await storage.getRebookingDashboardAnalytics(req.salonId);
    const startDate = /* @__PURE__ */ new Date();
    startDate.setDate(startDate.getDate() - 30);
    const reminderAnalytics = await storage.getRebookingReminderAnalytics(req.salonId, startDate, /* @__PURE__ */ new Date());
    res.json({
      dashboard: dashboardAnalytics,
      reminders: reminderAnalytics
    });
  } catch (error) {
    console.error("Error fetching rebooking analytics:", error);
    res.status(500).json({ error: "Failed to fetch analytics" });
  }
});
router12.post("/schedule/:salonId", requireAuth, requireSalonAccess2, async (req, res) => {
  try {
    const scheduledCount = await rebookingService.scheduleReminders(req.salonId);
    res.json({
      success: true,
      scheduledCount,
      message: `${scheduledCount} reminders scheduled`
    });
  } catch (error) {
    console.error("Error scheduling reminders:", error);
    res.status(500).json({ error: "Failed to schedule reminders" });
  }
});
router12.post("/process-reminders", requireAuth, async (req, res) => {
  try {
    const batchSize = req.body.batchSize || 50;
    const result = await rebookingService.processPendingReminders(batchSize);
    res.json({
      success: true,
      ...result,
      message: `Sent ${result.sent} reminders, ${result.failed} failed`
    });
  } catch (error) {
    console.error("Error processing reminders:", error);
    res.status(500).json({ error: "Failed to process reminders" });
  }
});
router12.get("/suggestions", requireAuth, async (req, res) => {
  try {
    const salonId = req.query.salonId;
    const suggestions = await rebookingService.getCustomerSuggestions(req.user.id, salonId);
    res.json(suggestions);
  } catch (error) {
    console.error("Error fetching suggestions:", error);
    res.status(500).json({ error: "Failed to fetch suggestions" });
  }
});
router12.post("/dismiss", requireAuth, async (req, res) => {
  try {
    const validatedData = dismissRebookingSchema.parse(req.body);
    await rebookingService.dismissRebooking(
      req.user.id,
      validatedData.serviceId,
      validatedData.salonId,
      validatedData.reason,
      validatedData.snoozeDays
    );
    res.json({ success: true });
  } catch (error) {
    if (error instanceof z8.ZodError) {
      return res.status(400).json({ error: "Invalid data", details: error.errors });
    }
    console.error("Error dismissing rebooking:", error);
    res.status(500).json({ error: "Failed to dismiss rebooking" });
  }
});
router12.post("/update-statuses/:salonId", requireAuth, requireSalonAccess2, async (req, res) => {
  try {
    const updatedCount = await rebookingService.updateRebookingStatuses(req.salonId);
    res.json({
      success: true,
      updatedCount,
      message: `${updatedCount} statuses updated`
    });
  } catch (error) {
    console.error("Error updating statuses:", error);
    res.status(500).json({ error: "Failed to update statuses" });
  }
});
function registerMobileRebookingRoutes(app2) {
  app2.get("/api/mobile/rebooking/suggestions", authenticateMobileUser, async (req, res) => {
    try {
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ error: "User not authenticated" });
      }
      const salonId = req.query.salonId;
      const suggestions = await rebookingService.getCustomerSuggestions(userId, salonId);
      res.json(suggestions);
    } catch (error) {
      console.error("Error fetching mobile rebooking suggestions:", error);
      res.status(500).json({ error: "Failed to fetch suggestions" });
    }
  });
  app2.post("/api/mobile/rebooking/dismiss", authenticateMobileUser, async (req, res) => {
    try {
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ error: "User not authenticated" });
      }
      const validatedData = dismissRebookingSchema.parse(req.body);
      await rebookingService.dismissRebooking(
        userId,
        validatedData.serviceId,
        validatedData.salonId,
        validatedData.reason,
        validatedData.snoozeDays
      );
      res.json({ success: true });
    } catch (error) {
      if (error instanceof z8.ZodError) {
        return res.status(400).json({ error: "Invalid data", details: error.errors });
      }
      console.error("Error dismissing mobile rebooking:", error);
      res.status(500).json({ error: "Failed to dismiss rebooking" });
    }
  });
}
var rebooking_routes_default = router12;

// server/routes/expressRebooking.routes.ts
import { Router as Router12 } from "express";

// server/services/expressRebooking.service.ts
init_db();
init_schema();
import { eq as eq24, and as and24, desc as desc16, gte as gte6, lte as lte6, sql as sql21, inArray as inArray9 } from "drizzle-orm";
import { addDays, parseISO, differenceInDays, format, isAfter } from "date-fns";
var SUGGESTION_LOOKAHEAD_DAYS = 14;
var SUGGESTION_EXPIRY_DAYS = 7;
var MIN_BOOKINGS_FOR_SUGGESTIONS = 2;
var ExpressRebookingService = class {
  async updatePreferencesAfterBooking(bookingId) {
    const booking = await db.select().from(bookings).where(eq24(bookings.id, bookingId)).limit(1);
    if (booking.length === 0 || !booking[0].userId || !booking[0].salonId) {
      return;
    }
    const { userId, salonId, serviceId, staffId, bookingDate, bookingTime, totalAmountPaisa } = booking[0];
    if (!userId || !salonId) return;
    const [existingPref, allBookings, staffCounts, serviceCounts, dayCounts] = await Promise.all([
      db.select().from(userBookingPreferences).where(and24(
        eq24(userBookingPreferences.userId, userId),
        eq24(userBookingPreferences.salonId, salonId)
      )).limit(1),
      db.select({ bookingDate: bookings.bookingDate }).from(bookings).where(and24(
        eq24(bookings.userId, userId),
        eq24(bookings.salonId, salonId),
        eq24(bookings.status, "completed")
      )).orderBy(desc16(bookings.bookingDate)),
      this.getStaffBookingCounts(userId, salonId),
      this.getServiceBookingCounts(userId, salonId),
      this.getDayOfWeekCounts(userId, salonId)
    ]);
    const topStaffId = staffCounts.length > 0 ? staffCounts[0].staffId : staffId;
    const topServiceIds = serviceCounts.slice(0, 3).map((s) => s.serviceId);
    const preferredDayOfWeek = dayCounts.length > 0 ? dayCounts[0].dayOfWeek : null;
    const timeSlotClassified = this.classifyTimeSlot(bookingTime || "12:00");
    const intervals = this.calculateBookingIntervals(
      allBookings.map((b) => b.bookingDate).filter(Boolean)
    );
    const avgInterval = intervals.length > 0 ? Math.round(this.median(intervals)) : 30;
    const currentTotalBookings = (existingPref[0]?.totalCompletedBookings || 0) + 1;
    const currentTotalSpent = (existingPref[0]?.totalSpentPaisa || 0) + (totalAmountPaisa || 0);
    const prefData = {
      userId,
      salonId,
      preferredStaffId: topStaffId,
      preferredServiceIds: topServiceIds.length > 0 ? topServiceIds : serviceId ? [serviceId] : null,
      preferredDayOfWeek,
      preferredTimeSlot: timeSlotClassified,
      preferredTimeExact: bookingTime,
      averageBookingIntervalDays: avgInterval,
      lastBookingId: bookingId,
      lastBookingDate: bookingDate,
      totalCompletedBookings: currentTotalBookings,
      totalSpentPaisa: currentTotalSpent
    };
    if (existingPref.length > 0) {
      await db.update(userBookingPreferences).set({ ...prefData, updatedAt: /* @__PURE__ */ new Date() }).where(eq24(userBookingPreferences.id, existingPref[0].id));
    } else {
      await db.insert(userBookingPreferences).values(prefData);
    }
  }
  async getSuggestionsForUser(userId) {
    const now = /* @__PURE__ */ new Date();
    const activeSuggestions = await db.select().from(rebookSuggestions).where(and24(
      eq24(rebookSuggestions.userId, userId),
      inArray9(rebookSuggestions.status, ["pending", "shown"]),
      gte6(rebookSuggestions.expiresAt, now)
    )).orderBy(desc16(rebookSuggestions.confidenceScore)).limit(10);
    if (activeSuggestions.length === 0) {
      const lastVisits2 = await this.getLastVisitsBatched(userId);
      return { suggestions: [], lastVisits: lastVisits2 };
    }
    const salonIds = [...new Set(activeSuggestions.map((s) => s.salonId))];
    const allServiceIds = [...new Set(activeSuggestions.flatMap((s) => s.suggestedServiceIds || []))];
    const staffIds = [...new Set(activeSuggestions.map((s) => s.suggestedStaffId).filter(Boolean))];
    const slotKeys = activeSuggestions.map((s) => ({
      salonId: s.salonId,
      date: s.suggestedDate,
      time: s.suggestedTime,
      staffId: s.suggestedStaffId
    }));
    const dates = [...new Set(slotKeys.map((k) => k.date))];
    const [salonData, serviceData, staffData, conflictingBookings] = await Promise.all([
      salonIds.length > 0 ? db.select({
        id: salons.id,
        name: salons.name,
        imageUrl: salons.imageUrl,
        rating: salons.rating
      }).from(salons).where(inArray9(salons.id, salonIds)) : [],
      allServiceIds.length > 0 ? db.select({
        id: services.id,
        name: services.name,
        priceInPaisa: services.priceInPaisa,
        durationMinutes: services.durationMinutes
      }).from(services).where(inArray9(services.id, allServiceIds)) : [],
      staffIds.length > 0 ? db.select({
        id: staff.id,
        name: staff.name,
        photoUrl: staff.photoUrl
      }).from(staff).where(inArray9(staff.id, staffIds)) : [],
      db.select({
        salonId: bookings.salonId,
        bookingDate: bookings.bookingDate,
        bookingTime: bookings.bookingTime,
        staffId: bookings.staffId
      }).from(bookings).where(and24(
        inArray9(bookings.salonId, salonIds),
        inArray9(bookings.bookingDate, dates),
        inArray9(bookings.status, ["confirmed", "pending"])
      ))
    ]);
    const salonMap = new Map(salonData.map((s) => [s.id, s]));
    const serviceMap = new Map(serviceData.map((s) => [s.id, s]));
    const staffMap = new Map(staffData.map((s) => [s.id, s]));
    const conflictSet = new Set(
      conflictingBookings.map(
        (b) => `${b.salonId}|${b.bookingDate}|${b.bookingTime}|${b.staffId || "any"}`
      )
    );
    const checkSlotAvailable = (salonId, date, time, staffId) => {
      if (staffId) {
        return !conflictSet.has(`${salonId}|${date}|${time}|${staffId}`);
      }
      for (const key of conflictSet) {
        if (key.startsWith(`${salonId}|${date}|${time}|`)) {
          return false;
        }
      }
      return true;
    };
    const pendingIds = activeSuggestions.filter((s) => s.status === "pending").map((s) => s.id);
    if (pendingIds.length > 0) {
      await db.update(rebookSuggestions).set({ status: "shown", shownAt: now }).where(inArray9(rebookSuggestions.id, pendingIds));
    }
    const enrichedSuggestions = activeSuggestions.map((suggestion) => {
      const salon = salonMap.get(suggestion.salonId);
      if (!salon) return null;
      const serviceList = (suggestion.suggestedServiceIds || []).map((id) => serviceMap.get(id)).filter(Boolean);
      const estimatedTotal = serviceList.reduce((sum4, svc) => sum4 + (svc.priceInPaisa ?? 0), 0);
      const staffInfo = suggestion.suggestedStaffId ? staffMap.get(suggestion.suggestedStaffId) || null : null;
      const slotAvailable = checkSlotAvailable(
        suggestion.salonId,
        suggestion.suggestedDate,
        suggestion.suggestedTime,
        suggestion.suggestedStaffId
      );
      return {
        id: suggestion.id,
        salon: {
          id: salon.id,
          name: salon.name,
          imageUrl: salon.imageUrl,
          rating: salon.rating ? parseFloat(String(salon.rating)) : null
        },
        suggestedDate: suggestion.suggestedDate,
        suggestedTime: suggestion.suggestedTime,
        services: serviceList,
        staff: staffInfo,
        estimatedTotal,
        reason: suggestion.reason,
        confidenceScore: suggestion.confidenceScore,
        slotAvailable,
        status: "shown",
        expiresAt: suggestion.expiresAt
      };
    }).filter(Boolean);
    const lastVisits = await this.getLastVisitsBatched(userId);
    return { suggestions: enrichedSuggestions, lastVisits };
  }
  generateSlotLockKey(salonId, date, time, staffId) {
    const key = `${salonId}|${date}|${time}|${staffId || "any"}`;
    let hash = 0;
    for (let i = 0; i < key.length; i++) {
      const char = key.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    return Math.abs(hash);
  }
  async quickBook(userId, suggestionId) {
    return await db.transaction(async (tx) => {
      const suggestion = await tx.select().from(rebookSuggestions).where(and24(
        eq24(rebookSuggestions.id, suggestionId),
        eq24(rebookSuggestions.userId, userId)
      )).limit(1);
      if (suggestion.length === 0) {
        return { success: false, error: "Suggestion not found or not authorized" };
      }
      if (suggestion[0].status === "accepted") {
        return { success: false, error: "Suggestion already used" };
      }
      const now = /* @__PURE__ */ new Date();
      if (isAfter(now, suggestion[0].expiresAt)) {
        return { success: false, error: "Suggestion has expired" };
      }
      const lockKey = this.generateSlotLockKey(
        suggestion[0].salonId,
        suggestion[0].suggestedDate,
        suggestion[0].suggestedTime,
        suggestion[0].suggestedStaffId
      );
      await tx.execute(sql21`SELECT pg_advisory_xact_lock(${lockKey})`);
      const existingBooking = await tx.select({ id: bookings.id }).from(bookings).where(and24(
        eq24(bookings.salonId, suggestion[0].salonId),
        eq24(bookings.bookingDate, suggestion[0].suggestedDate),
        eq24(bookings.bookingTime, suggestion[0].suggestedTime),
        inArray9(bookings.status, ["confirmed", "pending"]),
        suggestion[0].suggestedStaffId ? eq24(bookings.staffId, suggestion[0].suggestedStaffId) : sql21`true`
      )).limit(1);
      if (existingBooking.length > 0) {
        return { success: false, error: "The suggested time slot is no longer available" };
      }
      const [user, salon] = await Promise.all([
        tx.select().from(users).where(eq24(users.id, userId)).limit(1),
        tx.select().from(salons).where(eq24(salons.id, suggestion[0].salonId)).limit(1)
      ]);
      if (user.length === 0) {
        return { success: false, error: "User not found" };
      }
      if (salon.length === 0) {
        return { success: false, error: "Salon not found" };
      }
      let totalAmount = 0;
      const serviceNames = [];
      if (suggestion[0].suggestedServiceIds && suggestion[0].suggestedServiceIds.length > 0) {
        const serviceData = await tx.select().from(services).where(inArray9(services.id, suggestion[0].suggestedServiceIds));
        for (const svc of serviceData) {
          totalAmount += svc.priceInPaisa ?? 0;
          serviceNames.push(svc.name);
        }
      }
      let staffName = null;
      if (suggestion[0].suggestedStaffId) {
        const staffResult = await tx.select({ name: staff.name }).from(staff).where(eq24(staff.id, suggestion[0].suggestedStaffId)).limit(1);
        staffName = staffResult[0]?.name || null;
      }
      const primaryServiceId = suggestion[0].suggestedServiceIds?.[0] || null;
      const [newBooking] = await tx.insert(bookings).values({
        salonId: suggestion[0].salonId,
        serviceId: primaryServiceId,
        staffId: suggestion[0].suggestedStaffId,
        userId,
        customerName: `${user[0].firstName || ""} ${user[0].lastName || ""}`.trim() || "Customer",
        customerEmail: user[0].email || "",
        customerPhone: user[0].phone || "",
        bookingDate: suggestion[0].suggestedDate,
        bookingTime: suggestion[0].suggestedTime,
        status: "confirmed",
        totalAmountPaisa: totalAmount,
        paymentMethod: "pay_at_salon",
        source: "express_rebook"
      }).returning();
      await tx.update(rebookSuggestions).set({
        status: "accepted",
        respondedAt: now,
        resultingBookingId: newBooking.id
      }).where(eq24(rebookSuggestions.id, suggestionId));
      return {
        success: true,
        bookingId: newBooking.id,
        booking: {
          id: newBooking.id,
          salonName: salon[0].name,
          date: suggestion[0].suggestedDate,
          time: suggestion[0].suggestedTime,
          services: serviceNames,
          staffName,
          totalAmountPaisa: totalAmount
        }
      };
    });
  }
  async customizeBook(userId, suggestionId, modifications) {
    return await db.transaction(async (tx) => {
      const suggestion = await tx.select().from(rebookSuggestions).where(and24(
        eq24(rebookSuggestions.id, suggestionId),
        eq24(rebookSuggestions.userId, userId)
      )).limit(1);
      if (suggestion.length === 0) {
        return { success: false, error: "Suggestion not found or not authorized" };
      }
      const now = /* @__PURE__ */ new Date();
      if (isAfter(now, suggestion[0].expiresAt)) {
        return { success: false, error: "Suggestion has expired" };
      }
      const finalDate = modifications.date || suggestion[0].suggestedDate;
      const finalTime = modifications.time || suggestion[0].suggestedTime;
      const finalStaffId = modifications.staffId || suggestion[0].suggestedStaffId;
      let finalServiceIds = [...suggestion[0].suggestedServiceIds || []];
      if (modifications.removeServiceIds) {
        finalServiceIds = finalServiceIds.filter((id) => !modifications.removeServiceIds.includes(id));
      }
      if (modifications.addServiceIds) {
        finalServiceIds = [...finalServiceIds, ...modifications.addServiceIds];
      }
      if (finalServiceIds.length === 0) {
        return { success: false, error: "At least one service is required" };
      }
      const lockKey = this.generateSlotLockKey(
        suggestion[0].salonId,
        finalDate,
        finalTime,
        finalStaffId
      );
      await tx.execute(sql21`SELECT pg_advisory_xact_lock(${lockKey})`);
      const existingBooking = await tx.select({ id: bookings.id }).from(bookings).where(and24(
        eq24(bookings.salonId, suggestion[0].salonId),
        eq24(bookings.bookingDate, finalDate),
        eq24(bookings.bookingTime, finalTime),
        inArray9(bookings.status, ["confirmed", "pending"]),
        finalStaffId ? eq24(bookings.staffId, finalStaffId) : sql21`true`
      )).limit(1);
      if (existingBooking.length > 0) {
        return { success: false, error: "The selected time slot is not available" };
      }
      const [user, salon] = await Promise.all([
        tx.select().from(users).where(eq24(users.id, userId)).limit(1),
        tx.select().from(salons).where(eq24(salons.id, suggestion[0].salonId)).limit(1)
      ]);
      if (user.length === 0) {
        return { success: false, error: "User not found" };
      }
      if (salon.length === 0) {
        return { success: false, error: "Salon not found" };
      }
      let totalAmount = 0;
      const serviceNames = [];
      const serviceData = await tx.select().from(services).where(inArray9(services.id, finalServiceIds));
      for (const svc of serviceData) {
        totalAmount += svc.priceInPaisa ?? 0;
        serviceNames.push(svc.name);
      }
      let staffName = null;
      if (finalStaffId) {
        const staffResult = await tx.select({ name: staff.name }).from(staff).where(eq24(staff.id, finalStaffId)).limit(1);
        staffName = staffResult[0]?.name || null;
      }
      const [newBooking] = await tx.insert(bookings).values({
        salonId: suggestion[0].salonId,
        serviceId: finalServiceIds[0],
        staffId: finalStaffId,
        userId,
        customerName: `${user[0].firstName || ""} ${user[0].lastName || ""}`.trim() || "Customer",
        customerEmail: user[0].email || "",
        customerPhone: user[0].phone || "",
        bookingDate: finalDate,
        bookingTime: finalTime,
        status: "confirmed",
        totalAmountPaisa: totalAmount,
        paymentMethod: "pay_at_salon",
        source: "express_rebook_custom"
      }).returning();
      await tx.update(rebookSuggestions).set({
        status: "accepted",
        respondedAt: now,
        resultingBookingId: newBooking.id
      }).where(eq24(rebookSuggestions.id, suggestionId));
      return {
        success: true,
        bookingId: newBooking.id,
        booking: {
          id: newBooking.id,
          salonName: salon[0].name,
          date: finalDate,
          time: finalTime,
          services: serviceNames,
          staffName,
          totalAmountPaisa: totalAmount
        }
      };
    });
  }
  async dismissSuggestion(userId, suggestionId, reason) {
    const result = await db.update(rebookSuggestions).set({
      status: "dismissed",
      respondedAt: /* @__PURE__ */ new Date(),
      reason: reason ? `Dismissed: ${reason}` : void 0
    }).where(and24(
      eq24(rebookSuggestions.id, suggestionId),
      eq24(rebookSuggestions.userId, userId)
    )).returning({ id: rebookSuggestions.id });
    if (result.length === 0) {
      return { success: false, error: "Suggestion not found or not authorized" };
    }
    return { success: true };
  }
  async getLastBookingForSalon(userId, salonId) {
    const [lastBooking, pref] = await Promise.all([
      db.select().from(bookings).where(and24(
        eq24(bookings.userId, userId),
        eq24(bookings.salonId, salonId),
        eq24(bookings.status, "completed")
      )).orderBy(desc16(bookings.bookingDate)).limit(1),
      db.select().from(userBookingPreferences).where(and24(
        eq24(userBookingPreferences.userId, userId),
        eq24(userBookingPreferences.salonId, salonId)
      )).limit(1)
    ]);
    if (lastBooking.length === 0) {
      return { lastBooking: null, nextAvailableSlot: null, suggestedRebookDate: null };
    }
    const avgInterval = pref[0]?.averageBookingIntervalDays || 30;
    const lastDate = parseISO(lastBooking[0].bookingDate || "");
    const suggestedRebookDate = format(addDays(lastDate, avgInterval), "yyyy-MM-dd");
    const [serviceInfo, staffInfo] = await Promise.all([
      lastBooking[0].serviceId ? db.select().from(services).where(eq24(services.id, lastBooking[0].serviceId)).limit(1) : Promise.resolve([]),
      lastBooking[0].staffId ? db.select().from(staff).where(eq24(staff.id, lastBooking[0].staffId)).limit(1) : Promise.resolve([])
    ]);
    const nextSlot = await this.findNextAvailableSlot(
      salonId,
      lastBooking[0].bookingTime || "10:00",
      pref[0]?.preferredStaffId
    );
    return {
      lastBooking: {
        id: lastBooking[0].id,
        date: lastBooking[0].bookingDate,
        time: lastBooking[0].bookingTime,
        services: serviceInfo.length > 0 ? serviceInfo : [],
        staff: staffInfo[0] || null,
        totalPaid: lastBooking[0].totalAmountPaisa
      },
      nextAvailableSlot: nextSlot,
      suggestedRebookDate
    };
  }
  async generateSuggestionsForAllUsers() {
    const preferences = await db.select().from(userBookingPreferences).where(gte6(userBookingPreferences.totalCompletedBookings, MIN_BOOKINGS_FOR_SUGGESTIONS));
    let generatedCount = 0;
    const now = /* @__PURE__ */ new Date();
    for (const pref of preferences) {
      try {
        const existingSuggestion = await db.select({ id: rebookSuggestions.id }).from(rebookSuggestions).where(and24(
          eq24(rebookSuggestions.userId, pref.userId),
          eq24(rebookSuggestions.salonId, pref.salonId),
          inArray9(rebookSuggestions.status, ["pending", "shown"]),
          gte6(rebookSuggestions.expiresAt, now)
        )).limit(1);
        if (existingSuggestion.length > 0) continue;
        if (!pref.lastBookingDate || !pref.averageBookingIntervalDays) continue;
        const lastDate = parseISO(pref.lastBookingDate);
        const dueDate = addDays(lastDate, pref.averageBookingIntervalDays);
        const daysToDue = differenceInDays(dueDate, now);
        if (daysToDue > 3) continue;
        const slot = await this.findMatchingSlot({
          salonId: pref.salonId,
          staffId: pref.preferredStaffId,
          dayOfWeek: pref.preferredDayOfWeek,
          preferredTime: pref.preferredTimeExact || "10:00",
          startDate: daysToDue < 0 ? now : dueDate,
          lookAheadDays: SUGGESTION_LOOKAHEAD_DAYS
        });
        if (!slot) continue;
        const confidenceScore = this.calculateConfidenceScore(pref, slot);
        const reason = this.generateSuggestionReason(pref, daysToDue);
        await db.insert(rebookSuggestions).values({
          userId: pref.userId,
          salonId: pref.salonId,
          suggestedDate: slot.date,
          suggestedTime: slot.time,
          suggestedServiceIds: pref.preferredServiceIds || [],
          suggestedStaffId: pref.preferredStaffId,
          confidenceScore,
          reason,
          status: "pending",
          expiresAt: addDays(now, SUGGESTION_EXPIRY_DAYS)
        });
        generatedCount++;
      } catch (error) {
        console.error(`Error generating suggestion for user ${pref.userId}:`, error);
      }
    }
    return generatedCount;
  }
  async expireOldSuggestions() {
    const now = /* @__PURE__ */ new Date();
    const result = await db.update(rebookSuggestions).set({ status: "expired" }).where(and24(
      inArray9(rebookSuggestions.status, ["pending", "shown"]),
      lte6(rebookSuggestions.expiresAt, now)
    )).returning({ id: rebookSuggestions.id });
    return result.length;
  }
  async getLastVisitsBatched(userId) {
    const prefs = await db.select().from(userBookingPreferences).where(eq24(userBookingPreferences.userId, userId)).orderBy(desc16(userBookingPreferences.updatedAt)).limit(5);
    if (prefs.length === 0) return [];
    const salonIds = prefs.map((p) => p.salonId);
    const allServiceIds = [...new Set(prefs.flatMap((p) => p.preferredServiceIds || []))];
    const staffIds = [...new Set(prefs.map((p) => p.preferredStaffId).filter(Boolean))];
    const [salonData, serviceData, staffData] = await Promise.all([
      db.select({ id: salons.id, name: salons.name, imageUrl: salons.imageUrl }).from(salons).where(inArray9(salons.id, salonIds)),
      allServiceIds.length > 0 ? db.select({ id: services.id, name: services.name }).from(services).where(inArray9(services.id, allServiceIds)) : [],
      staffIds.length > 0 ? db.select({ id: staff.id, name: staff.name }).from(staff).where(inArray9(staff.id, staffIds)) : []
    ]);
    const salonMap = new Map(salonData.map((s) => [s.id, s]));
    const serviceMap = new Map(serviceData.map((s) => [s.id, s.name]));
    const staffMap = new Map(staffData.map((s) => [s.id, s.name]));
    const now = /* @__PURE__ */ new Date();
    return prefs.map((pref) => {
      const salon = salonMap.get(pref.salonId);
      if (!salon) return null;
      const serviceNames = (pref.preferredServiceIds || []).map((id) => serviceMap.get(id)).filter(Boolean);
      const staffName = pref.preferredStaffId ? staffMap.get(pref.preferredStaffId) || null : null;
      const daysSince = pref.lastBookingDate ? differenceInDays(now, parseISO(pref.lastBookingDate)) : 0;
      return {
        salonId: salon.id,
        salonName: salon.name,
        salonImageUrl: salon.imageUrl,
        lastVisitDate: pref.lastBookingDate || "",
        daysSince,
        services: serviceNames,
        staffName
      };
    }).filter(Boolean);
  }
  async getStaffBookingCounts(userId, salonId) {
    const result = await db.select({
      staffId: bookings.staffId,
      count: sql21`count(*)::int`
    }).from(bookings).where(and24(
      eq24(bookings.userId, userId),
      eq24(bookings.salonId, salonId),
      eq24(bookings.status, "completed"),
      sql21`${bookings.staffId} IS NOT NULL`
    )).groupBy(bookings.staffId).orderBy(desc16(sql21`count(*)`)).limit(5);
    return result.filter((r) => r.staffId).map((r) => ({
      staffId: r.staffId,
      count: Number(r.count)
    }));
  }
  async getServiceBookingCounts(userId, salonId) {
    const result = await db.select({
      serviceId: bookings.serviceId,
      count: sql21`count(*)::int`
    }).from(bookings).where(and24(
      eq24(bookings.userId, userId),
      eq24(bookings.salonId, salonId),
      eq24(bookings.status, "completed"),
      sql21`${bookings.serviceId} IS NOT NULL`
    )).groupBy(bookings.serviceId).orderBy(desc16(sql21`count(*)`)).limit(5);
    return result.filter((r) => r.serviceId).map((r) => ({
      serviceId: r.serviceId,
      count: Number(r.count)
    }));
  }
  async getDayOfWeekCounts(userId, salonId) {
    const result = await db.select({
      dayOfWeek: sql21`EXTRACT(DOW FROM ${bookings.bookingDate}::date)::int`,
      count: sql21`count(*)::int`
    }).from(bookings).where(and24(
      eq24(bookings.userId, userId),
      eq24(bookings.salonId, salonId),
      eq24(bookings.status, "completed")
    )).groupBy(sql21`EXTRACT(DOW FROM ${bookings.bookingDate}::date)`).orderBy(desc16(sql21`count(*)`)).limit(3);
    return result.map((r) => ({
      dayOfWeek: Number(r.dayOfWeek),
      count: Number(r.count)
    }));
  }
  classifyTimeSlot(time) {
    const hour = parseInt(time.split(":")[0] || "12");
    if (hour < 12) return "morning";
    if (hour < 17) return "afternoon";
    return "evening";
  }
  calculateBookingIntervals(dates) {
    if (dates.length < 2) return [];
    const sortedDates = dates.sort((a, b) => parseISO(b).getTime() - parseISO(a).getTime());
    const intervals = [];
    for (let i = 0; i < sortedDates.length - 1; i++) {
      const diff = differenceInDays(parseISO(sortedDates[i]), parseISO(sortedDates[i + 1]));
      if (diff > 0 && diff < 180) {
        intervals.push(diff);
      }
    }
    return intervals;
  }
  median(numbers) {
    if (numbers.length === 0) return 0;
    const sorted = [...numbers].sort((a, b) => a - b);
    const mid = Math.floor(sorted.length / 2);
    return sorted.length % 2 !== 0 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2;
  }
  async checkSlotAvailability(salonId, date, time, staffId) {
    const existingBooking = await db.select({ id: bookings.id }).from(bookings).where(and24(
      eq24(bookings.salonId, salonId),
      eq24(bookings.bookingDate, date),
      eq24(bookings.bookingTime, time),
      inArray9(bookings.status, ["confirmed", "pending"]),
      staffId ? eq24(bookings.staffId, staffId) : sql21`true`
    )).limit(1);
    return existingBooking.length === 0;
  }
  async findNextAvailableSlot(salonId, preferredTime, preferredStaffId) {
    const startDate = /* @__PURE__ */ new Date();
    const dates = [];
    for (let i = 0; i < 14; i++) {
      dates.push(format(addDays(startDate, i), "yyyy-MM-dd"));
    }
    const existingBookings = await db.select({
      bookingDate: bookings.bookingDate
    }).from(bookings).where(and24(
      eq24(bookings.salonId, salonId),
      inArray9(bookings.bookingDate, dates),
      eq24(bookings.bookingTime, preferredTime),
      inArray9(bookings.status, ["confirmed", "pending"]),
      preferredStaffId ? eq24(bookings.staffId, preferredStaffId) : sql21`true`
    ));
    const bookedDates = new Set(existingBookings.map((b) => b.bookingDate));
    for (const dateStr of dates) {
      if (!bookedDates.has(dateStr)) {
        return { date: dateStr, time: preferredTime, available: true };
      }
    }
    return null;
  }
  async findMatchingSlot(options) {
    const { salonId, staffId, dayOfWeek, preferredTime, startDate, lookAheadDays } = options;
    const dates = [];
    for (let i = 0; i < lookAheadDays; i++) {
      dates.push(format(addDays(startDate, i), "yyyy-MM-dd"));
    }
    const existingBookings = await db.select({
      bookingDate: bookings.bookingDate
    }).from(bookings).where(and24(
      eq24(bookings.salonId, salonId),
      inArray9(bookings.bookingDate, dates),
      eq24(bookings.bookingTime, preferredTime),
      inArray9(bookings.status, ["confirmed", "pending"]),
      staffId ? eq24(bookings.staffId, staffId) : sql21`true`
    ));
    const bookedDates = new Set(existingBookings.map((b) => b.bookingDate));
    if (dayOfWeek !== null && dayOfWeek !== void 0) {
      for (let i = 0; i < lookAheadDays; i++) {
        const checkDate = addDays(startDate, i);
        if (checkDate.getDay() === dayOfWeek) {
          const dateStr = format(checkDate, "yyyy-MM-dd");
          if (!bookedDates.has(dateStr)) {
            return { date: dateStr, time: preferredTime };
          }
        }
      }
    }
    for (const dateStr of dates) {
      if (!bookedDates.has(dateStr)) {
        return { date: dateStr, time: preferredTime };
      }
    }
    return null;
  }
  calculateConfidenceScore(pref, slot) {
    let score = 50;
    if (pref.preferredStaffId) {
      score += 10;
    }
    if (pref.preferredTimeExact === slot.time) {
      score += 10;
    }
    const slotDayOfWeek = parseISO(slot.date).getDay();
    if (pref.preferredDayOfWeek === slotDayOfWeek) {
      score += 5;
    }
    if ((pref.totalCompletedBookings ?? 0) >= 5) {
      score += 15;
    } else if ((pref.totalCompletedBookings ?? 0) >= 3) {
      score += 8;
    }
    return Math.min(100, score);
  }
  generateSuggestionReason(pref, daysToDue) {
    const interval = pref.averageBookingIntervalDays || 30;
    if (daysToDue < -7) {
      return `It's been over ${interval + Math.abs(daysToDue)} days since your last visit. We miss you!`;
    } else if (daysToDue < 0) {
      return `Your ${interval}-day appointment cycle is ${Math.abs(daysToDue)} days overdue`;
    } else if (daysToDue === 0) {
      return `Today is the perfect day for your next appointment!`;
    } else {
      return `It's almost time for your next visit (in ${daysToDue} days)`;
    }
  }
};
var expressRebookingService = new ExpressRebookingService();

// server/routes/expressRebooking.routes.ts
init_schema();
import { z as z9 } from "zod";
import rateLimit3 from "express-rate-limit";
var router13 = Router12();
var requireAuth2 = (req, res, next) => {
  if (!req.user?.id) {
    return res.status(401).json({ error: "Authentication required" });
  }
  next();
};
var quickBookLimiter = rateLimit3({
  windowMs: 60 * 1e3,
  max: 10,
  message: { error: "Too many booking attempts. Please wait a moment." },
  standardHeaders: true,
  legacyHeaders: false
});
router13.get("/suggestions", requireAuth2, async (req, res) => {
  try {
    const result = await expressRebookingService.getSuggestionsForUser(req.user.id);
    res.json(result);
  } catch (error) {
    console.error("Error fetching express rebook suggestions:", error);
    res.status(500).json({ error: "Failed to fetch suggestions" });
  }
});
router13.post("/quick", requireAuth2, quickBookLimiter, async (req, res) => {
  try {
    const validatedData = quickRebookSchema.parse(req.body);
    const result = await expressRebookingService.quickBook(req.user.id, validatedData.suggestionId);
    if (result.success) {
      res.status(201).json(result);
    } else {
      res.status(400).json({ error: result.error });
    }
  } catch (error) {
    if (error instanceof z9.ZodError) {
      return res.status(400).json({ error: "Invalid request data", details: error.errors });
    }
    console.error("Error processing quick rebook:", error);
    res.status(500).json({ error: "Failed to process booking" });
  }
});
router13.post("/customize", requireAuth2, quickBookLimiter, async (req, res) => {
  try {
    const validatedData = customizeRebookSchema.parse(req.body);
    const result = await expressRebookingService.customizeBook(
      req.user.id,
      validatedData.suggestionId,
      validatedData.modifications
    );
    if (result.success) {
      res.status(201).json(result);
    } else {
      res.status(400).json({ error: result.error });
    }
  } catch (error) {
    if (error instanceof z9.ZodError) {
      return res.status(400).json({ error: "Invalid request data", details: error.errors });
    }
    console.error("Error processing customized rebook:", error);
    res.status(500).json({ error: "Failed to process booking" });
  }
});
router13.post("/dismiss", requireAuth2, async (req, res) => {
  try {
    const validatedData = dismissRebookSuggestionSchema.parse(req.body);
    const result = await expressRebookingService.dismissSuggestion(
      req.user.id,
      validatedData.suggestionId,
      validatedData.reason
    );
    if (result.success) {
      res.json({ success: true });
    } else {
      res.status(400).json({ error: result.error });
    }
  } catch (error) {
    if (error instanceof z9.ZodError) {
      return res.status(400).json({ error: "Invalid request data", details: error.errors });
    }
    console.error("Error dismissing suggestion:", error);
    res.status(500).json({ error: "Failed to dismiss suggestion" });
  }
});
router13.get("/last-booking/:salonId", requireAuth2, async (req, res) => {
  try {
    const { salonId } = req.params;
    const result = await expressRebookingService.getLastBookingForSalon(req.user.id, salonId);
    res.json(result);
  } catch (error) {
    console.error("Error fetching last booking:", error);
    res.status(500).json({ error: "Failed to fetch last booking" });
  }
});
function registerMobileExpressRebookingRoutes(app2) {
  const mobileQuickBookLimiter = rateLimit3({
    windowMs: 60 * 1e3,
    max: 10,
    message: { error: "Too many booking attempts. Please wait a moment." },
    standardHeaders: true,
    legacyHeaders: false
  });
  app2.get("/api/mobile/express-rebook/suggestions", authenticateMobileUser, async (req, res) => {
    try {
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ error: "User not authenticated" });
      }
      const result = await expressRebookingService.getSuggestionsForUser(userId);
      res.json(result);
    } catch (error) {
      console.error("Error fetching mobile express rebook suggestions:", error);
      res.status(500).json({ error: "Failed to fetch suggestions" });
    }
  });
  app2.post("/api/mobile/express-rebook/quick", authenticateMobileUser, mobileQuickBookLimiter, async (req, res) => {
    try {
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ error: "User not authenticated" });
      }
      const validatedData = quickRebookSchema.parse(req.body);
      const result = await expressRebookingService.quickBook(userId, validatedData.suggestionId);
      if (result.success) {
        res.status(201).json(result);
      } else {
        res.status(400).json({ error: result.error });
      }
    } catch (error) {
      if (error instanceof z9.ZodError) {
        return res.status(400).json({ error: "Invalid request data", details: error.errors });
      }
      console.error("Error processing mobile quick rebook:", error);
      res.status(500).json({ error: "Failed to process booking" });
    }
  });
  app2.post("/api/mobile/express-rebook/customize", authenticateMobileUser, mobileQuickBookLimiter, async (req, res) => {
    try {
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ error: "User not authenticated" });
      }
      const validatedData = customizeRebookSchema.parse(req.body);
      const result = await expressRebookingService.customizeBook(
        userId,
        validatedData.suggestionId,
        validatedData.modifications
      );
      if (result.success) {
        res.status(201).json(result);
      } else {
        res.status(400).json({ error: result.error });
      }
    } catch (error) {
      if (error instanceof z9.ZodError) {
        return res.status(400).json({ error: "Invalid request data", details: error.errors });
      }
      console.error("Error processing mobile customized rebook:", error);
      res.status(500).json({ error: "Failed to process booking" });
    }
  });
  app2.post("/api/mobile/express-rebook/dismiss", authenticateMobileUser, async (req, res) => {
    try {
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ error: "User not authenticated" });
      }
      const validatedData = dismissRebookSuggestionSchema.parse(req.body);
      const result = await expressRebookingService.dismissSuggestion(
        userId,
        validatedData.suggestionId,
        validatedData.reason
      );
      if (result.success) {
        res.json({ success: true });
      } else {
        res.status(400).json({ error: result.error });
      }
    } catch (error) {
      if (error instanceof z9.ZodError) {
        return res.status(400).json({ error: "Invalid request data", details: error.errors });
      }
      console.error("Error dismissing mobile suggestion:", error);
      res.status(500).json({ error: "Failed to dismiss suggestion" });
    }
  });
  app2.get("/api/mobile/express-rebook/last-booking/:salonId", authenticateMobileUser, async (req, res) => {
    try {
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ error: "User not authenticated" });
      }
      const { salonId } = req.params;
      const result = await expressRebookingService.getLastBookingForSalon(userId, salonId);
      res.json(result);
    } catch (error) {
      console.error("Error fetching mobile last booking:", error);
      res.status(500).json({ error: "Failed to fetch last booking" });
    }
  });
  console.log("\u2705 Mobile Express Rebooking routes registered");
}
var expressRebooking_routes_default = router13;

// server/routes.ts
init_rbacService();

// server/routes/shopAdminRoutes.ts
init_rbacService();
import { Router as Router13 } from "express";
import { z as z10 } from "zod";
var router14 = Router13();
router14.use(populateUserFromSession);
router14.get(
  "/:salonId/admins",
  requireSalonAccess(["owner"]),
  async (req, res) => {
    try {
      const { salonId } = req.params;
      const salonPermissions = req.salonPermissions;
      const isBusinessOwner = salonPermissions?.isBusinessOwner === true;
      const isShopAdmin = salonPermissions?.role === "shop_admin";
      if (!isBusinessOwner) {
        const userId = req.user?.id;
        if (!userId) {
          return res.status(401).json({ success: false, message: "Authentication required" });
        }
        const hasAccess = await rbacService.isShopAdmin(userId, salonId);
        if (!hasAccess) {
          return res.status(403).json({
            success: false,
            message: "You do not have permission to view shop admins"
          });
        }
      }
      const admins = await rbacService.getShopAdmins(salonId);
      return res.json({
        success: true,
        admins
      });
    } catch (error) {
      console.error("Error fetching shop admins:", error);
      return res.status(500).json({ success: false, message: "Failed to fetch shop admins" });
    }
  }
);
router14.post(
  "/:salonId/assign",
  requireSalonAccess(["owner"]),
  requireBusinessOwner(),
  async (req, res) => {
    try {
      const currentUserId = req.user?.id;
      const { salonId } = req.params;
      const bodySchema = z10.object({
        userId: z10.string(),
        role: z10.enum(["shop_admin", "staff"]),
        notes: z10.string().optional()
      });
      const validation = bodySchema.safeParse(req.body);
      if (!validation.success) {
        return res.status(400).json({
          success: false,
          message: "Invalid request data",
          errors: validation.error.errors
        });
      }
      const { userId, role, notes } = validation.data;
      const result = await rbacService.assignRole(
        userId,
        salonId,
        role,
        currentUserId,
        notes,
        req.ip,
        req.get("user-agent")
      );
      if (!result.success) {
        return res.status(400).json({ success: false, message: result.error });
      }
      return res.json({
        success: true,
        message: `Successfully assigned ${role} role`,
        assignment: result.assignment
      });
    } catch (error) {
      console.error("Error assigning role:", error);
      return res.status(500).json({ success: false, message: "Failed to assign role" });
    }
  }
);
router14.post(
  "/:salonId/revoke",
  requireSalonAccess(["owner"]),
  requireBusinessOwner(),
  async (req, res) => {
    try {
      const currentUserId = req.user?.id;
      const { salonId } = req.params;
      const bodySchema = z10.object({
        userId: z10.string()
      });
      const validation = bodySchema.safeParse(req.body);
      if (!validation.success) {
        return res.status(400).json({
          success: false,
          message: "Invalid request data",
          errors: validation.error.errors
        });
      }
      const { userId } = validation.data;
      const result = await rbacService.revokeRole(
        userId,
        salonId,
        currentUserId,
        req.ip,
        req.get("user-agent")
      );
      if (!result.success) {
        return res.status(400).json({ success: false, message: result.error });
      }
      return res.json({
        success: true,
        message: "Successfully revoked role"
      });
    } catch (error) {
      console.error("Error revoking role:", error);
      return res.status(500).json({ success: false, message: "Failed to revoke role" });
    }
  }
);
router14.post(
  "/:salonId/update-role",
  requireSalonAccess(["owner"]),
  requireBusinessOwner(),
  async (req, res) => {
    try {
      const currentUserId = req.user?.id;
      const { salonId } = req.params;
      const bodySchema = z10.object({
        userId: z10.string(),
        newRole: z10.enum(["shop_admin", "staff"]),
        notes: z10.string().optional()
      });
      const validation = bodySchema.safeParse(req.body);
      if (!validation.success) {
        return res.status(400).json({
          success: false,
          message: "Invalid request data",
          errors: validation.error.errors
        });
      }
      const { userId, newRole, notes } = validation.data;
      const result = await rbacService.updateRole(
        userId,
        salonId,
        newRole,
        currentUserId,
        notes,
        req.ip,
        req.get("user-agent")
      );
      if (!result.success) {
        return res.status(400).json({ success: false, message: result.error });
      }
      return res.json({
        success: true,
        message: `Successfully updated role to ${newRole}`
      });
    } catch (error) {
      console.error("Error updating role:", error);
      return res.status(500).json({ success: false, message: "Failed to update role" });
    }
  }
);
router14.post("/assign", async (req, res) => {
  const { salonId } = req.body;
  if (!salonId) {
    return res.status(400).json({ success: false, message: "salonId is required" });
  }
  return res.status(301).json({
    success: false,
    message: "This endpoint is deprecated. Use POST /api/shop-admins/:salonId/assign instead"
  });
});
router14.post("/revoke", async (req, res) => {
  return res.status(301).json({
    success: false,
    message: "This endpoint is deprecated. Use POST /api/shop-admins/:salonId/revoke instead"
  });
});
router14.post("/update", async (req, res) => {
  return res.status(301).json({
    success: false,
    message: "This endpoint is deprecated. Use POST /api/shop-admins/:salonId/update-role instead"
  });
});
router14.get(
  "/:salonId/my-permissions",
  requireSalonAccess(["owner", "manager", "staff"]),
  async (req, res) => {
    try {
      const userId = req.user?.id;
      const { salonId } = req.params;
      const salonPermissions = req.salonPermissions;
      if (!salonPermissions) {
        return res.status(403).json({ success: false, message: "You do not have access to this salon" });
      }
      return res.json({
        success: true,
        userId,
        salonId,
        role: salonPermissions.role,
        permissions: salonPermissions.permissions,
        isBusinessOwner: salonPermissions.isBusinessOwner
      });
    } catch (error) {
      console.error("Error fetching permissions:", error);
      return res.status(500).json({ success: false, message: "Failed to fetch permissions" });
    }
  }
);
router14.get("/my-salons", async (req, res) => {
  try {
    const userId = req.user?.id;
    if (!userId) {
      return res.status(401).json({ success: false, message: "Authentication required" });
    }
    const salons11 = await rbacService.getSalonsForUser(userId);
    return res.json({
      success: true,
      salons: salons11
    });
  } catch (error) {
    console.error("Error fetching user salons:", error);
    return res.status(500).json({ success: false, message: "Failed to fetch salons" });
  }
});
router14.get("/permissions/all", async (req, res) => {
  try {
    const userId = req.user?.id;
    if (!userId) {
      return res.status(401).json({ success: false, message: "Authentication required" });
    }
    const allPermissions = await rbacService.getAllPermissions();
    const grouped = {};
    for (const permission of allPermissions) {
      if (!grouped[permission.category]) {
        grouped[permission.category] = [];
      }
      grouped[permission.category].push(permission);
    }
    return res.json({
      success: true,
      permissions: allPermissions,
      grouped
    });
  } catch (error) {
    console.error("Error fetching all permissions:", error);
    return res.status(500).json({ success: false, message: "Failed to fetch permissions" });
  }
});
router14.get("/permissions/role/:role", async (req, res) => {
  try {
    const userId = req.user?.id;
    if (!userId) {
      return res.status(401).json({ success: false, message: "Authentication required" });
    }
    const { role } = req.params;
    if (!["business_owner", "shop_admin", "staff"].includes(role)) {
      return res.status(400).json({ success: false, message: "Invalid role" });
    }
    const permissions2 = await rbacService.getRolePermissions(role);
    return res.json({
      success: true,
      role,
      permissions: permissions2
    });
  } catch (error) {
    console.error("Error fetching role permissions:", error);
    return res.status(500).json({ success: false, message: "Failed to fetch role permissions" });
  }
});
router14.get(
  "/:salonId/audit-logs",
  requireSalonAccess(["owner"]),
  requireBusinessOwner(),
  async (req, res) => {
    try {
      const { salonId } = req.params;
      const limit = parseInt(req.query.limit) || 50;
      const offset = parseInt(req.query.offset) || 0;
      const logs = await rbacService.getAuditLogs(salonId, limit, offset);
      return res.json({
        success: true,
        logs
      });
    } catch (error) {
      console.error("Error fetching audit logs:", error);
      return res.status(500).json({ success: false, message: "Failed to fetch audit logs" });
    }
  }
);
var shopAdminRoutes_default = router14;

// server/routes/job-cards.routes.ts
init_db();
init_schema();
import { Router as Router14 } from "express";
import rateLimit4 from "express-rate-limit";
import { eq as eq25, and as and25, desc as desc17, sql as sql22, gte as gte7, lte as lte7, inArray as inArray10, gt as gt3 } from "drizzle-orm";
var router15 = Router14();
async function getUserDisplayName(userId) {
  if (!userId) return "Staff";
  try {
    const [user] = await db.select({ firstName: users.firstName, lastName: users.lastName, email: users.email }).from(users).where(eq25(users.id, userId));
    if (user) {
      const name = `${user.firstName || ""} ${user.lastName || ""}`.trim();
      return name || user.email || "Staff";
    }
  } catch (e) {
    console.error("Error fetching user name:", e);
  }
  return "Staff";
}
router15.use(populateUserFromSession);
var publicCheckInLimiter = rateLimit4({
  windowMs: 15 * 60 * 1e3,
  max: 10,
  message: { error: "Too many check-in attempts. Please try again later." },
  standardHeaders: true,
  legacyHeaders: false,
  validate: { xForwardedForHeader: false }
});
async function createJobCardWithNumber(salonId, insertCallback) {
  const today = /* @__PURE__ */ new Date();
  const dateStr = today.toISOString().slice(0, 10).replace(/-/g, "");
  const startOfDay = new Date(today.getFullYear(), today.getMonth(), today.getDate(), 0, 0, 0, 0);
  const endOfDay = new Date(today.getFullYear(), today.getMonth(), today.getDate(), 23, 59, 59, 999);
  const lockKey = `job_card_seq:${salonId}:${dateStr}`;
  return await db.transaction(async (tx) => {
    await tx.execute(sql22`SELECT pg_advisory_xact_lock(hashtext(${lockKey}))`);
    const countResult = await tx.execute(sql22`
      SELECT COUNT(*) as cnt FROM job_cards 
      WHERE salon_id = ${salonId}
        AND created_at >= ${startOfDay.toISOString()}
        AND created_at <= ${endOfDay.toISOString()}
    `);
    const count11 = Number(countResult.rows[0]?.cnt || 0) + 1;
    const jobCardNumber = `JC-${dateStr}-${String(count11).padStart(3, "0")}`;
    const result = await insertCallback(jobCardNumber, tx);
    return result;
  });
}
async function logJobCardActivity(jobCardId, salonId, activityType, description, performedBy, performedByName, previousValue, newValue) {
  await db.insert(jobCardActivityLog).values({
    jobCardId,
    salonId,
    activityType,
    description,
    previousValue: previousValue ? previousValue : null,
    newValue: newValue ? newValue : null,
    performedBy,
    performedByName
  });
}
async function recalculateJobCardTotals(jobCardId) {
  const jobCard = await db.query.jobCards.findFirst({
    where: eq25(jobCards.id, jobCardId)
  });
  if (!jobCard) return null;
  const cardServices = await db.select().from(jobCardServices).where(and25(
    eq25(jobCardServices.jobCardId, jobCardId),
    sql22`${jobCardServices.status} != 'cancelled'`
  ));
  const cardProducts = await db.select().from(jobCardProducts).where(eq25(jobCardProducts.jobCardId, jobCardId));
  const serviceTaxRate = 5;
  const productTaxRate = 18;
  const servicesTotalPaisa = cardServices.reduce((sum4, s) => sum4 + s.finalPricePaisa, 0);
  const productsTotalPaisa = cardProducts.reduce((sum4, p) => sum4 + p.totalPricePaisa, 0);
  const serviceBasePaisa = Math.round(servicesTotalPaisa / (1 + serviceTaxRate / 100));
  const productBasePaisa = Math.round(productsTotalPaisa / (1 + productTaxRate / 100));
  let serviceTaxPaisa = servicesTotalPaisa - serviceBasePaisa;
  let productTaxPaisa = productsTotalPaisa - productBasePaisa;
  const subtotalPaisa = servicesTotalPaisa + productsTotalPaisa;
  let discountAmountPaisa = 0;
  if (jobCard.discountType === "percentage" && jobCard.discountValue) {
    discountAmountPaisa = Math.round(subtotalPaisa * (Number(jobCard.discountValue) / 100));
  } else if (jobCard.discountType === "fixed" && jobCard.discountValue) {
    discountAmountPaisa = Math.round(Number(jobCard.discountValue) * 100);
  }
  if (subtotalPaisa > 0 && discountAmountPaisa > 0) {
    const discountRatio = discountAmountPaisa / subtotalPaisa;
    serviceTaxPaisa = Math.round(serviceTaxPaisa * (1 - discountRatio));
    productTaxPaisa = Math.round(productTaxPaisa * (1 - discountRatio));
  }
  const taxAmountPaisa = serviceTaxPaisa + productTaxPaisa;
  const totalAmountPaisa = subtotalPaisa - discountAmountPaisa + (jobCard.tipAmountPaisa || 0);
  const balancePaisa = totalAmountPaisa - (jobCard.paidAmountPaisa || 0);
  const cardPayments = await db.select().from(jobCardPayments).where(and25(
    eq25(jobCardPayments.jobCardId, jobCardId),
    eq25(jobCardPayments.status, "completed"),
    eq25(jobCardPayments.isRefund, 0)
  ));
  const paidAmountPaisa = cardPayments.reduce((sum4, p) => sum4 + p.amountPaisa, 0);
  const actualBalancePaisa = totalAmountPaisa - paidAmountPaisa;
  let paymentStatus = JOB_CARD_PAYMENT_STATUSES.UNPAID;
  if (paidAmountPaisa >= totalAmountPaisa) {
    paymentStatus = JOB_CARD_PAYMENT_STATUSES.PAID;
  } else if (paidAmountPaisa > 0) {
    paymentStatus = JOB_CARD_PAYMENT_STATUSES.PARTIAL;
  }
  const estimatedDurationMinutes = cardServices.reduce((sum4, s) => sum4 + s.estimatedDurationMinutes, 0);
  const [updated] = await db.update(jobCards).set({
    subtotalPaisa,
    discountAmountPaisa,
    taxAmountPaisa,
    totalAmountPaisa,
    paidAmountPaisa,
    balancePaisa: actualBalancePaisa,
    paymentStatus,
    estimatedDurationMinutes,
    updatedAt: /* @__PURE__ */ new Date()
  }).where(eq25(jobCards.id, jobCardId)).returning();
  return updated;
}
router15.post("/:salonId/check-in", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId } = req.params;
    const userId = req.user?.id;
    const userName = await getUserDisplayName(req.user?.id);
    const parsed = checkInCustomerSchema.safeParse(req.body);
    if (!parsed.success) {
      return res.status(400).json({ error: "Invalid request body", details: parsed.error.errors });
    }
    const { bookingId, customerName, customerEmail, customerPhone, assignedStaffId, checkInMethod, isWalkIn, notes, serviceIds, staffId, verificationSessionId } = parsed.data;
    let booking = null;
    let customerId = null;
    let servicesFromBooking = [];
    let servicesFromWalkIn = [];
    let newUserCreated = false;
    if (checkInMethod === "walk_in" && !bookingId) {
      if (!customerPhone || !verificationSessionId) {
        return res.status(400).json({
          error: "Phone verification is required for walk-in customers",
          requiresVerification: true
        });
      }
      const now = /* @__PURE__ */ new Date();
      const verificationToken = await db.query.phoneVerificationTokens.findFirst({
        where: and25(
          eq25(phoneVerificationTokens.verificationSessionId, verificationSessionId),
          gt3(phoneVerificationTokens.sessionExpiresAt, now)
        )
      });
      if (!verificationToken || !verificationToken.verifiedAt) {
        return res.status(400).json({
          error: "Invalid or expired phone verification. Please verify your phone again.",
          sessionExpired: true
        });
      }
      const normalizedInputPhone = customerPhone.replace(/\D/g, "").slice(-10);
      const normalizedVerifiedPhone = verificationToken.phone.replace(/\D/g, "").slice(-10);
      if (normalizedInputPhone !== normalizedVerifiedPhone) {
        return res.status(400).json({
          error: "Phone number does not match verified number",
          phoneMismatch: true
        });
      }
      const isReturningCustomer = verificationToken.context === "walk-in-returning";
      console.log(`\u2705 Walk-in phone verified: ${customerPhone} (session: ${verificationSessionId.substring(0, 8)}..., returning: ${isReturningCustomer})`);
    }
    const normalizedCustomerPhone = customerPhone ? customerPhone.replace(/\D/g, "").slice(-10) : null;
    if (!bookingId && normalizedCustomerPhone) {
      const phoneWithPrefixWalkin = "+91" + normalizedCustomerPhone;
      let existingUser = await db.query.users.findFirst({
        where: eq25(users.phone, phoneWithPrefixWalkin)
      });
      if (!existingUser) {
        existingUser = await db.query.users.findFirst({
          where: eq25(users.phone, normalizedCustomerPhone)
        });
      }
      if (existingUser) {
        customerId = existingUser.id;
      } else {
        const nameParts = (customerName || "").trim().split(" ");
        const firstName = nameParts[0] || "Guest";
        const lastName = nameParts.slice(1).join(" ") || null;
        const [newUser] = await db.insert(users).values({
          phone: normalizedCustomerPhone,
          email: customerEmail || null,
          firstName,
          lastName,
          emailVerified: 0,
          phoneVerified: 1,
          // Phone was verified via OTP
          isActive: 1
        }).returning();
        customerId = newUser.id;
        newUserCreated = true;
        console.log(`Created new user account for walk-in customer: ${newUser.id} (${normalizedCustomerPhone})`);
      }
    }
    if (bookingId) {
      booking = await db.query.bookings.findFirst({
        where: and25(
          eq25(bookings.id, bookingId),
          eq25(bookings.salonId, salonId)
        )
      });
      if (!booking) {
        return res.status(404).json({ error: "Booking not found" });
      }
      const existingJobCard = await db.query.jobCards.findFirst({
        where: eq25(jobCards.bookingId, bookingId)
      });
      if (existingJobCard) {
        return res.status(400).json({
          error: "A job card already exists for this booking",
          jobCardId: existingJobCard.id
        });
      }
      customerId = booking.userId;
      if (!customerId && booking.customerPhone) {
        const cleanPhone = booking.customerPhone.replace(/\D/g, "");
        const normalizedPhone = cleanPhone.length > 10 ? cleanPhone.slice(-10) : cleanPhone;
        const phoneWithPrefix = "+91" + normalizedPhone;
        let existingUser = await db.query.users.findFirst({
          where: eq25(users.phone, phoneWithPrefix)
        });
        if (!existingUser) {
          existingUser = await db.query.users.findFirst({
            where: eq25(users.phone, normalizedPhone)
          });
        }
        if (existingUser) {
          customerId = existingUser.id;
          console.log(`Linked booking to existing user: ${existingUser.id} (${normalizedPhone})`);
        } else {
          const nameParts = (booking.customerName || "").trim().split(" ");
          const firstName = nameParts[0] || "Guest";
          const lastName = nameParts.slice(1).join(" ") || null;
          const [newUser] = await db.insert(users).values({
            phone: normalizedPhone,
            email: booking.customerEmail || null,
            firstName,
            lastName,
            emailVerified: 0,
            phoneVerified: 0,
            isActive: 1
          }).returning();
          customerId = newUser.id;
          console.log(`Created new user account for booking customer: ${newUser.id} (${normalizedPhone})`);
        }
        await db.update(bookings).set({ userId: customerId }).where(eq25(bookings.id, bookingId));
        console.log(`Updated booking ${bookingId} with userId ${customerId}`);
      }
      servicesFromBooking = await db.select({
        id: bookingServices.id,
        serviceId: bookingServices.serviceId,
        serviceName: services.name,
        serviceCategory: services.category,
        pricePaisa: services.priceInPaisa,
        durationMinutes: services.durationMinutes,
        staffId: sql22`NULL`.as("staffId")
      }).from(bookingServices).leftJoin(services, eq25(bookingServices.serviceId, services.id)).where(eq25(bookingServices.bookingId, bookingId));
      if (servicesFromBooking.length === 0 && booking.serviceId) {
        const [singleService] = await db.select({
          id: services.id,
          serviceId: services.id,
          serviceName: services.name,
          serviceCategory: services.category,
          pricePaisa: services.priceInPaisa,
          durationMinutes: services.durationMinutes
        }).from(services).where(eq25(services.id, booking.serviceId));
        if (singleService) {
          servicesFromBooking = [{
            ...singleService,
            staffId: booking.staffId || null
          }];
        }
      }
    }
    if (serviceIds && serviceIds.length > 0 && !bookingId) {
      const fetchedServices = await db.select({
        id: services.id,
        serviceName: services.name,
        serviceCategory: services.category,
        pricePaisa: services.priceInPaisa,
        durationMinutes: services.durationMinutes
      }).from(services).where(and25(
        eq25(services.salonId, salonId),
        inArray10(services.id, serviceIds)
      ));
      servicesFromWalkIn = fetchedServices.map((s) => ({
        ...s,
        serviceId: s.id,
        staffId: staffId || assignedStaffId || null
      }));
    }
    const effectiveStaffId = staffId || assignedStaffId || booking?.staffId || null;
    const isWalkInCheck = checkInMethod === "walk_in" || isWalkIn;
    const newJobCard = await createJobCardWithNumber(salonId, async (jobCardNumber, tx) => {
      const [insertedJobCard] = await tx.insert(jobCards).values({
        salonId,
        bookingId: bookingId || null,
        customerId,
        jobCardNumber,
        customerName,
        customerEmail: customerEmail || booking?.customerEmail || null,
        customerPhone: customerPhone || booking?.customerPhone || null,
        checkInMethod: checkInMethod || CHECK_IN_METHODS.MANUAL,
        checkInAt: /* @__PURE__ */ new Date(),
        checkInBy: userId || null,
        assignedStaffId: effectiveStaffId,
        status: JOB_CARD_STATUSES.OPEN,
        isWalkIn: isWalkInCheck ? 1 : 0,
        internalNotes: notes || null
      }).returning();
      return insertedJobCard;
    });
    if (servicesFromBooking.length > 0) {
      const jobCardServicesData = servicesFromBooking.map((s, index2) => ({
        jobCardId: newJobCard.id,
        salonId,
        serviceId: s.serviceId,
        staffId: s.staffId || effectiveStaffId,
        serviceName: s.serviceName || "Unknown Service",
        serviceCategory: s.serviceCategory || null,
        originalPricePaisa: s.pricePaisa || 0,
        discountPaisa: 0,
        finalPricePaisa: s.pricePaisa || 0,
        estimatedDurationMinutes: s.durationMinutes || 30,
        status: "pending",
        sequence: index2 + 1,
        source: "booking"
      }));
      await db.insert(jobCardServices).values(jobCardServicesData);
    }
    if (servicesFromWalkIn.length > 0) {
      const walkInServicesData = servicesFromWalkIn.map((s, index2) => ({
        jobCardId: newJobCard.id,
        salonId,
        serviceId: s.serviceId,
        staffId: effectiveStaffId,
        serviceName: s.serviceName || "Unknown Service",
        serviceCategory: s.serviceCategory || null,
        originalPricePaisa: s.pricePaisa || 0,
        discountPaisa: 0,
        finalPricePaisa: s.pricePaisa || 0,
        estimatedDurationMinutes: s.durationMinutes || 30,
        status: "pending",
        sequence: index2 + 1,
        source: "walk_in"
      }));
      await db.insert(jobCardServices).values(walkInServicesData);
    }
    await recalculateJobCardTotals(newJobCard.id);
    await logJobCardActivity(
      newJobCard.id,
      salonId,
      "check_in",
      `Customer ${customerName} checked in via ${checkInMethod}`,
      userId || null,
      userName,
      null,
      { jobCardNumber: newJobCard.jobCardNumber, checkInMethod, isWalkIn }
    );
    if (bookingId) {
      await db.update(bookings).set({ status: BOOKING_STATUSES.ARRIVED }).where(eq25(bookings.id, bookingId));
    }
    if (customerId) {
      const existingProfile = await db.query.clientProfiles.findFirst({
        where: and25(
          eq25(clientProfiles.salonId, salonId),
          eq25(clientProfiles.customerId, customerId)
        )
      });
      if (!existingProfile) {
        await db.insert(clientProfiles).values({
          salonId,
          customerId
        });
        const checkInType = isWalkInCheck ? "walk-in" : "booking";
        console.log(`Created client profile for ${checkInType} customer: salonId=${salonId}, customerId=${customerId}`);
      }
    }
    const fullJobCard = await db.query.jobCards.findFirst({
      where: eq25(jobCards.id, newJobCard.id)
    });
    const cardServices = await db.select().from(jobCardServices).where(eq25(jobCardServices.jobCardId, newJobCard.id));
    res.status(201).json({
      jobCard: {
        ...fullJobCard,
        services: cardServices
      }
    });
  } catch (error) {
    console.error("Error checking in customer:", error);
    res.status(500).json({ error: "Failed to check in customer" });
  }
});
router15.get("/:salonId/job-cards", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId } = req.params;
    const { status, date, staffId, customerId, limit = "50", offset = "0" } = req.query;
    let conditions = [eq25(jobCards.salonId, salonId)];
    if (status && status !== "all") {
      const statusArray = String(status).split(",");
      conditions.push(inArray10(jobCards.status, statusArray));
    }
    if (date) {
      const dateObj = new Date(String(date));
      const startOfDay = new Date(dateObj.setHours(0, 0, 0, 0));
      const endOfDay = new Date(dateObj.setHours(23, 59, 59, 999));
      conditions.push(and25(
        gte7(jobCards.checkInAt, startOfDay),
        lte7(jobCards.checkInAt, endOfDay)
      ));
    }
    if (staffId) {
      conditions.push(eq25(jobCards.assignedStaffId, String(staffId)));
    }
    if (customerId) {
      conditions.push(eq25(jobCards.customerId, String(customerId)));
    }
    const allJobCards = await db.select().from(jobCards).where(and25(...conditions)).orderBy(desc17(jobCards.checkInAt)).limit(Number(limit)).offset(Number(offset));
    const jobCardIds = allJobCards.map((jc) => jc.id);
    const cardServices = jobCardIds.length > 0 ? await db.select().from(jobCardServices).where(inArray10(jobCardServices.jobCardId, jobCardIds)) : [];
    const staffIds = Array.from(new Set(allJobCards.map((jc) => jc.assignedStaffId).filter(Boolean)));
    const staffMembers = staffIds.length > 0 ? await db.select().from(staff).where(inArray10(staff.id, staffIds)) : [];
    const staffMap = Object.fromEntries(staffMembers.map((s) => [s.id, s]));
    const result = allJobCards.map((jc) => ({
      ...jc,
      services: cardServices.filter((s) => s.jobCardId === jc.id),
      assignedStaffDetails: jc.assignedStaffId ? staffMap[jc.assignedStaffId] : null
    }));
    res.json({
      jobCards: result,
      total: result.length,
      limit: Number(limit),
      offset: Number(offset)
    });
  } catch (error) {
    console.error("Error fetching job cards:", error);
    res.status(500).json({ error: "Failed to fetch job cards" });
  }
});
router15.get("/:salonId/job-cards/:jobCardId", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId, jobCardId } = req.params;
    const jobCard = await db.query.jobCards.findFirst({
      where: and25(
        eq25(jobCards.id, jobCardId),
        eq25(jobCards.salonId, salonId)
      )
    });
    if (!jobCard) {
      return res.status(404).json({ error: "Job card not found" });
    }
    const cardServices = await db.select({
      id: jobCardServices.id,
      jobCardId: jobCardServices.jobCardId,
      serviceId: jobCardServices.serviceId,
      staffId: jobCardServices.staffId,
      serviceName: jobCardServices.serviceName,
      serviceCategory: jobCardServices.serviceCategory,
      originalPricePaisa: jobCardServices.originalPricePaisa,
      discountPaisa: jobCardServices.discountPaisa,
      finalPricePaisa: jobCardServices.finalPricePaisa,
      estimatedDurationMinutes: jobCardServices.estimatedDurationMinutes,
      actualDurationMinutes: jobCardServices.actualDurationMinutes,
      status: jobCardServices.status,
      startedAt: jobCardServices.startedAt,
      completedAt: jobCardServices.completedAt,
      sequence: jobCardServices.sequence,
      notes: jobCardServices.notes,
      source: jobCardServices.source,
      staffName: staff.name
    }).from(jobCardServices).leftJoin(staff, eq25(jobCardServices.staffId, staff.id)).where(eq25(jobCardServices.jobCardId, jobCardId)).orderBy(jobCardServices.sequence);
    const cardProducts = await db.select({
      id: jobCardProducts.id,
      jobCardId: jobCardProducts.jobCardId,
      productId: jobCardProducts.productId,
      staffId: jobCardProducts.staffId,
      productName: jobCardProducts.productName,
      productSku: jobCardProducts.productSku,
      productCategory: jobCardProducts.productCategory,
      quantity: jobCardProducts.quantity,
      unitPricePaisa: jobCardProducts.unitPricePaisa,
      discountPaisa: jobCardProducts.discountPaisa,
      totalPricePaisa: jobCardProducts.totalPricePaisa,
      taxAmountPaisa: jobCardProducts.taxAmountPaisa,
      notes: jobCardProducts.notes,
      staffName: staff.name
    }).from(jobCardProducts).leftJoin(staff, eq25(jobCardProducts.staffId, staff.id)).where(eq25(jobCardProducts.jobCardId, jobCardId));
    const cardPayments = await db.select({
      id: jobCardPayments.id,
      paymentMethod: jobCardPayments.paymentMethod,
      amountPaisa: jobCardPayments.amountPaisa,
      status: jobCardPayments.status,
      transactionId: jobCardPayments.transactionId,
      cardLast4: jobCardPayments.cardLast4,
      cardNetwork: jobCardPayments.cardNetwork,
      upiId: jobCardPayments.upiId,
      isRefund: jobCardPayments.isRefund,
      notes: jobCardPayments.notes,
      createdAt: jobCardPayments.createdAt,
      completedAt: jobCardPayments.completedAt,
      collectedByName: users.firstName
    }).from(jobCardPayments).leftJoin(users, eq25(jobCardPayments.collectedBy, users.id)).where(eq25(jobCardPayments.jobCardId, jobCardId)).orderBy(desc17(jobCardPayments.createdAt));
    const cardTips = await db.select({
      id: jobCardTips.id,
      staffId: jobCardTips.staffId,
      amountPaisa: jobCardTips.amountPaisa,
      paymentMethod: jobCardTips.paymentMethod,
      notes: jobCardTips.notes,
      staffName: staff.name
    }).from(jobCardTips).leftJoin(staff, eq25(jobCardTips.staffId, staff.id)).where(eq25(jobCardTips.jobCardId, jobCardId));
    const activityLog = await db.select().from(jobCardActivityLog).where(eq25(jobCardActivityLog.jobCardId, jobCardId)).orderBy(desc17(jobCardActivityLog.createdAt)).limit(50);
    let assignedStaffDetails = null;
    if (jobCard.assignedStaffId) {
      assignedStaffDetails = await db.query.staff.findFirst({
        where: eq25(staff.id, jobCard.assignedStaffId)
      });
    }
    res.json({
      ...jobCard,
      services: cardServices,
      products: cardProducts,
      payments: cardPayments,
      tips: cardTips,
      activityLog,
      assignedStaffDetails
    });
  } catch (error) {
    console.error("Error fetching job card details:", error);
    res.status(500).json({ error: "Failed to fetch job card details" });
  }
});
router15.post("/:salonId/job-cards/:jobCardId/services", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId, jobCardId } = req.params;
    const userId = req.user?.id;
    const userName = await getUserDisplayName(req.user?.id);
    const parsed = addJobCardServiceSchema.safeParse(req.body);
    if (!parsed.success) {
      return res.status(400).json({ error: "Invalid request body", details: parsed.error.errors });
    }
    const { serviceId, staffId, discountPaisa, notes } = parsed.data;
    const jobCard = await db.query.jobCards.findFirst({
      where: and25(
        eq25(jobCards.id, jobCardId),
        eq25(jobCards.salonId, salonId)
      )
    });
    if (!jobCard) {
      return res.status(404).json({ error: "Job card not found" });
    }
    if (jobCard.status === JOB_CARD_STATUSES.COMPLETED || jobCard.status === JOB_CARD_STATUSES.CANCELLED) {
      return res.status(400).json({ error: "Cannot add services to a closed or cancelled job card" });
    }
    const service = await db.query.services.findFirst({
      where: and25(
        eq25(services.id, serviceId),
        eq25(services.salonId, salonId)
      )
    });
    if (!service) {
      return res.status(404).json({ error: "Service not found" });
    }
    if (staffId) {
      const staffMember = await db.query.staff.findFirst({
        where: and25(
          eq25(staff.id, staffId),
          eq25(staff.salonId, salonId)
        )
      });
      if (!staffMember) {
        return res.status(400).json({ error: "Staff member not found or does not belong to this salon" });
      }
    }
    const existingServices = await db.select({ maxSequence: sql22`COALESCE(MAX(${jobCardServices.sequence}), 0)` }).from(jobCardServices).where(eq25(jobCardServices.jobCardId, jobCardId));
    const nextSequence = (existingServices[0]?.maxSequence || 0) + 1;
    const finalPricePaisa = service.priceInPaisa - (discountPaisa || 0);
    const [newService] = await db.insert(jobCardServices).values({
      jobCardId,
      salonId,
      serviceId,
      staffId: staffId || jobCard.assignedStaffId || null,
      serviceName: service.name,
      serviceCategory: service.category || null,
      originalPricePaisa: service.priceInPaisa,
      discountPaisa: discountPaisa || 0,
      finalPricePaisa,
      estimatedDurationMinutes: service.durationMinutes,
      status: "pending",
      sequence: nextSequence,
      notes: notes || null,
      source: "addon"
    }).returning();
    await recalculateJobCardTotals(jobCardId);
    await logJobCardActivity(
      jobCardId,
      salonId,
      "service_added",
      `Added service: ${service.name}`,
      userId || null,
      userName,
      null,
      { serviceId, serviceName: service.name, pricePaisa: service.priceInPaisa }
    );
    res.status(201).json(newService);
  } catch (error) {
    console.error("Error adding service to job card:", error);
    res.status(500).json({ error: "Failed to add service" });
  }
});
router15.delete("/:salonId/job-cards/:jobCardId/services/:serviceItemId", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId, jobCardId, serviceItemId } = req.params;
    const userId = req.user?.id;
    const userName = await getUserDisplayName(req.user?.id);
    const jobCard = await db.query.jobCards.findFirst({
      where: and25(
        eq25(jobCards.id, jobCardId),
        eq25(jobCards.salonId, salonId)
      )
    });
    if (!jobCard) {
      return res.status(404).json({ error: "Job card not found" });
    }
    if (jobCard.paymentStatus === JOB_CARD_PAYMENT_STATUSES.PAID) {
      return res.status(400).json({ error: "Cannot remove services after payment is completed" });
    }
    const serviceItem = await db.query.jobCardServices.findFirst({
      where: and25(
        eq25(jobCardServices.id, serviceItemId),
        eq25(jobCardServices.jobCardId, jobCardId)
      )
    });
    if (!serviceItem) {
      return res.status(404).json({ error: "Service not found on this job card" });
    }
    await db.update(jobCardServices).set({ status: "cancelled" }).where(eq25(jobCardServices.id, serviceItemId));
    await recalculateJobCardTotals(jobCardId);
    await logJobCardActivity(
      jobCardId,
      salonId,
      "service_removed",
      `Removed service: ${serviceItem.serviceName}`,
      userId || null,
      userName,
      { serviceId: serviceItem.serviceId, serviceName: serviceItem.serviceName },
      null
    );
    res.json({ success: true, message: "Service removed from job card" });
  } catch (error) {
    console.error("Error removing service from job card:", error);
    res.status(500).json({ error: "Failed to remove service" });
  }
});
router15.patch("/:salonId/job-cards/:jobCardId/services/:serviceItemId/status", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId, jobCardId, serviceItemId } = req.params;
    const { status } = req.body;
    const userId = req.user?.id;
    const userName = await getUserDisplayName(req.user?.id);
    const validStatuses = ["pending", "in_progress", "completed", "cancelled"];
    if (!validStatuses.includes(status)) {
      return res.status(400).json({ error: "Invalid status" });
    }
    const serviceItem = await db.query.jobCardServices.findFirst({
      where: and25(
        eq25(jobCardServices.id, serviceItemId),
        eq25(jobCardServices.jobCardId, jobCardId)
      )
    });
    if (!serviceItem) {
      return res.status(404).json({ error: "Service not found" });
    }
    const updateData = { status };
    if (status === "in_progress" && !serviceItem.startedAt) {
      updateData.startedAt = /* @__PURE__ */ new Date();
    } else if (status === "completed" && !serviceItem.completedAt) {
      updateData.completedAt = /* @__PURE__ */ new Date();
      if (serviceItem.startedAt) {
        const durationMs = (/* @__PURE__ */ new Date()).getTime() - new Date(serviceItem.startedAt).getTime();
        updateData.actualDurationMinutes = Math.round(durationMs / 6e4);
      }
    }
    const [updated] = await db.update(jobCardServices).set(updateData).where(eq25(jobCardServices.id, serviceItemId)).returning();
    await logJobCardActivity(
      jobCardId,
      salonId,
      "service_status_changed",
      `Service ${serviceItem.serviceName} status changed to ${status}`,
      userId || null,
      userName,
      { previousStatus: serviceItem.status },
      { newStatus: status }
    );
    const allServices = await db.select().from(jobCardServices).where(and25(
      eq25(jobCardServices.jobCardId, jobCardId),
      sql22`${jobCardServices.status} != 'cancelled'`
    ));
    const allCompleted = allServices.every((s) => s.status === "completed");
    const anyInProgress = allServices.some((s) => s.status === "in_progress");
    let jobCardStatus = JOB_CARD_STATUSES.OPEN;
    if (anyInProgress) {
      jobCardStatus = JOB_CARD_STATUSES.IN_SERVICE;
    } else if (allCompleted && allServices.length > 0) {
      jobCardStatus = JOB_CARD_STATUSES.PENDING_CHECKOUT;
    }
    const jobCard = await db.query.jobCards.findFirst({
      where: eq25(jobCards.id, jobCardId)
    });
    if (jobCard && jobCard.status !== jobCardStatus) {
      const updateJobCardData = { status: jobCardStatus, updatedAt: /* @__PURE__ */ new Date() };
      if (status === "in_progress" && !jobCard.serviceStartAt) {
        updateJobCardData.serviceStartAt = /* @__PURE__ */ new Date();
      } else if (allCompleted && !jobCard.serviceEndAt) {
        updateJobCardData.serviceEndAt = /* @__PURE__ */ new Date();
        if (jobCard.serviceStartAt) {
          const durationMs = (/* @__PURE__ */ new Date()).getTime() - new Date(jobCard.serviceStartAt).getTime();
          updateJobCardData.actualDurationMinutes = Math.round(durationMs / 6e4);
        }
      }
      await db.update(jobCards).set(updateJobCardData).where(eq25(jobCards.id, jobCardId));
    }
    res.json(updated);
  } catch (error) {
    console.error("Error updating service status:", error);
    res.status(500).json({ error: "Failed to update service status" });
  }
});
router15.post("/:salonId/job-cards/:jobCardId/products", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId, jobCardId } = req.params;
    const userId = req.user?.id;
    const userName = await getUserDisplayName(req.user?.id);
    const parsed = addJobCardProductSchema.safeParse(req.body);
    if (!parsed.success) {
      return res.status(400).json({ error: "Invalid request body", details: parsed.error.errors });
    }
    const { productId, staffId, quantity, discountPaisa, notes } = parsed.data;
    const jobCard = await db.query.jobCards.findFirst({
      where: and25(
        eq25(jobCards.id, jobCardId),
        eq25(jobCards.salonId, salonId)
      )
    });
    if (!jobCard) {
      return res.status(404).json({ error: "Job card not found" });
    }
    if (jobCard.status === JOB_CARD_STATUSES.COMPLETED || jobCard.status === JOB_CARD_STATUSES.CANCELLED) {
      return res.status(400).json({ error: "Cannot add products to a closed or cancelled job card" });
    }
    const product = await db.query.products.findFirst({
      where: and25(
        eq25(products.id, productId),
        eq25(products.salonId, salonId)
      )
    });
    if (!product) {
      return res.status(404).json({ error: "Product not found" });
    }
    if (product.trackStock && product.currentStock !== null && Number(product.currentStock) < quantity) {
      return res.status(400).json({
        error: "Insufficient stock",
        availableStock: product.currentStock,
        requestedQuantity: quantity
      });
    }
    const unitPricePaisa = product.retailPriceInPaisa || product.costPriceInPaisa || 0;
    const totalBeforeDiscount = unitPricePaisa * quantity;
    const totalPricePaisa = totalBeforeDiscount - (discountPaisa || 0);
    const taxRatePercent = 18;
    const taxAmountPaisa = Math.round(totalPricePaisa * (taxRatePercent / 100));
    const [newProduct] = await db.insert(jobCardProducts).values({
      jobCardId,
      salonId,
      productId,
      staffId: staffId || jobCard.assignedStaffId || null,
      productName: product.name,
      productSku: product.sku || null,
      productCategory: product.categoryId || null,
      quantity,
      unitPricePaisa,
      discountPaisa: discountPaisa || 0,
      totalPricePaisa,
      taxRatePercent: String(taxRatePercent),
      taxAmountPaisa,
      notes: notes || null
    }).returning();
    await recalculateJobCardTotals(jobCardId);
    await logJobCardActivity(
      jobCardId,
      salonId,
      "product_added",
      `Added product: ${product.name} (qty: ${quantity})`,
      userId || null,
      userName,
      null,
      { productId, productName: product.name, quantity, totalPricePaisa }
    );
    res.status(201).json(newProduct);
  } catch (error) {
    console.error("Error adding product to job card:", error);
    res.status(500).json({ error: "Failed to add product" });
  }
});
router15.delete("/:salonId/job-cards/:jobCardId/products/:productItemId", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId, jobCardId, productItemId } = req.params;
    const userId = req.user?.id;
    const userName = await getUserDisplayName(req.user?.id);
    const jobCard = await db.query.jobCards.findFirst({
      where: and25(
        eq25(jobCards.id, jobCardId),
        eq25(jobCards.salonId, salonId)
      )
    });
    if (!jobCard) {
      return res.status(404).json({ error: "Job card not found" });
    }
    if (jobCard.paymentStatus === JOB_CARD_PAYMENT_STATUSES.PAID) {
      return res.status(400).json({ error: "Cannot remove products after payment is completed" });
    }
    const productItem = await db.query.jobCardProducts.findFirst({
      where: and25(
        eq25(jobCardProducts.id, productItemId),
        eq25(jobCardProducts.jobCardId, jobCardId)
      )
    });
    if (!productItem) {
      return res.status(404).json({ error: "Product not found on this job card" });
    }
    await db.delete(jobCardProducts).where(eq25(jobCardProducts.id, productItemId));
    await recalculateJobCardTotals(jobCardId);
    await logJobCardActivity(
      jobCardId,
      salonId,
      "product_removed",
      `Removed product: ${productItem.productName}`,
      userId || null,
      userName,
      { productId: productItem.productId, productName: productItem.productName },
      null
    );
    res.json({ success: true, message: "Product removed from job card" });
  } catch (error) {
    console.error("Error removing product from job card:", error);
    res.status(500).json({ error: "Failed to remove product" });
  }
});
router15.post("/:salonId/job-cards/:jobCardId/discount", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId, jobCardId } = req.params;
    const userId = req.user?.id;
    const userName = await getUserDisplayName(req.user?.id);
    const parsed = applyJobCardDiscountSchema.safeParse(req.body);
    if (!parsed.success) {
      return res.status(400).json({ error: "Invalid request body", details: parsed.error.errors });
    }
    const { discountType, discountValue, discountReason } = parsed.data;
    const jobCard = await db.query.jobCards.findFirst({
      where: and25(
        eq25(jobCards.id, jobCardId),
        eq25(jobCards.salonId, salonId)
      )
    });
    if (!jobCard) {
      return res.status(404).json({ error: "Job card not found" });
    }
    if (jobCard.paymentStatus === JOB_CARD_PAYMENT_STATUSES.PAID) {
      return res.status(400).json({ error: "Cannot apply discount after payment is completed" });
    }
    await db.update(jobCards).set({
      discountType,
      discountValue: String(discountValue),
      discountReason: discountReason || null,
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq25(jobCards.id, jobCardId));
    const updated = await recalculateJobCardTotals(jobCardId);
    await logJobCardActivity(
      jobCardId,
      salonId,
      "discount_applied",
      `Applied ${discountType} discount of ${discountValue}${discountType === "percentage" ? "%" : " paisa"}`,
      userId || null,
      userName,
      { previousDiscount: jobCard.discountAmountPaisa },
      { discountType, discountValue, discountReason }
    );
    res.json(updated);
  } catch (error) {
    console.error("Error applying discount:", error);
    res.status(500).json({ error: "Failed to apply discount" });
  }
});
router15.post("/:salonId/job-cards/:jobCardId/payments", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId, jobCardId } = req.params;
    const userId = req.user?.id;
    const userName = await getUserDisplayName(req.user?.id);
    const parsed = processJobCardPaymentSchema.safeParse(req.body);
    if (!parsed.success) {
      return res.status(400).json({ error: "Invalid request body", details: parsed.error.errors });
    }
    const { paymentMethod, amountPaisa, transactionId, cardLast4, cardNetwork, upiId, notes } = parsed.data;
    const jobCard = await db.query.jobCards.findFirst({
      where: and25(
        eq25(jobCards.id, jobCardId),
        eq25(jobCards.salonId, salonId)
      )
    });
    if (!jobCard) {
      return res.status(404).json({ error: "Job card not found" });
    }
    if (jobCard.status === JOB_CARD_STATUSES.COMPLETED) {
      return res.status(400).json({ error: "Job card is already completed" });
    }
    if (jobCard.paymentStatus === JOB_CARD_PAYMENT_STATUSES.PAID) {
      return res.status(400).json({ error: "Job card is already fully paid" });
    }
    const lockKey = `payment:${jobCardId}`;
    try {
      await db.execute(sql22`SELECT pg_advisory_lock(hashtext(${lockKey}))`);
      const freshTotals = await db.execute(sql22`
        SELECT 
          jc.total_amount_paisa,
          COALESCE((
            SELECT SUM(amount_paisa) FROM job_card_payments 
            WHERE job_card_id = ${jobCardId} 
              AND status = 'completed' 
              AND is_refund = 0
          ), 0) as total_paid
        FROM job_cards jc
        WHERE jc.id = ${jobCardId}
      `);
      const totals = freshTotals.rows[0];
      const totalAmount = Number(totals?.total_amount_paisa || 0);
      const totalPaid = Number(totals?.total_paid || 0);
      const freshBalance = totalAmount - totalPaid;
      if (amountPaisa > freshBalance) {
        await db.execute(sql22`SELECT pg_advisory_unlock(hashtext(${lockKey}))`);
        return res.status(400).json({
          error: "Payment amount exceeds balance",
          balancePaisa: freshBalance,
          requestedAmountPaisa: amountPaisa
        });
      }
      const [newPayment] = await db.insert(jobCardPayments).values({
        jobCardId,
        salonId,
        paymentMethod,
        amountPaisa,
        status: "completed",
        transactionId: transactionId || null,
        cardLast4: cardLast4 || null,
        cardNetwork: cardNetwork || null,
        upiId: upiId || null,
        notes: notes || null,
        collectedBy: userId || null,
        completedAt: /* @__PURE__ */ new Date()
      }).returning();
      await db.execute(sql22`SELECT pg_advisory_unlock(hashtext(${lockKey}))`);
      const updated = await recalculateJobCardTotals(jobCardId);
      await logJobCardActivity(
        jobCardId,
        salonId,
        "payment_received",
        `Payment received: ${paymentMethod} - ${amountPaisa / 100} INR`,
        userId || null,
        userName,
        null,
        { paymentMethod, amountPaisa, transactionId }
      );
      res.status(201).json({
        payment: newPayment,
        jobCard: updated
      });
    } catch (lockError) {
      await db.execute(sql22`SELECT pg_advisory_unlock(hashtext(${lockKey}))`);
      throw lockError;
    }
  } catch (error) {
    console.error("Error processing payment:", error);
    res.status(500).json({ error: "Failed to process payment" });
  }
});
router15.post("/:salonId/job-cards/:jobCardId/tips", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId, jobCardId } = req.params;
    const userId = req.user?.id;
    const userName = await getUserDisplayName(req.user?.id);
    const parsed = addJobCardTipSchema.safeParse(req.body);
    if (!parsed.success) {
      return res.status(400).json({ error: "Invalid request body", details: parsed.error.errors });
    }
    const { staffId, amountPaisa, paymentMethod, notes } = parsed.data;
    const jobCard = await db.query.jobCards.findFirst({
      where: and25(
        eq25(jobCards.id, jobCardId),
        eq25(jobCards.salonId, salonId)
      )
    });
    if (!jobCard) {
      return res.status(404).json({ error: "Job card not found" });
    }
    const staffMember = await db.query.staff.findFirst({
      where: and25(
        eq25(staff.id, staffId),
        eq25(staff.salonId, salonId)
      )
    });
    if (!staffMember) {
      return res.status(404).json({ error: "Staff member not found" });
    }
    const [newTip] = await db.insert(jobCardTips).values({
      jobCardId,
      salonId,
      staffId,
      amountPaisa,
      paymentMethod: paymentMethod || "cash",
      notes: notes || null
    }).returning();
    const allTips = await db.select({ total: sql22`SUM(${jobCardTips.amountPaisa})` }).from(jobCardTips).where(eq25(jobCardTips.jobCardId, jobCardId));
    const totalTipsPaisa = allTips[0]?.total || 0;
    await db.update(jobCards).set({
      tipAmountPaisa: totalTipsPaisa,
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq25(jobCards.id, jobCardId));
    await recalculateJobCardTotals(jobCardId);
    await logJobCardActivity(
      jobCardId,
      salonId,
      "tip_added",
      `Tip added for ${staffMember.name}: ${amountPaisa / 100} INR`,
      userId || null,
      userName,
      null,
      { staffId, staffName: staffMember.name, amountPaisa, paymentMethod }
    );
    res.status(201).json(newTip);
  } catch (error) {
    console.error("Error adding tip:", error);
    res.status(500).json({ error: "Failed to add tip" });
  }
});
router15.patch("/:salonId/job-cards/:jobCardId/status", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId, jobCardId } = req.params;
    const userId = req.user?.id;
    const userName = await getUserDisplayName(req.user?.id);
    const parsed = updateJobCardStatusSchema.safeParse(req.body);
    if (!parsed.success) {
      return res.status(400).json({ error: "Invalid request body", details: parsed.error.errors });
    }
    const { status, notes } = parsed.data;
    const jobCard = await db.query.jobCards.findFirst({
      where: and25(
        eq25(jobCards.id, jobCardId),
        eq25(jobCards.salonId, salonId)
      )
    });
    if (!jobCard) {
      return res.status(404).json({ error: "Job card not found" });
    }
    const previousStatus = jobCard.status;
    const transitionValidation = validateJobCardStatusTransition(previousStatus, status);
    if (!transitionValidation.valid) {
      return res.status(400).json({ error: transitionValidation.error });
    }
    const updateData = {
      status,
      updatedAt: /* @__PURE__ */ new Date()
    };
    if (status === JOB_CARD_STATUSES.IN_SERVICE && !jobCard.serviceStartAt) {
      updateData.serviceStartAt = /* @__PURE__ */ new Date();
    }
    if (status === JOB_CARD_STATUSES.PENDING_CHECKOUT && !jobCard.serviceEndAt) {
      updateData.serviceEndAt = /* @__PURE__ */ new Date();
      if (jobCard.serviceStartAt) {
        const durationMs = (/* @__PURE__ */ new Date()).getTime() - new Date(jobCard.serviceStartAt).getTime();
        updateData.actualDurationMinutes = Math.round(durationMs / 6e4);
      }
    }
    if (notes) {
      updateData.internalNotes = jobCard.internalNotes ? `${jobCard.internalNotes}

[${(/* @__PURE__ */ new Date()).toISOString()}] ${notes}` : `[${(/* @__PURE__ */ new Date()).toISOString()}] ${notes}`;
    }
    const [updated] = await db.update(jobCards).set(updateData).where(eq25(jobCards.id, jobCardId)).returning();
    await logJobCardActivity(
      jobCardId,
      salonId,
      "status_changed",
      `Job card status changed from ${previousStatus} to ${status}`,
      userId || null,
      userName,
      { previousStatus },
      { newStatus: status, notes }
    );
    res.json(updated);
  } catch (error) {
    console.error("Error updating job card status:", error);
    res.status(500).json({ error: "Failed to update status" });
  }
});
router15.post("/:salonId/job-cards/:jobCardId/cancel", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId, jobCardId } = req.params;
    const { reason } = req.body;
    const userId = req.user?.id;
    const userName = await getUserDisplayName(req.user?.id);
    const jobCard = await db.query.jobCards.findFirst({
      where: and25(
        eq25(jobCards.id, jobCardId),
        eq25(jobCards.salonId, salonId)
      )
    });
    if (!jobCard) {
      return res.status(404).json({ error: "Job card not found" });
    }
    if (jobCard.status === JOB_CARD_STATUSES.COMPLETED) {
      return res.status(400).json({ error: "Cannot cancel a completed job card" });
    }
    if (jobCard.status === JOB_CARD_STATUSES.CANCELLED) {
      return res.status(400).json({ error: "Job card is already cancelled" });
    }
    const cardPayments = await db.select().from(jobCardPayments).where(and25(
      eq25(jobCardPayments.jobCardId, jobCardId),
      eq25(jobCardPayments.status, "completed"),
      eq25(jobCardPayments.isRefund, 0)
    ));
    const paidAmountPaisa = cardPayments.reduce((sum4, p) => sum4 + p.amountPaisa, 0);
    if (paidAmountPaisa > 0) {
      return res.status(400).json({
        error: "Cannot cancel job card with payments. Process refund first.",
        paidAmountPaisa
      });
    }
    const cardTips = await db.select().from(jobCardTips).where(eq25(jobCardTips.jobCardId, jobCardId));
    if (cardTips.length > 0) {
      return res.status(400).json({
        error: "Cannot cancel job card with tips recorded. Remove tips first.",
        tipCount: cardTips.length
      });
    }
    const completedServices = await db.select().from(jobCardServices).where(and25(
      eq25(jobCardServices.jobCardId, jobCardId),
      eq25(jobCardServices.status, "completed")
    ));
    if (completedServices.length > 0) {
      return res.status(400).json({
        error: "Cannot cancel job card with completed services.",
        completedServiceCount: completedServices.length
      });
    }
    const previousStatus = jobCard.status;
    const cardProducts = await db.select().from(jobCardProducts).where(eq25(jobCardProducts.jobCardId, jobCardId));
    for (const cardProduct of cardProducts) {
      const product = await db.query.products.findFirst({
        where: eq25(products.id, cardProduct.productId)
      });
      if (product && product.trackStock) {
        const previousStock = Number(product.currentStock) || 0;
        const newStock = previousStock + cardProduct.quantity;
        await db.execute(sql22`UPDATE products SET current_stock = ${newStock} WHERE id = ${cardProduct.productId}`);
        await logJobCardActivity(
          jobCardId,
          salonId,
          "stock_restored",
          `Restored ${cardProduct.quantity} units of ${cardProduct.productName} to inventory`,
          userId || null,
          userName,
          { previousStock },
          { newStock }
        );
      }
    }
    await db.delete(jobCardProducts).where(eq25(jobCardProducts.jobCardId, jobCardId));
    await db.update(jobCardServices).set({ status: "cancelled" }).where(eq25(jobCardServices.jobCardId, jobCardId));
    const [updated] = await db.update(jobCards).set({
      status: JOB_CARD_STATUSES.CANCELLED,
      cancellationReason: reason || "No reason provided",
      cancelledAt: /* @__PURE__ */ new Date(),
      cancelledBy: userId || null,
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq25(jobCards.id, jobCardId)).returning();
    if (jobCard.bookingId) {
      await db.update(bookings).set({ status: "cancelled" }).where(eq25(bookings.id, jobCard.bookingId));
    }
    await logJobCardActivity(
      jobCardId,
      salonId,
      "cancelled",
      `Job card cancelled: ${reason || "No reason provided"}`,
      userId || null,
      userName,
      { previousStatus },
      { newStatus: JOB_CARD_STATUSES.CANCELLED, reason }
    );
    res.json({
      success: true,
      message: "Job card cancelled successfully",
      jobCard: updated
    });
  } catch (error) {
    console.error("Error cancelling job card:", error);
    res.status(500).json({ error: "Failed to cancel job card" });
  }
});
router15.post("/:salonId/job-cards/:jobCardId/complete", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId, jobCardId } = req.params;
    const userId = req.user?.id;
    const userName = await getUserDisplayName(req.user?.id);
    const jobCard = await db.query.jobCards.findFirst({
      where: and25(
        eq25(jobCards.id, jobCardId),
        eq25(jobCards.salonId, salonId)
      )
    });
    if (!jobCard) {
      return res.status(404).json({ error: "Job card not found" });
    }
    if (jobCard.status === JOB_CARD_STATUSES.COMPLETED) {
      return res.status(400).json({ error: "Job card is already completed" });
    }
    const cardPayments = await db.select().from(jobCardPayments).where(and25(
      eq25(jobCardPayments.jobCardId, jobCardId),
      eq25(jobCardPayments.status, "completed"),
      eq25(jobCardPayments.isRefund, 0)
    ));
    const actualPaidAmountPaisa = cardPayments.reduce((sum4, p) => sum4 + p.amountPaisa, 0);
    const totalAmountPaisa = jobCard.totalAmountPaisa || 0;
    if (actualPaidAmountPaisa < totalAmountPaisa) {
      return res.status(400).json({
        error: "Cannot complete job card with outstanding balance",
        totalAmountPaisa,
        paidAmountPaisa: actualPaidAmountPaisa,
        balancePaisa: totalAmountPaisa - actualPaidAmountPaisa
      });
    }
    const today = /* @__PURE__ */ new Date();
    const dateStr = today.toISOString().slice(0, 10).replace(/-/g, "");
    const receiptNumber = `REC-${dateStr}-${jobCard.jobCardNumber.split("-").pop()}`;
    const commissionsCalculated = [];
    const inventoryUpdates = [];
    let feedbackSent = false;
    let updatedJobCard = null;
    try {
      await db.transaction(async (tx) => {
        const [updated] = await tx.update(jobCards).set({
          status: JOB_CARD_STATUSES.COMPLETED,
          checkoutAt: /* @__PURE__ */ new Date(),
          checkoutBy: userId || null,
          receiptNumber,
          serviceEndAt: jobCard.serviceEndAt || /* @__PURE__ */ new Date(),
          paidAmountPaisa: actualPaidAmountPaisa,
          balancePaisa: 0,
          paymentStatus: JOB_CARD_PAYMENT_STATUSES.PAID,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq25(jobCards.id, jobCardId)).returning();
        if (!updated) {
          throw new Error("Failed to update job card status");
        }
        updatedJobCard = updated;
        if (jobCard.bookingId) {
          await tx.update(bookings).set({ status: "completed" }).where(eq25(bookings.id, jobCard.bookingId));
        }
        await tx.update(jobCardServices).set({
          status: "completed"
        }).where(and25(
          eq25(jobCardServices.jobCardId, jobCardId),
          sql22`${jobCardServices.status} IN ('pending', 'in_progress')`
        ));
        const cardServices = await tx.select().from(jobCardServices).where(and25(
          eq25(jobCardServices.jobCardId, jobCardId),
          eq25(jobCardServices.commissionCalculated, 0),
          sql22`${jobCardServices.status} = 'completed'`
        ));
        for (const service of cardServices) {
          if (service.staffId) {
            const [specificRate] = await tx.select().from(commissionRates).where(and25(
              eq25(commissionRates.salonId, salonId),
              eq25(commissionRates.staffId, service.staffId),
              eq25(commissionRates.serviceId, service.serviceId),
              eq25(commissionRates.isActive, 1)
            )).limit(1);
            let commissionRateRecord = specificRate;
            if (!commissionRateRecord) {
              const [staffDefaultRate] = await tx.select().from(commissionRates).where(and25(
                eq25(commissionRates.salonId, salonId),
                eq25(commissionRates.staffId, service.staffId),
                sql22`${commissionRates.serviceId} IS NULL`,
                eq25(commissionRates.isActive, 1)
              )).limit(1);
              commissionRateRecord = staffDefaultRate;
            }
            if (!commissionRateRecord) {
              const [salonDefaultRate] = await tx.select().from(commissionRates).where(and25(
                eq25(commissionRates.salonId, salonId),
                eq25(commissionRates.isDefault, 1),
                eq25(commissionRates.isActive, 1)
              )).limit(1);
              commissionRateRecord = salonDefaultRate;
            }
            let ratePercent = 10;
            let rateId = null;
            if (commissionRateRecord) {
              ratePercent = Number(commissionRateRecord.rateValue);
              rateId = commissionRateRecord.id;
            }
            let commissionAmount = 0;
            if (commissionRateRecord?.rateType === "fixed_amount") {
              commissionAmount = Math.round(Number(commissionRateRecord.rateValue) * 100);
            } else {
              commissionAmount = Math.round(service.finalPricePaisa * (ratePercent / 100));
            }
            if (commissionRateRecord?.minAmount && commissionAmount < commissionRateRecord.minAmount) {
              commissionAmount = commissionRateRecord.minAmount;
            }
            if (commissionRateRecord?.maxAmount && commissionAmount > commissionRateRecord.maxAmount) {
              commissionAmount = commissionRateRecord.maxAmount;
            }
            const serviceDate = /* @__PURE__ */ new Date();
            const [newCommission] = await tx.insert(commissions).values({
              salonId,
              staffId: service.staffId,
              serviceId: service.serviceId,
              bookingId: jobCard.bookingId || null,
              rateId,
              baseAmountPaisa: service.finalPricePaisa,
              commissionAmountPaisa: commissionAmount,
              commissionRate: String(ratePercent),
              serviceDate,
              periodYear: serviceDate.getFullYear(),
              periodMonth: serviceDate.getMonth() + 1,
              paymentStatus: "pending"
            }).returning();
            await tx.update(jobCardServices).set({
              commissionCalculated: 1,
              commissionId: newCommission.id
            }).where(eq25(jobCardServices.id, service.id));
            commissionsCalculated.push(newCommission.id);
          }
        }
        const cardProductsForCommission = await tx.select().from(jobCardProducts).where(and25(
          eq25(jobCardProducts.jobCardId, jobCardId),
          sql22`${jobCardProducts.commissionCalculated} = 0 OR ${jobCardProducts.commissionCalculated} IS NULL`
        ));
        for (const productItem of cardProductsForCommission) {
          if (productItem.staffId) {
            const [specificProductRate] = await tx.select().from(commissionRates).where(and25(
              eq25(commissionRates.salonId, salonId),
              eq25(commissionRates.staffId, productItem.staffId),
              eq25(commissionRates.productId, productItem.productId),
              eq25(commissionRates.appliesTo, "product"),
              eq25(commissionRates.isActive, 1)
            )).limit(1);
            let productCommissionRateRecord = specificProductRate;
            if (!productCommissionRateRecord) {
              const [staffDefaultProductRate] = await tx.select().from(commissionRates).where(and25(
                eq25(commissionRates.salonId, salonId),
                eq25(commissionRates.staffId, productItem.staffId),
                sql22`${commissionRates.productId} IS NULL`,
                eq25(commissionRates.appliesTo, "product"),
                eq25(commissionRates.isActive, 1)
              )).limit(1);
              productCommissionRateRecord = staffDefaultProductRate;
            }
            if (!productCommissionRateRecord) {
              const [salonDefaultProductRate] = await tx.select().from(commissionRates).where(and25(
                eq25(commissionRates.salonId, salonId),
                sql22`${commissionRates.staffId} IS NULL`,
                sql22`${commissionRates.productId} IS NULL`,
                eq25(commissionRates.appliesTo, "product"),
                eq25(commissionRates.isActive, 1)
              )).limit(1);
              productCommissionRateRecord = salonDefaultProductRate;
            }
            if (productCommissionRateRecord) {
              const productRatePercent = Number(productCommissionRateRecord.rateValue);
              const productRateId = productCommissionRateRecord.id;
              let productCommissionAmount = 0;
              const productSaleAmount = productItem.finalPricePaisa || productItem.totalPricePaisa || productItem.unitPricePaisa * productItem.quantity;
              if (productCommissionRateRecord.rateType === "fixed_amount") {
                productCommissionAmount = Math.round(Number(productCommissionRateRecord.rateValue) * 100) * productItem.quantity;
              } else {
                productCommissionAmount = Math.round(productSaleAmount * (productRatePercent / 100));
              }
              if (productCommissionRateRecord.minAmount && productCommissionAmount < productCommissionRateRecord.minAmount) {
                productCommissionAmount = productCommissionRateRecord.minAmount;
              }
              if (productCommissionRateRecord.maxAmount && productCommissionAmount > productCommissionRateRecord.maxAmount) {
                productCommissionAmount = productCommissionRateRecord.maxAmount;
              }
              const productCommissionDate = /* @__PURE__ */ new Date();
              const [newProductCommission] = await tx.insert(commissions).values({
                salonId,
                staffId: productItem.staffId,
                productId: productItem.productId,
                bookingId: jobCard.bookingId || null,
                jobCardId,
                rateId: productRateId,
                sourceType: "product",
                baseAmountPaisa: productSaleAmount,
                commissionAmountPaisa: productCommissionAmount,
                commissionRate: String(productRatePercent),
                serviceDate: productCommissionDate,
                periodYear: productCommissionDate.getFullYear(),
                periodMonth: productCommissionDate.getMonth() + 1,
                paymentStatus: "pending"
              }).returning();
              await tx.update(jobCardProducts).set({
                commissionCalculated: 1,
                commissionId: newProductCommission.id
              }).where(eq25(jobCardProducts.id, productItem.id));
              commissionsCalculated.push(newProductCommission.id);
            }
          }
        }
        const cardProducts = await tx.select().from(jobCardProducts).where(eq25(jobCardProducts.jobCardId, jobCardId));
        for (const productItem of cardProducts) {
          const [product] = await tx.select().from(products).where(and25(
            eq25(products.id, productItem.productId),
            eq25(products.salonId, salonId)
          )).limit(1);
          if (product && product.trackStock === 1) {
            const currentStock = Number(product.currentStock) || 0;
            const quantityUsed = productItem.quantity || 1;
            const newStock = Math.max(0, currentStock - quantityUsed);
            await tx.update(products).set({
              currentStock: String(newStock),
              updatedAt: /* @__PURE__ */ new Date()
            }).where(eq25(products.id, productItem.productId));
            inventoryUpdates.push({
              productId: productItem.productId,
              quantity: quantityUsed,
              productName: productItem.productName
            });
          }
        }
        await tx.insert(jobCardActivityLog).values({
          jobCardId,
          salonId,
          activityType: "completed",
          description: `Job card completed. Receipt: ${receiptNumber}${commissionsCalculated.length > 0 ? `. Commissions calculated: ${commissionsCalculated.length}` : ""}${inventoryUpdates.length > 0 ? `. Inventory updated: ${inventoryUpdates.length} products` : ""}`,
          previousValue: null,
          newValue: {
            receiptNumber,
            totalAmountPaisa: jobCard.totalAmountPaisa,
            paidAmountPaisa: actualPaidAmountPaisa,
            commissionsCalculated: commissionsCalculated.length,
            inventoryUpdates: inventoryUpdates.length
          },
          performedBy: userId || null,
          performedByName: userName
        });
      });
      if (jobCard.customerEmail || jobCard.customerPhone) {
        try {
          const salon = await db.query.salons.findFirst({
            where: eq25(salons.id, salonId)
          });
          const feedbackLink = `${process.env.REPL_SLUG ? `https://${process.env.REPL_SLUG}.${process.env.REPL_OWNER}.repl.co` : "http://localhost:5000"}/feedback/${jobCardId}`;
          await logJobCardActivity(
            jobCardId,
            salonId,
            "feedback_requested",
            `Feedback request queued for customer${jobCard.customerEmail ? ` (${jobCard.customerEmail})` : ""}`,
            userId || null,
            userName,
            null,
            {
              customerEmail: jobCard.customerEmail,
              customerPhone: jobCard.customerPhone,
              feedbackLink
            }
          );
          if (jobCard.customerEmail && process.env.SENDGRID_API_KEY) {
            const { sendEmail: sendEmail2 } = await Promise.resolve().then(() => (init_emailService(), emailService_exports));
            const fromEmail = process.env.SENDGRID_FROM_EMAIL || "noreply@salonhub.com";
            const feedbackHtml = `
              <!DOCTYPE html>
              <html>
              <head>
                <meta charset="utf-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <title>How was your visit?</title>
              </head>
              <body style="margin: 0; padding: 0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background-color: #f7f7f7;">
                <table width="100%" cellpadding="0" cellspacing="0" style="background-color: #f7f7f7; padding: 40px 20px;">
                  <tr>
                    <td align="center">
                      <table width="600" cellpadding="0" cellspacing="0" style="background-color: #ffffff; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.08); overflow: hidden;">
                        <tr>
                          <td style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 40px; text-align: center;">
                            <h1 style="margin: 0; color: #ffffff; font-size: 28px; font-weight: 600;">${salon?.name || "SalonHub"}</h1>
                          </td>
                        </tr>
                        <tr>
                          <td style="padding: 40px;">
                            <h2 style="margin: 0 0 20px; color: #1a1a1a; font-size: 24px; font-weight: 600;">How was your visit?</h2>
                            <p style="margin: 0 0 16px; color: #4a4a4a; font-size: 16px; line-height: 1.6;">
                              Hi ${jobCard.customerName},
                            </p>
                            <p style="margin: 0 0 24px; color: #4a4a4a; font-size: 16px; line-height: 1.6;">
                              Thank you for visiting us today! We'd love to hear about your experience. Your feedback helps us improve our services.
                            </p>
                            <table cellpadding="0" cellspacing="0" style="margin: 30px 0;">
                              <tr>
                                <td align="center" bgcolor="#667eea" style="background-color: #667eea; border-radius: 8px;">
                                  <a href="${feedbackLink}" style="display: block; padding: 16px 48px; color: #ffffff; text-decoration: none; font-size: 16px; font-weight: 600; border-radius: 8px;">
                                    Share Your Feedback
                                  </a>
                                </td>
                              </tr>
                            </table>
                            <p style="margin: 20px 0 0; color: #666666; font-size: 14px;">
                              Receipt: ${receiptNumber}
                            </p>
                          </td>
                        </tr>
                        <tr>
                          <td style="background-color: #f9f9f9; padding: 24px 40px; text-align: center; border-top: 1px solid #e0e0e0;">
                            <p style="margin: 0; color: #888888; font-size: 12px;">
                              Thank you for choosing ${salon?.name || "us"}!
                            </p>
                          </td>
                        </tr>
                      </table>
                    </td>
                  </tr>
                </table>
              </body>
              </html>
            `;
            try {
              await sendEmail2({
                to: jobCard.customerEmail,
                from: fromEmail,
                subject: `How was your visit to ${salon?.name || "our salon"}?`,
                html: feedbackHtml,
                text: `Hi ${jobCard.customerName}, Thank you for visiting ${salon?.name || "us"} today! We'd love to hear about your experience. Please share your feedback at: ${feedbackLink}. Receipt: ${receiptNumber}`
              });
              feedbackSent = true;
            } catch (emailError) {
              console.error("Failed to send feedback email (will retry later):", emailError);
              await logJobCardActivity(
                jobCardId,
                salonId,
                "feedback_email_failed",
                `Failed to send feedback email to ${jobCard.customerEmail}. Manual follow-up may be required.`,
                userId || null,
                userName,
                null,
                { error: String(emailError) }
              );
            }
          }
        } catch (feedbackError) {
          console.error("Error in feedback notification flow:", feedbackError);
        }
      }
      res.json({
        ...updatedJobCard || {},
        message: "Job card completed successfully",
        receiptNumber,
        commissionsCalculated: commissionsCalculated.length,
        inventoryUpdates,
        feedbackSent
      });
    } catch (dbError) {
      console.error("Error in job card completion transaction:", dbError);
      throw dbError;
    }
  } catch (error) {
    console.error("Error completing job card:", error);
    res.status(500).json({ error: "Failed to complete job card" });
  }
});
router15.get("/:salonId/job-cards/:jobCardId/bill", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId, jobCardId } = req.params;
    const jobCard = await db.query.jobCards.findFirst({
      where: and25(
        eq25(jobCards.id, jobCardId),
        eq25(jobCards.salonId, salonId)
      )
    });
    if (!jobCard) {
      return res.status(404).json({ error: "Job card not found" });
    }
    const cardServices = await db.select().from(jobCardServices).where(and25(
      eq25(jobCardServices.jobCardId, jobCardId),
      sql22`${jobCardServices.status} != 'cancelled'`
    ));
    const cardProducts = await db.select().from(jobCardProducts).where(eq25(jobCardProducts.jobCardId, jobCardId));
    const cardPayments = await db.select().from(jobCardPayments).where(and25(
      eq25(jobCardPayments.jobCardId, jobCardId),
      eq25(jobCardPayments.status, "completed")
    ));
    const cardTips = await db.select().from(jobCardTips).where(eq25(jobCardTips.jobCardId, jobCardId));
    const servicesTotalPaisa = cardServices.reduce((sum4, s) => sum4 + s.finalPricePaisa, 0);
    const productsTotalPaisa = cardProducts.reduce((sum4, p) => sum4 + p.totalPricePaisa, 0);
    res.json({
      jobCardNumber: jobCard.jobCardNumber,
      customerName: jobCard.customerName,
      checkInAt: jobCard.checkInAt,
      status: jobCard.status,
      services: cardServices.map((s) => ({
        id: s.id,
        name: s.serviceName,
        category: s.serviceCategory,
        originalPricePaisa: s.originalPricePaisa,
        discountPaisa: s.discountPaisa,
        finalPricePaisa: s.finalPricePaisa,
        status: s.status
      })),
      servicesTotal: servicesTotalPaisa,
      products: cardProducts.map((p) => ({
        id: p.id,
        name: p.productName,
        quantity: p.quantity,
        unitPricePaisa: p.unitPricePaisa,
        discountPaisa: p.discountPaisa,
        totalPricePaisa: p.totalPricePaisa,
        taxAmountPaisa: p.taxAmountPaisa
      })),
      productsTotal: productsTotalPaisa,
      subtotalPaisa: jobCard.subtotalPaisa,
      discountType: jobCard.discountType,
      discountValue: jobCard.discountValue,
      discountAmountPaisa: jobCard.discountAmountPaisa,
      taxAmountPaisa: jobCard.taxAmountPaisa,
      tipAmountPaisa: jobCard.tipAmountPaisa,
      totalAmountPaisa: jobCard.totalAmountPaisa,
      payments: cardPayments.map((p) => ({
        id: p.id,
        method: p.paymentMethod,
        amountPaisa: p.amountPaisa,
        transactionId: p.transactionId,
        createdAt: p.createdAt
      })),
      paidAmountPaisa: jobCard.paidAmountPaisa,
      balancePaisa: jobCard.balancePaisa,
      paymentStatus: jobCard.paymentStatus,
      tips: cardTips.map((t) => ({
        id: t.id,
        staffId: t.staffId,
        amountPaisa: t.amountPaisa,
        paymentMethod: t.paymentMethod
      }))
    });
  } catch (error) {
    console.error("Error fetching job card bill:", error);
    res.status(500).json({ error: "Failed to fetch bill" });
  }
});
router15.get("/public/checkin/:salonId", publicCheckInLimiter, async (req, res) => {
  try {
    const { salonId } = req.params;
    const salon = await db.query.salons.findFirst({
      where: eq25(salons.id, salonId)
    });
    if (!salon) {
      return res.status(404).json({ error: "Salon not found" });
    }
    res.json({
      salonId: salon.id,
      salonName: salon.name,
      salonLogo: salon.imageUrl,
      salonAddress: salon.address
    });
  } catch (error) {
    console.error("Error fetching salon for check-in:", error);
    res.status(500).json({ error: "Failed to fetch salon info" });
  }
});
router15.post("/public/checkin/:salonId", publicCheckInLimiter, async (req, res) => {
  try {
    const { salonId } = req.params;
    const { phone, bookingId, customerName } = req.body;
    const salon = await db.query.salons.findFirst({
      where: eq25(salons.id, salonId)
    });
    if (!salon) {
      return res.status(404).json({ error: "Salon not found" });
    }
    let booking = null;
    if (bookingId) {
      booking = await db.query.bookings.findFirst({
        where: and25(
          eq25(bookings.id, bookingId),
          eq25(bookings.salonId, salonId),
          inArray10(bookings.status, ["confirmed", "pending"])
        )
      });
    } else if (phone) {
      const today = /* @__PURE__ */ new Date();
      const todayStr = today.toISOString().split("T")[0];
      booking = await db.query.bookings.findFirst({
        where: and25(
          eq25(bookings.salonId, salonId),
          eq25(bookings.customerPhone, phone),
          inArray10(bookings.status, ["confirmed", "pending"]),
          eq25(bookings.bookingDate, todayStr)
        ),
        orderBy: [desc17(bookings.bookingDate)]
      });
    }
    if (!booking && !customerName) {
      return res.status(404).json({
        error: "No booking found for today",
        requiresWalkIn: true
      });
    }
    const existingJobCard = booking ? await db.query.jobCards.findFirst({
      where: eq25(jobCards.bookingId, booking.id)
    }) : null;
    if (existingJobCard) {
      return res.status(400).json({
        error: "You are already checked in",
        jobCardId: existingJobCard.id,
        jobCardNumber: existingJobCard.jobCardNumber
      });
    }
    const newJobCard = await createJobCardWithNumber(salonId, async (jobCardNumber, tx) => {
      const [insertedJobCard] = await tx.insert(jobCards).values({
        salonId,
        bookingId: booking?.id || null,
        customerId: booking?.userId || null,
        jobCardNumber,
        customerName: booking?.customerName || customerName,
        customerEmail: booking?.customerEmail || null,
        customerPhone: booking?.customerPhone || phone || null,
        checkInMethod: CHECK_IN_METHODS.SELF_CHECKIN,
        checkInAt: /* @__PURE__ */ new Date(),
        status: JOB_CARD_STATUSES.OPEN,
        isWalkIn: booking ? 0 : 1
      }).returning();
      return insertedJobCard;
    });
    if (booking) {
      const bookingServicesData = await db.select({
        serviceId: bookingServices.serviceId,
        serviceName: services.name,
        serviceCategory: services.category,
        pricePaisa: services.priceInPaisa,
        durationMinutes: services.durationMinutes
      }).from(bookingServices).leftJoin(services, eq25(bookingServices.serviceId, services.id)).where(eq25(bookingServices.bookingId, booking.id));
      if (bookingServicesData.length > 0) {
        const jobCardServicesData = bookingServicesData.map((s, index2) => ({
          jobCardId: newJobCard.id,
          salonId,
          serviceId: s.serviceId,
          staffId: null,
          serviceName: s.serviceName || "Unknown Service",
          serviceCategory: s.serviceCategory || null,
          originalPricePaisa: s.pricePaisa || 0,
          discountPaisa: 0,
          finalPricePaisa: s.pricePaisa || 0,
          estimatedDurationMinutes: s.durationMinutes || 30,
          status: "pending",
          sequence: index2 + 1,
          source: "booking"
        }));
        await db.insert(jobCardServices).values(jobCardServicesData);
      }
      await db.update(bookings).set({ status: BOOKING_STATUSES.ARRIVED }).where(eq25(bookings.id, booking.id));
    }
    await recalculateJobCardTotals(newJobCard.id);
    await logJobCardActivity(
      newJobCard.id,
      salonId,
      "self_check_in",
      `Customer self-checked in via QR code`,
      null,
      booking?.customerName || customerName || "Guest",
      null,
      { checkInMethod: CHECK_IN_METHODS.SELF_CHECKIN, isWalkIn: !booking }
    );
    const customerId = booking?.userId || newJobCard.customerId;
    if (customerId) {
      const existingProfile = await db.query.clientProfiles.findFirst({
        where: and25(
          eq25(clientProfiles.salonId, salonId),
          eq25(clientProfiles.customerId, customerId)
        )
      });
      if (!existingProfile) {
        await db.insert(clientProfiles).values({
          salonId,
          customerId
        });
        console.log(`Created client profile for self-check-in customer: salonId=${salonId}, customerId=${customerId}`);
      }
    }
    res.status(201).json({
      success: true,
      message: "Check-in successful!",
      jobCardNumber: newJobCard.jobCardNumber,
      customerName: newJobCard.customerName,
      salonName: salon.name
    });
  } catch (error) {
    console.error("Error processing self check-in:", error);
    res.status(500).json({ error: "Failed to check in" });
  }
});
router15.get("/:salonId/today-stats", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId } = req.params;
    const today = /* @__PURE__ */ new Date();
    const startOfDay = new Date(today.getFullYear(), today.getMonth(), today.getDate(), 0, 0, 0);
    const endOfDay = new Date(today.getFullYear(), today.getMonth(), today.getDate(), 23, 59, 59);
    const todayJobCards = await db.select().from(jobCards).where(and25(
      eq25(jobCards.salonId, salonId),
      gte7(jobCards.checkInAt, startOfDay),
      lte7(jobCards.checkInAt, endOfDay)
    ));
    const stats = {
      total: todayJobCards.length,
      open: todayJobCards.filter((jc) => jc.status === JOB_CARD_STATUSES.OPEN).length,
      inService: todayJobCards.filter((jc) => jc.status === JOB_CARD_STATUSES.IN_SERVICE).length,
      pendingCheckout: todayJobCards.filter((jc) => jc.status === JOB_CARD_STATUSES.PENDING_CHECKOUT).length,
      completed: todayJobCards.filter((jc) => jc.status === JOB_CARD_STATUSES.COMPLETED).length,
      cancelled: todayJobCards.filter((jc) => jc.status === JOB_CARD_STATUSES.CANCELLED).length,
      noShow: todayJobCards.filter((jc) => jc.status === JOB_CARD_STATUSES.NO_SHOW).length,
      totalRevenuePaisa: todayJobCards.filter((jc) => jc.status === JOB_CARD_STATUSES.COMPLETED).reduce((sum4, jc) => sum4 + jc.paidAmountPaisa, 0),
      walkIns: todayJobCards.filter((jc) => jc.isWalkIn === 1).length
    };
    res.json(stats);
  } catch (error) {
    console.error("Error fetching today stats:", error);
    res.status(500).json({ error: "Failed to fetch stats" });
  }
});
function registerJobCardRoutes(app2) {
  app2.use("/api/salons", router15);
}

// server/routes/commission-payout.routes.ts
init_db();
init_schema();
import { Router as Router15 } from "express";
import { eq as eq26, and as and26, desc as desc18, sql as sql23, gte as gte8, lte as lte8 } from "drizzle-orm";
import { z as z11 } from "zod";
import ExcelJS2 from "exceljs";
import PDFDocument2 from "pdfkit";
var router16 = Router15();
router16.use(populateUserFromSession);
var formatCurrency = (paisa) => {
  return `\u20B9${(paisa / 100).toFixed(2)}`;
};
var getStaffSummary = async (salonId, staffId, periodStart, periodEnd) => {
  const commissionsResult = await db.select({
    totalCommissions: sql23`COALESCE(SUM(${commissions.commissionAmountPaisa}), 0)`,
    count: sql23`COUNT(*)`
  }).from(commissions).where(
    and26(
      eq26(commissions.salonId, salonId),
      eq26(commissions.staffId, staffId),
      eq26(commissions.paymentStatus, "pending"),
      eq26(commissions.isReversed, 0),
      gte8(commissions.serviceDate, periodStart),
      lte8(commissions.serviceDate, periodEnd)
    )
  );
  const tipsResult = await db.select({
    totalTips: sql23`COALESCE(SUM(${jobCardTips.amountPaisa}), 0)`
  }).from(jobCardTips).innerJoin(jobCards, eq26(jobCardTips.jobCardId, jobCards.id)).where(
    and26(
      eq26(jobCards.salonId, salonId),
      eq26(jobCardTips.staffId, staffId),
      gte8(jobCardTips.createdAt, periodStart),
      lte8(jobCardTips.createdAt, periodEnd)
    )
  );
  const adjustmentsResult = await db.select({
    totalBonuses: sql23`COALESCE(SUM(CASE WHEN ${staffAdjustments.adjustmentType} = 'bonus' THEN ${staffAdjustments.amountPaisa} ELSE 0 END), 0)`,
    totalDeductions: sql23`COALESCE(SUM(CASE WHEN ${staffAdjustments.adjustmentType} = 'deduction' THEN ${staffAdjustments.amountPaisa} ELSE 0 END), 0)`
  }).from(staffAdjustments).where(
    and26(
      eq26(staffAdjustments.salonId, salonId),
      eq26(staffAdjustments.staffId, staffId),
      eq26(staffAdjustments.status, "pending"),
      gte8(staffAdjustments.effectiveDate, periodStart),
      lte8(staffAdjustments.effectiveDate, periodEnd)
    )
  );
  const commissionTotal = Number(commissionsResult[0]?.totalCommissions || 0);
  const tipsTotal = Number(tipsResult[0]?.totalTips || 0);
  const bonuses = Number(adjustmentsResult[0]?.totalBonuses || 0);
  const deductions = Number(adjustmentsResult[0]?.totalDeductions || 0);
  const adjustmentsNet = bonuses - deductions;
  const total = commissionTotal + tipsTotal + adjustmentsNet;
  return {
    commissions: commissionTotal,
    tips: tipsTotal,
    bonuses,
    deductions,
    adjustmentsNet,
    total,
    commissionCount: Number(commissionsResult[0]?.count || 0)
  };
};
router16.get("/summary/:salonId", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId } = req.params;
    const { startDate, endDate, staffId } = req.query;
    const periodStart = startDate ? new Date(startDate) : new Date((/* @__PURE__ */ new Date()).setDate(1));
    const periodEnd = endDate ? new Date(endDate) : /* @__PURE__ */ new Date();
    let staffFilter = eq26(staff.salonId, salonId);
    if (staffId) {
      staffFilter = and26(staffFilter, eq26(staff.id, staffId));
    }
    const staffList = await db.select().from(staff).where(staffFilter);
    const summaries = await Promise.all(
      staffList.map(async (s) => {
        const summary = await getStaffSummary(salonId, s.id, periodStart, periodEnd);
        return {
          staffId: s.id,
          staffName: s.name,
          ...summary
        };
      })
    );
    const totals = summaries.reduce(
      (acc, s) => ({
        commissions: acc.commissions + s.commissions,
        tips: acc.tips + s.tips,
        bonuses: acc.bonuses + s.bonuses,
        deductions: acc.deductions + s.deductions,
        adjustmentsNet: acc.adjustmentsNet + s.adjustmentsNet,
        total: acc.total + s.total
      }),
      { commissions: 0, tips: 0, bonuses: 0, deductions: 0, adjustmentsNet: 0, total: 0 }
    );
    res.json({
      periodStart: periodStart.toISOString(),
      periodEnd: periodEnd.toISOString(),
      staffSummaries: summaries,
      totals
    });
  } catch (error) {
    console.error("Error fetching commission summary:", error);
    res.status(500).json({ error: "Failed to fetch commission summary" });
  }
});
router16.get("/commissions/:salonId", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId } = req.params;
    const { startDate, endDate, staffId, sourceType, status, limit = "50", offset = "0" } = req.query;
    let conditions = [eq26(commissions.salonId, salonId)];
    if (startDate) {
      conditions.push(gte8(commissions.serviceDate, new Date(startDate)));
    }
    if (endDate) {
      conditions.push(lte8(commissions.serviceDate, new Date(endDate)));
    }
    if (staffId) {
      conditions.push(eq26(commissions.staffId, staffId));
    }
    if (sourceType) {
      conditions.push(eq26(commissions.sourceType, sourceType));
    }
    if (status === "paid") {
      conditions.push(eq26(commissions.paymentStatus, "paid"));
    } else if (status === "unpaid") {
      conditions.push(eq26(commissions.paymentStatus, "pending"));
    } else if (status === "reversed") {
      conditions.push(eq26(commissions.isReversed, 1));
    }
    const commissionsData = await db.select({
      commission: commissions,
      staffName: staff.name,
      serviceName: services.name,
      productName: products.name
    }).from(commissions).leftJoin(staff, eq26(commissions.staffId, staff.id)).leftJoin(services, eq26(commissions.serviceId, services.id)).leftJoin(products, eq26(commissions.productId, products.id)).where(and26(...conditions)).orderBy(desc18(commissions.serviceDate)).limit(Number(limit)).offset(Number(offset));
    const countResult = await db.select({ count: sql23`COUNT(*)` }).from(commissions).where(and26(...conditions));
    res.json({
      commissions: commissionsData.map((c) => ({
        ...c.commission,
        staffName: c.staffName,
        serviceName: c.serviceName,
        productName: c.productName
      })),
      total: Number(countResult[0]?.count || 0)
    });
  } catch (error) {
    console.error("Error fetching commissions:", error);
    res.status(500).json({ error: "Failed to fetch commissions" });
  }
});
router16.get("/payouts/:salonId", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId } = req.params;
    const { staffId, status, limit = "50", offset = "0" } = req.query;
    let conditions = [eq26(staffPayouts.salonId, salonId)];
    if (staffId) {
      conditions.push(eq26(staffPayouts.staffId, staffId));
    }
    if (status) {
      conditions.push(eq26(staffPayouts.status, status));
    }
    const payoutsData = await db.select({
      payout: staffPayouts,
      staffName: staff.name,
      processedByName: users.firstName
    }).from(staffPayouts).leftJoin(staff, eq26(staffPayouts.staffId, staff.id)).leftJoin(users, eq26(staffPayouts.processedBy, users.id)).where(and26(...conditions)).orderBy(desc18(staffPayouts.paymentDate)).limit(Number(limit)).offset(Number(offset));
    const countResult = await db.select({ count: sql23`COUNT(*)` }).from(staffPayouts).where(and26(...conditions));
    res.json({
      payouts: payoutsData.map((p) => ({
        ...p.payout,
        staffName: p.staffName,
        processedByName: p.processedByName
      })),
      total: Number(countResult[0]?.count || 0)
    });
  } catch (error) {
    console.error("Error fetching payouts:", error);
    res.status(500).json({ error: "Failed to fetch payouts" });
  }
});
router16.post("/payouts/:salonId", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId } = req.params;
    const userId = req.user?.id;
    const payoutSchema = z11.object({
      staffId: z11.string(),
      periodStart: z11.string().datetime(),
      periodEnd: z11.string().datetime(),
      paymentMethod: z11.enum(["cash", "bank_transfer", "cheque", "upi", "other"]),
      paymentReference: z11.string().optional(),
      notes: z11.string().optional()
    });
    const validatedData = payoutSchema.parse(req.body);
    const periodStart = new Date(validatedData.periodStart);
    const periodEnd = new Date(validatedData.periodEnd);
    const summary = await getStaffSummary(salonId, validatedData.staffId, periodStart, periodEnd);
    if (summary.total <= 0) {
      return res.status(400).json({ error: "No payable amount for this period" });
    }
    const [payout] = await db.transaction(async (tx) => {
      const [newPayout] = await tx.insert(staffPayouts).values({
        salonId,
        staffId: validatedData.staffId,
        totalAmountPaisa: summary.total,
        commissionAmountPaisa: summary.commissions,
        tipsAmountPaisa: summary.tips,
        adjustmentsAmountPaisa: summary.adjustmentsNet,
        periodStart,
        periodEnd,
        paymentMethod: validatedData.paymentMethod,
        paymentReference: validatedData.paymentReference || null,
        paymentDate: /* @__PURE__ */ new Date(),
        status: "completed",
        processedBy: userId || null,
        notes: validatedData.notes || null
      }).returning();
      await tx.update(commissions).set({ paymentStatus: "paid", paidAt: /* @__PURE__ */ new Date(), paidBy: userId || null, payoutId: newPayout.id }).where(
        and26(
          eq26(commissions.salonId, salonId),
          eq26(commissions.staffId, validatedData.staffId),
          eq26(commissions.paymentStatus, "pending"),
          eq26(commissions.isReversed, 0),
          gte8(commissions.serviceDate, periodStart),
          lte8(commissions.serviceDate, periodEnd)
        )
      );
      await tx.update(staffAdjustments).set({ status: "included", payoutId: newPayout.id }).where(
        and26(
          eq26(staffAdjustments.salonId, salonId),
          eq26(staffAdjustments.staffId, validatedData.staffId),
          eq26(staffAdjustments.status, "pending"),
          gte8(staffAdjustments.effectiveDate, periodStart),
          lte8(staffAdjustments.effectiveDate, periodEnd)
        )
      );
      return [newPayout];
    });
    res.status(201).json(payout);
  } catch (error) {
    console.error("Error creating payout:", error);
    if (error instanceof z11.ZodError) {
      return res.status(400).json({ error: "Invalid input", details: error.errors });
    }
    res.status(500).json({ error: "Failed to create payout" });
  }
});
router16.get("/adjustments/:salonId", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId } = req.params;
    const { staffId, status, type, limit = "50", offset = "0" } = req.query;
    let conditions = [eq26(staffAdjustments.salonId, salonId)];
    if (staffId) {
      conditions.push(eq26(staffAdjustments.staffId, staffId));
    }
    if (status) {
      conditions.push(eq26(staffAdjustments.status, status));
    }
    if (type) {
      conditions.push(eq26(staffAdjustments.adjustmentType, type));
    }
    const adjustmentsData = await db.select({
      adjustment: staffAdjustments,
      staffName: staff.name,
      createdByName: users.firstName
    }).from(staffAdjustments).leftJoin(staff, eq26(staffAdjustments.staffId, staff.id)).leftJoin(users, eq26(staffAdjustments.createdBy, users.id)).where(and26(...conditions)).orderBy(desc18(staffAdjustments.effectiveDate)).limit(Number(limit)).offset(Number(offset));
    const countResult = await db.select({ count: sql23`COUNT(*)` }).from(staffAdjustments).where(and26(...conditions));
    res.json({
      adjustments: adjustmentsData.map((a) => ({
        ...a.adjustment,
        staffName: a.staffName,
        createdByName: a.createdByName
      })),
      total: Number(countResult[0]?.count || 0)
    });
  } catch (error) {
    console.error("Error fetching adjustments:", error);
    res.status(500).json({ error: "Failed to fetch adjustments" });
  }
});
router16.post("/adjustments/:salonId", requireBusinessOwner(), async (req, res) => {
  try {
    const { salonId } = req.params;
    const userId = req.user?.id;
    if (!userId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const adjustmentSchema = z11.object({
      staffId: z11.string(),
      adjustmentType: z11.enum(["bonus", "deduction"]),
      category: z11.string(),
      amountPaisa: z11.number().positive(),
      reason: z11.string().min(1),
      effectiveDate: z11.string().datetime()
    });
    const validatedData = adjustmentSchema.parse(req.body);
    const [adjustment] = await db.insert(staffAdjustments).values({
      salonId,
      staffId: validatedData.staffId,
      adjustmentType: validatedData.adjustmentType,
      category: validatedData.category,
      amountPaisa: validatedData.amountPaisa,
      reason: validatedData.reason,
      effectiveDate: new Date(validatedData.effectiveDate),
      status: "pending",
      createdBy: userId
    }).returning();
    res.status(201).json(adjustment);
  } catch (error) {
    console.error("Error creating adjustment:", error);
    if (error instanceof z11.ZodError) {
      return res.status(400).json({ error: "Invalid input", details: error.errors });
    }
    res.status(500).json({ error: "Failed to create adjustment" });
  }
});
router16.delete("/adjustments/:salonId/:adjustmentId", requireBusinessOwner(), async (req, res) => {
  try {
    const { salonId, adjustmentId } = req.params;
    const [adjustment] = await db.select().from(staffAdjustments).where(and26(eq26(staffAdjustments.id, adjustmentId), eq26(staffAdjustments.salonId, salonId)));
    if (!adjustment) {
      return res.status(404).json({ error: "Adjustment not found" });
    }
    if (adjustment.status !== "pending") {
      return res.status(400).json({ error: "Cannot delete adjustment that has been processed" });
    }
    await db.delete(staffAdjustments).where(eq26(staffAdjustments.id, adjustmentId));
    res.json({ success: true });
  } catch (error) {
    console.error("Error deleting adjustment:", error);
    res.status(500).json({ error: "Failed to delete adjustment" });
  }
});
router16.get("/rates/:salonId", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId } = req.params;
    const { type } = req.query;
    let conditions = [eq26(commissionRates.salonId, salonId), eq26(commissionRates.isActive, 1)];
    if (type === "service") {
      conditions.push(eq26(commissionRates.appliesTo, "service"));
    } else if (type === "product") {
      conditions.push(eq26(commissionRates.appliesTo, "product"));
    }
    const ratesData = await db.select({
      rate: commissionRates,
      staffName: staff.name,
      serviceName: services.name,
      productName: products.name
    }).from(commissionRates).leftJoin(staff, eq26(commissionRates.staffId, staff.id)).leftJoin(services, eq26(commissionRates.serviceId, services.id)).leftJoin(products, eq26(commissionRates.productId, products.id)).where(and26(...conditions)).orderBy(desc18(commissionRates.createdAt));
    res.json(
      ratesData.map((r) => ({
        ...r.rate,
        staffName: r.staffName,
        serviceName: r.serviceName,
        productName: r.productName
      }))
    );
  } catch (error) {
    console.error("Error fetching commission rates:", error);
    res.status(500).json({ error: "Failed to fetch commission rates" });
  }
});
router16.post("/rates/:salonId", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId } = req.params;
    const rateSchema = z11.object({
      staffId: z11.string().nullable().optional(),
      serviceId: z11.string().nullable().optional(),
      productId: z11.string().nullable().optional(),
      rateType: z11.enum(["percentage", "fixed"]),
      rateValue: z11.number().positive(),
      appliesTo: z11.enum(["service", "product"]).default("service"),
      minAmount: z11.number().nullable().optional(),
      maxAmount: z11.number().nullable().optional()
    });
    const validatedData = rateSchema.parse(req.body);
    const [rate] = await db.insert(commissionRates).values({
      salonId,
      staffId: validatedData.staffId || null,
      serviceId: validatedData.serviceId || null,
      productId: validatedData.productId || null,
      rateType: validatedData.rateType,
      rateValue: validatedData.rateValue.toString(),
      appliesTo: validatedData.appliesTo,
      minAmount: validatedData.minAmount || null,
      maxAmount: validatedData.maxAmount || null,
      isActive: 1
    }).returning();
    res.status(201).json(rate);
  } catch (error) {
    console.error("Error creating commission rate:", error);
    if (error instanceof z11.ZodError) {
      return res.status(400).json({ error: "Invalid input", details: error.errors });
    }
    res.status(500).json({ error: "Failed to create commission rate" });
  }
});
router16.put("/rates/:salonId/:rateId", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId, rateId } = req.params;
    const rateSchema = z11.object({
      rateType: z11.enum(["percentage", "fixed"]).optional(),
      rateValue: z11.number().positive().optional(),
      isActive: z11.number().min(0).max(1).optional(),
      minAmount: z11.number().nullable().optional(),
      maxAmount: z11.number().nullable().optional()
    });
    const validatedData = rateSchema.parse(req.body);
    const updateData = {};
    if (validatedData.rateType) updateData.rateType = validatedData.rateType;
    if (validatedData.rateValue) updateData.rateValue = validatedData.rateValue.toString();
    if (validatedData.isActive !== void 0) updateData.isActive = validatedData.isActive;
    if (validatedData.minAmount !== void 0) updateData.minAmount = validatedData.minAmount;
    if (validatedData.maxAmount !== void 0) updateData.maxAmount = validatedData.maxAmount;
    const [rate] = await db.update(commissionRates).set(updateData).where(and26(eq26(commissionRates.id, rateId), eq26(commissionRates.salonId, salonId))).returning();
    if (!rate) {
      return res.status(404).json({ error: "Commission rate not found" });
    }
    res.json(rate);
  } catch (error) {
    console.error("Error updating commission rate:", error);
    if (error instanceof z11.ZodError) {
      return res.status(400).json({ error: "Invalid input", details: error.errors });
    }
    res.status(500).json({ error: "Failed to update commission rate" });
  }
});
router16.get("/reversals/:salonId", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId } = req.params;
    const { limit = "50", offset = "0" } = req.query;
    const reversalsData = await db.select({
      reversal: commissionReversals,
      commission: commissions,
      staffName: staff.name,
      reversedByName: users.firstName
    }).from(commissionReversals).innerJoin(commissions, eq26(commissionReversals.originalCommissionId, commissions.id)).leftJoin(staff, eq26(commissions.staffId, staff.id)).leftJoin(users, eq26(commissionReversals.reversedBy, users.id)).where(eq26(commissionReversals.salonId, salonId)).orderBy(desc18(commissionReversals.reversedAt)).limit(Number(limit)).offset(Number(offset));
    res.json(
      reversalsData.map((r) => ({
        ...r.reversal,
        originalCommission: r.commission,
        staffName: r.staffName,
        reversedByName: r.reversedByName
      }))
    );
  } catch (error) {
    console.error("Error fetching reversals:", error);
    res.status(500).json({ error: "Failed to fetch reversals" });
  }
});
async function reverseCommission(commissionId, reason, reversedBy, isPartial = false, partialAmount) {
  const [commission] = await db.select().from(commissions).where(eq26(commissions.id, commissionId));
  if (!commission) {
    throw new Error("Commission not found");
  }
  if (commission.isReversed === 1) {
    throw new Error("Commission already reversed");
  }
  const reversalAmount = isPartial && partialAmount ? partialAmount : commission.commissionAmountPaisa;
  const alreadyPaid = commission.paymentStatus === "paid" ? 1 : 0;
  return await db.transaction(async (tx) => {
    const [reversal] = await tx.insert(commissionReversals).values({
      salonId: commission.salonId,
      originalCommissionId: commissionId,
      reversalAmountPaisa: reversalAmount,
      reversalReason: reason,
      alreadyPaid,
      reversedBy
    }).returning();
    await tx.update(commissions).set({
      isReversed: 1,
      reversalId: reversal.id,
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq26(commissions.id, commissionId));
    let recoveryAdjustment = null;
    if (alreadyPaid === 1) {
      const [adjustment] = await tx.insert(staffAdjustments).values({
        salonId: commission.salonId,
        staffId: commission.staffId,
        adjustmentType: "deduction",
        category: "commission_recovery",
        amountPaisa: reversalAmount,
        reason: `Recovery for reversed commission (${reason})`,
        effectiveDate: /* @__PURE__ */ new Date(),
        status: "pending",
        createdBy: reversedBy || "system"
      }).returning();
      recoveryAdjustment = adjustment;
      await tx.update(commissionReversals).set({ recoveryAdjustmentId: adjustment.id }).where(eq26(commissionReversals.id, reversal.id));
    }
    return { success: true, reversal, recoveryAdjustment };
  });
}
router16.post("/reverse/:salonId/:commissionId", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId, commissionId } = req.params;
    const userId = req.user?.id || null;
    const reverseSchema = z11.object({
      reason: z11.string().min(1),
      isPartial: z11.boolean().optional().default(false),
      partialAmount: z11.number().positive().optional()
    });
    const validatedData = reverseSchema.parse(req.body);
    const [commission] = await db.select().from(commissions).where(and26(eq26(commissions.id, commissionId), eq26(commissions.salonId, salonId)));
    if (!commission) {
      return res.status(404).json({ error: "Commission not found" });
    }
    const result = await reverseCommission(commissionId, validatedData.reason, userId, validatedData.isPartial, validatedData.partialAmount);
    res.json(result);
  } catch (error) {
    console.error("Error reversing commission:", error);
    if (error instanceof z11.ZodError) {
      return res.status(400).json({ error: "Invalid input", details: error.errors });
    }
    if (error instanceof Error) {
      return res.status(400).json({ error: error.message });
    }
    res.status(500).json({ error: "Failed to reverse commission" });
  }
});
router16.get("/export/:salonId/excel", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId } = req.params;
    const { startDate, endDate, staffId, type = "summary" } = req.query;
    const periodStart = startDate ? new Date(startDate) : new Date((/* @__PURE__ */ new Date()).setDate(1));
    const periodEnd = endDate ? new Date(endDate) : /* @__PURE__ */ new Date();
    const workbook = new ExcelJS2.Workbook();
    workbook.creator = "SalonHub";
    workbook.created = /* @__PURE__ */ new Date();
    if (type === "summary" || type === "all") {
      const summarySheet = workbook.addWorksheet("Commission Summary");
      summarySheet.columns = [
        { header: "Staff Name", key: "staffName", width: 25 },
        { header: "Commissions", key: "commissions", width: 15 },
        { header: "Tips", key: "tips", width: 15 },
        { header: "Bonuses", key: "bonuses", width: 15 },
        { header: "Deductions", key: "deductions", width: 15 },
        { header: "Net Adjustments", key: "adjustmentsNet", width: 15 },
        { header: "Total Payable", key: "total", width: 15 }
      ];
      let staffFilter = eq26(staff.salonId, salonId);
      if (staffId) {
        staffFilter = and26(staffFilter, eq26(staff.id, staffId));
      }
      const staffList = await db.select().from(staff).where(staffFilter);
      for (const s of staffList) {
        const summary = await getStaffSummary(salonId, s.id, periodStart, periodEnd);
        summarySheet.addRow({
          staffName: s.name,
          commissions: formatCurrency(summary.commissions),
          tips: formatCurrency(summary.tips),
          bonuses: formatCurrency(summary.bonuses),
          deductions: formatCurrency(summary.deductions),
          adjustmentsNet: formatCurrency(summary.adjustmentsNet),
          total: formatCurrency(summary.total)
        });
      }
    }
    if (type === "detailed" || type === "all") {
      const detailSheet = workbook.addWorksheet("Commission Details");
      detailSheet.columns = [
        { header: "Date", key: "date", width: 12 },
        { header: "Staff", key: "staff", width: 20 },
        { header: "Source", key: "source", width: 15 },
        { header: "Item", key: "item", width: 25 },
        { header: "Sale Amount", key: "saleAmount", width: 15 },
        { header: "Commission", key: "commission", width: 15 },
        { header: "Status", key: "status", width: 12 }
      ];
      let conditions = [eq26(commissions.salonId, salonId), gte8(commissions.serviceDate, periodStart), lte8(commissions.serviceDate, periodEnd)];
      if (staffId) {
        conditions.push(eq26(commissions.staffId, staffId));
      }
      const commissionsData = await db.select({
        commission: commissions,
        staffName: staff.name,
        serviceName: services.name,
        productName: products.name
      }).from(commissions).leftJoin(staff, eq26(commissions.staffId, staff.id)).leftJoin(services, eq26(commissions.serviceId, services.id)).leftJoin(products, eq26(commissions.productId, products.id)).where(and26(...conditions)).orderBy(desc18(commissions.serviceDate));
      for (const c of commissionsData) {
        detailSheet.addRow({
          date: c.commission.serviceDate?.toISOString().split("T")[0],
          staff: c.staffName,
          source: c.commission.sourceType,
          item: c.serviceName || c.productName || "N/A",
          saleAmount: formatCurrency(c.commission.baseAmountPaisa),
          commission: formatCurrency(c.commission.commissionAmountPaisa),
          status: c.commission.isReversed ? "Reversed" : c.commission.paymentStatus === "paid" ? "Paid" : "Unpaid"
        });
      }
    }
    res.setHeader("Content-Type", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet");
    res.setHeader("Content-Disposition", `attachment; filename=commission-report-${periodStart.toISOString().split("T")[0]}-${periodEnd.toISOString().split("T")[0]}.xlsx`);
    await workbook.xlsx.write(res);
    res.end();
  } catch (error) {
    console.error("Error generating Excel export:", error);
    res.status(500).json({ error: "Failed to generate Excel export" });
  }
});
router16.get("/export/:salonId/pdf", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId } = req.params;
    const { startDate, endDate, staffId } = req.query;
    const periodStart = startDate ? new Date(startDate) : new Date((/* @__PURE__ */ new Date()).setDate(1));
    const periodEnd = endDate ? new Date(endDate) : /* @__PURE__ */ new Date();
    const [salon] = await db.select().from(salons).where(eq26(salons.id, salonId));
    const doc = new PDFDocument2({ margin: 50 });
    res.setHeader("Content-Type", "application/pdf");
    res.setHeader("Content-Disposition", `attachment; filename=payout-statement-${periodStart.toISOString().split("T")[0]}-${periodEnd.toISOString().split("T")[0]}.pdf`);
    doc.pipe(res);
    doc.fontSize(20).text(salon?.name || "Salon", { align: "center" });
    doc.fontSize(14).text("Commission & Payout Statement", { align: "center" });
    doc.moveDown();
    doc.fontSize(10).text(`Period: ${periodStart.toISOString().split("T")[0]} to ${periodEnd.toISOString().split("T")[0]}`, { align: "center" });
    doc.moveDown(2);
    let staffFilter = eq26(staff.salonId, salonId);
    if (staffId) {
      staffFilter = and26(staffFilter, eq26(staff.id, staffId));
    }
    const staffList = await db.select().from(staff).where(staffFilter);
    for (const s of staffList) {
      const summary = await getStaffSummary(salonId, s.id, periodStart, periodEnd);
      doc.fontSize(12).font("Helvetica-Bold").text(s.name);
      doc.font("Helvetica").fontSize(10);
      doc.text(`Service Commissions: ${formatCurrency(summary.commissions)}`);
      doc.text(`Tips Received: ${formatCurrency(summary.tips)}`);
      doc.text(`Bonuses: ${formatCurrency(summary.bonuses)}`);
      doc.text(`Deductions: ${formatCurrency(summary.deductions)}`);
      doc.font("Helvetica-Bold").text(`Total Payable: ${formatCurrency(summary.total)}`);
      doc.font("Helvetica");
      doc.moveDown();
    }
    doc.end();
  } catch (error) {
    console.error("Error generating PDF export:", error);
    res.status(500).json({ error: "Failed to generate PDF export" });
  }
});
router16.get("/staff-statement/:salonId/:staffId", requireSalonAccess(), async (req, res) => {
  try {
    const { salonId, staffId } = req.params;
    const { startDate, endDate } = req.query;
    const periodStart = startDate ? new Date(startDate) : new Date((/* @__PURE__ */ new Date()).setMonth((/* @__PURE__ */ new Date()).getMonth() - 1));
    const periodEnd = endDate ? new Date(endDate) : /* @__PURE__ */ new Date();
    const [staffMember] = await db.select().from(staff).where(and26(eq26(staff.id, staffId), eq26(staff.salonId, salonId)));
    if (!staffMember) {
      return res.status(404).json({ error: "Staff member not found" });
    }
    const summary = await getStaffSummary(salonId, staffId, periodStart, periodEnd);
    const commissionsData = await db.select({
      commission: commissions,
      serviceName: services.name,
      productName: products.name
    }).from(commissions).leftJoin(services, eq26(commissions.serviceId, services.id)).leftJoin(products, eq26(commissions.productId, products.id)).where(
      and26(eq26(commissions.salonId, salonId), eq26(commissions.staffId, staffId), gte8(commissions.serviceDate, periodStart), lte8(commissions.serviceDate, periodEnd))
    ).orderBy(desc18(commissions.serviceDate));
    const tipsData = await db.select({
      tip: jobCardTips,
      jobCardNumber: jobCards.jobCardNumber
    }).from(jobCardTips).innerJoin(jobCards, eq26(jobCardTips.jobCardId, jobCards.id)).where(and26(eq26(jobCards.salonId, salonId), eq26(jobCardTips.staffId, staffId), gte8(jobCardTips.createdAt, periodStart), lte8(jobCardTips.createdAt, periodEnd))).orderBy(desc18(jobCardTips.createdAt));
    const adjustmentsData = await db.select().from(staffAdjustments).where(
      and26(
        eq26(staffAdjustments.salonId, salonId),
        eq26(staffAdjustments.staffId, staffId),
        gte8(staffAdjustments.effectiveDate, periodStart),
        lte8(staffAdjustments.effectiveDate, periodEnd)
      )
    ).orderBy(desc18(staffAdjustments.effectiveDate));
    const payoutsData = await db.select().from(staffPayouts).where(
      and26(eq26(staffPayouts.salonId, salonId), eq26(staffPayouts.staffId, staffId), gte8(staffPayouts.periodStart, periodStart), lte8(staffPayouts.periodEnd, periodEnd))
    ).orderBy(desc18(staffPayouts.paymentDate));
    res.json({
      staff: staffMember,
      period: { start: periodStart, end: periodEnd },
      summary,
      commissions: commissionsData.map((c) => ({
        ...c.commission,
        itemName: c.serviceName || c.productName
      })),
      tips: tipsData.map((t) => ({
        ...t.tip,
        jobCardNumber: t.jobCardNumber
      })),
      adjustments: adjustmentsData,
      payouts: payoutsData
    });
  } catch (error) {
    console.error("Error fetching staff statement:", error);
    res.status(500).json({ error: "Failed to fetch staff statement" });
  }
});
function registerCommissionPayoutRoutes(app2) {
  app2.use("/api/commission-payout", router16);
}

// server/routes/customer-import.routes.ts
init_db();
init_schema();
import { Router as Router16 } from "express";
import multer3 from "multer";
import { eq as eq28, and as and28, sql as sql25, gte as gte9 } from "drizzle-orm";
import { z as z13 } from "zod";

// server/services/customerImportService.ts
init_db();
init_schema();
import { eq as eq27, and as and27, sql as sql24 } from "drizzle-orm";
import { z as z12 } from "zod";
var importRowSchema = z12.object({
  name: z12.string().min(1, "Name is required").max(255).transform((s) => s.trim()),
  phone: z12.string().min(10, "Phone number too short").max(20),
  email: z12.string().email("Invalid email format").optional().or(z12.literal("")).transform((s) => s || null)
});
function parseCSVContent(content) {
  const lines = content.split("\n").filter((line) => line.trim());
  if (lines.length < 2) {
    throw new Error("CSV file must have at least a header row and one data row");
  }
  const headers = parseCSVLine(lines[0]);
  const rows = [];
  for (let i = 1; i < lines.length; i++) {
    const values = parseCSVLine(lines[i]);
    const row = {};
    headers.forEach((header, index2) => {
      row[header.trim()] = values[index2]?.trim() || "";
    });
    rows.push(row);
  }
  return rows;
}
function parseCSVLine(line) {
  const result = [];
  let current = "";
  let inQuotes = false;
  for (let i = 0; i < line.length; i++) {
    const char = line[i];
    if (char === '"') {
      if (inQuotes && line[i + 1] === '"') {
        current += '"';
        i++;
      } else {
        inQuotes = !inQuotes;
      }
    } else if (char === "," && !inQuotes) {
      result.push(current);
      current = "";
    } else {
      current += char;
    }
  }
  result.push(current);
  return result;
}
function detectColumns(headers) {
  const namePatterns = ["name", "customer_name", "customer name", "full_name", "full name", "client_name", "client name"];
  const phonePatterns = ["phone", "mobile", "phone_number", "phone number", "mobile_number", "mobile number", "contact", "cell"];
  const emailPatterns = ["email", "email_address", "email address", "e-mail"];
  const lowerHeaders = headers.map((h) => h.toLowerCase().trim());
  let nameColumn = headers.find((_, i) => namePatterns.some((p) => lowerHeaders[i].includes(p)));
  let phoneColumn = headers.find((_, i) => phonePatterns.some((p) => lowerHeaders[i].includes(p)));
  let emailColumn = headers.find((_, i) => emailPatterns.some((p) => lowerHeaders[i].includes(p)));
  if (!nameColumn || !phoneColumn) {
    return null;
  }
  return {
    nameColumn,
    phoneColumn,
    emailColumn
  };
}
async function previewImport(salonId, rows, mapping, maxPreviewRows = 10) {
  const errors = [];
  const preview = [];
  let validRows = 0;
  let invalidRows = 0;
  let duplicateRows = 0;
  const existingPhones = await getExistingPhones(salonId);
  const seenPhones = /* @__PURE__ */ new Set();
  for (let i = 0; i < rows.length; i++) {
    const row = rows[i];
    const rowNumber = i + 2;
    const rawData = {
      name: row[mapping.nameColumn] || "",
      phone: row[mapping.phoneColumn] || "",
      email: mapping.emailColumn ? row[mapping.emailColumn] || "" : ""
    };
    const rowErrors = [];
    let normalizedPhone = "";
    let isValid = true;
    let isDuplicate = false;
    if (!rawData.name.trim()) {
      rowErrors.push("Name is required");
      isValid = false;
    }
    if (!rawData.phone.trim()) {
      rowErrors.push("Phone number is required");
      isValid = false;
    } else {
      try {
        normalizedPhone = normalizePhoneNumber2(rawData.phone);
        if (existingPhones.has(normalizedPhone)) {
          isDuplicate = true;
          duplicateRows++;
        } else if (seenPhones.has(normalizedPhone)) {
          isDuplicate = true;
          duplicateRows++;
        } else {
          seenPhones.add(normalizedPhone);
        }
      } catch (e) {
        rowErrors.push(e.message || "Invalid phone number format");
        isValid = false;
      }
    }
    if (rawData.email && rawData.email.trim()) {
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      if (!emailRegex.test(rawData.email.trim())) {
        rowErrors.push("Invalid email format");
        isValid = false;
      }
    }
    if (!isValid) {
      invalidRows++;
      errors.push({
        rowNumber,
        originalData: rawData,
        errors: rowErrors
      });
    } else if (!isDuplicate) {
      validRows++;
    }
    if (preview.length < maxPreviewRows) {
      preview.push({
        rowNumber,
        name: rawData.name.trim(),
        phone: rawData.phone.trim(),
        normalizedPhone,
        email: rawData.email?.trim() || null,
        isDuplicate,
        isValid: isValid && !isDuplicate
      });
    }
  }
  return {
    totalRows: rows.length,
    validRows,
    invalidRows,
    duplicateRows,
    errors: errors.slice(0, 100),
    preview
  };
}
async function getExistingPhones(salonId) {
  const existing = await db.select({ normalizedPhone: importedCustomers.normalizedPhone }).from(importedCustomers).where(eq27(importedCustomers.salonId, salonId));
  return new Set(existing.map((e) => e.normalizedPhone));
}
async function executeImport(salonId, userId, fileName, rows, mapping) {
  const [batch] = await db.insert(customerImportBatches).values({
    salonId,
    importedBy: userId,
    fileName,
    totalRecords: rows.length,
    status: IMPORT_BATCH_STATUSES.PROCESSING
  }).returning();
  const errors = [];
  let successfulImports = 0;
  let failedImports = 0;
  let duplicateSkipped = 0;
  const existingPhones = await getExistingPhones(salonId);
  const seenPhones = /* @__PURE__ */ new Set();
  const BATCH_SIZE2 = 100;
  for (let batchStart = 0; batchStart < rows.length; batchStart += BATCH_SIZE2) {
    const batchRows = rows.slice(batchStart, batchStart + BATCH_SIZE2);
    const validRecords = [];
    for (let i = 0; i < batchRows.length; i++) {
      const row = batchRows[i];
      const rowNumber = batchStart + i + 2;
      const rawData = {
        name: row[mapping.nameColumn] || "",
        phone: row[mapping.phoneColumn] || "",
        email: mapping.emailColumn ? row[mapping.emailColumn] || "" : ""
      };
      const rowErrors = [];
      let normalizedPhone = "";
      let isValid = true;
      if (!rawData.name.trim()) {
        rowErrors.push("Name is required");
        isValid = false;
      }
      if (!rawData.phone.trim()) {
        rowErrors.push("Phone number is required");
        isValid = false;
      } else {
        try {
          normalizedPhone = normalizePhoneNumber2(rawData.phone);
        } catch (e) {
          rowErrors.push(e.message || "Invalid phone number format");
          isValid = false;
        }
      }
      if (rawData.email && rawData.email.trim()) {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        if (!emailRegex.test(rawData.email.trim())) {
          rowErrors.push("Invalid email format");
          isValid = false;
        }
      }
      if (!isValid) {
        failedImports++;
        errors.push({
          rowNumber,
          originalData: rawData,
          errors: rowErrors
        });
        continue;
      }
      if (existingPhones.has(normalizedPhone) || seenPhones.has(normalizedPhone)) {
        duplicateSkipped++;
        continue;
      }
      seenPhones.add(normalizedPhone);
      validRecords.push({
        salonId,
        importBatchId: batch.id,
        customerName: rawData.name.trim(),
        phone: rawData.phone.trim(),
        email: rawData.email?.trim() || null,
        normalizedPhone,
        status: IMPORTED_CUSTOMER_STATUSES.PENDING
      });
    }
    if (validRecords.length > 0) {
      try {
        await db.insert(importedCustomers).values(validRecords);
        successfulImports += validRecords.length;
      } catch (e) {
        console.error("Batch insert error:", e);
        failedImports += validRecords.length;
        errors.push({
          rowNumber: batchStart + 2,
          originalData: { batch: `Rows ${batchStart + 2} - ${batchStart + batchRows.length + 1}` },
          errors: [`Batch insert failed: ${e.message}`]
        });
      }
    }
  }
  await db.update(customerImportBatches).set({
    status: IMPORT_BATCH_STATUSES.COMPLETED,
    successfulImports,
    failedImports,
    duplicateSkipped,
    errorLog: errors.length > 0 ? errors : null,
    completedAt: /* @__PURE__ */ new Date()
  }).where(eq27(customerImportBatches.id, batch.id));
  return {
    batchId: batch.id,
    totalRecords: rows.length,
    successfulImports,
    failedImports,
    duplicateSkipped,
    errors
  };
}
async function getImportBatches(salonId) {
  return db.select().from(customerImportBatches).where(eq27(customerImportBatches.salonId, salonId)).orderBy(sql24`${customerImportBatches.createdAt} DESC`);
}
async function getImportBatch(batchId) {
  const [batch] = await db.select().from(customerImportBatches).where(eq27(customerImportBatches.id, batchId));
  return batch;
}
async function getImportedCustomers(salonId, options = {}) {
  const { status, search, page = 1, limit = 50 } = options;
  const offset = (page - 1) * limit;
  const whereCondition = status ? and27(eq27(importedCustomers.salonId, salonId), eq27(importedCustomers.status, status)) : eq27(importedCustomers.salonId, salonId);
  const results = await db.select().from(importedCustomers).where(whereCondition).orderBy(sql24`${importedCustomers.createdAt} DESC`).limit(limit).offset(offset);
  const [countResult] = await db.select({ count: sql24`count(*)` }).from(importedCustomers).where(whereCondition);
  return {
    customers: results,
    total: Number(countResult?.count || 0),
    page,
    limit,
    totalPages: Math.ceil(Number(countResult?.count || 0) / limit)
  };
}

// server/routes/customer-import.routes.ts
var router17 = Router16();
var upload3 = multer3({
  storage: multer3.memoryStorage(),
  limits: {
    fileSize: 5 * 1024 * 1024
  },
  fileFilter: (req, file, cb) => {
    const allowedMimes = ["text/csv", "application/csv", "text/plain"];
    if (allowedMimes.includes(file.mimetype) || file.originalname.endsWith(".csv")) {
      cb(null, true);
    } else {
      cb(new Error("Only CSV files are allowed"));
    }
  }
});
router17.use(populateUserFromSession);
var columnMappingSchema = z13.object({
  nameColumn: z13.string().min(1),
  phoneColumn: z13.string().min(1),
  emailColumn: z13.string().optional()
});
router17.post(
  "/:salonId/customers/import/preview",
  requireSalonAccess(["owner", "shop_admin"]),
  upload3.single("file"),
  async (req, res) => {
    try {
      const { salonId } = req.params;
      const file = req.file;
      if (!file) {
        return res.status(400).json({ error: "No file uploaded" });
      }
      const content = file.buffer.toString("utf-8");
      let rows;
      try {
        rows = parseCSVContent(content);
      } catch (e) {
        return res.status(400).json({ error: e.message || "Failed to parse CSV file" });
      }
      if (rows.length === 0) {
        return res.status(400).json({ error: "CSV file is empty" });
      }
      if (rows.length > 1e4) {
        return res.status(400).json({ error: "CSV file exceeds maximum of 10,000 rows" });
      }
      const headers = Object.keys(rows[0]);
      const detectedMapping = detectColumns(headers);
      let mapping;
      if (req.body.mapping) {
        try {
          mapping = columnMappingSchema.parse(JSON.parse(req.body.mapping));
        } catch (e) {
          return res.status(400).json({ error: "Invalid column mapping provided" });
        }
      } else if (detectedMapping) {
        mapping = detectedMapping;
      } else {
        return res.status(400).json({
          error: "Could not auto-detect columns. Please provide column mapping.",
          headers,
          hint: "Required columns: name, phone. Optional: email"
        });
      }
      const preview = await previewImport(salonId, rows, mapping, 20);
      res.json({
        fileName: file.originalname,
        headers,
        detectedMapping,
        mapping,
        preview,
        rowCount: rows.length
      });
    } catch (error) {
      console.error("CSV preview error:", error);
      res.status(500).json({ error: error.message || "Failed to preview import" });
    }
  }
);
router17.post(
  "/:salonId/customers/import",
  requireSalonAccess(["owner", "shop_admin"]),
  upload3.single("file"),
  async (req, res) => {
    try {
      const { salonId } = req.params;
      const userId = req.user?.id;
      const file = req.file;
      if (!userId) {
        return res.status(401).json({ error: "User not authenticated" });
      }
      if (!file) {
        return res.status(400).json({ error: "No file uploaded" });
      }
      let mapping;
      try {
        mapping = columnMappingSchema.parse(JSON.parse(req.body.mapping));
      } catch (e) {
        return res.status(400).json({ error: "Column mapping is required for import" });
      }
      const content = file.buffer.toString("utf-8");
      let rows;
      try {
        rows = parseCSVContent(content);
      } catch (e) {
        return res.status(400).json({ error: e.message || "Failed to parse CSV file" });
      }
      if (rows.length === 0) {
        return res.status(400).json({ error: "CSV file is empty" });
      }
      if (rows.length > 1e4) {
        return res.status(400).json({ error: "CSV file exceeds maximum of 10,000 rows" });
      }
      const result = await executeImport(salonId, userId, file.originalname, rows, mapping);
      res.json({
        success: true,
        batchId: result.batchId,
        totalRecords: result.totalRecords,
        successfulImports: result.successfulImports,
        failedImports: result.failedImports,
        duplicateSkipped: result.duplicateSkipped,
        errors: result.errors.slice(0, 50)
      });
    } catch (error) {
      console.error("CSV import error:", error);
      res.status(500).json({ error: error.message || "Failed to import customers" });
    }
  }
);
router17.get(
  "/:salonId/customers/import/batches",
  requireSalonAccess(["owner", "shop_admin"]),
  async (req, res) => {
    try {
      const { salonId } = req.params;
      const batches = await getImportBatches(salonId);
      res.json(batches);
    } catch (error) {
      console.error("Get import batches error:", error);
      res.status(500).json({ error: "Failed to fetch import batches" });
    }
  }
);
router17.get(
  "/:salonId/customers/import/batches/:batchId",
  requireSalonAccess(["owner", "shop_admin"]),
  async (req, res) => {
    try {
      const { batchId } = req.params;
      const batch = await getImportBatch(batchId);
      if (!batch) {
        return res.status(404).json({ error: "Import batch not found" });
      }
      res.json(batch);
    } catch (error) {
      console.error("Get import batch error:", error);
      res.status(500).json({ error: "Failed to fetch import batch" });
    }
  }
);
router17.get(
  "/:salonId/customers/imported",
  requireSalonAccess(["owner", "shop_admin"]),
  async (req, res) => {
    try {
      const { salonId } = req.params;
      const { status, search, page = "1", limit = "50" } = req.query;
      const result = await getImportedCustomers(salonId, {
        status,
        search,
        page: parseInt(page, 10),
        limit: parseInt(limit, 10)
      });
      res.json(result);
    } catch (error) {
      console.error("Get imported customers error:", error);
      res.status(500).json({ error: "Failed to fetch imported customers" });
    }
  }
);
router17.delete(
  "/:salonId/customers/imported/:customerId",
  requireSalonAccess(["owner", "shop_admin"]),
  async (req, res) => {
    try {
      const { salonId, customerId } = req.params;
      const [customer] = await db.select().from(importedCustomers).where(and28(
        eq28(importedCustomers.id, customerId),
        eq28(importedCustomers.salonId, salonId)
      ));
      if (!customer) {
        return res.status(404).json({ error: "Customer not found" });
      }
      await db.delete(importedCustomers).where(eq28(importedCustomers.id, customerId));
      res.json({ success: true, message: "Customer deleted successfully" });
    } catch (error) {
      console.error("Delete imported customer error:", error);
      res.status(500).json({ error: "Failed to delete customer" });
    }
  }
);
router17.get(
  "/:salonId/customers/import/stats",
  requireSalonAccess(["owner", "shop_admin"]),
  async (req, res) => {
    try {
      const { salonId } = req.params;
      const now = /* @__PURE__ */ new Date();
      const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1e3);
      const monthAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1e3);
      const [totalResult] = await db.select({ count: sql25`count(*)` }).from(importedCustomers).where(eq28(importedCustomers.salonId, salonId));
      const [weekResult] = await db.select({ count: sql25`count(*)` }).from(importedCustomers).where(and28(
        eq28(importedCustomers.salonId, salonId),
        gte9(importedCustomers.createdAt, weekAgo)
      ));
      const [monthResult] = await db.select({ count: sql25`count(*)` }).from(importedCustomers).where(and28(
        eq28(importedCustomers.salonId, salonId),
        gte9(importedCustomers.createdAt, monthAgo)
      ));
      const statusCounts = await db.select({
        status: importedCustomers.status,
        count: sql25`count(*)`
      }).from(importedCustomers).where(eq28(importedCustomers.salonId, salonId)).groupBy(importedCustomers.status);
      const statusMap = statusCounts.reduce((acc, { status, count: count11 }) => {
        acc[status] = Number(count11);
        return acc;
      }, {});
      res.json({
        totalImported: Number(totalResult?.count || 0),
        importedThisWeek: Number(weekResult?.count || 0),
        importedThisMonth: Number(monthResult?.count || 0),
        byStatus: {
          pending: statusMap.pending || 0,
          invited: statusMap.invited || 0,
          registered: statusMap.registered || 0,
          expired: statusMap.expired || 0
        },
        conversionRate: statusMap.registered ? (statusMap.registered / Number(totalResult?.count || 1) * 100).toFixed(1) : "0.0"
      });
    } catch (error) {
      console.error("Get import stats error:", error);
      res.status(500).json({ error: "Failed to fetch import statistics" });
    }
  }
);
function registerCustomerImportRoutes(app2) {
  app2.use("/api/salons", router17);
}

// server/routes/campaign.routes.ts
import express2, { Router as Router17 } from "express";
import { z as z14 } from "zod";

// server/services/campaignService.ts
init_db();
init_schema();
import { eq as eq29, and as and29, desc as desc20, count as count5 } from "drizzle-orm";
var CAMPAIGN_STATUSES2 = {
  DRAFT: "draft",
  SCHEDULED: "scheduled",
  SENDING: "sending",
  COMPLETED: "completed",
  PAUSED: "paused",
  FAILED: "failed"
};
var MESSAGE_STATUSES2 = {
  PENDING: "pending",
  SENT: "sent",
  DELIVERED: "delivered",
  FAILED: "failed",
  READ: "read"
};
async function createCampaign(input) {
  const pendingCustomers = await db.select({ count: count5() }).from(importedCustomers).where(and29(
    eq29(importedCustomers.salonId, input.salonId),
    eq29(importedCustomers.status, IMPORTED_CUSTOMER_STATUSES.PENDING)
  ));
  const targetCount = pendingCustomers[0]?.count || 0;
  const [campaign] = await db.insert(invitationCampaigns).values({
    salonId: input.salonId,
    name: input.name,
    channel: input.channel,
    messageTemplate: input.messageTemplate,
    welcomeOfferId: input.welcomeOfferId || null,
    scheduledFor: input.scheduledFor || null,
    targetCustomerCount: targetCount,
    status: input.scheduledFor ? CAMPAIGN_STATUSES2.SCHEDULED : CAMPAIGN_STATUSES2.DRAFT,
    createdBy: input.createdBy
  }).returning();
  return campaign;
}
async function getCampaign(campaignId) {
  const [campaign] = await db.select().from(invitationCampaigns).where(eq29(invitationCampaigns.id, campaignId));
  return campaign || null;
}
async function getCampaignsBySalon(salonId) {
  return db.select().from(invitationCampaigns).where(eq29(invitationCampaigns.salonId, salonId)).orderBy(desc20(invitationCampaigns.createdAt));
}
async function getCampaignStats(campaignId) {
  const campaign = await getCampaign(campaignId);
  if (!campaign) return null;
  const delivered = campaign.messagesDelivered || 0;
  const sent = campaign.messagesSent || 0;
  const deliveryRate = sent > 0 ? delivered / sent * 100 : 0;
  return {
    id: campaign.id,
    name: campaign.name,
    status: campaign.status,
    channel: campaign.channel,
    targetCustomerCount: campaign.targetCustomerCount,
    messagesSent: sent,
    messagesDelivered: delivered,
    messagesFailed: campaign.messagesFailed || 0,
    deliveryRate: Math.round(deliveryRate * 100) / 100,
    createdAt: campaign.createdAt,
    startedAt: campaign.startedAt,
    completedAt: campaign.completedAt
  };
}
async function validateCampaignStart(campaignId) {
  const campaign = await getCampaign(campaignId);
  if (!campaign) {
    return { success: false, error: "Campaign not found" };
  }
  if (campaign.status === CAMPAIGN_STATUSES2.SENDING) {
    return { success: false, error: "Campaign is already sending" };
  }
  if (campaign.status === CAMPAIGN_STATUSES2.COMPLETED) {
    return { success: false, error: "Campaign has already completed" };
  }
  if (campaign.status === CAMPAIGN_STATUSES2.FAILED) {
    return { success: false, error: "Campaign has failed. Please create a new campaign." };
  }
  const [salon] = await db.select().from(salons).where(eq29(salons.id, campaign.salonId));
  if (!salon) {
    return { success: false, error: "Salon not found" };
  }
  const pendingCustomers = await db.select({ count: count5() }).from(importedCustomers).where(and29(
    eq29(importedCustomers.salonId, campaign.salonId),
    eq29(importedCustomers.status, IMPORTED_CUSTOMER_STATUSES.PENDING)
  ));
  const pendingCount = pendingCustomers[0]?.count || 0;
  if (pendingCount === 0) {
    return { success: false, error: "No pending customers to invite" };
  }
  return { success: true, campaign, pendingCount };
}
async function startCampaign(campaignId, onProgress) {
  const campaign = await getCampaign(campaignId);
  if (!campaign) {
    return { success: false, error: "Campaign not found" };
  }
  if (campaign.status === CAMPAIGN_STATUSES2.SENDING) {
    return { success: false, error: "Campaign is already sending" };
  }
  if (campaign.status === CAMPAIGN_STATUSES2.COMPLETED) {
    return { success: false, error: "Campaign has already completed" };
  }
  if (campaign.status === CAMPAIGN_STATUSES2.FAILED) {
    return { success: false, error: "Campaign has failed. Please create a new campaign." };
  }
  const [salon] = await db.select().from(salons).where(eq29(salons.id, campaign.salonId));
  if (!salon) {
    await markCampaignFailed(campaignId, "Salon not found");
    return { success: false, error: "Salon not found" };
  }
  let welcomeOffer = null;
  if (campaign.welcomeOfferId) {
    const [offer] = await db.select().from(welcomeOffers).where(eq29(welcomeOffers.id, campaign.welcomeOfferId));
    welcomeOffer = offer;
  }
  const pendingCustomers = await db.select().from(importedCustomers).where(and29(
    eq29(importedCustomers.salonId, campaign.salonId),
    eq29(importedCustomers.status, IMPORTED_CUSTOMER_STATUSES.PENDING)
  ));
  if (pendingCustomers.length === 0) {
    return { success: false, error: "No pending customers to invite" };
  }
  const channels = campaign.channel === "both" ? ["whatsapp", "sms"] : [campaign.channel];
  const totalMessages = pendingCustomers.length * channels.length;
  await db.update(invitationCampaigns).set({
    status: CAMPAIGN_STATUSES2.SENDING,
    startedAt: campaign.startedAt || /* @__PURE__ */ new Date(),
    targetCustomerCount: totalMessages
  }).where(eq29(invitationCampaigns.id, campaignId));
  let sentCount = 0;
  let deliveredCount = 0;
  let failedCount = 0;
  let processedCustomers = 0;
  try {
    for (const customer of pendingCustomers) {
      const currentCampaign = await getCampaign(campaignId);
      if (currentCampaign?.status === CAMPAIGN_STATUSES2.PAUSED) {
        console.log(`Campaign ${campaignId} paused at ${processedCustomers}/${pendingCustomers.length} customers`);
        break;
      }
      const offerCode = welcomeOffer ? generateOfferCode("WELCOME") : "";
      const offerAmount = welcomeOffer ? welcomeOffer.discountType === "percentage" ? `${welcomeOffer.discountValue}%` : `\u20B9${(welcomeOffer.discountValue / 100).toFixed(0)}` : "";
      const templateVariables = {
        customer_name: customer.customerName.split(" ")[0] || "Customer",
        salon_name: salon.name,
        offer_amount: offerAmount,
        offer_code: offerCode,
        download_link: `https://app.salonhub.com/s/${salon.id}`,
        expiry_days: welcomeOffer ? `${welcomeOffer.validityDays}` : "30"
      };
      const personalizedMessage = replaceTemplateVariables(campaign.messageTemplate, templateVariables);
      for (const channel of channels) {
        const [messageRecord] = await db.insert(invitationMessages).values({
          campaignId: campaign.id,
          importedCustomerId: customer.id,
          channel,
          status: MESSAGE_STATUSES2.PENDING
        }).returning();
        try {
          const result = await sendMessage({
            to: customer.normalizedPhone,
            message: personalizedMessage,
            channel
          });
          if (result.success && result.messageSid) {
            await db.update(invitationMessages).set({
              twilioMessageSid: result.messageSid,
              status: MESSAGE_STATUSES2.SENT,
              sentAt: /* @__PURE__ */ new Date()
            }).where(eq29(invitationMessages.id, messageRecord.id));
            sentCount++;
            if (result.status === "delivered") {
              deliveredCount++;
              await db.update(invitationMessages).set({
                status: MESSAGE_STATUSES2.DELIVERED,
                deliveredAt: /* @__PURE__ */ new Date()
              }).where(eq29(invitationMessages.id, messageRecord.id));
            }
          } else {
            failedCount++;
            await db.update(invitationMessages).set({
              status: MESSAGE_STATUSES2.FAILED,
              errorMessage: result.error || "Unknown error"
            }).where(eq29(invitationMessages.id, messageRecord.id));
          }
        } catch (error) {
          failedCount++;
          await db.update(invitationMessages).set({
            status: MESSAGE_STATUSES2.FAILED,
            errorMessage: error.message || "Send failed"
          }).where(eq29(invitationMessages.id, messageRecord.id));
        }
        await new Promise((resolve) => setTimeout(resolve, 50));
      }
      await db.update(importedCustomers).set({
        status: IMPORTED_CUSTOMER_STATUSES.INVITED,
        invitedAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq29(importedCustomers.id, customer.id));
      processedCustomers++;
      await db.update(invitationCampaigns).set({
        messagesSent: sentCount,
        messagesDelivered: deliveredCount,
        messagesFailed: failedCount
      }).where(eq29(invitationCampaigns.id, campaignId));
      if (onProgress) {
        onProgress({
          campaignId,
          totalMessages,
          sentCount,
          deliveredCount,
          failedCount,
          percentComplete: Math.round((sentCount + failedCount) / totalMessages * 100),
          status: CAMPAIGN_STATUSES2.SENDING
        });
      }
    }
    const finalCampaign = await getCampaign(campaignId);
    if (finalCampaign?.status !== CAMPAIGN_STATUSES2.PAUSED) {
      await db.update(invitationCampaigns).set({
        status: CAMPAIGN_STATUSES2.COMPLETED,
        completedAt: /* @__PURE__ */ new Date(),
        messagesSent: sentCount,
        messagesDelivered: deliveredCount,
        messagesFailed: failedCount
      }).where(eq29(invitationCampaigns.id, campaignId));
    }
    return { success: true };
  } catch (error) {
    console.error(`Campaign ${campaignId} fatal error:`, error);
    await markCampaignFailed(campaignId, error.message || "Unknown error");
    return { success: false, error: error.message || "Campaign failed unexpectedly" };
  }
}
async function markCampaignFailed(campaignId, errorMessage) {
  await db.update(invitationCampaigns).set({
    status: CAMPAIGN_STATUSES2.FAILED
  }).where(eq29(invitationCampaigns.id, campaignId));
  console.error(`Campaign ${campaignId} marked as FAILED: ${errorMessage}`);
}
async function pauseCampaign(campaignId) {
  const campaign = await getCampaign(campaignId);
  if (!campaign) {
    return { success: false, error: "Campaign not found" };
  }
  if (campaign.status !== CAMPAIGN_STATUSES2.SENDING) {
    return { success: false, error: "Campaign is not currently sending" };
  }
  await db.update(invitationCampaigns).set({ status: CAMPAIGN_STATUSES2.PAUSED }).where(eq29(invitationCampaigns.id, campaignId));
  return { success: true };
}
async function resumeCampaign(campaignId) {
  const campaign = await getCampaign(campaignId);
  if (!campaign) {
    return { success: false, error: "Campaign not found" };
  }
  if (campaign.status !== CAMPAIGN_STATUSES2.PAUSED) {
    return { success: false, error: "Campaign is not paused" };
  }
  return startCampaign(campaignId);
}
async function updateMessageDeliveryStatus(twilioMessageSid, status, errorCode, errorMessage) {
  const [message] = await db.select().from(invitationMessages).where(eq29(invitationMessages.twilioMessageSid, twilioMessageSid));
  if (!message) {
    console.log(`No message found for Twilio SID: ${twilioMessageSid}`);
    return false;
  }
  const updateData = {};
  switch (status) {
    case "delivered":
      updateData.status = MESSAGE_STATUSES2.DELIVERED;
      updateData.deliveredAt = /* @__PURE__ */ new Date();
      break;
    case "read":
      updateData.status = MESSAGE_STATUSES2.READ;
      updateData.readAt = /* @__PURE__ */ new Date();
      break;
    case "failed":
    case "undelivered":
      updateData.status = MESSAGE_STATUSES2.FAILED;
      updateData.errorMessage = errorMessage || `Error code: ${errorCode}`;
      break;
    case "sent":
    case "queued":
      updateData.status = MESSAGE_STATUSES2.SENT;
      break;
  }
  await db.update(invitationMessages).set(updateData).where(eq29(invitationMessages.id, message.id));
  await updateCampaignStats(message.campaignId);
  return true;
}
async function updateCampaignStats(campaignId) {
  const messageStats = await db.select({
    status: invitationMessages.status,
    count: count5()
  }).from(invitationMessages).where(eq29(invitationMessages.campaignId, campaignId)).groupBy(invitationMessages.status);
  let sent = 0;
  let delivered = 0;
  let failed = 0;
  for (const stat of messageStats) {
    if (stat.status === MESSAGE_STATUSES2.SENT || stat.status === MESSAGE_STATUSES2.DELIVERED || stat.status === MESSAGE_STATUSES2.READ) {
      sent += stat.count;
    }
    if (stat.status === MESSAGE_STATUSES2.DELIVERED || stat.status === MESSAGE_STATUSES2.READ) {
      delivered += stat.count;
    }
    if (stat.status === MESSAGE_STATUSES2.FAILED) {
      failed += stat.count;
    }
  }
  await db.update(invitationCampaigns).set({
    messagesSent: sent,
    messagesDelivered: delivered,
    messagesFailed: failed
  }).where(eq29(invitationCampaigns.id, campaignId));
}
async function getCampaignMessages(campaignId, options = {}) {
  const conditions = [eq29(invitationMessages.campaignId, campaignId)];
  if (options.status) {
    conditions.push(eq29(invitationMessages.status, options.status));
  }
  const [totalResult] = await db.select({ count: count5() }).from(invitationMessages).where(and29(...conditions));
  const messages = await db.select().from(invitationMessages).where(and29(...conditions)).orderBy(desc20(invitationMessages.createdAt)).limit(options.limit || 50).offset(options.offset || 0);
  return {
    messages,
    total: totalResult?.count || 0
  };
}
async function deleteCampaign(campaignId) {
  const campaign = await getCampaign(campaignId);
  if (!campaign) {
    return { success: false, error: "Campaign not found" };
  }
  if (campaign.status === CAMPAIGN_STATUSES2.SENDING) {
    return { success: false, error: "Cannot delete a campaign that is currently sending" };
  }
  await db.delete(invitationCampaigns).where(eq29(invitationCampaigns.id, campaignId));
  return { success: true };
}

// server/routes/campaign.routes.ts
var router18 = Router17();
var createCampaignSchema = z14.object({
  name: z14.string().min(1, "Campaign name is required").max(255),
  channel: z14.enum(["whatsapp", "sms", "both"]),
  messageTemplate: z14.string().min(1, "Message template is required"),
  welcomeOfferId: z14.string().optional(),
  scheduledFor: z14.string().datetime().optional().transform((val) => val ? new Date(val) : void 0)
});
router18.post(
  "/salons/:salonId/invitation-campaigns",
  requireSalonAccess(["owner", "shop_admin"]),
  async (req, res) => {
    try {
      const { salonId } = req.params;
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      const parseResult = createCampaignSchema.safeParse(req.body);
      if (!parseResult.success) {
        return res.status(400).json({
          error: "Validation failed",
          details: parseResult.error.errors
        });
      }
      const campaign = await createCampaign({
        salonId,
        createdBy: userId,
        ...parseResult.data
      });
      res.status(201).json(campaign);
    } catch (error) {
      console.error("Error creating campaign:", error);
      res.status(500).json({ error: error.message || "Failed to create campaign" });
    }
  }
);
router18.get(
  "/salons/:salonId/invitation-campaigns",
  requireSalonAccess(["owner", "shop_admin", "staff"]),
  async (req, res) => {
    try {
      const { salonId } = req.params;
      const campaigns = await getCampaignsBySalon(salonId);
      res.json(campaigns);
    } catch (error) {
      console.error("Error fetching campaigns:", error);
      res.status(500).json({ error: error.message || "Failed to fetch campaigns" });
    }
  }
);
router18.get(
  "/salons/:salonId/invitation-campaigns/:campaignId",
  requireSalonAccess(["owner", "shop_admin", "staff"]),
  async (req, res) => {
    try {
      const { campaignId } = req.params;
      const campaign = await getCampaign(campaignId);
      if (!campaign) {
        return res.status(404).json({ error: "Campaign not found" });
      }
      res.json(campaign);
    } catch (error) {
      console.error("Error fetching campaign:", error);
      res.status(500).json({ error: error.message || "Failed to fetch campaign" });
    }
  }
);
router18.get(
  "/salons/:salonId/invitation-campaigns/:campaignId/stats",
  requireSalonAccess(["owner", "shop_admin", "staff"]),
  async (req, res) => {
    try {
      const { campaignId } = req.params;
      const stats = await getCampaignStats(campaignId);
      if (!stats) {
        return res.status(404).json({ error: "Campaign not found" });
      }
      res.json(stats);
    } catch (error) {
      console.error("Error fetching campaign stats:", error);
      res.status(500).json({ error: error.message || "Failed to fetch stats" });
    }
  }
);
router18.post(
  "/salons/:salonId/invitation-campaigns/:campaignId/send",
  requireSalonAccess(["owner", "shop_admin"]),
  async (req, res) => {
    try {
      const { salonId, campaignId } = req.params;
      const validation = await validateCampaignStart(campaignId);
      if (!validation.success) {
        return res.status(400).json({ error: validation.error });
      }
      if (validation.campaign && validation.campaign.salonId !== salonId) {
        return res.status(403).json({ error: "Campaign does not belong to this salon" });
      }
      res.json({
        message: "Campaign sending started",
        campaignId,
        status: CAMPAIGN_STATUSES2.SENDING,
        targetCount: validation.pendingCount
      });
      startCampaign(campaignId).then((result) => {
        if (!result.success) {
          console.error(`Campaign ${campaignId} failed:`, result.error);
        } else {
          console.log(`Campaign ${campaignId} completed successfully`);
        }
      }).catch((error) => {
        console.error(`Campaign ${campaignId} error:`, error);
      });
    } catch (error) {
      console.error("Error starting campaign:", error);
      res.status(500).json({ error: error.message || "Failed to start campaign" });
    }
  }
);
router18.post(
  "/salons/:salonId/invitation-campaigns/:campaignId/pause",
  requireSalonAccess(["owner", "shop_admin"]),
  async (req, res) => {
    try {
      const { salonId, campaignId } = req.params;
      const campaign = await getCampaign(campaignId);
      if (!campaign) {
        return res.status(404).json({ error: "Campaign not found" });
      }
      if (campaign.salonId !== salonId) {
        return res.status(403).json({ error: "Campaign does not belong to this salon" });
      }
      const result = await pauseCampaign(campaignId);
      if (!result.success) {
        return res.status(400).json({ error: result.error });
      }
      res.json({
        message: "Campaign paused",
        campaignId,
        status: CAMPAIGN_STATUSES2.PAUSED
      });
    } catch (error) {
      console.error("Error pausing campaign:", error);
      res.status(500).json({ error: error.message || "Failed to pause campaign" });
    }
  }
);
router18.post(
  "/salons/:salonId/invitation-campaigns/:campaignId/resume",
  requireSalonAccess(["owner", "shop_admin"]),
  async (req, res) => {
    try {
      const { salonId, campaignId } = req.params;
      const campaign = await getCampaign(campaignId);
      if (!campaign) {
        return res.status(404).json({ error: "Campaign not found" });
      }
      if (campaign.salonId !== salonId) {
        return res.status(403).json({ error: "Campaign does not belong to this salon" });
      }
      if (campaign.status !== CAMPAIGN_STATUSES2.PAUSED) {
        return res.status(400).json({ error: "Campaign is not paused" });
      }
      res.json({
        message: "Campaign resuming",
        campaignId,
        status: CAMPAIGN_STATUSES2.SENDING
      });
      resumeCampaign(campaignId).then((result) => {
        if (!result.success) {
          console.error(`Campaign ${campaignId} resume failed:`, result.error);
        }
      }).catch((error) => {
        console.error(`Campaign ${campaignId} resume error:`, error);
      });
    } catch (error) {
      console.error("Error resuming campaign:", error);
      res.status(500).json({ error: error.message || "Failed to resume campaign" });
    }
  }
);
router18.get(
  "/salons/:salonId/invitation-campaigns/:campaignId/messages",
  requireSalonAccess(["owner", "shop_admin", "staff"]),
  async (req, res) => {
    try {
      const { campaignId } = req.params;
      const { status, limit, offset } = req.query;
      const result = await getCampaignMessages(campaignId, {
        status,
        limit: limit ? parseInt(limit, 10) : void 0,
        offset: offset ? parseInt(offset, 10) : void 0
      });
      res.json(result);
    } catch (error) {
      console.error("Error fetching messages:", error);
      res.status(500).json({ error: error.message || "Failed to fetch messages" });
    }
  }
);
router18.delete(
  "/salons/:salonId/invitation-campaigns/:campaignId",
  requireSalonAccess(["owner"]),
  async (req, res) => {
    try {
      const { salonId, campaignId } = req.params;
      const campaign = await getCampaign(campaignId);
      if (!campaign) {
        return res.status(404).json({ error: "Campaign not found" });
      }
      if (campaign.salonId !== salonId) {
        return res.status(403).json({ error: "Campaign does not belong to this salon" });
      }
      const result = await deleteCampaign(campaignId);
      if (!result.success) {
        return res.status(400).json({ error: result.error });
      }
      res.json({ message: "Campaign deleted successfully" });
    } catch (error) {
      console.error("Error deleting campaign:", error);
      res.status(500).json({ error: error.message || "Failed to delete campaign" });
    }
  }
);
function registerTwilioWebhook(app2) {
  app2.post("/api/webhooks/twilio/status", express2.urlencoded({ extended: false }), async (req, res) => {
    try {
      const payload = parseStatusCallback(req.body);
      if (!payload) {
        console.warn("Invalid Twilio status callback payload:", req.body);
        return res.sendStatus(400);
      }
      console.log(`Twilio status update: ${payload.messageSid} -> ${payload.status}`);
      await updateMessageDeliveryStatus(
        payload.messageSid,
        payload.status,
        payload.errorCode,
        payload.errorMessage
      );
      res.sendStatus(200);
    } catch (error) {
      console.error("Error processing Twilio webhook:", error);
      res.sendStatus(500);
    }
  });
}
function registerCampaignRoutes(app2) {
  app2.use("/api", router18);
  registerTwilioWebhook(app2);
}

// server/routes/welcome-offer.routes.ts
import { Router as Router18 } from "express";
import { z as z15 } from "zod";
init_storage();
var router19 = Router18();
var createOfferSchema2 = z15.object({
  name: z15.string().min(1, "Offer name is required").max(255),
  discountType: z15.enum(["percentage", "fixed"]),
  discountValue: z15.number().positive("Discount value must be positive"),
  maxDiscountInPaisa: z15.number().positive().optional(),
  minimumPurchaseInPaisa: z15.number().positive().optional(),
  validityDays: z15.number().min(1).max(365).optional().default(30),
  usageLimit: z15.number().min(1).max(100).optional().default(1)
});
var updateOfferSchema2 = z15.object({
  name: z15.string().min(1).max(255).optional(),
  discountType: z15.enum(["percentage", "fixed"]).optional(),
  discountValue: z15.number().positive().optional(),
  maxDiscountInPaisa: z15.number().positive().nullable().optional(),
  minimumPurchaseInPaisa: z15.number().positive().nullable().optional(),
  validityDays: z15.number().min(1).max(365).optional(),
  usageLimit: z15.number().min(1).max(100).optional(),
  isActive: z15.number().min(0).max(1).optional()
});
var redeemOfferSchema = z15.object({
  bookingId: z15.string().min(1, "Booking ID is required"),
  bookingAmountInPaisa: z15.number().positive("Booking amount must be positive")
});
var validateOfferSchema = z15.object({
  bookingAmountInPaisa: z15.number().positive("Booking amount must be positive")
});
router19.post(
  "/salons/:salonId/welcome-offers",
  requireSalonAccess(["owner", "shop_admin"]),
  async (req, res) => {
    try {
      const { salonId } = req.params;
      const parseResult = createOfferSchema2.safeParse(req.body);
      if (!parseResult.success) {
        return res.status(400).json({
          error: "Validation failed",
          details: parseResult.error.errors
        });
      }
      const offer = await createWelcomeOffer({
        salonId,
        ...parseResult.data
      });
      res.status(201).json(offer);
    } catch (error) {
      console.error("Error creating welcome offer:", error);
      res.status(500).json({ error: error.message || "Failed to create offer" });
    }
  }
);
router19.get(
  "/salons/:salonId/welcome-offers",
  requireSalonAccess(["owner", "shop_admin", "staff"]),
  async (req, res) => {
    try {
      const { salonId } = req.params;
      const offers = await getWelcomeOffersBySalon(salonId);
      res.json(offers);
    } catch (error) {
      console.error("Error fetching welcome offers:", error);
      res.status(500).json({ error: error.message || "Failed to fetch offers" });
    }
  }
);
router19.get(
  "/salons/:salonId/welcome-offers/:offerId",
  requireSalonAccess(["owner", "shop_admin", "staff"]),
  async (req, res) => {
    try {
      const { salonId, offerId } = req.params;
      const offer = await getWelcomeOffer(offerId);
      if (!offer) {
        return res.status(404).json({ error: "Offer not found" });
      }
      if (offer.salonId !== salonId) {
        return res.status(403).json({ error: "Offer does not belong to this salon" });
      }
      res.json(offer);
    } catch (error) {
      console.error("Error fetching welcome offer:", error);
      res.status(500).json({ error: error.message || "Failed to fetch offer" });
    }
  }
);
router19.put(
  "/salons/:salonId/welcome-offers/:offerId",
  requireSalonAccess(["owner", "shop_admin"]),
  async (req, res) => {
    try {
      const { salonId, offerId } = req.params;
      const existingOffer = await getWelcomeOffer(offerId);
      if (!existingOffer) {
        return res.status(404).json({ error: "Offer not found" });
      }
      if (existingOffer.salonId !== salonId) {
        return res.status(403).json({ error: "Offer does not belong to this salon" });
      }
      const parseResult = updateOfferSchema2.safeParse(req.body);
      if (!parseResult.success) {
        return res.status(400).json({
          error: "Validation failed",
          details: parseResult.error.errors
        });
      }
      const offer = await updateWelcomeOffer(offerId, parseResult.data);
      res.json(offer);
    } catch (error) {
      console.error("Error updating welcome offer:", error);
      res.status(500).json({ error: error.message || "Failed to update offer" });
    }
  }
);
router19.delete(
  "/salons/:salonId/welcome-offers/:offerId",
  requireSalonAccess(["owner"]),
  async (req, res) => {
    try {
      const { salonId, offerId } = req.params;
      const existingOffer = await getWelcomeOffer(offerId);
      if (!existingOffer) {
        return res.status(404).json({ error: "Offer not found" });
      }
      if (existingOffer.salonId !== salonId) {
        return res.status(403).json({ error: "Offer does not belong to this salon" });
      }
      const result = await deleteWelcomeOffer(offerId);
      if (!result.success) {
        return res.status(400).json({ error: result.error });
      }
      res.json({ message: "Offer deleted successfully" });
    } catch (error) {
      console.error("Error deleting welcome offer:", error);
      res.status(500).json({ error: error.message || "Failed to delete offer" });
    }
  }
);
router19.post(
  "/salons/:salonId/welcome-offers/:offerId/toggle",
  requireSalonAccess(["owner", "shop_admin"]),
  async (req, res) => {
    try {
      const { salonId, offerId } = req.params;
      const existingOffer = await getWelcomeOffer(offerId);
      if (!existingOffer) {
        return res.status(404).json({ error: "Offer not found" });
      }
      if (existingOffer.salonId !== salonId) {
        return res.status(403).json({ error: "Offer does not belong to this salon" });
      }
      const offer = await toggleWelcomeOfferActive(offerId);
      res.json(offer);
    } catch (error) {
      console.error("Error toggling welcome offer:", error);
      res.status(500).json({ error: error.message || "Failed to toggle offer" });
    }
  }
);
router19.post(
  "/salons/:salonId/welcome-offers/:offerId/validate",
  requireSalonAccess(["owner", "shop_admin", "staff"]),
  async (req, res) => {
    try {
      const { offerId } = req.params;
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      const parseResult = validateOfferSchema.safeParse(req.body);
      if (!parseResult.success) {
        return res.status(400).json({
          error: "Validation failed",
          details: parseResult.error.errors
        });
      }
      const result = await validateWelcomeOffer(
        offerId,
        userId,
        parseResult.data.bookingAmountInPaisa
      );
      res.json({
        valid: result.valid,
        discountInPaisa: result.discount,
        discountFormatted: result.offer ? formatOfferAmount(result.offer) : null,
        reason: result.reason
      });
    } catch (error) {
      console.error("Error validating welcome offer:", error);
      res.status(500).json({ error: error.message || "Failed to validate offer" });
    }
  }
);
router19.post(
  "/salons/:salonId/welcome-offers/:offerId/redeem",
  requireSalonAccess(["owner", "shop_admin", "staff"]),
  async (req, res) => {
    try {
      const { salonId, offerId } = req.params;
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      const existingOffer = await getWelcomeOffer(offerId);
      if (!existingOffer) {
        return res.status(404).json({ error: "Offer not found" });
      }
      if (existingOffer.salonId !== salonId) {
        return res.status(403).json({ error: "Offer does not belong to this salon" });
      }
      const parseResult = redeemOfferSchema.safeParse(req.body);
      if (!parseResult.success) {
        return res.status(400).json({
          error: "Validation failed",
          details: parseResult.error.errors
        });
      }
      const result = await redeemWelcomeOffer(
        offerId,
        userId,
        parseResult.data.bookingId,
        parseResult.data.bookingAmountInPaisa
      );
      if (!result.success) {
        return res.status(400).json({ error: result.error });
      }
      res.json({
        message: "Offer redeemed successfully",
        redemption: result.redemption,
        discountAppliedInPaisa: result.redemption?.discountAppliedInPaisa
      });
    } catch (error) {
      console.error("Error redeeming welcome offer:", error);
      res.status(500).json({ error: error.message || "Failed to redeem offer" });
    }
  }
);
router19.get(
  "/salons/:salonId/welcome-offers/:offerId/redemptions",
  requireSalonAccess(["owner", "shop_admin"]),
  async (req, res) => {
    try {
      const { salonId, offerId } = req.params;
      const { limit, offset } = req.query;
      const existingOffer = await getWelcomeOffer(offerId);
      if (!existingOffer) {
        return res.status(404).json({ error: "Offer not found" });
      }
      if (existingOffer.salonId !== salonId) {
        return res.status(403).json({ error: "Offer does not belong to this salon" });
      }
      const result = await getOfferRedemptions(offerId, {
        limit: limit ? parseInt(limit, 10) : void 0,
        offset: offset ? parseInt(offset, 10) : void 0
      });
      res.json(result);
    } catch (error) {
      console.error("Error fetching redemptions:", error);
      res.status(500).json({ error: error.message || "Failed to fetch redemptions" });
    }
  }
);
router19.get(
  "/salons/:salonId/welcome-offers/generate-code",
  requireSalonAccess(["owner", "shop_admin"]),
  async (req, res) => {
    try {
      const { prefix } = req.query;
      const code = generateOfferCode(prefix || "WELCOME");
      res.json({ code });
    } catch (error) {
      console.error("Error generating offer code:", error);
      res.status(500).json({ error: error.message || "Failed to generate code" });
    }
  }
);
router19.get(
  "/mobile/check-imported-customer",
  authenticateMobileUser,
  async (req, res) => {
    try {
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      const user = await storage.getUserById(userId);
      if (!user || !user.phone) {
        return res.status(400).json({ error: "No verified phone number on account" });
      }
      const result = await checkImportedCustomerByPhone(user.phone);
      res.json(result);
    } catch (error) {
      console.error("Error checking imported customer:", error);
      res.status(500).json({ error: error.message || "Failed to check customer" });
    }
  }
);
router19.post(
  "/mobile/apply-welcome-offers",
  authenticateMobileUser,
  async (req, res) => {
    try {
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      const user = await storage.getUserById(userId);
      if (!user) {
        return res.status(401).json({ error: "User not found" });
      }
      if (!user.phone) {
        return res.status(400).json({ error: "No verified phone number on account" });
      }
      const result = await autoApplyWelcomeOfferOnRegistration(userId, user.phone);
      res.json(result);
    } catch (error) {
      console.error("Error applying welcome offers:", error);
      res.status(500).json({ error: error.message || "Failed to apply offers" });
    }
  }
);
router19.get(
  "/mobile/my-offers",
  authenticateMobileUser,
  async (req, res) => {
    try {
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      const offers = await getUserActiveOffers(userId);
      res.json({
        offers: offers.map(({ redemption, offer }) => ({
          redemptionId: redemption.id,
          offerId: offer.id,
          offerName: offer.name,
          salonId: offer.salonId,
          discountType: offer.discountType,
          discountValue: offer.discountValue,
          discountFormatted: formatOfferAmount(offer),
          maxDiscountInPaisa: offer.maxDiscountInPaisa,
          minimumPurchaseInPaisa: offer.minimumPurchaseInPaisa,
          expiresAt: redemption.expiresAt,
          status: redemption.status
        }))
      });
    } catch (error) {
      console.error("Error fetching user offers:", error);
      res.status(500).json({ error: error.message || "Failed to fetch offers" });
    }
  }
);
function registerWelcomeOfferRoutes(app2) {
  app2.use("/api", router19);
}

// server/routes/onboarding-analytics.routes.ts
import { Router as Router19 } from "express";

// server/services/onboardingAnalyticsService.ts
init_db();
init_schema();
import { eq as eq30, sql as sql27, and as and30, gte as gte10, count as count6, sum as sum2 } from "drizzle-orm";
var OnboardingAnalyticsService = class {
  async getImportMetrics(salonId) {
    const now = /* @__PURE__ */ new Date();
    const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1e3);
    const monthAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1e3);
    const [totalResult] = await db.select({ count: count6() }).from(importedCustomers).where(eq30(importedCustomers.salonId, salonId));
    const [weekResult] = await db.select({ count: count6() }).from(importedCustomers).where(
      and30(
        eq30(importedCustomers.salonId, salonId),
        gte10(importedCustomers.createdAt, weekAgo)
      )
    );
    const [monthResult] = await db.select({ count: count6() }).from(importedCustomers).where(
      and30(
        eq30(importedCustomers.salonId, salonId),
        gte10(importedCustomers.createdAt, monthAgo)
      )
    );
    const batches = await db.select({
      batchId: customerImportBatches.id,
      fileName: customerImportBatches.fileName,
      totalRecords: customerImportBatches.totalRecords,
      successfulImports: customerImportBatches.successfulImports,
      failedImports: customerImportBatches.failedImports,
      duplicateSkipped: customerImportBatches.duplicateSkipped,
      createdAt: customerImportBatches.createdAt
    }).from(customerImportBatches).where(eq30(customerImportBatches.salonId, salonId)).orderBy(sql27`${customerImportBatches.createdAt} DESC`).limit(20);
    return {
      totalImported: totalResult?.count || 0,
      thisWeek: weekResult?.count || 0,
      thisMonth: monthResult?.count || 0,
      byBatch: batches
    };
  }
  async getCampaignMetrics(salonId) {
    const campaigns = await db.select({
      campaignId: invitationCampaigns.id,
      name: invitationCampaigns.name,
      channel: invitationCampaigns.channel,
      status: invitationCampaigns.status,
      targetCount: invitationCampaigns.targetCustomerCount,
      sent: invitationCampaigns.messagesSent,
      delivered: invitationCampaigns.messagesDelivered,
      failed: invitationCampaigns.messagesFailed,
      createdAt: invitationCampaigns.createdAt
    }).from(invitationCampaigns).where(eq30(invitationCampaigns.salonId, salonId)).orderBy(sql27`${invitationCampaigns.createdAt} DESC`);
    const totalSent = campaigns.reduce((sum4, c) => sum4 + (c.sent || 0), 0);
    const totalDelivered = campaigns.reduce((sum4, c) => sum4 + (c.delivered || 0), 0);
    const totalFailed = campaigns.reduce((sum4, c) => sum4 + (c.failed || 0), 0);
    return {
      totalCampaigns: campaigns.length,
      totalMessagesSent: totalSent,
      totalMessagesDelivered: totalDelivered,
      totalMessagesFailed: totalFailed,
      deliveryRate: totalSent > 0 ? Math.round(totalDelivered / totalSent * 100) : 0,
      byCampaign: campaigns.map((c) => ({
        ...c,
        deliveryRate: c.sent > 0 ? Math.round(c.delivered / c.sent * 100) : 0
      }))
    };
  }
  async getConversionMetrics(salonId) {
    const [totalResult] = await db.select({ count: count6() }).from(importedCustomers).where(eq30(importedCustomers.salonId, salonId));
    const [invitedResult] = await db.select({ count: count6() }).from(importedCustomers).where(
      and30(
        eq30(importedCustomers.salonId, salonId),
        sql27`${importedCustomers.status} IN ('invited', 'registered')`
      )
    );
    const [registeredResult] = await db.select({ count: count6() }).from(importedCustomers).where(
      and30(
        eq30(importedCustomers.salonId, salonId),
        eq30(importedCustomers.status, "registered")
      )
    );
    const total = totalResult?.count || 0;
    const invited = invitedResult?.count || 0;
    const registered = registeredResult?.count || 0;
    return {
      totalImported: total,
      totalInvited: invited,
      totalRegistered: registered,
      importToInviteRate: total > 0 ? Math.round(invited / total * 100) : 0,
      inviteToRegisterRate: invited > 0 ? Math.round(registered / invited * 100) : 0,
      overallConversionRate: total > 0 ? Math.round(registered / total * 100) : 0
    };
  }
  async getOfferMetrics(salonId) {
    const offers = await db.select({
      offerId: welcomeOffers.id,
      offerName: welcomeOffers.name,
      discountType: welcomeOffers.discountType,
      discountValue: welcomeOffers.discountValue,
      totalRedemptions: welcomeOffers.totalRedemptions,
      isActive: welcomeOffers.isActive
    }).from(welcomeOffers).where(eq30(welcomeOffers.salonId, salonId));
    const redemptionTotals = await db.select({
      welcomeOfferId: welcomeOfferRedemptions.welcomeOfferId,
      totalDiscount: sum2(welcomeOfferRedemptions.discountAppliedInPaisa),
      redemptionCount: count6()
    }).from(welcomeOfferRedemptions).innerJoin(welcomeOffers, eq30(welcomeOfferRedemptions.welcomeOfferId, welcomeOffers.id)).where(eq30(welcomeOffers.salonId, salonId)).groupBy(welcomeOfferRedemptions.welcomeOfferId);
    const redemptionMap = new Map(
      redemptionTotals.map((r) => [
        r.welcomeOfferId,
        { totalDiscount: Number(r.totalDiscount) || 0, count: r.redemptionCount || 0 }
      ])
    );
    const totalRedemptions = offers.reduce((sum4, o) => sum4 + (o.totalRedemptions || 0), 0);
    const totalDiscountGiven = Array.from(redemptionMap.values()).reduce(
      (sum4, r) => sum4 + r.totalDiscount,
      0
    );
    return {
      totalOffers: offers.length,
      activeOffers: offers.filter((o) => o.isActive === 1).length,
      totalRedemptions,
      totalDiscountGivenInPaisa: totalDiscountGiven,
      redemptionsByOffer: offers.map((o) => ({
        offerId: o.offerId,
        offerName: o.offerName,
        discountType: o.discountType,
        discountValue: o.discountValue,
        totalRedemptions: o.totalRedemptions || 0,
        totalDiscountGiven: redemptionMap.get(o.offerId)?.totalDiscount || 0,
        isActive: o.isActive === 1
      }))
    };
  }
  async getConversionFunnel(salonId) {
    const [importedResult] = await db.select({ count: count6() }).from(importedCustomers).where(eq30(importedCustomers.salonId, salonId));
    const [invitedResult] = await db.select({ count: count6() }).from(importedCustomers).where(
      and30(
        eq30(importedCustomers.salonId, salonId),
        sql27`${importedCustomers.status} IN ('invited', 'registered')`
      )
    );
    const [deliveredResult] = await db.select({ count: sql27`COUNT(DISTINCT ${invitationMessages.importedCustomerId})` }).from(invitationMessages).innerJoin(importedCustomers, eq30(invitationMessages.importedCustomerId, importedCustomers.id)).where(
      and30(
        eq30(importedCustomers.salonId, salonId),
        eq30(invitationMessages.status, "delivered")
      )
    );
    const [registeredResult] = await db.select({ count: count6() }).from(importedCustomers).where(
      and30(
        eq30(importedCustomers.salonId, salonId),
        eq30(importedCustomers.status, "registered")
      )
    );
    const [bookingResult] = await db.execute(sql27`
      SELECT COUNT(DISTINCT ic.id) as count
      FROM imported_customers ic
      INNER JOIN users u ON ic.linked_user_id = u.id
      INNER JOIN bookings b ON b.customer_id = u.id
      WHERE ic.salon_id = ${salonId}
      AND ic.status = 'registered'
    `);
    const imported = importedResult?.count || 0;
    const invited = invitedResult?.count || 0;
    const delivered = deliveredResult?.count || 0;
    const registered = registeredResult?.count || 0;
    const firstBooking = Number(bookingResult?.[0]?.count) || 0;
    return {
      imported,
      invited,
      delivered,
      registered,
      firstBooking,
      rates: {
        importToInvite: imported > 0 ? Math.round(invited / imported * 100) : 0,
        inviteToDelivered: invited > 0 ? Math.round(delivered / invited * 100) : 0,
        deliveredToRegistered: delivered > 0 ? Math.round(registered / delivered * 100) : 0,
        registeredToBooking: registered > 0 ? Math.round(firstBooking / registered * 100) : 0,
        overallConversion: imported > 0 ? Math.round(firstBooking / imported * 100) : 0
      }
    };
  }
  async getFullAnalytics(salonId) {
    const [importMetrics, campaignMetrics, conversionMetrics, offerMetrics, funnel] = await Promise.all([
      this.getImportMetrics(salonId),
      this.getCampaignMetrics(salonId),
      this.getConversionMetrics(salonId),
      this.getOfferMetrics(salonId),
      this.getConversionFunnel(salonId)
    ]);
    return {
      importMetrics,
      campaignMetrics,
      conversionMetrics,
      offerMetrics,
      funnel
    };
  }
};
var onboardingAnalyticsService = new OnboardingAnalyticsService();

// server/routes/onboarding-analytics.routes.ts
var router20 = Router19();
router20.get(
  "/salons/:salonId/onboarding-analytics",
  requireSalonAccess(["owner", "shop_admin"]),
  async (req, res) => {
    try {
      const { salonId } = req.params;
      const analytics = await onboardingAnalyticsService.getFullAnalytics(salonId);
      res.json(analytics);
    } catch (error) {
      console.error("Error fetching onboarding analytics:", error);
      res.status(500).json({ error: "Failed to fetch onboarding analytics" });
    }
  }
);
router20.get(
  "/salons/:salonId/onboarding-analytics/import",
  requireSalonAccess(["owner", "shop_admin"]),
  async (req, res) => {
    try {
      const { salonId } = req.params;
      const importMetrics = await onboardingAnalyticsService.getImportMetrics(salonId);
      res.json(importMetrics);
    } catch (error) {
      console.error("Error fetching import metrics:", error);
      res.status(500).json({ error: "Failed to fetch import metrics" });
    }
  }
);
router20.get(
  "/salons/:salonId/onboarding-analytics/campaigns",
  requireSalonAccess(["owner", "shop_admin"]),
  async (req, res) => {
    try {
      const { salonId } = req.params;
      const campaignMetrics = await onboardingAnalyticsService.getCampaignMetrics(salonId);
      res.json(campaignMetrics);
    } catch (error) {
      console.error("Error fetching campaign metrics:", error);
      res.status(500).json({ error: "Failed to fetch campaign metrics" });
    }
  }
);
router20.get(
  "/salons/:salonId/onboarding-analytics/conversions",
  requireSalonAccess(["owner", "shop_admin"]),
  async (req, res) => {
    try {
      const { salonId } = req.params;
      const conversionMetrics = await onboardingAnalyticsService.getConversionMetrics(salonId);
      res.json(conversionMetrics);
    } catch (error) {
      console.error("Error fetching conversion metrics:", error);
      res.status(500).json({ error: "Failed to fetch conversion metrics" });
    }
  }
);
router20.get(
  "/salons/:salonId/onboarding-analytics/offers",
  requireSalonAccess(["owner", "shop_admin"]),
  async (req, res) => {
    try {
      const { salonId } = req.params;
      const offerMetrics = await onboardingAnalyticsService.getOfferMetrics(salonId);
      res.json(offerMetrics);
    } catch (error) {
      console.error("Error fetching offer metrics:", error);
      res.status(500).json({ error: "Failed to fetch offer metrics" });
    }
  }
);
router20.get(
  "/salons/:salonId/onboarding-analytics/funnel",
  requireSalonAccess(["owner", "shop_admin"]),
  async (req, res) => {
    try {
      const { salonId } = req.params;
      const funnel = await onboardingAnalyticsService.getConversionFunnel(salonId);
      res.json(funnel);
    } catch (error) {
      console.error("Error fetching conversion funnel:", error);
      res.status(500).json({ error: "Failed to fetch conversion funnel" });
    }
  }
);
function registerOnboardingAnalyticsRoutes(app2) {
  app2.use("/api", router20);
}

// server/routes/phone-verification.routes.ts
init_db();
init_schema();
import { Router as Router20 } from "express";
import { eq as eq31, and as and31, gt as gt4, desc as desc21 } from "drizzle-orm";
import crypto9 from "crypto";
import rateLimit5 from "express-rate-limit";
var router21 = Router20();
var OTP_EXPIRY_MINUTES = 10;
var SESSION_EXPIRY_MINUTES = 30;
var MAX_OTP_ATTEMPTS = 3;
var MAX_RESEND_PER_PHONE_PER_HOUR = 5;
function generateOTP() {
  return crypto9.randomInt(1e5, 1e6).toString();
}
function hashOTP(otp) {
  return crypto9.createHash("sha256").update(otp).digest("hex");
}
function generateSessionId() {
  return crypto9.randomBytes(32).toString("hex");
}
var otpRequestLimiter = rateLimit5({
  windowMs: 60 * 60 * 1e3,
  max: 10,
  message: { error: "Too many OTP requests. Please try again later." },
  standardHeaders: true,
  legacyHeaders: false
});
var otpVerifyLimiter = rateLimit5({
  windowMs: 15 * 60 * 1e3,
  max: 20,
  message: { error: "Too many verification attempts. Please try again later." },
  standardHeaders: true,
  legacyHeaders: false
});
router21.post("/request", otpRequestLimiter, async (req, res) => {
  try {
    const { phone, context = "booking" } = req.body;
    if (!phone) {
      return res.status(400).json({ error: "Phone number is required" });
    }
    let normalizedPhone;
    try {
      normalizedPhone = normalizePhoneNumber2(phone);
    } catch (err) {
      return res.status(400).json({ error: "Invalid phone number format" });
    }
    const oneHourAgo = new Date(Date.now() - 60 * 60 * 1e3);
    const recentRequests = await db.query.phoneVerificationTokens.findMany({
      where: and31(
        eq31(phoneVerificationTokens.phone, normalizedPhone),
        gt4(phoneVerificationTokens.createdAt, oneHourAgo)
      )
    });
    if (recentRequests.length >= MAX_RESEND_PER_PHONE_PER_HOUR) {
      return res.status(429).json({
        error: "Too many OTP requests for this number. Please try again later.",
        retryAfterMinutes: 60
      });
    }
    const otp = generateOTP();
    const codeHash = hashOTP(otp);
    const expiresAt = new Date(Date.now() + OTP_EXPIRY_MINUTES * 60 * 1e3);
    const messageResult = await sendMessage({
      to: normalizedPhone,
      message: `Your SalonHub verification code is: ${otp}. This code expires in ${OTP_EXPIRY_MINUTES} minutes. Do not share this code with anyone.`,
      channel: "sms"
    });
    if (!messageResult.success) {
      console.error("Failed to send OTP SMS:", messageResult.error);
      return res.status(500).json({ error: "Failed to send verification code. Please try again." });
    }
    await db.insert(phoneVerificationTokens).values({
      phone: normalizedPhone,
      codeHash,
      context,
      expiresAt,
      attempts: 0,
      maxAttempts: MAX_OTP_ATTEMPTS
    });
    console.log(`\u{1F4F1} OTP sent to ${normalizedPhone} (context: ${context})`);
    res.json({
      success: true,
      message: "Verification code sent successfully",
      expiresInMinutes: OTP_EXPIRY_MINUTES,
      phone: normalizedPhone
    });
  } catch (error) {
    console.error("Error requesting OTP:", error);
    res.status(500).json({ error: "Failed to send verification code" });
  }
});
router21.post("/verify", otpVerifyLimiter, async (req, res) => {
  try {
    const { phone, code } = req.body;
    if (!phone || !code) {
      return res.status(400).json({ error: "Phone number and verification code are required" });
    }
    let normalizedPhone;
    try {
      normalizedPhone = normalizePhoneNumber2(phone);
    } catch (err) {
      return res.status(400).json({ error: "Invalid phone number format" });
    }
    const now = /* @__PURE__ */ new Date();
    const token = await db.query.phoneVerificationTokens.findFirst({
      where: and31(
        eq31(phoneVerificationTokens.phone, normalizedPhone),
        gt4(phoneVerificationTokens.expiresAt, now)
      ),
      orderBy: [desc21(phoneVerificationTokens.createdAt)]
    });
    if (!token) {
      return res.status(400).json({
        error: "No valid verification code found. Please request a new code.",
        expired: true
      });
    }
    if (token.verifiedAt) {
      return res.status(400).json({
        error: "This code has already been used. Please request a new code."
      });
    }
    if (token.attempts >= token.maxAttempts) {
      return res.status(400).json({
        error: "Maximum verification attempts exceeded. Please request a new code.",
        maxAttemptsReached: true
      });
    }
    const codeHash = hashOTP(code);
    if (codeHash !== token.codeHash) {
      await db.update(phoneVerificationTokens).set({ attempts: token.attempts + 1 }).where(eq31(phoneVerificationTokens.id, token.id));
      const remainingAttempts = token.maxAttempts - token.attempts - 1;
      return res.status(400).json({
        error: "Invalid verification code",
        remainingAttempts
      });
    }
    const sessionId = generateSessionId();
    const sessionExpiresAt = new Date(Date.now() + SESSION_EXPIRY_MINUTES * 60 * 1e3);
    await db.update(phoneVerificationTokens).set({
      verifiedAt: now,
      verificationSessionId: sessionId,
      sessionExpiresAt
    }).where(eq31(phoneVerificationTokens.id, token.id));
    const updatedE164 = await db.update(users).set({ phoneVerified: 1 }).where(eq31(users.phone, normalizedPhone)).returning({ id: users.id });
    if (updatedE164.length === 0) {
      const legacyPhone = normalizedPhone.replace(/^\+\d+/, "");
      await db.update(users).set({ phoneVerified: 1, phone: normalizedPhone }).where(eq31(users.phone, legacyPhone));
    }
    console.log(`\u2705 Phone verified: ${normalizedPhone} (session: ${sessionId.substring(0, 8)}...)`);
    res.json({
      success: true,
      message: "Phone number verified successfully",
      verificationSessionId: sessionId,
      sessionExpiresInMinutes: SESSION_EXPIRY_MINUTES,
      phone: normalizedPhone
    });
  } catch (error) {
    console.error("Error verifying OTP:", error);
    res.status(500).json({ error: "Failed to verify code" });
  }
});
router21.get("/status", async (req, res) => {
  try {
    const { phone, createSession } = req.query;
    if (!phone || typeof phone !== "string") {
      return res.status(400).json({ error: "Phone number is required" });
    }
    let e164Phone;
    let nationalNumber;
    if (phone.startsWith("+")) {
      e164Phone = phone;
      nationalNumber = phone.replace(/\D/g, "").slice(-10);
    } else {
      nationalNumber = phone.replace(/\D/g, "").slice(-10);
      e164Phone = "+91" + nationalNumber;
    }
    if (nationalNumber.length < 8 || nationalNumber.length > 12) {
      return res.status(400).json({ error: "Invalid phone number format" });
    }
    let existingUser = await db.query.users.findFirst({
      where: eq31(users.phone, e164Phone)
    });
    if (!existingUser) {
      existingUser = await db.query.users.findFirst({
        where: eq31(users.phone, nationalNumber)
      });
    }
    if (existingUser) {
      const isVerified = existingUser.phoneVerified === 1;
      if (isVerified && createSession === "true") {
        const now = /* @__PURE__ */ new Date();
        const existingSession = await db.query.phoneVerificationTokens.findFirst({
          where: and31(
            eq31(phoneVerificationTokens.phone, e164Phone),
            eq31(phoneVerificationTokens.context, "walk-in-returning"),
            gt4(phoneVerificationTokens.sessionExpiresAt, now)
          ),
          orderBy: [desc21(phoneVerificationTokens.createdAt)]
        });
        if (existingSession && existingSession.verificationSessionId) {
          const remainingMinutes = Math.ceil((existingSession.sessionExpiresAt.getTime() - now.getTime()) / 6e4);
          console.log(`\u267B\uFE0F Reusing session for returning customer: ${e164Phone} (session: ${existingSession.verificationSessionId.substring(0, 8)}..., expires in ${remainingMinutes}min)`);
          return res.json({
            exists: true,
            phoneVerified: true,
            userId: existingUser.id,
            firstName: existingUser.firstName,
            lastName: existingUser.lastName,
            verificationSessionId: existingSession.verificationSessionId,
            sessionExpiresInMinutes: remainingMinutes
          });
        }
        const sessionId = generateSessionId();
        const sessionExpiresAt = new Date(Date.now() + SESSION_EXPIRY_MINUTES * 60 * 1e3);
        await db.insert(phoneVerificationTokens).values({
          phone: e164Phone,
          codeHash: "return-session",
          // No OTP for returning customers
          context: "walk-in-returning",
          expiresAt: now,
          // Already expired (no OTP to verify)
          verifiedAt: now,
          // Already verified
          verificationSessionId: sessionId,
          sessionExpiresAt,
          attempts: 0,
          maxAttempts: 0
        });
        console.log(`\u2705 Created session for returning customer: ${e164Phone} (session: ${sessionId.substring(0, 8)}...)`);
        return res.json({
          exists: true,
          phoneVerified: true,
          userId: existingUser.id,
          firstName: existingUser.firstName,
          lastName: existingUser.lastName,
          verificationSessionId: sessionId,
          sessionExpiresInMinutes: SESSION_EXPIRY_MINUTES
        });
      }
      return res.json({
        exists: true,
        phoneVerified: isVerified,
        userId: existingUser.id,
        firstName: existingUser.firstName,
        lastName: existingUser.lastName
      });
    }
    res.json({
      exists: false,
      phoneVerified: false,
      userId: null
    });
  } catch (error) {
    console.error("Error checking phone status:", error);
    res.status(500).json({ error: "Failed to check phone status" });
  }
});
router21.post("/validate-session", async (req, res) => {
  try {
    const { verificationSessionId, phone } = req.body;
    if (!verificationSessionId) {
      return res.status(400).json({ valid: false, error: "Session ID is required" });
    }
    let normalizedPhone;
    if (phone) {
      try {
        normalizedPhone = normalizePhoneNumber2(phone);
      } catch (err) {
        return res.status(400).json({ valid: false, error: "Invalid phone format" });
      }
    }
    const now = /* @__PURE__ */ new Date();
    const whereClause = normalizedPhone ? and31(
      eq31(phoneVerificationTokens.verificationSessionId, verificationSessionId),
      eq31(phoneVerificationTokens.phone, normalizedPhone),
      gt4(phoneVerificationTokens.sessionExpiresAt, now)
    ) : and31(
      eq31(phoneVerificationTokens.verificationSessionId, verificationSessionId),
      gt4(phoneVerificationTokens.sessionExpiresAt, now)
    );
    const token = await db.query.phoneVerificationTokens.findFirst({
      where: whereClause
    });
    if (!token || !token.verifiedAt) {
      return res.json({ valid: false, error: "Invalid or expired session" });
    }
    res.json({
      valid: true,
      phone: token.phone,
      context: token.context,
      verifiedAt: token.verifiedAt
    });
  } catch (error) {
    console.error("Error validating session:", error);
    res.status(500).json({ valid: false, error: "Failed to validate session" });
  }
});
function normalizeString(str) {
  return str.toLowerCase().trim().replace(/\s+/g, " ").normalize("NFD").replace(/[\u0300-\u036f]/g, "");
}
function calculateSimilarity(str1, str2) {
  const s1 = normalizeString(str1);
  const s2 = normalizeString(str2);
  if (s1 === s2) return 1;
  if (s1.length === 0 || s2.length === 0) return 0;
  const longer = s1.length > s2.length ? s1 : s2;
  const shorter = s1.length > s2.length ? s2 : s1;
  if (longer.includes(shorter) || shorter.includes(longer)) {
    return shorter.length / longer.length;
  }
  let matches = 0;
  const range = Math.floor(Math.max(s1.length, s2.length) / 2) - 1;
  const s1Matches = new Array(s1.length).fill(false);
  const s2Matches = new Array(s2.length).fill(false);
  for (let i = 0; i < s1.length; i++) {
    const start = Math.max(0, i - range);
    const end = Math.min(i + range + 1, s2.length);
    for (let j = start; j < end; j++) {
      if (!s2Matches[j] && s1[i] === s2[j]) {
        s1Matches[i] = true;
        s2Matches[j] = true;
        matches++;
        break;
      }
    }
  }
  if (matches === 0) return 0;
  let transpositions = 0;
  let k = 0;
  for (let i = 0; i < s1.length; i++) {
    if (s1Matches[i]) {
      while (!s2Matches[k]) k++;
      if (s1[i] !== s2[k]) transpositions++;
      k++;
    }
  }
  const jaro = (matches / s1.length + matches / s2.length + (matches - transpositions / 2) / matches) / 3;
  let prefix = 0;
  for (let i = 0; i < Math.min(4, shorter.length); i++) {
    if (s1[i] === s2[i]) prefix++;
    else break;
  }
  return jaro + prefix * 0.1 * (1 - jaro);
}
router21.post("/identity-check", async (req, res) => {
  try {
    const { phone, providedName, providedEmail } = req.body;
    if (!phone) {
      return res.status(400).json({ error: "Phone number is required" });
    }
    if (!providedName && !providedEmail) {
      return res.status(400).json({ error: "Name or email is required for identity check" });
    }
    let e164Phone;
    try {
      e164Phone = normalizePhoneNumber2(phone);
    } catch {
      return res.status(400).json({ error: "Invalid phone number format" });
    }
    const existingUser = await db.query.users.findFirst({
      where: eq31(users.phone, e164Phone)
    });
    if (!existingUser) {
      return res.json({
        identityMatched: false,
        reason: "no_user_found",
        requiresOtp: true
      });
    }
    let isKnownSalonCustomer = false;
    if (existingUser.phoneVerified !== 1) {
      const clientProfile = await db.query.clientProfiles.findFirst({
        where: eq31(clientProfiles.customerId, existingUser.id)
      });
      isKnownSalonCustomer = !!clientProfile;
      if (!isKnownSalonCustomer) {
        return res.json({
          identityMatched: false,
          reason: "phone_not_verified",
          requiresOtp: true
        });
      }
      console.log(`\u{1F4CB} User ${e164Phone} has client profile - allowing identity check despite phone_verified=0`);
    }
    const NAME_MATCH_THRESHOLD = 0.75;
    let nameMatched = false;
    let emailMatched = false;
    let nameSimilarity = 0;
    if (providedName && existingUser.firstName) {
      const storedFullName = `${existingUser.firstName || ""} ${existingUser.lastName || ""}`.trim();
      const providedFullName = providedName.trim();
      nameSimilarity = calculateSimilarity(storedFullName, providedFullName);
      const storedFirst = normalizeString(existingUser.firstName || "");
      const providedFirst = normalizeString(providedName.split(" ")[0] || "");
      const firstNameSimilarity = calculateSimilarity(storedFirst, providedFirst);
      nameSimilarity = Math.max(nameSimilarity, firstNameSimilarity);
      nameMatched = nameSimilarity >= NAME_MATCH_THRESHOLD;
    }
    if (providedEmail && existingUser.email) {
      const normalizedProvidedEmail = providedEmail.toLowerCase().trim();
      const normalizedStoredEmail = existingUser.email.toLowerCase().trim();
      emailMatched = normalizedProvidedEmail === normalizedStoredEmail;
    }
    const identityMatched = nameMatched || emailMatched;
    console.log(`\u{1F50D} Identity check for ${e164Phone}: name="${providedName}" (similarity: ${nameSimilarity.toFixed(2)}), email="${providedEmail || "none"}"`);
    console.log(`   Result: nameMatched=${nameMatched}, emailMatched=${emailMatched}, identityMatched=${identityMatched}`);
    if (identityMatched) {
      const sessionId = generateSessionId();
      const now = /* @__PURE__ */ new Date();
      const sessionExpiresAt = new Date(Date.now() + SESSION_EXPIRY_MINUTES * 60 * 1e3);
      await db.insert(phoneVerificationTokens).values({
        phone: e164Phone,
        codeHash: "id-verified",
        context: "identity-bypass",
        expiresAt: now,
        verifiedAt: now,
        verificationSessionId: sessionId,
        sessionExpiresAt,
        attempts: 0,
        maxAttempts: 0
      });
      console.log(`\u2705 Identity verified for returning customer: ${e164Phone}`);
      return res.json({
        identityMatched: true,
        reason: emailMatched ? "email_matched" : "name_matched",
        requiresOtp: false,
        verificationSessionId: sessionId,
        sessionExpiresInMinutes: SESSION_EXPIRY_MINUTES,
        userId: existingUser.id,
        firstName: existingUser.firstName,
        lastName: existingUser.lastName
      });
    }
    console.log(`\u26A0\uFE0F Identity mismatch for ${e164Phone}: stored name="${existingUser.firstName} ${existingUser.lastName}", provided="${providedName}"`);
    return res.json({
      identityMatched: false,
      reason: "identity_mismatch",
      requiresOtp: true,
      message: "Please verify with OTP to continue"
    });
  } catch (error) {
    console.error("Error in identity check:", error);
    res.status(500).json({ error: "Failed to verify identity" });
  }
});
var phone_verification_routes_default = router21;

// server/routes/subscription.routes.ts
import { Router as Router21 } from "express";

// server/services/subscriptionService.ts
init_db();
init_schema();
import Razorpay7 from "razorpay";
import crypto10 from "crypto";
import { eq as eq32, and as and32, desc as desc22, lte as lte11 } from "drizzle-orm";
var razorpay6 = new Razorpay7({
  key_id: process.env.RAZORPAY_KEY_ID || "",
  key_secret: process.env.RAZORPAY_KEY_SECRET || ""
});
var TIER_CONFIGS = {
  [SUBSCRIPTION_TIERS.FREE]: {
    features: {
      instagramBooking: false,
      facebookBooking: false,
      messengerBot: false,
      reserveWithGoogle: false,
      customBranding: false,
      prioritySupport: false,
      analyticsAdvanced: false,
      apiAccess: false
    },
    limits: {
      maxStaff: 3,
      maxServices: 10,
      maxLocations: 1
    },
    monthlyPricePaisa: 0,
    yearlyPricePaisa: 0
  },
  [SUBSCRIPTION_TIERS.GROWTH]: {
    features: {
      instagramBooking: true,
      facebookBooking: true,
      messengerBot: false,
      reserveWithGoogle: false,
      customBranding: false,
      prioritySupport: true,
      analyticsAdvanced: true,
      apiAccess: false
    },
    limits: {
      maxStaff: 10,
      maxServices: 50,
      maxLocations: 2
    },
    monthlyPricePaisa: 99900,
    yearlyPricePaisa: 999900
  },
  [SUBSCRIPTION_TIERS.ELITE]: {
    features: {
      instagramBooking: true,
      facebookBooking: true,
      messengerBot: true,
      reserveWithGoogle: true,
      customBranding: true,
      prioritySupport: true,
      analyticsAdvanced: true,
      apiAccess: true
    },
    limits: {
      maxStaff: -1,
      maxServices: -1,
      maxLocations: 5
    },
    monthlyPricePaisa: 199900,
    yearlyPricePaisa: 1999900
  }
};
var REFUND_POLICIES = {
  FULL_REFUND_DAYS: 7,
  // Full refund within 7 days of payment
  PRORATED_REFUND_DAYS: 30,
  // Prorated refund up to 30 days
  MIN_REFUND_AMOUNT_PAISA: 100,
  // Minimum refund 1 (Razorpay requirement)
  GRACE_PERIOD_DAYS: 3,
  // Days after period end before downgrade
  MAX_PAYMENT_RETRIES: 3
  // Max failed payments before downgrade
};
var SubscriptionService = class {
  async initializeTiers() {
    const existingTiers = await db.select().from(subscriptionTiers);
    if (existingTiers.length === 0) {
      const tierData = [
        {
          name: SUBSCRIPTION_TIERS.FREE,
          displayName: "Free",
          description: "Basic salon listing and booking features",
          monthlyPricePaisa: TIER_CONFIGS.free.monthlyPricePaisa,
          yearlyPricePaisa: TIER_CONFIGS.free.yearlyPricePaisa,
          features: JSON.stringify(TIER_CONFIGS.free.features),
          limits: JSON.stringify(TIER_CONFIGS.free.limits),
          sortOrder: 0
        },
        {
          name: SUBSCRIPTION_TIERS.GROWTH,
          displayName: "Growth",
          description: "Instagram & Facebook booking buttons, priority support",
          monthlyPricePaisa: TIER_CONFIGS.growth.monthlyPricePaisa,
          yearlyPricePaisa: TIER_CONFIGS.growth.yearlyPricePaisa,
          features: JSON.stringify(TIER_CONFIGS.growth.features),
          limits: JSON.stringify(TIER_CONFIGS.growth.limits),
          sortOrder: 1
        },
        {
          name: SUBSCRIPTION_TIERS.ELITE,
          displayName: "Elite",
          description: "All Growth features + Reserve with Google, Messenger bot, API access",
          monthlyPricePaisa: TIER_CONFIGS.elite.monthlyPricePaisa,
          yearlyPricePaisa: TIER_CONFIGS.elite.yearlyPricePaisa,
          features: JSON.stringify(TIER_CONFIGS.elite.features),
          limits: JSON.stringify(TIER_CONFIGS.elite.limits),
          sortOrder: 2
        }
      ];
      for (const tier of tierData) {
        await db.insert(subscriptionTiers).values(tier);
      }
      console.log("\u2705 Subscription tiers initialized");
    }
  }
  async getAllTiers() {
    return db.select().from(subscriptionTiers).orderBy(subscriptionTiers.sortOrder);
  }
  async getTierById(tierId) {
    const [tier] = await db.select().from(subscriptionTiers).where(eq32(subscriptionTiers.id, tierId));
    return tier;
  }
  async getTierByName(tierName) {
    const [tier] = await db.select().from(subscriptionTiers).where(eq32(subscriptionTiers.name, tierName));
    return tier;
  }
  async getSalonSubscription(salonId) {
    const [subscription] = await db.select({
      subscription: salonSubscriptions,
      tier: subscriptionTiers
    }).from(salonSubscriptions).leftJoin(subscriptionTiers, eq32(salonSubscriptions.tierId, subscriptionTiers.id)).where(eq32(salonSubscriptions.salonId, salonId)).orderBy(desc22(salonSubscriptions.createdAt)).limit(1);
    return subscription;
  }
  async createFreeSubscription(salonId) {
    const freeTier = await this.getTierByName(SUBSCRIPTION_TIERS.FREE);
    if (!freeTier) {
      throw new Error("Free tier not found. Please initialize tiers first.");
    }
    const now = /* @__PURE__ */ new Date();
    const nextYear = new Date(now);
    nextYear.setFullYear(nextYear.getFullYear() + 100);
    const [subscription] = await db.insert(salonSubscriptions).values({
      salonId,
      tierId: freeTier.id,
      status: SUBSCRIPTION_STATUSES.ACTIVE,
      billingCycle: "none",
      currentPeriodStart: now,
      currentPeriodEnd: nextYear
    }).returning();
    return subscription;
  }
  async createTrialSubscription(salonId, tierName, trialDays = 14) {
    const tier = await this.getTierByName(tierName);
    if (!tier) {
      throw new Error(`Tier ${tierName} not found`);
    }
    const now = /* @__PURE__ */ new Date();
    const trialEnd = new Date(now);
    trialEnd.setDate(trialEnd.getDate() + trialDays);
    const existing = await this.getSalonSubscription(salonId);
    if (existing) {
      await db.update(salonSubscriptions).set({
        tierId: tier.id,
        status: SUBSCRIPTION_STATUSES.TRIALING,
        trialEndsAt: trialEnd,
        currentPeriodStart: now,
        currentPeriodEnd: trialEnd,
        updatedAt: now
      }).where(eq32(salonSubscriptions.id, existing.subscription.id));
      return this.getSalonSubscription(salonId);
    }
    const [subscription] = await db.insert(salonSubscriptions).values({
      salonId,
      tierId: tier.id,
      status: SUBSCRIPTION_STATUSES.TRIALING,
      billingCycle: "monthly",
      currentPeriodStart: now,
      currentPeriodEnd: trialEnd,
      trialEndsAt: trialEnd
    }).returning();
    return subscription;
  }
  async createRazorpaySubscription(salonId, tierName, billingCycle) {
    const tier = await this.getTierByName(tierName);
    if (!tier) {
      throw new Error(`Tier ${tierName} not found`);
    }
    if (tier.name === SUBSCRIPTION_TIERS.FREE) {
      return this.createFreeSubscription(salonId);
    }
    const [salon] = await db.select().from(salons).where(eq32(salons.id, salonId));
    if (!salon) {
      throw new Error("Salon not found");
    }
    const amount = billingCycle === "monthly" ? tier.monthlyPricePaisa : tier.yearlyPricePaisa;
    const period = billingCycle === "monthly" ? "monthly" : "yearly";
    const intervalCount = billingCycle === "monthly" ? 1 : 12;
    try {
      const plan = await razorpay6.plans.create({
        period,
        interval: intervalCount,
        item: {
          name: `${tier.displayName} Plan - ${billingCycle}`,
          amount,
          currency: "INR",
          description: tier.description || ""
        }
      });
      const rzpSubscription = await razorpay6.subscriptions.create({
        plan_id: plan.id,
        total_count: billingCycle === "monthly" ? 120 : 10,
        quantity: 1,
        customer_notify: 1,
        notes: {
          salonId,
          tierName
        }
      });
      const now = /* @__PURE__ */ new Date();
      const periodEnd = new Date(now);
      if (billingCycle === "monthly") {
        periodEnd.setMonth(periodEnd.getMonth() + 1);
      } else {
        periodEnd.setFullYear(periodEnd.getFullYear() + 1);
      }
      const existing = await this.getSalonSubscription(salonId);
      if (existing) {
        await db.update(salonSubscriptions).set({
          tierId: tier.id,
          status: SUBSCRIPTION_STATUSES.ACTIVE,
          billingCycle,
          currentPeriodStart: now,
          currentPeriodEnd: periodEnd,
          razorpaySubscriptionId: rzpSubscription.id,
          razorpayPlanId: plan.id,
          nextPaymentAt: periodEnd,
          updatedAt: now
        }).where(eq32(salonSubscriptions.id, existing.subscription.id));
      } else {
        await db.insert(salonSubscriptions).values({
          salonId,
          tierId: tier.id,
          status: SUBSCRIPTION_STATUSES.ACTIVE,
          billingCycle,
          currentPeriodStart: now,
          currentPeriodEnd: periodEnd,
          razorpaySubscriptionId: rzpSubscription.id,
          razorpayPlanId: plan.id,
          nextPaymentAt: periodEnd
        });
      }
      return {
        subscriptionId: rzpSubscription.id,
        shortUrl: rzpSubscription.short_url,
        status: rzpSubscription.status
      };
    } catch (error) {
      console.error("Razorpay subscription creation error:", error);
      throw new Error(`Failed to create subscription: ${error.message}`);
    }
  }
  async createUpgradeOrder(salonId, tierName, billingCycle) {
    const tier = await this.getTierByName(tierName);
    if (!tier) {
      throw new Error(`Tier ${tierName} not found`);
    }
    const amount = billingCycle === "monthly" ? tier.monthlyPricePaisa : tier.yearlyPricePaisa;
    try {
      const order = await razorpay6.orders.create({
        amount,
        currency: "INR",
        receipt: `sub_${salonId.substring(0, 8)}_${Date.now()}`.substring(0, 40),
        notes: {
          salonId,
          tierName,
          billingCycle,
          type: "subscription_upgrade"
        }
      });
      return {
        orderId: order.id,
        amount: order.amount,
        currency: order.currency,
        keyId: process.env.RAZORPAY_KEY_ID
      };
    } catch (error) {
      console.error("Razorpay order creation error:", error);
      throw new Error(`Failed to create order: ${error.message}`);
    }
  }
  async verifyPaymentAndActivate(salonId, tierName, billingCycle, razorpayOrderId, razorpayPaymentId, razorpaySignature) {
    const sign = razorpayOrderId + "|" + razorpayPaymentId;
    const expectedSign = crypto10.createHmac("sha256", process.env.RAZORPAY_KEY_SECRET || "").update(sign).digest("hex");
    if (razorpaySignature !== expectedSign) {
      throw new Error("Invalid payment signature");
    }
    const tier = await this.getTierByName(tierName);
    if (!tier) {
      throw new Error(`Tier ${tierName} not found`);
    }
    const now = /* @__PURE__ */ new Date();
    const periodEnd = new Date(now);
    if (billingCycle === "monthly") {
      periodEnd.setMonth(periodEnd.getMonth() + 1);
    } else {
      periodEnd.setFullYear(periodEnd.getFullYear() + 1);
    }
    const existing = await this.getSalonSubscription(salonId);
    let subscriptionId;
    if (existing) {
      await db.update(salonSubscriptions).set({
        tierId: tier.id,
        status: SUBSCRIPTION_STATUSES.ACTIVE,
        billingCycle,
        currentPeriodStart: now,
        currentPeriodEnd: periodEnd,
        lastPaymentAt: now,
        nextPaymentAt: periodEnd,
        failedPaymentCount: 0,
        updatedAt: now
      }).where(eq32(salonSubscriptions.id, existing.subscription.id));
      subscriptionId = existing.subscription.id;
    } else {
      const [newSub] = await db.insert(salonSubscriptions).values({
        salonId,
        tierId: tier.id,
        status: SUBSCRIPTION_STATUSES.ACTIVE,
        billingCycle,
        currentPeriodStart: now,
        currentPeriodEnd: periodEnd,
        lastPaymentAt: now,
        nextPaymentAt: periodEnd
      }).returning();
      subscriptionId = newSub.id;
    }
    const amount = billingCycle === "monthly" ? tier.monthlyPricePaisa : tier.yearlyPricePaisa;
    await db.insert(subscriptionPayments).values({
      subscriptionId,
      salonId,
      amountPaisa: amount,
      status: "paid",
      razorpayPaymentId,
      razorpayOrderId,
      razorpaySignature,
      periodStart: now,
      periodEnd
    });
    return this.getSalonSubscription(salonId);
  }
  // ==================== REFUND METHODS (Industry Standard) ====================
  /**
   * Calculate prorated refund amount based on unused days
   * Industry standard: Refund = (Original Amount * Unused Days) / Total Days
   */
  calculateProratedRefund(originalAmountPaisa, periodStart, periodEnd, cancellationDate = /* @__PURE__ */ new Date()) {
    const totalDays = Math.ceil((periodEnd.getTime() - periodStart.getTime()) / (1e3 * 60 * 60 * 24));
    const daysUsed = Math.ceil((cancellationDate.getTime() - periodStart.getTime()) / (1e3 * 60 * 60 * 24));
    const unusedDays = Math.max(0, totalDays - daysUsed);
    if (daysUsed <= REFUND_POLICIES.FULL_REFUND_DAYS) {
      return {
        refundAmountPaisa: originalAmountPaisa,
        daysUsed,
        totalDays,
        refundType: "full"
      };
    }
    const refundAmountPaisa = Math.floor(originalAmountPaisa * unusedDays / totalDays);
    if (refundAmountPaisa < REFUND_POLICIES.MIN_REFUND_AMOUNT_PAISA || unusedDays <= 0) {
      return {
        refundAmountPaisa: 0,
        daysUsed,
        totalDays,
        refundType: "none"
      };
    }
    return {
      refundAmountPaisa,
      daysUsed,
      totalDays,
      refundType: "prorated"
    };
  }
  /**
   * Process refund via Razorpay
   * Handles full, prorated, and partial refunds
   */
  async processRefund(salonId, reason, requestedBy) {
    const subscription = await this.getSalonSubscription(salonId);
    if (!subscription) {
      return { success: false, message: "No subscription found" };
    }
    const [lastPayment] = await db.select().from(subscriptionPayments).where(and32(
      eq32(subscriptionPayments.salonId, salonId),
      eq32(subscriptionPayments.status, "paid")
    )).orderBy(desc22(subscriptionPayments.createdAt)).limit(1);
    if (!lastPayment || !lastPayment.razorpayPaymentId) {
      return { success: false, message: "No refundable payment found" };
    }
    const refundCalc = this.calculateProratedRefund(
      lastPayment.amountPaisa,
      subscription.subscription.currentPeriodStart,
      subscription.subscription.currentPeriodEnd
    );
    if (refundCalc.refundType === "none" || refundCalc.refundAmountPaisa === 0) {
      return {
        success: false,
        message: "No refund applicable. Subscription period has been mostly used."
      };
    }
    try {
      const razorpayRefund = await razorpay6.payments.refund(lastPayment.razorpayPaymentId, {
        amount: refundCalc.refundAmountPaisa,
        speed: "normal",
        // 'normal' (5-7 days) or 'optimum' (instant if possible)
        notes: {
          salonId,
          subscriptionId: subscription.subscription.id,
          refundType: refundCalc.refundType,
          reason: reason || "Subscription cancellation"
        },
        receipt: `ref_${salonId.substring(0, 6)}_${Date.now()}`.substring(0, 40)
      });
      const [refundRecord] = await db.insert(subscriptionRefunds).values({
        paymentId: lastPayment.id,
        subscriptionId: subscription.subscription.id,
        salonId,
        originalAmountPaisa: lastPayment.amountPaisa,
        refundAmountPaisa: refundCalc.refundAmountPaisa,
        refundType: refundCalc.refundType,
        reason,
        status: "processing",
        razorpayRefundId: razorpayRefund.id,
        razorpayPaymentId: lastPayment.razorpayPaymentId,
        daysUsed: refundCalc.daysUsed,
        totalDays: refundCalc.totalDays,
        requestedBy
      }).returning();
      return {
        success: true,
        refundId: refundRecord.id,
        razorpayRefundId: razorpayRefund.id,
        refundAmount: refundCalc.refundAmountPaisa / 100,
        message: `Refund of \u20B9${(refundCalc.refundAmountPaisa / 100).toFixed(2)} initiated. Will be processed within 5-7 business days.`
      };
    } catch (error) {
      console.error("Razorpay refund error:", error);
      await db.insert(subscriptionRefunds).values({
        paymentId: lastPayment.id,
        subscriptionId: subscription.subscription.id,
        salonId,
        originalAmountPaisa: lastPayment.amountPaisa,
        refundAmountPaisa: refundCalc.refundAmountPaisa,
        refundType: refundCalc.refundType,
        reason,
        status: "failed",
        razorpayPaymentId: lastPayment.razorpayPaymentId,
        failureReason: error.message,
        daysUsed: refundCalc.daysUsed,
        totalDays: refundCalc.totalDays,
        requestedBy
      });
      return {
        success: false,
        message: `Refund failed: ${error.message}. Please contact support.`
      };
    }
  }
  /**
   * Cancel subscription with optional refund processing
   * Industry standard: User retains access until current period ends (grace period)
   */
  async cancelSubscription(salonId, reason, processRefund = true, requestedBy) {
    const existing = await this.getSalonSubscription(salonId);
    if (!existing) {
      throw new Error("No active subscription found");
    }
    const now = /* @__PURE__ */ new Date();
    let refundResult;
    if (processRefund && existing.tier?.name !== SUBSCRIPTION_TIERS.FREE) {
      refundResult = await this.processRefund(salonId, reason, requestedBy);
    }
    if (existing.subscription.razorpaySubscriptionId) {
      try {
        await razorpay6.subscriptions.cancel(existing.subscription.razorpaySubscriptionId, {
          cancel_at_cycle_end: false
          // Immediate cancellation
        });
      } catch (error) {
        console.error("Error cancelling Razorpay subscription:", error);
      }
    }
    const gracePeriodEnd = new Date(existing.subscription.currentPeriodEnd);
    gracePeriodEnd.setDate(gracePeriodEnd.getDate() + REFUND_POLICIES.GRACE_PERIOD_DAYS);
    await db.update(salonSubscriptions).set({
      status: SUBSCRIPTION_STATUSES.CANCELLED,
      cancelledAt: now,
      cancelReason: reason,
      updatedAt: now
      // Don't immediately downgrade - keep tier until period end
    }).where(eq32(salonSubscriptions.id, existing.subscription.id));
    const updatedSubscription = await this.getSalonSubscription(salonId);
    return {
      subscription: updatedSubscription,
      refund: refundResult
    };
  }
  /**
   * Handle expired subscriptions - downgrade to free tier
   * Called by background job after grace period ends
   */
  async handleExpiredSubscriptions() {
    const now = /* @__PURE__ */ new Date();
    const gracePeriodAgo = new Date(now);
    gracePeriodAgo.setDate(gracePeriodAgo.getDate() - REFUND_POLICIES.GRACE_PERIOD_DAYS);
    const freeTier = await this.getTierByName(SUBSCRIPTION_TIERS.FREE);
    if (!freeTier) {
      console.error("Free tier not found");
      return 0;
    }
    const expiredSubs = await db.select().from(salonSubscriptions).where(and32(
      eq32(salonSubscriptions.status, SUBSCRIPTION_STATUSES.CANCELLED),
      lte11(salonSubscriptions.currentPeriodEnd, gracePeriodAgo)
    ));
    let downgradeCount = 0;
    for (const sub of expiredSubs) {
      if (sub.tierId !== freeTier.id) {
        await db.update(salonSubscriptions).set({
          tierId: freeTier.id,
          status: SUBSCRIPTION_STATUSES.EXPIRED,
          updatedAt: now
        }).where(eq32(salonSubscriptions.id, sub.id));
        downgradeCount++;
      }
    }
    if (downgradeCount > 0) {
      console.log(`[Subscription] Downgraded ${downgradeCount} expired subscriptions to free tier`);
    }
    return downgradeCount;
  }
  // ==================== PAUSE/RESUME FUNCTIONALITY ====================
  /**
   * Pause subscription - keeps data but suspends billing
   * Industry standard: Max pause duration is typically 3 months
   */
  async pauseSubscription(salonId, pauseUntil) {
    const subscription = await this.getSalonSubscription(salonId);
    if (!subscription) {
      throw new Error("No subscription found");
    }
    if (subscription.tier?.name === SUBSCRIPTION_TIERS.FREE) {
      throw new Error("Cannot pause free subscription");
    }
    const now = /* @__PURE__ */ new Date();
    const maxPauseDate = new Date(now);
    maxPauseDate.setMonth(maxPauseDate.getMonth() + 3);
    const pauseEnd = pauseUntil && pauseUntil < maxPauseDate ? pauseUntil : maxPauseDate;
    if (subscription.subscription.razorpaySubscriptionId) {
      try {
        await razorpay6.subscriptions.pause(subscription.subscription.razorpaySubscriptionId);
      } catch (error) {
        console.error("Error pausing Razorpay subscription:", error);
      }
    }
    await db.update(salonSubscriptions).set({
      status: "paused",
      updatedAt: now
    }).where(eq32(salonSubscriptions.id, subscription.subscription.id));
    return this.getSalonSubscription(salonId);
  }
  /**
   * Resume paused subscription
   */
  async resumeSubscription(salonId) {
    const subscription = await this.getSalonSubscription(salonId);
    if (!subscription) {
      throw new Error("No subscription found");
    }
    if (subscription.subscription.status !== "paused") {
      throw new Error("Subscription is not paused");
    }
    if (subscription.subscription.razorpaySubscriptionId) {
      try {
        await razorpay6.subscriptions.resume(subscription.subscription.razorpaySubscriptionId);
      } catch (error) {
        console.error("Error resuming Razorpay subscription:", error);
      }
    }
    const now = /* @__PURE__ */ new Date();
    await db.update(salonSubscriptions).set({
      status: SUBSCRIPTION_STATUSES.ACTIVE,
      updatedAt: now
    }).where(eq32(salonSubscriptions.id, subscription.subscription.id));
    return this.getSalonSubscription(salonId);
  }
  // ==================== FAILED PAYMENT HANDLING (Dunning) ====================
  /**
   * Handle failed payment - increment counter and potentially downgrade
   * Industry standard dunning: 3 retries over 7 days, then downgrade
   */
  async handleFailedPayment(salonId, paymentId, failureReason) {
    const subscription = await this.getSalonSubscription(salonId);
    if (!subscription) return;
    const newFailedCount = (subscription.subscription.failedPaymentCount || 0) + 1;
    const now = /* @__PURE__ */ new Date();
    await db.insert(subscriptionPayments).values({
      subscriptionId: subscription.subscription.id,
      salonId,
      amountPaisa: subscription.tier?.monthlyPricePaisa || 0,
      status: "failed",
      razorpayPaymentId: paymentId,
      failureReason,
      periodStart: now,
      periodEnd: now
    });
    const updateData = {
      failedPaymentCount: newFailedCount,
      updatedAt: now
    };
    if (newFailedCount >= REFUND_POLICIES.MAX_PAYMENT_RETRIES) {
      updateData.status = SUBSCRIPTION_STATUSES.PAST_DUE;
      console.log(`[Subscription] Salon ${salonId} marked as past_due after ${newFailedCount} failed payments`);
    }
    await db.update(salonSubscriptions).set(updateData).where(eq32(salonSubscriptions.id, subscription.subscription.id));
  }
  /**
   * Handle successful payment after failures - reset counter
   */
  async handleSuccessfulPayment(salonId, paymentId, amountPaisa) {
    const subscription = await this.getSalonSubscription(salonId);
    if (!subscription) return;
    const now = /* @__PURE__ */ new Date();
    const periodEnd = new Date(now);
    if (subscription.subscription.billingCycle === "monthly") {
      periodEnd.setMonth(periodEnd.getMonth() + 1);
    } else {
      periodEnd.setFullYear(periodEnd.getFullYear() + 1);
    }
    await db.insert(subscriptionPayments).values({
      subscriptionId: subscription.subscription.id,
      salonId,
      amountPaisa,
      status: "paid",
      razorpayPaymentId: paymentId,
      periodStart: now,
      periodEnd
    });
    await db.update(salonSubscriptions).set({
      status: SUBSCRIPTION_STATUSES.ACTIVE,
      failedPaymentCount: 0,
      lastPaymentAt: now,
      nextPaymentAt: periodEnd,
      currentPeriodStart: now,
      currentPeriodEnd: periodEnd,
      updatedAt: now
    }).where(eq32(salonSubscriptions.id, subscription.subscription.id));
  }
  // ==================== WEBHOOK HANDLING ====================
  /**
   * Verify Razorpay webhook signature
   */
  verifyWebhookSignature(body, signature) {
    const expectedSignature = crypto10.createHmac("sha256", process.env.RAZORPAY_WEBHOOK_SECRET || "").update(body).digest("hex");
    return crypto10.timingSafeEqual(
      Buffer.from(signature),
      Buffer.from(expectedSignature)
    );
  }
  /**
   * Check if webhook event was already processed (idempotency)
   */
  async isEventProcessed(eventId) {
    const [existing] = await db.select().from(razorpayWebhookEvents).where(eq32(razorpayWebhookEvents.eventId, eventId));
    return !!existing && existing.status === "processed";
  }
  /**
   * Record webhook event for idempotency
   */
  async recordWebhookEvent(eventId, eventType, payload, status, errorMessage) {
    const [existing] = await db.select().from(razorpayWebhookEvents).where(eq32(razorpayWebhookEvents.eventId, eventId));
    if (existing) {
      await db.update(razorpayWebhookEvents).set({
        status,
        processedAt: status === "processed" ? /* @__PURE__ */ new Date() : null,
        errorMessage,
        retryCount: existing.retryCount + 1
      }).where(eq32(razorpayWebhookEvents.id, existing.id));
    } else {
      await db.insert(razorpayWebhookEvents).values({
        eventId,
        eventType,
        payload,
        status,
        processedAt: status === "processed" ? /* @__PURE__ */ new Date() : null,
        errorMessage
      });
    }
  }
  // ==================== EXISTING METHODS ====================
  async checkFeatureAccess(salonId, feature) {
    const subscription = await this.getSalonSubscription(salonId);
    if (!subscription || !subscription.tier) {
      return false;
    }
    if (subscription.subscription.status !== SUBSCRIPTION_STATUSES.ACTIVE && subscription.subscription.status !== SUBSCRIPTION_STATUSES.TRIALING) {
      return false;
    }
    const features = subscription.tier.features;
    return features[feature] === true;
  }
  async getPaymentHistory(salonId, limit = 10) {
    return db.select().from(subscriptionPayments).where(eq32(subscriptionPayments.salonId, salonId)).orderBy(desc22(subscriptionPayments.createdAt)).limit(limit);
  }
  async getRefundHistory(salonId, limit = 10) {
    return db.select().from(subscriptionRefunds).where(eq32(subscriptionRefunds.salonId, salonId)).orderBy(desc22(subscriptionRefunds.createdAt)).limit(limit);
  }
  /**
   * Get refund estimate without processing
   */
  async getRefundEstimate(salonId) {
    const subscription = await this.getSalonSubscription(salonId);
    if (!subscription || subscription.tier?.name === SUBSCRIPTION_TIERS.FREE) {
      return { eligible: false, message: "No paid subscription to refund" };
    }
    const [lastPayment] = await db.select().from(subscriptionPayments).where(and32(
      eq32(subscriptionPayments.salonId, salonId),
      eq32(subscriptionPayments.status, "paid")
    )).orderBy(desc22(subscriptionPayments.createdAt)).limit(1);
    if (!lastPayment) {
      return { eligible: false, message: "No refundable payment found" };
    }
    const refundCalc = this.calculateProratedRefund(
      lastPayment.amountPaisa,
      subscription.subscription.currentPeriodStart,
      subscription.subscription.currentPeriodEnd
    );
    if (refundCalc.refundType === "none") {
      return {
        eligible: false,
        daysUsed: refundCalc.daysUsed,
        totalDays: refundCalc.totalDays,
        message: "No refund available. Most of the subscription period has been used."
      };
    }
    return {
      eligible: true,
      refundAmount: refundCalc.refundAmountPaisa / 100,
      refundType: refundCalc.refundType,
      daysUsed: refundCalc.daysUsed,
      totalDays: refundCalc.totalDays,
      message: refundCalc.refundType === "full" ? "Full refund available (within 7-day cancellation window)" : `Prorated refund of \u20B9${(refundCalc.refundAmountPaisa / 100).toFixed(2)} available for ${refundCalc.totalDays - refundCalc.daysUsed} unused days`
    };
  }
};
var subscriptionService = new SubscriptionService();

// server/routes/subscription.routes.ts
init_db();
init_schema();
import { eq as eq33, count as count7, sql as sql28, and as and33, gte as gte12, desc as desc23 } from "drizzle-orm";
var router22 = Router21();
router22.get("/tiers", async (req, res) => {
  try {
    const tiers = await subscriptionService.getAllTiers();
    const formattedTiers = tiers.map((tier) => ({
      id: tier.id,
      name: tier.name,
      displayName: tier.displayName,
      description: tier.description,
      monthlyPrice: tier.monthlyPricePaisa / 100,
      yearlyPrice: tier.yearlyPricePaisa / 100,
      monthlyPricePaisa: tier.monthlyPricePaisa,
      yearlyPricePaisa: tier.yearlyPricePaisa,
      features: tier.features,
      limits: tier.limits
    }));
    res.json({ tiers: formattedTiers });
  } catch (error) {
    console.error("Error fetching tiers:", error);
    res.status(500).json({ error: "Failed to fetch subscription tiers" });
  }
});
router22.get("/salon/:salonId", async (req, res) => {
  try {
    const { salonId } = req.params;
    const [salon] = await db.select().from(salons).where(eq33(salons.id, salonId));
    if (!salon) {
      return res.status(404).json({ error: "Salon not found" });
    }
    let subscription = await subscriptionService.getSalonSubscription(salonId);
    if (!subscription) {
      await subscriptionService.createFreeSubscription(salonId);
      subscription = await subscriptionService.getSalonSubscription(salonId);
    }
    if (!subscription) {
      return res.status(500).json({ error: "Failed to get subscription" });
    }
    res.json({
      subscription: {
        id: subscription.subscription.id,
        status: subscription.subscription.status,
        billingCycle: subscription.subscription.billingCycle,
        currentPeriodStart: subscription.subscription.currentPeriodStart,
        currentPeriodEnd: subscription.subscription.currentPeriodEnd,
        trialEndsAt: subscription.subscription.trialEndsAt,
        nextPaymentAt: subscription.subscription.nextPaymentAt
      },
      tier: subscription.tier ? {
        id: subscription.tier.id,
        name: subscription.tier.name,
        displayName: subscription.tier.displayName,
        features: subscription.tier.features,
        limits: subscription.tier.limits
      } : null
    });
  } catch (error) {
    console.error("Error fetching salon subscription:", error);
    res.status(500).json({ error: "Failed to fetch subscription" });
  }
});
router22.get("/salon/:salonId/status", async (req, res) => {
  try {
    const { salonId } = req.params;
    const [salon] = await db.select().from(salons).where(eq33(salons.id, salonId));
    if (!salon) {
      return res.status(404).json({ error: "Salon not found" });
    }
    let subscription = await subscriptionService.getSalonSubscription(salonId);
    if (!subscription) {
      await subscriptionService.createFreeSubscription(salonId);
      subscription = await subscriptionService.getSalonSubscription(salonId);
    }
    if (!subscription) {
      return res.status(500).json({ error: "Failed to get subscription" });
    }
    const normalizedStatus = subscription.subscription.status?.toLowerCase();
    const normalizedTierSlug = subscription.tier?.name?.toLowerCase() || "free";
    res.json({
      subscription: {
        id: subscription.subscription.id,
        salonId: subscription.subscription.salonId,
        tierId: subscription.subscription.tierId,
        status: normalizedStatus,
        billingCycle: subscription.subscription.billingCycle,
        currentPeriodStart: subscription.subscription.currentPeriodStart,
        currentPeriodEnd: subscription.subscription.currentPeriodEnd,
        trialEndsAt: subscription.subscription.trialEndsAt,
        tier: subscription.tier ? {
          id: subscription.tier.id,
          name: subscription.tier.name,
          slug: normalizedTierSlug,
          monthlyPricePaisa: subscription.tier.monthlyPricePaisa,
          yearlyPricePaisa: subscription.tier.yearlyPricePaisa,
          maxStaff: subscription.tier.limits?.maxStaff ?? null,
          maxServices: subscription.tier.limits?.maxServices ?? null,
          features: Object.keys(subscription.tier.features || {}).filter(
            (k) => subscription.tier?.features?.[k] === true
          )
        } : null
      },
      tier: subscription.tier ? {
        id: subscription.tier.id,
        name: subscription.tier.name,
        slug: normalizedTierSlug,
        monthlyPricePaisa: subscription.tier.monthlyPricePaisa,
        yearlyPricePaisa: subscription.tier.yearlyPricePaisa,
        maxStaff: subscription.tier.limits?.maxStaff ?? null,
        maxServices: subscription.tier.limits?.maxServices ?? null,
        features: Object.keys(subscription.tier.features || {}).filter(
          (k) => subscription.tier?.features?.[k] === true
        )
      } : null
    });
  } catch (error) {
    console.error("Error fetching salon subscription status:", error);
    res.status(500).json({ error: "Failed to fetch subscription status" });
  }
});
router22.post("/salon/:salonId/start-trial", populateUserFromSession, requireSalonAccess(), async (req, res) => {
  try {
    const { salonId } = req.params;
    const { tierName, trialDays = 14 } = req.body;
    if (!tierName) {
      return res.status(400).json({ error: "Tier name is required" });
    }
    const subscription = await subscriptionService.createTrialSubscription(salonId, tierName, trialDays);
    res.json({
      success: true,
      message: `${trialDays}-day trial started for ${tierName} tier`,
      subscription
    });
  } catch (error) {
    console.error("Error starting trial:", error);
    res.status(500).json({ error: error.message || "Failed to start trial" });
  }
});
router22.post("/salon/:salonId/create-upgrade-order", populateUserFromSession, requireSalonAccess(), async (req, res) => {
  try {
    const { salonId } = req.params;
    const { tierName, billingCycle = "monthly" } = req.body;
    if (!tierName) {
      return res.status(400).json({ error: "Tier name is required" });
    }
    if (!["monthly", "yearly"].includes(billingCycle)) {
      return res.status(400).json({ error: "Billing cycle must be monthly or yearly" });
    }
    const order = await subscriptionService.createUpgradeOrder(salonId, tierName, billingCycle);
    res.json({
      success: true,
      order
    });
  } catch (error) {
    console.error("Error creating upgrade order:", error);
    res.status(500).json({ error: error.message || "Failed to create order" });
  }
});
router22.post("/salon/:salonId/verify-upgrade", populateUserFromSession, requireSalonAccess(), async (req, res) => {
  try {
    const { salonId } = req.params;
    const {
      tierName,
      billingCycle,
      razorpay_order_id,
      razorpay_payment_id,
      razorpay_signature
    } = req.body;
    if (!tierName || !razorpay_order_id || !razorpay_payment_id || !razorpay_signature) {
      return res.status(400).json({ error: "Missing required payment verification parameters" });
    }
    const subscription = await subscriptionService.verifyPaymentAndActivate(
      salonId,
      tierName,
      billingCycle || "monthly",
      razorpay_order_id,
      razorpay_payment_id,
      razorpay_signature
    );
    res.json({
      success: true,
      message: `Subscription upgraded to ${tierName}`,
      subscription
    });
  } catch (error) {
    console.error("Error verifying upgrade:", error);
    res.status(400).json({ error: error.message || "Payment verification failed" });
  }
});
router22.post("/salon/:salonId/cancel", populateUserFromSession, requireSalonAccess(), async (req, res) => {
  try {
    const { salonId } = req.params;
    const { reason } = req.body;
    const subscription = await subscriptionService.cancelSubscription(salonId, reason);
    res.json({
      success: true,
      message: "Subscription cancelled. You have been moved to the Free tier.",
      subscription
    });
  } catch (error) {
    console.error("Error cancelling subscription:", error);
    res.status(500).json({ error: error.message || "Failed to cancel subscription" });
  }
});
router22.get("/salon/:salonId/refund-estimate", populateUserFromSession, requireSalonAccess(), async (req, res) => {
  try {
    const { salonId } = req.params;
    const estimate = await subscriptionService.getRefundEstimate(salonId);
    res.json(estimate);
  } catch (error) {
    console.error("Error getting refund estimate:", error);
    res.status(500).json({ error: error.message || "Failed to get refund estimate" });
  }
});
router22.post("/salon/:salonId/process-refund", populateUserFromSession, requireSalonAccess(), async (req, res) => {
  try {
    const { salonId } = req.params;
    const { reason } = req.body;
    const result = await subscriptionService.processRefund(salonId, reason);
    res.json(result);
  } catch (error) {
    console.error("Error processing refund:", error);
    res.status(500).json({ error: error.message || "Failed to process refund" });
  }
});
router22.post("/salon/:salonId/pause", populateUserFromSession, requireSalonAccess(), async (req, res) => {
  try {
    const { salonId } = req.params;
    const { pauseUntil } = req.body;
    const subscription = await subscriptionService.pauseSubscription(
      salonId,
      pauseUntil ? new Date(pauseUntil) : void 0
    );
    res.json({
      success: true,
      message: "Subscription paused successfully",
      subscription
    });
  } catch (error) {
    console.error("Error pausing subscription:", error);
    res.status(500).json({ error: error.message || "Failed to pause subscription" });
  }
});
router22.post("/salon/:salonId/resume", populateUserFromSession, requireSalonAccess(), async (req, res) => {
  try {
    const { salonId } = req.params;
    const subscription = await subscriptionService.resumeSubscription(salonId);
    res.json({
      success: true,
      message: "Subscription resumed successfully",
      subscription
    });
  } catch (error) {
    console.error("Error resuming subscription:", error);
    res.status(500).json({ error: error.message || "Failed to resume subscription" });
  }
});
router22.get("/salon/:salonId/feature-access/:feature", async (req, res) => {
  try {
    const { salonId, feature } = req.params;
    const validFeatures = [
      "instagramBooking",
      "facebookBooking",
      "messengerBot",
      "reserveWithGoogle",
      "customBranding",
      "prioritySupport",
      "analyticsAdvanced",
      "apiAccess"
    ];
    if (!validFeatures.includes(feature)) {
      return res.status(400).json({ error: "Invalid feature name" });
    }
    const hasAccess = await subscriptionService.checkFeatureAccess(salonId, feature);
    res.json({
      feature,
      hasAccess
    });
  } catch (error) {
    console.error("Error checking feature access:", error);
    res.status(500).json({ error: "Failed to check feature access" });
  }
});
router22.get("/salon/:salonId/payment-history", async (req, res) => {
  try {
    const { salonId } = req.params;
    const limit = parseInt(req.query.limit) || 10;
    const payments3 = await subscriptionService.getPaymentHistory(salonId, limit);
    res.json({
      payments: payments3.map((p) => ({
        id: p.id,
        amount: p.amountPaisa / 100,
        currency: p.currency,
        status: p.status,
        paymentMethod: p.paymentMethod,
        periodStart: p.periodStart,
        periodEnd: p.periodEnd,
        createdAt: p.createdAt
      }))
    });
  } catch (error) {
    console.error("Error fetching payment history:", error);
    res.status(500).json({ error: "Failed to fetch payment history" });
  }
});
router22.post("/initialize-tiers", async (req, res) => {
  try {
    await subscriptionService.initializeTiers();
    res.json({ success: true, message: "Subscription tiers initialized" });
  } catch (error) {
    console.error("Error initializing tiers:", error);
    res.status(500).json({ error: "Failed to initialize tiers" });
  }
});
router22.get("/admin/tiers", populateUserFromSession, requireSuperAdmin(), async (req, res) => {
  try {
    const tiers = await db.select().from(subscriptionTiers).orderBy(subscriptionTiers.sortOrder);
    const subscriberCounts = await db.select({
      tierId: salonSubscriptions.tierId,
      totalSubscribers: count7(salonSubscriptions.id),
      activeSubscribers: sql28`SUM(CASE WHEN ${salonSubscriptions.status} = 'active' THEN 1 ELSE 0 END)`,
      trialingSubscribers: sql28`SUM(CASE WHEN ${salonSubscriptions.status} = 'trialing' THEN 1 ELSE 0 END)`
    }).from(salonSubscriptions).groupBy(salonSubscriptions.tierId);
    const countMap = subscriberCounts.reduce((acc, item) => {
      acc[item.tierId] = {
        total: parseInt(String(item.totalSubscribers)) || 0,
        active: parseInt(String(item.activeSubscribers)) || 0,
        trialing: parseInt(String(item.trialingSubscribers)) || 0
      };
      return acc;
    }, {});
    const tiersWithStats = tiers.map((tier) => ({
      ...tier,
      subscribers: countMap[tier.id] || { total: 0, active: 0, trialing: 0 },
      monthlyRevenuePaisa: (countMap[tier.id]?.active || 0) * tier.monthlyPricePaisa
    }));
    res.json({ tiers: tiersWithStats });
  } catch (error) {
    console.error("Error fetching tiers for admin:", error);
    res.status(500).json({ error: "Failed to fetch subscription tiers" });
  }
});
router22.get("/admin/analytics", populateUserFromSession, requireSuperAdmin(), async (req, res) => {
  try {
    const now = /* @__PURE__ */ new Date();
    const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1e3);
    const revenueStats = await db.select({
      tierId: salonSubscriptions.tierId,
      tierName: subscriptionTiers.name,
      totalActive: count7(salonSubscriptions.id),
      monthlyRevenuePaisa: sql28`SUM(CASE 
          WHEN ${salonSubscriptions.billingCycle} = 'monthly' THEN ${subscriptionTiers.monthlyPricePaisa}
          WHEN ${salonSubscriptions.billingCycle} = 'yearly' THEN ${subscriptionTiers.yearlyPricePaisa} / 12
          ELSE 0
        END)`
    }).from(salonSubscriptions).innerJoin(subscriptionTiers, eq33(salonSubscriptions.tierId, subscriptionTiers.id)).where(eq33(salonSubscriptions.status, "active")).groupBy(salonSubscriptions.tierId, subscriptionTiers.name);
    const statusCounts = await db.select({
      status: salonSubscriptions.status,
      count: count7(salonSubscriptions.id)
    }).from(salonSubscriptions).groupBy(salonSubscriptions.status);
    const newSubscriptions = await db.select({
      count: count7(salonSubscriptions.id)
    }).from(salonSubscriptions).where(gte12(salonSubscriptions.createdAt, thirtyDaysAgo));
    const cancellations = await db.select({
      count: count7(salonSubscriptions.id)
    }).from(salonSubscriptions).where(and33(
      gte12(salonSubscriptions.cancelledAt, thirtyDaysAgo),
      eq33(salonSubscriptions.status, "canceled")
    ));
    const totalMonthlyRevenue = revenueStats.reduce((sum4, tier) => sum4 + (parseInt(String(tier.monthlyRevenuePaisa)) || 0), 0);
    const statusMap = statusCounts.reduce((acc, item) => {
      acc[item.status] = parseInt(String(item.count)) || 0;
      return acc;
    }, {});
    res.json({
      overview: {
        totalMonthlyRevenuePaisa: totalMonthlyRevenue,
        totalAnnualRevenuePaisa: totalMonthlyRevenue * 12,
        totalActive: statusMap.active || 0,
        totalTrialing: statusMap.trialing || 0,
        totalCanceled: statusMap.canceled || 0,
        totalPastDue: statusMap.past_due || 0,
        newSubscriptions30Days: parseInt(String(newSubscriptions[0]?.count)) || 0,
        cancellations30Days: parseInt(String(cancellations[0]?.count)) || 0
      },
      revenueByTier: revenueStats.map((tier) => ({
        tierId: tier.tierId,
        tierName: tier.tierName,
        activeSubscribers: parseInt(String(tier.totalActive)) || 0,
        monthlyRevenuePaisa: parseInt(String(tier.monthlyRevenuePaisa)) || 0
      }))
    });
  } catch (error) {
    console.error("Error fetching subscription analytics:", error);
    res.status(500).json({ error: "Failed to fetch subscription analytics" });
  }
});
router22.get("/admin/subscriptions", populateUserFromSession, requireSuperAdmin(), async (req, res) => {
  try {
    const { status, tierId, limit = 50, offset = 0 } = req.query;
    let query = db.select({
      subscription: salonSubscriptions,
      tier: subscriptionTiers,
      salon: salons
    }).from(salonSubscriptions).innerJoin(subscriptionTiers, eq33(salonSubscriptions.tierId, subscriptionTiers.id)).innerJoin(salons, eq33(salonSubscriptions.salonId, salons.id)).orderBy(desc23(salonSubscriptions.createdAt)).limit(Number(limit)).offset(Number(offset));
    const subscriptions = await query;
    res.json({
      subscriptions: subscriptions.map((sub) => ({
        id: sub.subscription.id,
        salonId: sub.subscription.salonId,
        salonName: sub.salon.name,
        salonCity: sub.salon.city,
        tierName: sub.tier.name,
        tierDisplayName: sub.tier.displayName,
        status: sub.subscription.status,
        billingCycle: sub.subscription.billingCycle,
        currentPeriodStart: sub.subscription.currentPeriodStart,
        currentPeriodEnd: sub.subscription.currentPeriodEnd,
        trialEndsAt: sub.subscription.trialEndsAt,
        createdAt: sub.subscription.createdAt
      }))
    });
  } catch (error) {
    console.error("Error fetching subscriptions for admin:", error);
    res.status(500).json({ error: "Failed to fetch subscriptions" });
  }
});
router22.put("/admin/tiers/:tierId", populateUserFromSession, requireSuperAdmin(), async (req, res) => {
  try {
    const { tierId } = req.params;
    const {
      displayName,
      description,
      monthlyPricePaisa,
      yearlyPricePaisa,
      features,
      limits,
      isActive,
      sortOrder,
      trialDays,
      billingConfig
    } = req.body;
    const updateData = { updatedAt: /* @__PURE__ */ new Date() };
    if (displayName !== void 0) updateData.displayName = displayName;
    if (description !== void 0) updateData.description = description;
    if (monthlyPricePaisa !== void 0) updateData.monthlyPricePaisa = monthlyPricePaisa;
    if (yearlyPricePaisa !== void 0) updateData.yearlyPricePaisa = yearlyPricePaisa;
    if (features !== void 0) updateData.features = features;
    if (limits !== void 0) updateData.limits = limits;
    if (isActive !== void 0) updateData.isActive = isActive ? 1 : 0;
    if (sortOrder !== void 0) updateData.sortOrder = sortOrder;
    const [updatedTier] = await db.update(subscriptionTiers).set(updateData).where(eq33(subscriptionTiers.id, tierId)).returning();
    if (!updatedTier) {
      return res.status(404).json({ error: "Tier not found" });
    }
    res.json({ tier: updatedTier, message: "Tier updated successfully" });
  } catch (error) {
    console.error("Error updating tier:", error);
    res.status(500).json({ error: "Failed to update tier" });
  }
});
router22.post("/admin/tiers", populateUserFromSession, requireSuperAdmin(), async (req, res) => {
  try {
    const {
      name,
      displayName,
      description,
      monthlyPricePaisa,
      yearlyPricePaisa,
      features,
      limits,
      sortOrder
    } = req.body;
    if (!name || !displayName) {
      return res.status(400).json({ error: "Name and display name are required" });
    }
    const [existingTier] = await db.select().from(subscriptionTiers).where(eq33(subscriptionTiers.name, name.toLowerCase()));
    if (existingTier) {
      return res.status(400).json({ error: "A tier with this name already exists" });
    }
    const [newTier] = await db.insert(subscriptionTiers).values({
      name: name.toLowerCase(),
      displayName,
      description: description || "",
      monthlyPricePaisa: monthlyPricePaisa || 0,
      yearlyPricePaisa: yearlyPricePaisa || 0,
      features: features || {},
      limits: limits || {},
      isActive: 1,
      sortOrder: sortOrder || 99
    }).returning();
    res.status(201).json({ tier: newTier, message: "Tier created successfully" });
  } catch (error) {
    console.error("Error creating tier:", error);
    res.status(500).json({ error: "Failed to create tier" });
  }
});
router22.delete("/admin/tiers/:tierId", populateUserFromSession, requireSuperAdmin(), async (req, res) => {
  try {
    const { tierId } = req.params;
    const [tier] = await db.select().from(subscriptionTiers).where(eq33(subscriptionTiers.id, tierId));
    if (!tier) {
      return res.status(404).json({ error: "Tier not found" });
    }
    if (tier.name === "free") {
      return res.status(400).json({ error: "Cannot delete the Free tier" });
    }
    await db.update(subscriptionTiers).set({ isActive: 0, updatedAt: /* @__PURE__ */ new Date() }).where(eq33(subscriptionTiers.id, tierId));
    res.json({ message: "Tier deactivated successfully" });
  } catch (error) {
    console.error("Error deleting tier:", error);
    res.status(500).json({ error: "Failed to delete tier" });
  }
});
router22.post("/admin/subscriptions/:salonId/change-tier", populateUserFromSession, requireSuperAdmin(), async (req, res) => {
  try {
    const { salonId } = req.params;
    const { tierId, reason } = req.body;
    if (!tierId) {
      return res.status(400).json({ error: "Tier ID is required" });
    }
    const [tier] = await db.select().from(subscriptionTiers).where(eq33(subscriptionTiers.id, tierId));
    if (!tier) {
      return res.status(404).json({ error: "Tier not found" });
    }
    const now = /* @__PURE__ */ new Date();
    const periodEnd = new Date(now.getTime() + 30 * 24 * 60 * 60 * 1e3);
    const [existingSub] = await db.select().from(salonSubscriptions).where(eq33(salonSubscriptions.salonId, salonId));
    if (existingSub) {
      await db.update(salonSubscriptions).set({
        tierId,
        status: "active",
        currentPeriodStart: now,
        currentPeriodEnd: periodEnd,
        updatedAt: now
      }).where(eq33(salonSubscriptions.salonId, salonId));
    } else {
      await db.insert(salonSubscriptions).values({
        salonId,
        tierId,
        status: "active",
        billingCycle: "monthly",
        currentPeriodStart: now,
        currentPeriodEnd: periodEnd
      });
    }
    res.json({
      success: true,
      message: `Salon subscription changed to ${tier.displayName}`,
      tier: tier.name
    });
  } catch (error) {
    console.error("Error changing subscription tier:", error);
    res.status(500).json({ error: "Failed to change subscription tier" });
  }
});
router22.post("/admin/subscriptions/:salonId/cancel", populateUserFromSession, requireSuperAdmin(), async (req, res) => {
  try {
    const { salonId } = req.params;
    const { reason } = req.body;
    const [freeTier] = await db.select().from(subscriptionTiers).where(eq33(subscriptionTiers.name, "free"));
    if (!freeTier) {
      return res.status(500).json({ error: "Free tier not configured" });
    }
    const now = /* @__PURE__ */ new Date();
    await db.update(salonSubscriptions).set({
      tierId: freeTier.id,
      status: "canceled",
      cancelledAt: now,
      cancelReason: reason || "Admin cancelled",
      updatedAt: now
    }).where(eq33(salonSubscriptions.salonId, salonId));
    res.json({
      success: true,
      message: "Subscription cancelled and downgraded to Free tier"
    });
  } catch (error) {
    console.error("Error cancelling subscription:", error);
    res.status(500).json({ error: "Failed to cancel subscription" });
  }
});
router22.get("/salon/:salonId/refund-estimate", populateUserFromSession, requireSalonAccess(), async (req, res) => {
  try {
    const { salonId } = req.params;
    const [salon] = await db.select().from(salons).where(eq33(salons.id, salonId));
    if (!salon) {
      return res.status(404).json({ error: "Salon not found" });
    }
    const estimate = await subscriptionService.getRefundEstimate(salonId);
    res.json({
      eligible: estimate.eligible,
      refundAmount: estimate.refundAmount || 0,
      refundType: estimate.refundType,
      daysUsed: estimate.daysUsed,
      totalDays: estimate.totalDays,
      message: estimate.message
    });
  } catch (error) {
    console.error("Error getting refund estimate:", error);
    res.status(500).json({ error: error.message || "Failed to get refund estimate" });
  }
});
router22.post("/salon/:salonId/process-refund", populateUserFromSession, requireSalonAccess(), async (req, res) => {
  try {
    const { salonId } = req.params;
    const { reason } = req.body;
    const [salon] = await db.select().from(salons).where(eq33(salons.id, salonId));
    if (!salon) {
      return res.status(404).json({ error: "Salon not found" });
    }
    const result = await subscriptionService.processRefund(salonId, reason);
    res.json({
      success: result.success,
      refundId: result.refundId,
      razorpayRefundId: result.razorpayRefundId,
      refundAmount: result.refundAmount || 0,
      message: result.message
    });
  } catch (error) {
    console.error("Error processing refund:", error);
    res.status(500).json({ error: error.message || "Failed to process refund" });
  }
});
router22.post("/salon/:salonId/pause", populateUserFromSession, requireSalonAccess(), async (req, res) => {
  try {
    const { salonId } = req.params;
    const { reason, pauseDurationDays = 30 } = req.body;
    const [salon] = await db.select().from(salons).where(eq33(salons.id, salonId));
    if (!salon) {
      return res.status(404).json({ error: "Salon not found" });
    }
    if (pauseDurationDays < 1 || pauseDurationDays > 90) {
      return res.status(400).json({ error: "Pause duration must be between 1 and 90 days" });
    }
    const result = await subscriptionService.pauseSubscription(salonId, reason);
    res.json({
      success: true,
      message: "Subscription paused successfully",
      pausedUntil: result.pausedUntil,
      status: result.status
    });
  } catch (error) {
    console.error("Error pausing subscription:", error);
    res.status(500).json({ error: error.message || "Failed to pause subscription" });
  }
});
router22.post("/salon/:salonId/resume", populateUserFromSession, requireSalonAccess(), async (req, res) => {
  try {
    const { salonId } = req.params;
    const [salon] = await db.select().from(salons).where(eq33(salons.id, salonId));
    if (!salon) {
      return res.status(404).json({ error: "Salon not found" });
    }
    const result = await subscriptionService.resumeSubscription(salonId);
    res.json({
      success: true,
      message: "Subscription resumed successfully",
      status: result.status,
      currentPeriodEnd: result.currentPeriodEnd
    });
  } catch (error) {
    console.error("Error resuming subscription:", error);
    res.status(500).json({ error: error.message || "Failed to resume subscription" });
  }
});
var subscription_routes_default = router22;

// server/routes/razorpay-webhook.routes.ts
import { Router as Router22 } from "express";
var router23 = Router22();
router23.post("/razorpay", async (req, res) => {
  const signature = req.headers["x-razorpay-signature"];
  if (!signature) {
    console.error("[Webhook] Missing Razorpay signature");
    return res.status(400).json({ error: "Missing signature" });
  }
  const rawBody = JSON.stringify(req.body);
  const isValid = subscriptionService.verifyWebhookSignature(rawBody, signature);
  if (!isValid) {
    console.error("[Webhook] Invalid Razorpay signature");
    return res.status(401).json({ error: "Invalid signature" });
  }
  const event = req.body;
  const eventId = event.event_id || `${event.event}_${Date.now()}`;
  const eventType = event.event;
  const alreadyProcessed = await subscriptionService.isEventProcessed(eventId);
  if (alreadyProcessed) {
    console.log(`[Webhook] Event ${eventId} already processed, skipping`);
    return res.status(200).json({ status: "already_processed" });
  }
  await subscriptionService.recordWebhookEvent(eventId, eventType, event.payload, "received");
  try {
    const payload = event.payload;
    switch (eventType) {
      // Payment captured successfully
      case "payment.captured": {
        const payment = payload.payment?.entity;
        if (payment) {
          const notes = payment.notes || {};
          const salonId = notes.salonId;
          if (salonId) {
            await subscriptionService.handleSuccessfulPayment(
              salonId,
              payment.id,
              payment.amount
            );
            console.log(`[Webhook] Payment captured for salon ${salonId}: ${payment.id}`);
          }
        }
        break;
      }
      // Payment failed
      case "payment.failed": {
        const payment = payload.payment?.entity;
        if (payment) {
          const notes = payment.notes || {};
          const salonId = notes.salonId;
          if (salonId) {
            const failureReason = payment.error_description || payment.error_reason || "Payment failed";
            await subscriptionService.handleFailedPayment(
              salonId,
              payment.id,
              failureReason
            );
            console.log(`[Webhook] Payment failed for salon ${salonId}: ${failureReason}`);
          }
        }
        break;
      }
      // Subscription activated
      case "subscription.activated": {
        const subscription = payload.subscription?.entity;
        if (subscription) {
          const notes = subscription.notes || {};
          const salonId = notes.salonId;
          console.log(`[Webhook] Subscription activated for salon ${salonId}: ${subscription.id}`);
        }
        break;
      }
      // Subscription charged (recurring payment)
      case "subscription.charged": {
        const subscription = payload.subscription?.entity;
        const payment = payload.payment?.entity;
        if (subscription && payment) {
          const notes = subscription.notes || {};
          const salonId = notes.salonId;
          if (salonId) {
            await subscriptionService.handleSuccessfulPayment(
              salonId,
              payment.id,
              payment.amount
            );
            console.log(`[Webhook] Subscription charged for salon ${salonId}: ${payment.id}`);
          }
        }
        break;
      }
      // Subscription halted (multiple payment failures)
      case "subscription.halted": {
        const subscription = payload.subscription?.entity;
        if (subscription) {
          const notes = subscription.notes || {};
          const salonId = notes.salonId;
          console.log(`[Webhook] Subscription halted for salon ${salonId}: ${subscription.id}`);
        }
        break;
      }
      // Subscription cancelled
      case "subscription.cancelled": {
        const subscription = payload.subscription?.entity;
        if (subscription) {
          const notes = subscription.notes || {};
          const salonId = notes.salonId;
          console.log(`[Webhook] Subscription cancelled for salon ${salonId}: ${subscription.id}`);
        }
        break;
      }
      // Refund created
      case "refund.created": {
        const refund = payload.refund?.entity;
        if (refund) {
          console.log(`[Webhook] Refund created: ${refund.id} for amount ${refund.amount / 100}`);
        }
        break;
      }
      // Refund processed
      case "refund.processed": {
        const refund = payload.refund?.entity;
        if (refund) {
          console.log(`[Webhook] Refund processed: ${refund.id} - Status: ${refund.status}`);
        }
        break;
      }
      // Refund failed
      case "refund.failed": {
        const refund = payload.refund?.entity;
        if (refund) {
          console.log(`[Webhook] Refund failed: ${refund.id} - Reason: ${refund.failure_reason}`);
        }
        break;
      }
      // Order paid
      case "order.paid": {
        const order = payload.order?.entity;
        const payment = payload.payment?.entity;
        if (order && payment) {
          const notes = order.notes || {};
          if (notes.type === "subscription_upgrade") {
            console.log(`[Webhook] Subscription upgrade order paid: ${order.id}`);
          }
        }
        break;
      }
      default:
        console.log(`[Webhook] Unhandled event type: ${eventType}`);
    }
    await subscriptionService.recordWebhookEvent(eventId, eventType, event.payload, "processed");
    res.status(200).json({ status: "processed" });
  } catch (error) {
    console.error(`[Webhook] Error processing ${eventType}:`, error);
    await subscriptionService.recordWebhookEvent(eventId, eventType, event.payload, "failed", error.message);
    res.status(200).json({ status: "error_recorded" });
  }
});
var razorpay_webhook_routes_default = router23;

// server/routes/meta.routes.ts
import { Router as Router23 } from "express";

// server/services/metaIntegrationService.ts
init_db();
init_schema();
import crypto11 from "crypto";
import { eq as eq34, and as and34, desc as desc24, gte as gte13 } from "drizzle-orm";
var META_GRAPH_API_VERSION = "v18.0";
var META_GRAPH_API_URL = `https://graph.facebook.com/${META_GRAPH_API_VERSION}`;
var ENCRYPTION_ALGORITHM = "aes-256-gcm";
var IV_LENGTH = 12;
var AUTH_TAG_LENGTH = 16;
function getEncryptionKey() {
  const keyString = process.env.META_TOKEN_ENCRYPTION_KEY || process.env.JWT_ACCESS_SECRET || "default-development-key-32chars!";
  return crypto11.createHash("sha256").update(keyString).digest();
}
function encryptToken(plaintext) {
  const key = getEncryptionKey();
  const iv = crypto11.randomBytes(IV_LENGTH);
  const cipher = crypto11.createCipheriv(ENCRYPTION_ALGORITHM, key, iv, { authTagLength: AUTH_TAG_LENGTH });
  let encrypted = cipher.update(plaintext, "utf8", "hex");
  encrypted += cipher.final("hex");
  const authTag = cipher.getAuthTag();
  return `${iv.toString("hex")}:${authTag.toString("hex")}:${encrypted}`;
}
function decryptToken(encryptedData) {
  if (!encryptedData) {
    return null;
  }
  const parts = encryptedData.split(":");
  if (parts.length !== 3) {
    if (process.env.NODE_ENV === "production") {
      console.warn("Token appears unencrypted - rejecting in production for security");
      return null;
    }
    console.warn("Token appears unencrypted - allowing in development only");
    return encryptedData;
  }
  try {
    const key = getEncryptionKey();
    const [ivHex, authTagHex, encrypted] = parts;
    const iv = Buffer.from(ivHex, "hex");
    const authTag = Buffer.from(authTagHex, "hex");
    const decipher = crypto11.createDecipheriv(ENCRYPTION_ALGORITHM, key, iv, { authTagLength: AUTH_TAG_LENGTH });
    decipher.setAuthTag(authTag);
    let decrypted = decipher.update(encrypted, "hex", "utf8");
    decrypted += decipher.final("utf8");
    return decrypted;
  } catch (error) {
    console.error("Token decryption failed:", error);
    return null;
  }
}
function getDecryptedToken(integration, tokenField) {
  const encryptedToken = integration[tokenField];
  return decryptToken(encryptedToken);
}
var MetaIntegrationService = class {
  config;
  constructor() {
    this.config = {
      clientId: process.env.META_APP_ID || "",
      clientSecret: process.env.META_APP_SECRET || "",
      redirectUri: process.env.META_REDIRECT_URI || `${process.env.REPLIT_DEV_DOMAIN || ""}/api/meta/callback`
    };
  }
  getOAuthUrl(salonId, state) {
    const scopes = [
      "pages_manage_cta",
      "pages_read_engagement",
      "pages_messaging",
      "instagram_basic",
      "instagram_manage_messages",
      "business_management"
    ].join(",");
    const stateParam = state || Buffer.from(JSON.stringify({ salonId })).toString("base64");
    return `https://www.facebook.com/${META_GRAPH_API_VERSION}/dialog/oauth?client_id=${this.config.clientId}&redirect_uri=${encodeURIComponent(this.config.redirectUri)}&scope=${scopes}&state=${stateParam}&response_type=code`;
  }
  async exchangeCodeForToken(code) {
    const response = await fetch(
      `${META_GRAPH_API_URL}/oauth/access_token?client_id=${this.config.clientId}&client_secret=${this.config.clientSecret}&redirect_uri=${encodeURIComponent(this.config.redirectUri)}&code=${code}`
    );
    if (!response.ok) {
      const error = await response.json();
      throw new Error(`Failed to exchange code: ${error.error?.message || "Unknown error"}`);
    }
    const data = await response.json();
    const longLivedResponse = await fetch(
      `${META_GRAPH_API_URL}/oauth/access_token?grant_type=fb_exchange_token&client_id=${this.config.clientId}&client_secret=${this.config.clientSecret}&fb_exchange_token=${data.access_token}`
    );
    if (!longLivedResponse.ok) {
      return {
        accessToken: data.access_token,
        expiresIn: data.expires_in || 3600,
        userId: ""
      };
    }
    const longLivedData = await longLivedResponse.json();
    const meResponse = await fetch(
      `${META_GRAPH_API_URL}/me?access_token=${longLivedData.access_token}`
    );
    const meData = await meResponse.json();
    return {
      accessToken: longLivedData.access_token,
      expiresIn: longLivedData.expires_in || 5184e3,
      userId: meData.id
    };
  }
  async getUserPages(userAccessToken) {
    const response = await fetch(
      `${META_GRAPH_API_URL}/me/accounts?fields=id,name,access_token,category,instagram_business_account{id,username}&access_token=${userAccessToken}`
    );
    if (!response.ok) {
      const error = await response.json();
      throw new Error(`Failed to fetch pages: ${error.error?.message || "Unknown error"}`);
    }
    const data = await response.json();
    return data.data.map((page) => ({
      id: page.id,
      name: page.name,
      accessToken: page.access_token,
      category: page.category,
      instagramBusinessAccount: page.instagram_business_account ? {
        id: page.instagram_business_account.id,
        username: page.instagram_business_account.username
      } : void 0
    }));
  }
  async connectSalonToPage(salonId, page, userAccessToken, userId) {
    const hasAccess = await subscriptionService.checkFeatureAccess(salonId, "facebookBooking");
    if (!hasAccess) {
      throw new Error("Facebook booking feature requires Growth or Elite subscription");
    }
    const webhookVerifyToken = crypto11.randomBytes(32).toString("hex");
    const now = /* @__PURE__ */ new Date();
    const tokenExpiresAt = new Date(now.getTime() + 60 * 24 * 60 * 60 * 1e3);
    const existing = await db.select().from(metaIntegrations).where(eq34(metaIntegrations.salonId, salonId)).limit(1);
    const encryptedPageToken = encryptToken(page.accessToken);
    const encryptedUserToken = encryptToken(userAccessToken);
    if (existing.length > 0) {
      await db.update(metaIntegrations).set({
        fbPageId: page.id,
        fbPageName: page.name,
        fbPageAccessToken: encryptedPageToken,
        fbPageTokenExpiresAt: tokenExpiresAt,
        igAccountId: page.instagramBusinessAccount?.id || null,
        igUsername: page.instagramBusinessAccount?.username || null,
        metaUserId: userId,
        metaUserAccessToken: encryptedUserToken,
        metaUserTokenExpiresAt: tokenExpiresAt,
        status: "active",
        webhookVerifyToken,
        lastSyncAt: now,
        syncError: null,
        updatedAt: now
      }).where(eq34(metaIntegrations.id, existing[0].id));
      return existing[0].id;
    }
    const [integration] = await db.insert(metaIntegrations).values({
      salonId,
      fbPageId: page.id,
      fbPageName: page.name,
      fbPageAccessToken: encryptedPageToken,
      fbPageTokenExpiresAt: tokenExpiresAt,
      igAccountId: page.instagramBusinessAccount?.id,
      igUsername: page.instagramBusinessAccount?.username,
      metaUserId: userId,
      metaUserAccessToken: encryptedUserToken,
      metaUserTokenExpiresAt: tokenExpiresAt,
      status: "active",
      webhookVerifyToken,
      lastSyncAt: now
    }).returning();
    return integration.id;
  }
  async disconnectSalon(salonId) {
    const [integration] = await db.select().from(metaIntegrations).where(eq34(metaIntegrations.salonId, salonId));
    if (!integration) {
      throw new Error("No Meta integration found for this salon");
    }
    await db.update(metaIntegrations).set({
      status: "disconnected",
      fbPageAccessToken: null,
      igAccessToken: null,
      metaUserAccessToken: null,
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq34(metaIntegrations.id, integration.id));
    return { success: true };
  }
  async getIntegrationStatus(salonId) {
    const [integration] = await db.select().from(metaIntegrations).where(eq34(metaIntegrations.salonId, salonId));
    if (!integration) {
      return {
        connected: false,
        facebook: null,
        instagram: null
      };
    }
    const now = /* @__PURE__ */ new Date();
    const fbTokenExpired = integration.fbPageTokenExpiresAt && integration.fbPageTokenExpiresAt < now;
    const igTokenExpired = integration.igTokenExpiresAt && integration.igTokenExpiresAt < now;
    return {
      connected: integration.status === "active",
      status: integration.status,
      facebook: integration.fbPageId ? {
        pageId: integration.fbPageId,
        pageName: integration.fbPageName,
        tokenExpired: fbTokenExpired,
        tokenExpiresAt: integration.fbPageTokenExpiresAt
      } : null,
      instagram: integration.igAccountId ? {
        accountId: integration.igAccountId,
        username: integration.igUsername,
        tokenExpired: igTokenExpired,
        tokenExpiresAt: integration.igTokenExpiresAt
      } : null,
      lastSyncAt: integration.lastSyncAt,
      syncError: integration.syncError,
      settings: {
        bookingLeadTimeHours: integration.bookingLeadTimeHours,
        cancellationPolicy: integration.cancellationPolicy,
        autoConfirmBookings: integration.autoConfirmBookings === 1,
        sendDmReminders: integration.sendDmReminders === 1
      }
    };
  }
  async updateIntegrationSettings(salonId, settings) {
    const [integration] = await db.select().from(metaIntegrations).where(eq34(metaIntegrations.salonId, salonId));
    if (!integration) {
      throw new Error("No Meta integration found for this salon");
    }
    await db.update(metaIntegrations).set({
      bookingLeadTimeHours: settings.bookingLeadTimeHours ?? integration.bookingLeadTimeHours,
      cancellationPolicy: settings.cancellationPolicy ?? integration.cancellationPolicy,
      autoConfirmBookings: settings.autoConfirmBookings !== void 0 ? settings.autoConfirmBookings ? 1 : 0 : integration.autoConfirmBookings,
      sendDmReminders: settings.sendDmReminders !== void 0 ? settings.sendDmReminders ? 1 : 0 : integration.sendDmReminders,
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq34(metaIntegrations.id, integration.id));
    return this.getIntegrationStatus(salonId);
  }
  async getDecryptedAccessToken(salonId) {
    const [integration] = await db.select().from(metaIntegrations).where(eq34(metaIntegrations.salonId, salonId));
    if (!integration) {
      return { pageToken: null, userToken: null };
    }
    return {
      pageToken: getDecryptedToken(integration, "fbPageAccessToken"),
      userToken: getDecryptedToken(integration, "metaUserAccessToken")
    };
  }
  verifyWebhookSignature(payload, signature) {
    if (!this.config.clientSecret) {
      if (process.env.NODE_ENV === "production") {
        console.error("META_APP_SECRET not configured in production - rejecting webhook");
        return { valid: false, error: "META_APP_SECRET not configured" };
      }
      console.warn("META_APP_SECRET not configured - allowing webhook in development/sandbox mode");
      return { valid: true };
    }
    if (!signature) {
      return { valid: false, error: "Missing X-Hub-Signature-256 header" };
    }
    const expectedSignature = crypto11.createHmac("sha256", this.config.clientSecret).update(payload).digest("hex");
    const providedSignature = signature.replace("sha256=", "");
    if (providedSignature.length !== expectedSignature.length) {
      return { valid: false, error: "Invalid signature format" };
    }
    const isValid = crypto11.timingSafeEqual(
      Buffer.from(providedSignature),
      Buffer.from(expectedSignature)
    );
    if (!isValid) {
      return { valid: false, error: "Signature verification failed" };
    }
    return { valid: true };
  }
  async processWebhookEvent(eventType, payload, signature) {
    const [event] = await db.insert(metaWebhookEvents).values({
      eventType,
      payload,
      signature,
      processed: 0
    }).returning();
    try {
      switch (eventType) {
        case "page":
          await this.handlePageEvent(payload);
          break;
        case "instagram":
          await this.handleInstagramEvent(payload);
          break;
        case "messaging":
          await this.handleMessagingEvent(payload);
          break;
        default:
          console.log(`Unhandled webhook event type: ${eventType}`);
      }
      await db.update(metaWebhookEvents).set({
        processed: 1,
        processedAt: /* @__PURE__ */ new Date()
      }).where(eq34(metaWebhookEvents.id, event.id));
    } catch (error) {
      await db.update(metaWebhookEvents).set({
        processed: 0,
        error: error.message
      }).where(eq34(metaWebhookEvents.id, event.id));
      throw error;
    }
    return event.id;
  }
  async handlePageEvent(payload) {
    console.log("Processing page event:", JSON.stringify(payload, null, 2));
  }
  async handleInstagramEvent(payload) {
    console.log("Processing Instagram event:", JSON.stringify(payload, null, 2));
  }
  async handleMessagingEvent(payload) {
    console.log("Processing messaging event:", JSON.stringify(payload, null, 2));
  }
  async trackButtonClick(salonId, source) {
    const today = /* @__PURE__ */ new Date();
    today.setHours(0, 0, 0, 0);
    const [existing] = await db.select().from(socialBookingAnalytics).where(
      and34(
        eq34(socialBookingAnalytics.salonId, salonId),
        eq34(socialBookingAnalytics.source, source),
        gte13(socialBookingAnalytics.date, today)
      )
    );
    if (existing) {
      await db.update(socialBookingAnalytics).set({
        buttonClicks: existing.buttonClicks + 1
      }).where(eq34(socialBookingAnalytics.id, existing.id));
    } else {
      await db.insert(socialBookingAnalytics).values({
        salonId,
        date: today,
        source,
        buttonClicks: 1
      });
    }
  }
  async trackBookingStarted(salonId, source) {
    const today = /* @__PURE__ */ new Date();
    today.setHours(0, 0, 0, 0);
    const [existing] = await db.select().from(socialBookingAnalytics).where(
      and34(
        eq34(socialBookingAnalytics.salonId, salonId),
        eq34(socialBookingAnalytics.source, source),
        gte13(socialBookingAnalytics.date, today)
      )
    );
    if (existing) {
      await db.update(socialBookingAnalytics).set({
        bookingStarted: existing.bookingStarted + 1
      }).where(eq34(socialBookingAnalytics.id, existing.id));
    }
  }
  async trackBookingCompleted(salonId, source, revenuePaisa) {
    const today = /* @__PURE__ */ new Date();
    today.setHours(0, 0, 0, 0);
    const [existing] = await db.select().from(socialBookingAnalytics).where(
      and34(
        eq34(socialBookingAnalytics.salonId, salonId),
        eq34(socialBookingAnalytics.source, source),
        gte13(socialBookingAnalytics.date, today)
      )
    );
    if (existing) {
      await db.update(socialBookingAnalytics).set({
        bookingsCompleted: existing.bookingsCompleted + 1,
        revenuePaisa: existing.revenuePaisa + revenuePaisa
      }).where(eq34(socialBookingAnalytics.id, existing.id));
    }
  }
  async getAnalytics(salonId, days = 30) {
    const startDate = /* @__PURE__ */ new Date();
    startDate.setDate(startDate.getDate() - days);
    startDate.setHours(0, 0, 0, 0);
    const analytics = await db.select().from(socialBookingAnalytics).where(
      and34(
        eq34(socialBookingAnalytics.salonId, salonId),
        gte13(socialBookingAnalytics.date, startDate)
      )
    ).orderBy(desc24(socialBookingAnalytics.date));
    const totals = {
      instagram: {
        buttonClicks: 0,
        bookingStarted: 0,
        bookingsCompleted: 0,
        bookingsCancelled: 0,
        revenue: 0
      },
      facebook: {
        buttonClicks: 0,
        bookingStarted: 0,
        bookingsCompleted: 0,
        bookingsCancelled: 0,
        revenue: 0
      }
    };
    for (const record of analytics) {
      const source = record.source;
      if (totals[source]) {
        totals[source].buttonClicks += record.buttonClicks;
        totals[source].bookingStarted += record.bookingStarted;
        totals[source].bookingsCompleted += record.bookingsCompleted;
        totals[source].bookingsCancelled += record.bookingsCancelled;
        totals[source].revenue += record.revenuePaisa / 100;
      }
    }
    return {
      period: { start: startDate, end: /* @__PURE__ */ new Date() },
      totals,
      daily: analytics.map((a) => ({
        date: a.date,
        source: a.source,
        buttonClicks: a.buttonClicks,
        bookingStarted: a.bookingStarted,
        bookingsCompleted: a.bookingsCompleted,
        bookingsCancelled: a.bookingsCancelled,
        revenue: a.revenuePaisa / 100,
        conversionRate: a.buttonClicks > 0 ? (a.bookingsCompleted / a.buttonClicks * 100).toFixed(1) : "0"
      }))
    };
  }
};
var metaIntegrationService = new MetaIntegrationService();

// server/routes/meta.routes.ts
init_db();
init_schema();
import { eq as eq35 } from "drizzle-orm";
var router24 = Router23();
router24.get("/connect/:salonId", async (req, res) => {
  try {
    const { salonId } = req.params;
    const [salon] = await db.select().from(salons).where(eq35(salons.id, salonId));
    if (!salon) {
      return res.status(404).json({ error: "Salon not found" });
    }
    const hasAccess = await subscriptionService.checkFeatureAccess(salonId, "facebookBooking");
    if (!hasAccess) {
      return res.status(403).json({
        error: "Facebook/Instagram booking requires Growth or Elite subscription",
        upgradeRequired: true
      });
    }
    const state = Buffer.from(JSON.stringify({ salonId, timestamp: Date.now() })).toString("base64");
    const oauthUrl = metaIntegrationService.getOAuthUrl(salonId, state);
    res.json({ oauthUrl });
  } catch (error) {
    console.error("Error generating OAuth URL:", error);
    res.status(500).json({ error: "Failed to initiate Meta connection" });
  }
});
router24.get("/callback", async (req, res) => {
  try {
    const { code, state, error, error_description } = req.query;
    if (error) {
      console.error("OAuth error:", error, error_description);
      return res.redirect(`/salon/settings/integrations?error=${encodeURIComponent(error_description || "Connection failed")}`);
    }
    if (!code || !state) {
      return res.redirect("/salon/settings/integrations?error=Missing authorization code");
    }
    let stateData;
    try {
      stateData = JSON.parse(Buffer.from(state, "base64").toString());
    } catch {
      return res.redirect("/salon/settings/integrations?error=Invalid state parameter");
    }
    const { accessToken, userId } = await metaIntegrationService.exchangeCodeForToken(code);
    const pages = await metaIntegrationService.getUserPages(accessToken);
    if (pages.length === 0) {
      return res.redirect(`/salon/settings/integrations?error=No Facebook Pages found. Please create a Page first.`);
    }
    if (pages.length === 1) {
      await metaIntegrationService.connectSalonToPage(stateData.salonId, pages[0], accessToken, userId);
      return res.redirect(`/salon/settings/integrations?success=true&page=${encodeURIComponent(pages[0].name)}`);
    }
    const pagesParam = Buffer.from(JSON.stringify(pages.map((p) => ({
      id: p.id,
      name: p.name,
      instagram: p.instagramBusinessAccount?.username
    })))).toString("base64");
    res.redirect(`/salon/settings/integrations/select-page?pages=${pagesParam}&token=${Buffer.from(accessToken).toString("base64")}&userId=${userId}&salonId=${stateData.salonId}`);
  } catch (error) {
    console.error("OAuth callback error:", error);
    res.redirect(`/salon/settings/integrations?error=${encodeURIComponent(error.message || "Connection failed")}`);
  }
});
router24.post("/connect/:salonId/select-page", async (req, res) => {
  try {
    const { salonId } = req.params;
    const { pageId, token, userId } = req.body;
    if (!pageId || !token || !userId) {
      return res.status(400).json({ error: "Missing required parameters" });
    }
    const accessToken = Buffer.from(token, "base64").toString();
    const pages = await metaIntegrationService.getUserPages(accessToken);
    const selectedPage = pages.find((p) => p.id === pageId);
    if (!selectedPage) {
      return res.status(404).json({ error: "Page not found" });
    }
    await metaIntegrationService.connectSalonToPage(salonId, selectedPage, accessToken, userId);
    res.json({
      success: true,
      message: `Connected to ${selectedPage.name}`,
      facebook: {
        pageId: selectedPage.id,
        pageName: selectedPage.name
      },
      instagram: selectedPage.instagramBusinessAccount ? {
        accountId: selectedPage.instagramBusinessAccount.id,
        username: selectedPage.instagramBusinessAccount.username
      } : null
    });
  } catch (error) {
    console.error("Error selecting page:", error);
    res.status(500).json({ error: error.message || "Failed to connect to page" });
  }
});
router24.post("/disconnect/:salonId", async (req, res) => {
  try {
    const { salonId } = req.params;
    await metaIntegrationService.disconnectSalon(salonId);
    res.json({
      success: true,
      message: "Disconnected from Facebook/Instagram"
    });
  } catch (error) {
    console.error("Error disconnecting:", error);
    res.status(500).json({ error: error.message || "Failed to disconnect" });
  }
});
router24.get("/status/:salonId", async (req, res) => {
  try {
    const { salonId } = req.params;
    const status = await metaIntegrationService.getIntegrationStatus(salonId);
    res.json(status);
  } catch (error) {
    console.error("Error getting status:", error);
    res.status(500).json({ error: "Failed to get integration status" });
  }
});
router24.put("/settings/:salonId", async (req, res) => {
  try {
    const { salonId } = req.params;
    const settings = req.body;
    const updated = await metaIntegrationService.updateIntegrationSettings(salonId, settings);
    res.json({
      success: true,
      settings: updated.settings
    });
  } catch (error) {
    console.error("Error updating settings:", error);
    res.status(500).json({ error: error.message || "Failed to update settings" });
  }
});
router24.get("/analytics/:salonId", async (req, res) => {
  try {
    const { salonId } = req.params;
    const days = parseInt(req.query.days) || 30;
    const hasAccess = await subscriptionService.checkFeatureAccess(salonId, "analyticsAdvanced");
    if (!hasAccess) {
      return res.status(403).json({
        error: "Advanced analytics requires Growth or Elite subscription",
        upgradeRequired: true
      });
    }
    const analytics = await metaIntegrationService.getAnalytics(salonId, days);
    res.json(analytics);
  } catch (error) {
    console.error("Error fetching analytics:", error);
    res.status(500).json({ error: "Failed to fetch analytics" });
  }
});
router24.get("/webhook", async (req, res) => {
  const mode = req.query["hub.mode"];
  const token = req.query["hub.verify_token"];
  const challenge = req.query["hub.challenge"];
  const verifyToken = process.env.META_WEBHOOK_VERIFY_TOKEN;
  if (mode === "subscribe" && token === verifyToken) {
    console.log("Meta webhook verified");
    res.status(200).send(challenge);
  } else {
    console.error("Meta webhook verification failed");
    res.status(403).send("Verification failed");
  }
});
router24.post("/webhook", async (req, res) => {
  try {
    const signature = req.headers["x-hub-signature-256"];
    const rawBody = typeof req.body === "string" ? req.body : JSON.stringify(req.body);
    const verification = metaIntegrationService.verifyWebhookSignature(rawBody, signature);
    if (!verification.valid) {
      console.error("Invalid webhook signature:", verification.error);
      return res.status(401).json({ error: "Invalid signature", details: verification.error });
    }
    const { object, entry } = typeof req.body === "string" ? JSON.parse(req.body) : req.body;
    if (!entry || !Array.isArray(entry)) {
      return res.status(200).send("OK");
    }
    for (const event of entry) {
      await metaIntegrationService.processWebhookEvent(object, event, signature);
    }
    res.status(200).send("OK");
  } catch (error) {
    console.error("Webhook processing error:", error);
    res.status(200).send("OK");
  }
});
router24.post("/track/click/:salonId", async (req, res) => {
  try {
    const { salonId } = req.params;
    const { source } = req.body;
    if (!["instagram", "facebook"].includes(source)) {
      return res.status(400).json({ error: "Invalid source" });
    }
    await metaIntegrationService.trackButtonClick(salonId, source);
    res.json({ success: true });
  } catch (error) {
    console.error("Error tracking click:", error);
    res.status(500).json({ error: "Failed to track click" });
  }
});
router24.post("/track/booking-started/:salonId", async (req, res) => {
  try {
    const { salonId } = req.params;
    const { source } = req.body;
    if (!["instagram", "facebook"].includes(source)) {
      return res.status(400).json({ error: "Invalid source" });
    }
    await metaIntegrationService.trackBookingStarted(salonId, source);
    res.json({ success: true });
  } catch (error) {
    console.error("Error tracking booking started:", error);
    res.status(500).json({ error: "Failed to track" });
  }
});
var meta_routes_default = router24;

// server/routes/settings.routes.ts
init_db();
init_schema();
import { Router as Router24 } from "express";
import { eq as eq36, desc as desc25 } from "drizzle-orm";
var router25 = Router24();
var DEFAULT_SETTINGS = {
  general: {
    platformName: "Stylemate",
    platformTagline: "Connect with the best salons near you",
    contactEmail: "support@stylemate.in",
    contactPhone: "+91-9999999999",
    defaultCurrency: "INR",
    defaultTimezone: "Asia/Kolkata",
    defaultLanguage: "en"
  },
  booking: {
    advanceBookingDays: 30,
    minBookingNoticeMins: 60,
    maxServicesPerBooking: 5,
    bufferTimeMins: 15,
    allowInstantBooking: true,
    requirePhoneVerification: false,
    cancellationWindowHours: 24,
    rescheduleWindowHours: 12,
    noShowPenaltyPercent: 0
  },
  payment: {
    razorpayEnabled: true,
    defaultCommissionPercent: 10,
    minPayoutAmountPaisa: 5e4,
    payoutFrequency: "weekly",
    gstPercent: 18,
    allowPartialPayments: false,
    allowCashPayments: true,
    allowWalletPayments: true
  },
  communication: {
    sendGridEnabled: false,
    twilioEnabled: false,
    enableEmailNotifications: true,
    enableSmsNotifications: true,
    enablePushNotifications: true,
    bookingConfirmationEmail: true,
    bookingReminderHoursBefore: 24,
    marketingEmailsEnabled: false
  },
  security: {
    minPasswordLength: 8,
    requirePasswordUppercase: true,
    requirePasswordNumber: true,
    requirePasswordSpecial: false,
    sessionTimeoutMins: 1440,
    maxLoginAttempts: 5,
    lockoutDurationMins: 30,
    require2FAForAdmin: false,
    enableAuditLogs: true
  },
  features: {
    enableEvents: true,
    enableShop: true,
    enableLoyalty: true,
    enableReferrals: true,
    enableAIConsultant: true,
    enableJobCards: true,
    enableMetaIntegration: true,
    enableSmartRebooking: true,
    enableGiftCards: true,
    enableCustomerImport: true,
    enableReviews: true,
    enableWaitlist: false,
    enableDynamicPricing: false
  },
  maintenance: {
    maintenanceMode: false,
    maintenanceMessage: "We are currently performing scheduled maintenance. Please check back soon.",
    maintenanceEndTime: null,
    allowAdminAccess: true
  },
  branding: {
    primaryColor: "#8B5CF6",
    secondaryColor: "#EC4899",
    logoUrl: "",
    faviconUrl: "",
    footerText: "\xA9 2025 Stylemate. All rights reserved.",
    showPoweredBy: true
  }
};
router25.get("/admin/all", populateUserFromSession, requireSuperAdmin(), async (req, res) => {
  try {
    const configs = await db.select().from(platformConfig);
    const settings = JSON.parse(JSON.stringify(DEFAULT_SETTINGS));
    for (const config of configs) {
      if (config.configKey.includes(".")) {
        const [category, key] = config.configKey.split(".");
        if (settings[category]) {
          settings[category][key] = config.configValue;
        }
      } else {
        const categorySettings = config.configValue;
        if (settings[config.configKey]) {
          settings[config.configKey] = { ...settings[config.configKey], ...categorySettings };
        }
      }
    }
    res.json({ settings, lastUpdated: configs[0]?.updatedAt });
  } catch (error) {
    console.error("Error fetching platform settings:", error);
    res.status(500).json({ error: "Failed to fetch platform settings" });
  }
});
router25.get("/admin/:category", populateUserFromSession, requireSuperAdmin(), async (req, res) => {
  try {
    const { category } = req.params;
    if (!DEFAULT_SETTINGS[category]) {
      return res.status(404).json({ error: "Settings category not found" });
    }
    const [config] = await db.select().from(platformConfig).where(eq36(platformConfig.configKey, category));
    const settings = config ? { ...DEFAULT_SETTINGS[category], ...config.configValue } : DEFAULT_SETTINGS[category];
    res.json({
      category,
      settings,
      lastUpdated: config?.updatedAt
    });
  } catch (error) {
    console.error("Error fetching settings category:", error);
    res.status(500).json({ error: "Failed to fetch settings" });
  }
});
router25.put("/admin/:category", populateUserFromSession, requireSuperAdmin(), async (req, res) => {
  try {
    const { category } = req.params;
    const userId = req.user?.id;
    if (!DEFAULT_SETTINGS[category]) {
      return res.status(404).json({ error: "Settings category not found" });
    }
    const updates = req.body;
    const allowedKeys = Object.keys(DEFAULT_SETTINGS[category]);
    const sanitizedUpdates = {};
    for (const key of Object.keys(updates)) {
      if (allowedKeys.includes(key)) {
        sanitizedUpdates[key] = updates[key];
      }
    }
    const [existingConfig] = await db.select().from(platformConfig).where(eq36(platformConfig.configKey, category));
    if (existingConfig) {
      const currentSettings = existingConfig.configValue;
      const mergedSettings = { ...currentSettings, ...sanitizedUpdates };
      await db.update(platformConfig).set({
        configValue: mergedSettings,
        updatedBy: userId,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq36(platformConfig.configKey, category));
    } else {
      await db.insert(platformConfig).values({
        configKey: category,
        configValue: sanitizedUpdates,
        description: `${category.charAt(0).toUpperCase() + category.slice(1)} settings`,
        updatedBy: userId
      });
    }
    const [updatedConfig] = await db.select().from(platformConfig).where(eq36(platformConfig.configKey, category));
    const finalSettings = {
      ...DEFAULT_SETTINGS[category],
      ...updatedConfig?.configValue
    };
    res.json({
      success: true,
      message: `${category} settings updated successfully`,
      settings: finalSettings
    });
  } catch (error) {
    console.error("Error updating settings:", error);
    res.status(500).json({ error: "Failed to update settings" });
  }
});
router25.post("/admin/reset/:category", populateUserFromSession, requireSuperAdmin(), async (req, res) => {
  try {
    const { category } = req.params;
    if (!DEFAULT_SETTINGS[category]) {
      return res.status(404).json({ error: "Settings category not found" });
    }
    await db.delete(platformConfig).where(eq36(platformConfig.configKey, category));
    res.json({
      success: true,
      message: `${category} settings reset to defaults`,
      settings: DEFAULT_SETTINGS[category]
    });
  } catch (error) {
    console.error("Error resetting settings:", error);
    res.status(500).json({ error: "Failed to reset settings" });
  }
});
router25.get("/admin/audit-log", populateUserFromSession, requireSuperAdmin(), async (req, res) => {
  try {
    const { limit = 50 } = req.query;
    const configs = await db.select({
      id: platformConfig.id,
      configKey: platformConfig.configKey,
      updatedBy: platformConfig.updatedBy,
      updatedAt: platformConfig.updatedAt,
      updatedByUser: users.email
    }).from(platformConfig).leftJoin(users, eq36(platformConfig.updatedBy, users.id)).orderBy(desc25(platformConfig.updatedAt)).limit(Number(limit));
    res.json({ auditLog: configs });
  } catch (error) {
    console.error("Error fetching audit log:", error);
    res.status(500).json({ error: "Failed to fetch audit log" });
  }
});
router25.get("/admin/defaults", populateUserFromSession, requireSuperAdmin(), async (req, res) => {
  res.json({ defaults: DEFAULT_SETTINGS });
});
router25.post("/admin/toggle-maintenance", populateUserFromSession, requireSuperAdmin(), async (req, res) => {
  try {
    const { enabled, message, endTime } = req.body;
    const userId = req.user?.id;
    const maintenanceSettings = {
      maintenanceMode: enabled,
      maintenanceMessage: message || DEFAULT_SETTINGS.maintenance.maintenanceMessage,
      maintenanceEndTime: endTime || null,
      allowAdminAccess: true
    };
    const [existingConfig] = await db.select().from(platformConfig).where(eq36(platformConfig.configKey, "maintenance"));
    if (existingConfig) {
      await db.update(platformConfig).set({
        configValue: maintenanceSettings,
        updatedBy: userId,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq36(platformConfig.configKey, "maintenance"));
    } else {
      await db.insert(platformConfig).values({
        configKey: "maintenance",
        configValue: maintenanceSettings,
        description: "Maintenance mode settings",
        updatedBy: userId
      });
    }
    res.json({
      success: true,
      message: enabled ? "Maintenance mode enabled" : "Maintenance mode disabled",
      settings: maintenanceSettings
    });
  } catch (error) {
    console.error("Error toggling maintenance mode:", error);
    res.status(500).json({ error: "Failed to toggle maintenance mode" });
  }
});
router25.post("/admin/toggle-feature", populateUserFromSession, requireSuperAdmin(), async (req, res) => {
  try {
    const { feature, enabled } = req.body;
    const userId = req.user?.id;
    if (!Object.keys(DEFAULT_SETTINGS.features).includes(feature)) {
      return res.status(400).json({ error: "Invalid feature key" });
    }
    const [existingConfig] = await db.select().from(platformConfig).where(eq36(platformConfig.configKey, "features"));
    const currentFeatures = existingConfig?.configValue || {};
    const updatedFeatures = { ...currentFeatures, [feature]: enabled };
    if (existingConfig) {
      await db.update(platformConfig).set({
        configValue: updatedFeatures,
        updatedBy: userId,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq36(platformConfig.configKey, "features"));
    } else {
      await db.insert(platformConfig).values({
        configKey: "features",
        configValue: updatedFeatures,
        description: "Feature flags",
        updatedBy: userId
      });
    }
    res.json({
      success: true,
      feature,
      enabled,
      message: `Feature "${feature}" ${enabled ? "enabled" : "disabled"}`
    });
  } catch (error) {
    console.error("Error toggling feature:", error);
    res.status(500).json({ error: "Failed to toggle feature" });
  }
});
var settings_routes_default = router25;

// server/routes/mobile-user.routes.ts
init_db();
init_schema();
import { eq as eq37, and as and35, sql as sql29, desc as desc26 } from "drizzle-orm";
import { z as z16 } from "zod";
var updateProfileSchema = z16.object({
  firstName: z16.string().min(1).max(100).optional(),
  lastName: z16.string().min(1).max(100).optional(),
  phoneNumber: z16.string().min(10).max(20).optional(),
  email: z16.string().email().optional(),
  profileImageUrl: z16.string().url().optional().nullable()
});
function registerMobileUserRoutes(app2) {
  app2.get("/api/mobile/users/profile", authenticateMobileUser, async (req, res) => {
    try {
      const userId = req.user.id;
      const user = await db.query.users.findFirst({
        where: eq37(users.id, userId)
      });
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }
      res.json({
        success: true,
        user: {
          id: user.id,
          firstName: user.firstName,
          lastName: user.lastName,
          email: user.email,
          phone: user.phone,
          profileImageUrl: user.profileImageUrl,
          emailVerified: user.emailVerified === 1,
          phoneVerified: user.phoneVerified === 1,
          createdAt: user.createdAt,
          memberSince: user.createdAt ? new Date(user.createdAt).toLocaleDateString("en-US", { month: "short", year: "numeric" }) : null
        }
      });
    } catch (error) {
      console.error("Error fetching user profile:", error);
      res.status(500).json({ error: "Failed to fetch user profile" });
    }
  });
  app2.patch("/api/mobile/users/profile", authenticateMobileUser, async (req, res) => {
    try {
      const userId = req.user.id;
      const parsed = updateProfileSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ error: "Invalid request body", details: parsed.error.errors });
      }
      const updateData = {};
      if (parsed.data.firstName !== void 0) updateData.firstName = parsed.data.firstName;
      if (parsed.data.lastName !== void 0) updateData.lastName = parsed.data.lastName;
      if (parsed.data.phoneNumber !== void 0) updateData.phone = parsed.data.phoneNumber;
      if (parsed.data.email !== void 0) updateData.email = parsed.data.email;
      if (parsed.data.profileImageUrl !== void 0) updateData.profileImageUrl = parsed.data.profileImageUrl;
      updateData.updatedAt = /* @__PURE__ */ new Date();
      if (parsed.data.email) {
        const existingEmail = await db.query.users.findFirst({
          where: and35(
            eq37(users.email, parsed.data.email),
            sql29`${users.id} != ${userId}`
          )
        });
        if (existingEmail) {
          return res.status(409).json({
            error: "Email already in use",
            field: "email"
          });
        }
      }
      if (parsed.data.phoneNumber) {
        const existingPhone = await db.query.users.findFirst({
          where: and35(
            eq37(users.phone, parsed.data.phoneNumber),
            sql29`${users.id} != ${userId}`
          )
        });
        if (existingPhone) {
          return res.status(409).json({
            error: "Phone number already in use",
            field: "phoneNumber"
          });
        }
      }
      const [updatedUser] = await db.update(users).set(updateData).where(eq37(users.id, userId)).returning();
      res.json({
        success: true,
        user: {
          id: updatedUser.id,
          firstName: updatedUser.firstName,
          lastName: updatedUser.lastName,
          email: updatedUser.email,
          phone: updatedUser.phone,
          profileImageUrl: updatedUser.profileImageUrl,
          emailVerified: updatedUser.emailVerified === 1,
          phoneVerified: updatedUser.phoneVerified === 1
        }
      });
    } catch (error) {
      console.error("Error updating user profile:", error);
      if (error.code === "23505") {
        return res.status(409).json({
          error: "Email or phone number already in use",
          details: error.detail
        });
      }
      res.status(500).json({ error: "Failed to update user profile" });
    }
  });
  app2.get("/api/mobile/users/stats", authenticateMobileUser, async (req, res) => {
    try {
      const userId = req.user.id;
      const now = /* @__PURE__ */ new Date();
      const [upcomingResult] = await db.select({ count: sql29`count(*)` }).from(bookings).where(and35(
        eq37(bookings.userId, userId),
        sql29`${bookings.status} IN ('pending', 'confirmed')`,
        sql29`${bookings.bookingDate}::date >= CURRENT_DATE`
      ));
      const [totalResult] = await db.select({ count: sql29`count(*)` }).from(bookings).where(eq37(bookings.userId, userId));
      const [spentResult] = await db.select({
        total: sql29`COALESCE(SUM(${bookings.finalAmountPaisa}), 0)`
      }).from(bookings).where(and35(
        eq37(bookings.userId, userId),
        eq37(bookings.status, "completed")
      ));
      const favoriteServiceResult = await db.select({
        serviceName: services.name,
        count: sql29`count(*)`
      }).from(bookings).innerJoin(services, eq37(bookings.serviceId, services.id)).where(and35(
        eq37(bookings.userId, userId),
        eq37(bookings.status, "completed")
      )).groupBy(services.name).orderBy(desc26(sql29`count(*)`)).limit(1);
      res.json({
        success: true,
        stats: {
          upcomingBookings: parseInt(String(upcomingResult?.count || 0)),
          totalBookings: parseInt(String(totalResult?.count || 0)),
          totalSpent: parseInt(String(spentResult?.total || 0)),
          totalSpentFormatted: `\u20B9${(parseInt(String(spentResult?.total || 0)) / 100).toFixed(0)}`,
          favoriteService: favoriteServiceResult[0]?.serviceName || "None",
          favoriteServiceCount: parseInt(String(favoriteServiceResult[0]?.count || 0))
        }
      });
    } catch (error) {
      console.error("Error fetching user stats:", error);
      res.status(500).json({ error: "Failed to fetch user stats" });
    }
  });
}

// server/routes/mobile-bookings.routes.ts
init_db();
init_schema();
import { eq as eq38, and as and36, sql as sql30, desc as desc27, or as or13, asc as asc6, inArray as inArray13 } from "drizzle-orm";
import { z as z17 } from "zod";
var cancelBookingSchema = z17.object({
  reason: z17.string().max(500).optional()
});
var rescheduleBookingSchema = z17.object({
  bookingDate: z17.string().regex(/^\d{4}-\d{2}-\d{2}$/),
  bookingTime: z17.string().regex(/^\d{2}:\d{2}$/)
});
var submitReviewSchema = z17.object({
  rating: z17.number().min(1).max(5),
  comment: z17.string().max(2e3).optional()
});
var createBookingSchema = z17.object({
  salonId: z17.string().min(1),
  serviceIds: z17.array(z17.string()).min(1),
  staffId: z17.string().optional(),
  date: z17.string().regex(/^\d{4}-\d{2}-\d{2}$/),
  time: z17.string().regex(/^\d{2}:\d{2}$/),
  serviceType: z17.enum(["salon", "home"]).default("salon"),
  address: z17.string().optional(),
  notes: z17.string().max(1e3).optional(),
  // Package booking fields
  packageId: z17.string().optional(),
  isPackageBooking: z17.boolean().optional(),
  totalPrice: z17.number().optional(),
  totalDuration: z17.number().optional(),
  // Offer/coupon discount fields
  offerId: z17.string().optional()
}).refine(
  (data) => data.serviceType !== "home" || data.address && data.address.trim().length > 0,
  { message: "Address is required for home service", path: ["address"] }
);
function registerMobileBookingsRoutes(app2) {
  app2.post("/api/mobile/bookings", authenticateMobileUser, async (req, res) => {
    try {
      const userId = req.user.id;
      const parsed = createBookingSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({
          error: "Invalid booking data",
          details: parsed.error.flatten()
        });
      }
      const { salonId, serviceIds, staffId, date, time, serviceType, address, notes } = parsed.data;
      const bookingDate = new Date(date);
      const today = /* @__PURE__ */ new Date();
      today.setHours(0, 0, 0, 0);
      if (bookingDate < today) {
        return res.status(400).json({ error: "Cannot book appointments in the past" });
      }
      const salon = await db.query.salons.findFirst({
        where: eq38(salons.id, salonId)
      });
      if (!salon) {
        return res.status(404).json({ error: "Salon not found" });
      }
      if (salon.isActive !== 1) {
        return res.status(400).json({ error: "This salon is not currently accepting bookings" });
      }
      const selectedServices = await db.select().from(services).where(and36(
        eq38(services.salonId, salonId),
        inArray13(services.id, serviceIds),
        eq38(services.isActive, 1)
      ));
      if (selectedServices.length === 0) {
        return res.status(400).json({ error: "No valid services found for this salon" });
      }
      if (selectedServices.length !== serviceIds.length) {
        const foundIds = new Set(selectedServices.map((s) => s.id));
        const invalidIds = serviceIds.filter((id) => !foundIds.has(id));
        return res.status(400).json({
          error: "Some services are invalid or do not belong to this salon",
          invalidServiceIds: invalidIds
        });
      }
      if (staffId) {
        const staffMember = await db.query.staff.findFirst({
          where: and36(
            eq38(staff.id, staffId),
            eq38(staff.salonId, salonId),
            eq38(staff.isActive, 1)
          )
        });
        if (!staffMember) {
          return res.status(400).json({ error: "Invalid or inactive staff member" });
        }
      }
      const user = await db.query.users.findFirst({
        where: eq38(users.id, userId)
      });
      if (!user) {
        return res.status(401).json({ error: "User not found" });
      }
      const serviceTotalPaisa = selectedServices.reduce((sum4, s) => sum4 + (s.priceInPaisa || 0), 0);
      const serviceTotalDuration = selectedServices.reduce((sum4, s) => sum4 + (s.durationMinutes || 0), 0);
      const primaryService = selectedServices[0];
      const serviceNames = selectedServices.map((s) => s.name).join(", ");
      let totalAmountPaisa = serviceTotalPaisa;
      let totalDuration = serviceTotalDuration;
      let packageName = null;
      let isPackageBookingFlag = false;
      const { packageId, isPackageBooking: isPackageBookingInput, totalPrice: clientTotalPrice, totalDuration: clientTotalDuration } = parsed.data;
      if (packageId && isPackageBookingInput) {
        const packageData = await db.query.servicePackages.findFirst({
          where: and36(
            eq38(servicePackages.id, packageId),
            eq38(servicePackages.salonId, salonId)
          )
        });
        if (!packageData) {
          return res.status(404).json({ error: "Package not found" });
        }
        if (!packageData.isActive) {
          return res.status(400).json({ error: "Package is no longer active" });
        }
        const now = /* @__PURE__ */ new Date();
        if (packageData.validFrom && new Date(packageData.validFrom) > now) {
          return res.status(400).json({ error: "Package is not yet available" });
        }
        if (packageData.validUntil && new Date(packageData.validUntil) < now) {
          return res.status(400).json({ error: "Package has expired" });
        }
        const packageServiceIds = Array.isArray(packageData.serviceIds) ? packageData.serviceIds : JSON.parse(packageData.serviceIds || "[]");
        const sortedPackageServiceIds = [...packageServiceIds].sort();
        const sortedRequestServiceIds = [...serviceIds].sort();
        if (JSON.stringify(sortedPackageServiceIds) !== JSON.stringify(sortedRequestServiceIds)) {
          console.warn(`Package service mismatch: package has ${packageServiceIds.join(",")}, request has ${serviceIds.join(",")}`);
          return res.status(400).json({
            error: "Service mismatch",
            details: "The services in your booking do not match the package contents"
          });
        }
        totalAmountPaisa = packageData.packagePriceInPaisa;
        totalDuration = packageData.totalDurationMinutes;
        packageName = packageData.name;
        isPackageBookingFlag = true;
        console.log(`\u{1F4E6} Mobile package booking: using package price ${totalAmountPaisa} instead of service total ${serviceTotalPaisa}`);
      } else {
        totalAmountPaisa = serviceTotalPaisa;
        totalDuration = serviceTotalDuration;
        if (clientTotalPrice && clientTotalPrice !== serviceTotalPaisa) {
          console.warn(`Non-package price mismatch ignored: client sent ${clientTotalPrice}, using server calculated ${serviceTotalPaisa}`);
        }
      }
      const { offerId } = parsed.data;
      let offerDiscountPaisa = 0;
      let appliedOffer = null;
      if (offerId && !isPackageBookingFlag) {
        const offer = await db.query.platformOffers.findFirst({
          where: eq38(platformOffers.id, offerId)
        });
        if (offer) {
          const now = /* @__PURE__ */ new Date();
          const validFrom = offer.validFrom ? new Date(offer.validFrom) : /* @__PURE__ */ new Date(0);
          const validUntil = offer.validUntil ? new Date(offer.validUntil) : /* @__PURE__ */ new Date("2099-12-31");
          const isDateValid = now >= validFrom && now <= validUntil;
          const isOfferActive = offer.isActive === 1 && isDateValid;
          const hasUsageRemaining = !offer.usageLimit || (offer.usageCount || 0) < offer.usageLimit;
          const isSalonApplicable = !offer.salonId || offer.salonId === salonId || offer.isPlatformWide === 1;
          const meetsMinimum = !offer.minimumPurchase || totalAmountPaisa >= offer.minimumPurchase;
          let userUsageValid = true;
          const maxPerUser = offer.maxUsagePerUser;
          if (maxPerUser) {
            const [userUsageCount] = await db.select({ count: sql30`count(*)` }).from(userOfferUsage).where(and36(
              eq38(userOfferUsage.userId, userId),
              eq38(userOfferUsage.offerId, offerId)
            ));
            const userUsages = parseInt(String(userUsageCount?.count || 0)) || 0;
            userUsageValid = userUsages < maxPerUser;
            if (!userUsageValid) {
              console.log(`\u26A0\uFE0F User ${userId} exceeded per-user limit for offer ${offerId}`);
            }
          }
          if (isOfferActive && hasUsageRemaining && isSalonApplicable && meetsMinimum && userUsageValid) {
            const offerDetails = {
              id: offer.id,
              title: offer.title,
              description: offer.description,
              discountType: offer.discountType,
              discountValue: offer.discountValue,
              minimumPurchase: offer.minimumPurchase,
              maxDiscount: offer.maxDiscount,
              isPlatformWide: offer.isPlatformWide,
              salonId: offer.salonId,
              ownedBySalonId: offer.ownedBySalonId,
              validFrom,
              validUntil,
              usageLimit: offer.usageLimit,
              usageCount: offer.usageCount || 0,
              imageUrl: offer.imageUrl
            };
            offerDiscountPaisa = OfferCalculator.calculateDiscount(offerDetails, totalAmountPaisa);
            if (offerDiscountPaisa > 0) {
              appliedOffer = {
                id: offer.id,
                title: offer.title,
                discountType: offer.discountType,
                discountValue: offer.discountValue
              };
              console.log(`\u{1F39F}\uFE0F Mobile offer applied: ${offer.title}, discount ${offerDiscountPaisa} paisa on total ${totalAmountPaisa}`);
            }
          } else {
            console.log(`\u26A0\uFE0F Offer ${offerId} not applicable: active=${isOfferActive}, usage=${hasUsageRemaining}, salon=${isSalonApplicable}, minimum=${meetsMinimum}`);
          }
        } else {
          console.warn(`\u26A0\uFE0F Offer ${offerId} not found`);
        }
      }
      const originalAmountPaisa = serviceTotalPaisa;
      const packageDiscountPaisa = isPackageBookingFlag ? serviceTotalPaisa - totalAmountPaisa : 0;
      const totalDiscountPaisa = packageDiscountPaisa + offerDiscountPaisa;
      const finalAmountPaisa = totalAmountPaisa - offerDiscountPaisa;
      const customerName = `${user.firstName || ""} ${user.lastName || ""}`.trim() || "Customer";
      const customerEmail = user.email || "";
      const customerPhone = user.phone || "";
      const bookingNotes = isPackageBookingFlag && packageName ? `Package: ${packageName}${notes ? `
${notes}` : ""}` : notes || null;
      const [newBooking] = await db.insert(bookings).values({
        userId,
        salonId,
        salonName: salon.name,
        serviceId: primaryService.id,
        staffId: staffId || null,
        bookingDate: date,
        bookingTime: time,
        status: "pending",
        totalAmountPaisa: finalAmountPaisa,
        originalAmountPaisa,
        finalAmountPaisa,
        discountAmountPaisa: totalDiscountPaisa,
        offerId: appliedOffer?.id || null,
        offerTitle: appliedOffer?.title || null,
        notes: bookingNotes,
        customerName,
        customerEmail,
        customerPhone
      }).returning();
      if (appliedOffer && offerDiscountPaisa > 0) {
        try {
          await db.update(platformOffers).set({ usageCount: sql30`COALESCE(${platformOffers.usageCount}, 0) + 1` }).where(eq38(platformOffers.id, appliedOffer.id));
          const [existingUsage] = await db.select({ count: sql30`count(*)` }).from(userOfferUsage).where(and36(
            eq38(userOfferUsage.userId, userId),
            eq38(userOfferUsage.offerId, appliedOffer.id)
          ));
          const usageNumber = (parseInt(String(existingUsage?.count || 0)) || 0) + 1;
          await db.insert(userOfferUsage).values({
            offerId: appliedOffer.id,
            userId,
            bookingId: newBooking.id,
            discountAppliedInPaisa: offerDiscountPaisa,
            usageNumber
          });
          console.log(`\u2705 Mobile offer usage tracked: user ${userId}, offer ${appliedOffer.id}, usage #${usageNumber}`);
        } catch (usageError) {
          console.error("Failed to track offer usage:", usageError);
        }
      }
      try {
        const { sendBookingConfirmation: sendBookingConfirmation2 } = await Promise.resolve().then(() => (init_communicationService(), communicationService_exports));
        await sendBookingConfirmation2(
          salonId,
          newBooking.id,
          customerEmail,
          customerPhone || void 0,
          {
            customer_name: customerName || "Valued Customer",
            salon_name: salon.name || "Our Salon",
            service_name: serviceNames,
            booking_date: date,
            booking_time: time,
            staff_name: staffId ? "Your assigned stylist" : "Our Team",
            total_amount: (finalAmountPaisa / 100).toFixed(0)
          }
        );
        console.log(`\u2705 Mobile booking confirmation sent for booking ${newBooking.id}`);
      } catch (notificationError) {
        console.error("Failed to send mobile booking confirmation:", notificationError);
      }
      const totalSavings = totalDiscountPaisa > 0 ? totalDiscountPaisa / 100 : 0;
      res.status(201).json({
        success: true,
        message: appliedOffer ? `Booking created with ${appliedOffer.title} applied!` : isPackageBookingFlag ? "Package booking created successfully" : "Booking created successfully",
        booking: {
          ...newBooking,
          salonName: salon.name,
          serviceName: serviceNames,
          serviceDuration: totalDuration,
          totalAmount: finalAmountPaisa / 100,
          originalAmount: originalAmountPaisa / 100,
          finalAmount: finalAmountPaisa / 100,
          discountAmount: totalDiscountPaisa / 100,
          savings: totalSavings,
          serviceCount: selectedServices.length,
          isPackageBooking: isPackageBookingFlag,
          packageName,
          offerId: appliedOffer?.id || null,
          offerTitle: appliedOffer?.title || null,
          appliedOffer: appliedOffer ? {
            id: appliedOffer.id,
            title: appliedOffer.title,
            discountAmount: offerDiscountPaisa / 100
          } : null
        }
      });
    } catch (error) {
      console.error("Error creating booking:", error);
      res.status(500).json({ error: "Failed to create booking" });
    }
  });
  app2.get("/api/mobile/bookings/my-bookings", authenticateMobileUser, async (req, res) => {
    try {
      const userId = req.user.id;
      const status = req.query.status;
      const limit = parseInt(req.query.limit) || 20;
      const offset = parseInt(req.query.offset) || 0;
      let whereCondition = eq38(bookings.userId, userId);
      if (status === "upcoming") {
        whereCondition = and36(
          eq38(bookings.userId, userId),
          or13(
            eq38(bookings.status, "pending"),
            eq38(bookings.status, "confirmed")
          ),
          sql30`${bookings.bookingDate}::date >= CURRENT_DATE`
        );
      } else if (status === "completed") {
        whereCondition = and36(
          eq38(bookings.userId, userId),
          eq38(bookings.status, "completed")
        );
      } else if (status === "cancelled") {
        whereCondition = and36(
          eq38(bookings.userId, userId),
          eq38(bookings.status, "cancelled")
        );
      }
      const userBookings = await db.select({
        id: bookings.id,
        salonId: bookings.salonId,
        salonName: salons.name,
        salonImageUrl: salons.imageUrl,
        salonAddress: salons.address,
        serviceId: bookings.serviceId,
        serviceName: services.name,
        serviceDuration: services.durationMinutes,
        staffId: bookings.staffId,
        staffName: staff.name,
        staffImageUrl: staff.photoUrl,
        bookingDate: bookings.bookingDate,
        bookingTime: bookings.bookingTime,
        status: bookings.status,
        totalAmountPaisa: bookings.totalAmountPaisa,
        finalAmountPaisa: bookings.finalAmountPaisa,
        discountAmountPaisa: bookings.discountAmountPaisa,
        paymentMethod: bookings.paymentMethod,
        notes: bookings.notes,
        createdAt: bookings.createdAt
      }).from(bookings).leftJoin(salons, eq38(bookings.salonId, salons.id)).leftJoin(services, eq38(bookings.serviceId, services.id)).leftJoin(staff, eq38(bookings.staffId, staff.id)).where(whereCondition).orderBy(
        status === "upcoming" ? asc6(sql30`${bookings.bookingDate}::date`) : desc27(bookings.createdAt)
      ).limit(limit).offset(offset);
      const [countResult] = await db.select({ count: sql30`count(*)` }).from(bookings).where(whereCondition);
      res.json({
        success: true,
        bookings: userBookings.map((b) => ({
          ...b,
          totalAmount: b.totalAmountPaisa ? b.totalAmountPaisa / 100 : 0,
          finalAmount: b.finalAmountPaisa ? b.finalAmountPaisa / 100 : 0,
          discountAmount: b.discountAmountPaisa ? b.discountAmountPaisa / 100 : 0
        })),
        pagination: {
          total: parseInt(String(countResult?.count || 0)),
          limit,
          offset,
          hasMore: offset + userBookings.length < parseInt(String(countResult?.count || 0))
        }
      });
    } catch (error) {
      console.error("Error fetching user bookings:", error);
      res.status(500).json({ error: "Failed to fetch bookings" });
    }
  });
  app2.get("/api/mobile/bookings/:bookingId", authenticateMobileUser, async (req, res) => {
    try {
      const userId = req.user.id;
      const { bookingId } = req.params;
      const booking = await db.select({
        id: bookings.id,
        salonId: bookings.salonId,
        salonName: salons.name,
        salonImageUrl: salons.imageUrl,
        salonAddress: salons.address,
        salonPhone: salons.phone,
        salonLatitude: salons.latitude,
        salonLongitude: salons.longitude,
        serviceId: bookings.serviceId,
        serviceName: services.name,
        serviceDuration: services.durationMinutes,
        serviceDescription: services.description,
        staffId: bookings.staffId,
        staffName: staff.name,
        staffImageUrl: staff.photoUrl,
        staffRoles: staff.roles,
        bookingDate: bookings.bookingDate,
        bookingTime: bookings.bookingTime,
        status: bookings.status,
        totalAmountPaisa: bookings.totalAmountPaisa,
        originalAmountPaisa: bookings.originalAmountPaisa,
        finalAmountPaisa: bookings.finalAmountPaisa,
        discountAmountPaisa: bookings.discountAmountPaisa,
        offerTitle: bookings.offerTitle,
        paymentMethod: bookings.paymentMethod,
        notes: bookings.notes,
        customerName: bookings.customerName,
        customerEmail: bookings.customerEmail,
        customerPhone: bookings.customerPhone,
        createdAt: bookings.createdAt
      }).from(bookings).leftJoin(salons, eq38(bookings.salonId, salons.id)).leftJoin(services, eq38(bookings.serviceId, services.id)).leftJoin(staff, eq38(bookings.staffId, staff.id)).where(and36(
        eq38(bookings.id, bookingId),
        eq38(bookings.userId, userId)
      )).limit(1);
      if (booking.length === 0) {
        return res.status(404).json({ error: "Booking not found" });
      }
      const b = booking[0];
      res.json({
        success: true,
        booking: {
          ...b,
          totalAmount: b.totalAmountPaisa ? b.totalAmountPaisa / 100 : 0,
          originalAmount: b.originalAmountPaisa ? b.originalAmountPaisa / 100 : 0,
          finalAmount: b.finalAmountPaisa ? b.finalAmountPaisa / 100 : 0,
          discountAmount: b.discountAmountPaisa ? b.discountAmountPaisa / 100 : 0
        }
      });
    } catch (error) {
      console.error("Error fetching booking details:", error);
      res.status(500).json({ error: "Failed to fetch booking details" });
    }
  });
  app2.post("/api/mobile/bookings/:bookingId/cancel", authenticateMobileUser, async (req, res) => {
    try {
      const userId = req.user.id;
      const { bookingId } = req.params;
      const parsed = cancelBookingSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ error: "Invalid request body", details: parsed.error.errors });
      }
      const existing = await db.query.bookings.findFirst({
        where: and36(
          eq38(bookings.id, bookingId),
          eq38(bookings.userId, userId)
        )
      });
      if (!existing) {
        return res.status(404).json({ error: "Booking not found" });
      }
      if (existing.status === "cancelled") {
        return res.status(400).json({ error: "Booking is already cancelled" });
      }
      if (existing.status === "completed") {
        return res.status(400).json({ error: "Cannot cancel a completed booking" });
      }
      const cancellationNote = parsed.data.reason ? `Cancelled by customer: ${parsed.data.reason}` : "Cancelled by customer via mobile app";
      const [updatedBooking] = await db.update(bookings).set({
        status: "cancelled",
        notes: existing.notes ? `${existing.notes}

${cancellationNote}` : cancellationNote
      }).where(eq38(bookings.id, bookingId)).returning();
      res.json({
        success: true,
        message: "Booking cancelled successfully",
        booking: {
          id: updatedBooking.id,
          status: updatedBooking.status
        }
      });
    } catch (error) {
      console.error("Error cancelling booking:", error);
      res.status(500).json({ error: "Failed to cancel booking" });
    }
  });
  app2.patch("/api/mobile/bookings/:bookingId/reschedule", authenticateMobileUser, async (req, res) => {
    try {
      const userId = req.user.id;
      const { bookingId } = req.params;
      const parsed = rescheduleBookingSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ error: "Invalid request body", details: parsed.error.errors });
      }
      const existing = await db.query.bookings.findFirst({
        where: and36(
          eq38(bookings.id, bookingId),
          eq38(bookings.userId, userId)
        )
      });
      if (!existing) {
        return res.status(404).json({ error: "Booking not found" });
      }
      if (existing.status === "cancelled") {
        return res.status(400).json({ error: "Cannot reschedule a cancelled booking" });
      }
      if (existing.status === "completed") {
        return res.status(400).json({ error: "Cannot reschedule a completed booking" });
      }
      const newDate = new Date(parsed.data.bookingDate);
      if (newDate < /* @__PURE__ */ new Date()) {
        return res.status(400).json({ error: "Cannot reschedule to a past date" });
      }
      const rescheduleNote = `Rescheduled from ${existing.bookingDate} ${existing.bookingTime} to ${parsed.data.bookingDate} ${parsed.data.bookingTime}`;
      const [updatedBooking] = await db.update(bookings).set({
        bookingDate: parsed.data.bookingDate,
        bookingTime: parsed.data.bookingTime,
        notes: existing.notes ? `${existing.notes}

${rescheduleNote}` : rescheduleNote
      }).where(eq38(bookings.id, bookingId)).returning();
      res.json({
        success: true,
        message: "Booking rescheduled successfully",
        booking: {
          id: updatedBooking.id,
          bookingDate: updatedBooking.bookingDate,
          bookingTime: updatedBooking.bookingTime,
          status: updatedBooking.status
        }
      });
    } catch (error) {
      console.error("Error rescheduling booking:", error);
      res.status(500).json({ error: "Failed to reschedule booking" });
    }
  });
  app2.post("/api/mobile/bookings/:bookingId/review", authenticateMobileUser, async (req, res) => {
    try {
      const userId = req.user.id;
      const { bookingId } = req.params;
      const parsed = submitReviewSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ error: "Invalid request body", details: parsed.error.errors });
      }
      const booking = await db.query.bookings.findFirst({
        where: and36(
          eq38(bookings.id, bookingId),
          eq38(bookings.userId, userId)
        )
      });
      if (!booking) {
        return res.status(404).json({ error: "Booking not found" });
      }
      if (booking.status !== "completed") {
        return res.status(400).json({ error: "You can only review completed bookings" });
      }
      const existingReview = await db.query.salonReviews.findFirst({
        where: and36(
          eq38(salonReviews.bookingId, bookingId),
          eq38(salonReviews.customerId, userId)
        )
      });
      if (existingReview) {
        return res.status(400).json({ error: "You have already reviewed this booking" });
      }
      const [newReview] = await db.insert(salonReviews).values({
        salonId: booking.salonId,
        customerId: userId,
        bookingId,
        rating: parsed.data.rating,
        comment: parsed.data.comment || null,
        isVerified: 1,
        source: "salonhub"
      }).returning();
      const [ratingStats] = await db.select({
        avgRating: sql30`AVG(${salonReviews.rating})`,
        reviewCount: sql30`COUNT(*)`
      }).from(salonReviews).where(eq38(salonReviews.salonId, booking.salonId));
      await db.update(salons).set({
        rating: parseFloat(String(ratingStats.avgRating || 0)).toFixed(1),
        reviewCount: parseInt(String(ratingStats.reviewCount || 0))
      }).where(eq38(salons.id, booking.salonId));
      res.json({
        success: true,
        message: "Review submitted successfully",
        review: {
          id: newReview.id,
          rating: newReview.rating,
          createdAt: newReview.createdAt
        }
      });
    } catch (error) {
      console.error("Error submitting review:", error);
      res.status(500).json({ error: "Failed to submit review" });
    }
  });
}

// server/routes/mobile-offers.routes.ts
init_db();
init_schema();
import { eq as eq39, and as and37, sql as sql31, desc as desc28, gte as gte16, lte as lte13, or as or14 } from "drizzle-orm";
function registerMobileOffersRoutes(app2) {
  app2.get("/api/mobile/offers/trending", authenticateMobileUser, async (req, res) => {
    try {
      const userId = req.user.id;
      const limit = parseInt(req.query.limit) || 10;
      const now = /* @__PURE__ */ new Date();
      const offers = await db.select({
        id: platformOffers.id,
        title: platformOffers.title,
        description: platformOffers.description,
        discountType: platformOffers.discountType,
        discountValue: platformOffers.discountValue,
        minimumPurchase: platformOffers.minimumPurchase,
        validUntil: platformOffers.validUntil,
        usageCount: platformOffers.usageCount,
        isPlatformWide: platformOffers.isPlatformWide,
        imageUrl: platformOffers.imageUrl,
        salonId: platformOffers.salonId,
        salonName: salons.name,
        salonImageUrl: salons.imageUrl
      }).from(platformOffers).leftJoin(salons, eq39(platformOffers.salonId, salons.id)).where(and37(
        eq39(platformOffers.isActive, 1),
        eq39(platformOffers.approvalStatus, "approved"),
        lte13(platformOffers.validFrom, now),
        gte16(platformOffers.validUntil, now),
        or14(
          sql31`${platformOffers.usageLimit} IS NULL`,
          sql31`${platformOffers.usageCount} < ${platformOffers.usageLimit}`
        )
      )).orderBy(desc28(platformOffers.usageCount), desc28(platformOffers.discountValue)).limit(limit);
      const savedOfferIds = await db.select({ offerId: savedOffers.offerId }).from(savedOffers).where(eq39(savedOffers.userId, userId));
      const savedOfferIdSet = new Set(savedOfferIds.map((s) => s.offerId));
      res.json({
        success: true,
        offers: offers.map((offer) => ({
          ...offer,
          isSaved: savedOfferIdSet.has(offer.id),
          discountText: offer.discountType === "percentage" ? `${offer.discountValue}% OFF` : `\u20B9${(offer.discountValue / 100).toFixed(0)} OFF`,
          daysRemaining: Math.ceil((new Date(offer.validUntil).getTime() - now.getTime()) / (1e3 * 60 * 60 * 24))
        }))
      });
    } catch (error) {
      console.error("Error fetching trending offers:", error);
      res.status(500).json({ error: "Failed to fetch trending offers" });
    }
  });
  app2.get("/api/mobile/offers/saved", authenticateMobileUser, async (req, res) => {
    try {
      const userId = req.user.id;
      const limit = parseInt(req.query.limit) || 20;
      const offset = parseInt(req.query.offset) || 0;
      const now = /* @__PURE__ */ new Date();
      const saved = await db.select({
        id: platformOffers.id,
        title: platformOffers.title,
        description: platformOffers.description,
        discountType: platformOffers.discountType,
        discountValue: platformOffers.discountValue,
        minimumPurchase: platformOffers.minimumPurchase,
        validUntil: platformOffers.validUntil,
        isPlatformWide: platformOffers.isPlatformWide,
        imageUrl: platformOffers.imageUrl,
        salonId: platformOffers.salonId,
        salonName: salons.name,
        salonImageUrl: salons.imageUrl,
        savedAt: savedOffers.savedAt,
        isActive: platformOffers.isActive,
        validFrom: platformOffers.validFrom
      }).from(savedOffers).innerJoin(platformOffers, eq39(savedOffers.offerId, platformOffers.id)).leftJoin(salons, eq39(platformOffers.salonId, salons.id)).where(eq39(savedOffers.userId, userId)).orderBy(desc28(savedOffers.savedAt)).limit(limit).offset(offset);
      const [countResult] = await db.select({ count: sql31`count(*)` }).from(savedOffers).where(eq39(savedOffers.userId, userId));
      res.json({
        success: true,
        offers: saved.map((offer) => {
          const isExpired = new Date(offer.validUntil) < now;
          const isNotYetValid = new Date(offer.validFrom) > now;
          return {
            ...offer,
            isSaved: true,
            discountText: offer.discountType === "percentage" ? `${offer.discountValue}% OFF` : `\u20B9${(offer.discountValue / 100).toFixed(0)} OFF`,
            daysRemaining: isExpired ? 0 : Math.ceil((new Date(offer.validUntil).getTime() - now.getTime()) / (1e3 * 60 * 60 * 24)),
            isValid: offer.isActive === 1 && !isExpired && !isNotYetValid,
            isExpired
          };
        }),
        pagination: {
          total: parseInt(String(countResult?.count || 0)),
          limit,
          offset,
          hasMore: offset + saved.length < parseInt(String(countResult?.count || 0))
        }
      });
    } catch (error) {
      console.error("Error fetching saved offers:", error);
      res.status(500).json({ error: "Failed to fetch saved offers" });
    }
  });
  app2.get("/api/mobile/offers/count", authenticateMobileUser, async (req, res) => {
    try {
      const now = /* @__PURE__ */ new Date();
      const [activeResult] = await db.select({ count: sql31`count(*)` }).from(platformOffers).where(and37(
        eq39(platformOffers.isActive, 1),
        eq39(platformOffers.approvalStatus, "approved"),
        lte13(platformOffers.validFrom, now),
        gte16(platformOffers.validUntil, now),
        or14(
          sql31`${platformOffers.usageLimit} IS NULL`,
          sql31`${platformOffers.usageCount} < ${platformOffers.usageLimit}`
        )
      ));
      const [newThisWeekResult] = await db.select({ count: sql31`count(*)` }).from(platformOffers).where(and37(
        eq39(platformOffers.isActive, 1),
        eq39(platformOffers.approvalStatus, "approved"),
        gte16(platformOffers.createdAt, sql31`NOW() - INTERVAL '7 days'`)
      ));
      res.json({
        success: true,
        counts: {
          activeOffers: parseInt(String(activeResult?.count || 0)),
          newThisWeek: parseInt(String(newThisWeekResult?.count || 0))
        }
      });
    } catch (error) {
      console.error("Error fetching offer counts:", error);
      res.status(500).json({ error: "Failed to fetch offer counts" });
    }
  });
  app2.get("/api/mobile/offers", authenticateMobileUser, async (req, res) => {
    try {
      const userId = req.user.id;
      const limit = parseInt(req.query.limit) || 20;
      const offset = parseInt(req.query.offset) || 0;
      const salonId = req.query.salonId;
      const category = req.query.category;
      const sortBy = req.query.sortBy || "newest";
      const now = /* @__PURE__ */ new Date();
      let whereCondition = and37(
        eq39(platformOffers.isActive, 1),
        eq39(platformOffers.approvalStatus, "approved"),
        lte13(platformOffers.validFrom, now),
        gte16(platformOffers.validUntil, now),
        or14(
          sql31`${platformOffers.usageLimit} IS NULL`,
          sql31`${platformOffers.usageCount} < ${platformOffers.usageLimit}`
        )
      );
      if (salonId) {
        whereCondition = and37(
          whereCondition,
          or14(
            eq39(platformOffers.salonId, salonId),
            eq39(platformOffers.isPlatformWide, 1)
          )
        );
      }
      let orderBy;
      switch (sortBy) {
        case "discount":
          orderBy = desc28(platformOffers.discountValue);
          break;
        case "expiring":
          orderBy = platformOffers.validUntil;
          break;
        case "popular":
          orderBy = desc28(platformOffers.usageCount);
          break;
        default:
          orderBy = desc28(platformOffers.createdAt);
      }
      const offers = await db.select({
        id: platformOffers.id,
        title: platformOffers.title,
        description: platformOffers.description,
        discountType: platformOffers.discountType,
        discountValue: platformOffers.discountValue,
        minimumPurchase: platformOffers.minimumPurchase,
        maxDiscount: platformOffers.maxDiscount,
        validFrom: platformOffers.validFrom,
        validUntil: platformOffers.validUntil,
        usageLimit: platformOffers.usageLimit,
        usageCount: platformOffers.usageCount,
        isPlatformWide: platformOffers.isPlatformWide,
        imageUrl: platformOffers.imageUrl,
        salonId: platformOffers.salonId,
        salonName: salons.name,
        salonImageUrl: salons.imageUrl
      }).from(platformOffers).leftJoin(salons, eq39(platformOffers.salonId, salons.id)).where(whereCondition).orderBy(orderBy).limit(limit).offset(offset);
      const savedOfferIds = await db.select({ offerId: savedOffers.offerId }).from(savedOffers).where(eq39(savedOffers.userId, userId));
      const savedOfferIdSet = new Set(savedOfferIds.map((s) => s.offerId));
      const [countResult] = await db.select({ count: sql31`count(*)` }).from(platformOffers).where(whereCondition);
      res.json({
        success: true,
        offers: offers.map((offer) => ({
          ...offer,
          isSaved: savedOfferIdSet.has(offer.id),
          discountText: offer.discountType === "percentage" ? `${offer.discountValue}% OFF` : `\u20B9${(offer.discountValue / 100).toFixed(0)} OFF`,
          minimumPurchaseText: offer.minimumPurchase ? `Min. \u20B9${(offer.minimumPurchase / 100).toFixed(0)}` : null,
          maxDiscountText: offer.maxDiscount ? `Up to \u20B9${(offer.maxDiscount / 100).toFixed(0)}` : null,
          daysRemaining: Math.ceil((new Date(offer.validUntil).getTime() - now.getTime()) / (1e3 * 60 * 60 * 24)),
          usesRemaining: offer.usageLimit ? offer.usageLimit - (offer.usageCount || 0) : null
        })),
        pagination: {
          total: parseInt(String(countResult?.count || 0)),
          limit,
          offset,
          hasMore: offset + offers.length < parseInt(String(countResult?.count || 0))
        }
      });
    } catch (error) {
      console.error("Error fetching offers:", error);
      res.status(500).json({ error: "Failed to fetch offers" });
    }
  });
  app2.get("/api/mobile/offers/:offerId", authenticateMobileUser, async (req, res) => {
    try {
      const userId = req.user.id;
      const { offerId } = req.params;
      const now = /* @__PURE__ */ new Date();
      const offer = await db.select({
        id: platformOffers.id,
        title: platformOffers.title,
        description: platformOffers.description,
        discountType: platformOffers.discountType,
        discountValue: platformOffers.discountValue,
        minimumPurchase: platformOffers.minimumPurchase,
        maxDiscount: platformOffers.maxDiscount,
        validFrom: platformOffers.validFrom,
        validUntil: platformOffers.validUntil,
        usageLimit: platformOffers.usageLimit,
        usageCount: platformOffers.usageCount,
        isPlatformWide: platformOffers.isPlatformWide,
        imageUrl: platformOffers.imageUrl,
        salonId: platformOffers.salonId,
        salonName: salons.name,
        salonImageUrl: salons.imageUrl,
        salonAddress: salons.address,
        salonPhone: salons.phone
      }).from(platformOffers).leftJoin(salons, eq39(platformOffers.salonId, salons.id)).where(eq39(platformOffers.id, offerId)).limit(1);
      if (offer.length === 0) {
        return res.status(404).json({ error: "Offer not found" });
      }
      const o = offer[0];
      const savedOffer = await db.query.savedOffers.findFirst({
        where: and37(
          eq39(savedOffers.userId, userId),
          eq39(savedOffers.offerId, offerId)
        )
      });
      const isExpired = new Date(o.validUntil) < now;
      const isNotYetValid = new Date(o.validFrom) > now;
      const isUsedUp = o.usageLimit !== null && (o.usageCount || 0) >= o.usageLimit;
      res.json({
        success: true,
        offer: {
          ...o,
          isSaved: !!savedOffer,
          discountText: o.discountType === "percentage" ? `${o.discountValue}% OFF` : `\u20B9${(o.discountValue / 100).toFixed(0)} OFF`,
          minimumPurchaseText: o.minimumPurchase ? `Minimum purchase of \u20B9${(o.minimumPurchase / 100).toFixed(0)} required` : null,
          maxDiscountText: o.maxDiscount ? `Maximum discount of \u20B9${(o.maxDiscount / 100).toFixed(0)}` : null,
          daysRemaining: isExpired ? 0 : Math.ceil((new Date(o.validUntil).getTime() - now.getTime()) / (1e3 * 60 * 60 * 24)),
          usesRemaining: o.usageLimit ? o.usageLimit - (o.usageCount || 0) : null,
          isValid: !isExpired && !isNotYetValid && !isUsedUp,
          validityMessage: isExpired ? "This offer has expired" : isNotYetValid ? `This offer starts on ${new Date(o.validFrom).toLocaleDateString()}` : isUsedUp ? "This offer has been fully redeemed" : `Valid until ${new Date(o.validUntil).toLocaleDateString()}`
        }
      });
    } catch (error) {
      console.error("Error fetching offer details:", error);
      res.status(500).json({ error: "Failed to fetch offer details" });
    }
  });
  app2.post("/api/mobile/offers/:offerId/save", authenticateMobileUser, async (req, res) => {
    try {
      const userId = req.user.id;
      const { offerId } = req.params;
      const offer = await db.query.platformOffers.findFirst({
        where: eq39(platformOffers.id, offerId)
      });
      if (!offer) {
        return res.status(404).json({ error: "Offer not found" });
      }
      const existing = await db.query.savedOffers.findFirst({
        where: and37(
          eq39(savedOffers.userId, userId),
          eq39(savedOffers.offerId, offerId)
        )
      });
      if (existing) {
        return res.json({
          success: true,
          message: "Offer already saved",
          savedOffer: existing
        });
      }
      const [newSavedOffer] = await db.insert(savedOffers).values({
        userId,
        offerId
      }).returning();
      res.json({
        success: true,
        message: "Offer saved successfully",
        savedOffer: newSavedOffer
      });
    } catch (error) {
      console.error("Error saving offer:", error);
      res.status(500).json({ error: "Failed to save offer" });
    }
  });
  app2.delete("/api/mobile/offers/:offerId/save", authenticateMobileUser, async (req, res) => {
    try {
      const userId = req.user.id;
      const { offerId } = req.params;
      const existing = await db.query.savedOffers.findFirst({
        where: and37(
          eq39(savedOffers.userId, userId),
          eq39(savedOffers.offerId, offerId)
        )
      });
      if (!existing) {
        return res.status(404).json({ error: "Saved offer not found" });
      }
      await db.delete(savedOffers).where(eq39(savedOffers.id, existing.id));
      res.json({
        success: true,
        message: "Offer removed from saved"
      });
    } catch (error) {
      console.error("Error removing saved offer:", error);
      res.status(500).json({ error: "Failed to remove saved offer" });
    }
  });
}

// server/routes/mobile-packages.routes.ts
init_db();
init_schema();
import { eq as eq40, and as and38, desc as desc29, sql as sql32 } from "drizzle-orm";
function registerMobilePackagesRoutes(app2) {
  app2.get("/api/mobile/salons/:salonId/packages", async (req, res) => {
    try {
      const { salonId } = req.params;
      const salon = await db.query.salons.findFirst({
        where: eq40(salons.id, salonId)
      });
      if (!salon) {
        return res.status(404).json({ error: "Salon not found" });
      }
      const packages = await db.select({
        id: servicePackages.id,
        name: servicePackages.name,
        description: servicePackages.description,
        regularPriceInPaisa: servicePackages.regularPriceInPaisa,
        packagePriceInPaisa: servicePackages.packagePriceInPaisa,
        totalDurationMinutes: servicePackages.totalDurationMinutes,
        discountPercentage: servicePackages.discountPercentage,
        validFrom: servicePackages.validFrom,
        validUntil: servicePackages.validUntil,
        isActive: servicePackages.isActive,
        serviceCount: sql32`(
            SELECT COUNT(*) FROM ${packageServices} 
            WHERE ${packageServices.packageId} = ${servicePackages.id}
          )`
      }).from(servicePackages).where(
        and38(
          eq40(servicePackages.salonId, salonId),
          eq40(servicePackages.isActive, true)
        )
      ).orderBy(desc29(servicePackages.createdAt));
      const now = /* @__PURE__ */ new Date();
      const activePackages = packages.filter((pkg) => {
        if (pkg.validFrom && new Date(pkg.validFrom) > now) return false;
        if (pkg.validUntil && new Date(pkg.validUntil) < now) return false;
        return true;
      });
      res.json({
        success: true,
        packages: activePackages.map((pkg) => ({
          ...pkg,
          regularPrice: pkg.regularPriceInPaisa / 100,
          packagePrice: pkg.packagePriceInPaisa / 100,
          savings: (pkg.regularPriceInPaisa - pkg.packagePriceInPaisa) / 100,
          savingsPercentage: pkg.discountPercentage || Math.round((pkg.regularPriceInPaisa - pkg.packagePriceInPaisa) / pkg.regularPriceInPaisa * 100)
        }))
      });
    } catch (error) {
      console.error("Error fetching salon packages:", error);
      res.status(500).json({ error: "Failed to fetch packages" });
    }
  });
  app2.get("/api/mobile/salons/:salonId/packages/:packageId", async (req, res) => {
    try {
      const { salonId, packageId } = req.params;
      const salon = await db.query.salons.findFirst({
        where: eq40(salons.id, salonId)
      });
      if (!salon) {
        return res.status(404).json({ error: "Salon not found" });
      }
      const packageData = await db.query.servicePackages.findFirst({
        where: and38(
          eq40(servicePackages.id, packageId),
          eq40(servicePackages.salonId, salonId)
        )
      });
      if (!packageData) {
        return res.status(404).json({ error: "Package not found" });
      }
      if (!packageData.isActive) {
        return res.status(400).json({ error: "Package is not currently available" });
      }
      const now = /* @__PURE__ */ new Date();
      if (packageData.validFrom && new Date(packageData.validFrom) > now) {
        return res.status(400).json({ error: "Package is not yet available" });
      }
      if (packageData.validUntil && new Date(packageData.validUntil) < now) {
        return res.status(400).json({ error: "Package has expired" });
      }
      const packageServicesList = await db.select({
        id: services.id,
        name: services.name,
        description: services.description,
        category: services.category,
        subCategory: services.subCategory,
        priceInPaisa: services.priceInPaisa,
        durationMinutes: services.durationMinutes,
        imageUrl: services.imageUrl,
        quantity: packageServices.quantity
      }).from(packageServices).innerJoin(services, eq40(packageServices.serviceId, services.id)).where(eq40(packageServices.packageId, packageId));
      res.json({
        success: true,
        package: {
          id: packageData.id,
          salonId: packageData.salonId,
          name: packageData.name,
          description: packageData.description,
          regularPriceInPaisa: packageData.regularPriceInPaisa,
          packagePriceInPaisa: packageData.packagePriceInPaisa,
          totalDurationMinutes: packageData.totalDurationMinutes,
          discountPercentage: packageData.discountPercentage,
          regularPrice: packageData.regularPriceInPaisa / 100,
          packagePrice: packageData.packagePriceInPaisa / 100,
          savings: (packageData.regularPriceInPaisa - packageData.packagePriceInPaisa) / 100,
          savingsPercentage: packageData.discountPercentage || Math.round((packageData.regularPriceInPaisa - packageData.packagePriceInPaisa) / packageData.regularPriceInPaisa * 100),
          validFrom: packageData.validFrom,
          validUntil: packageData.validUntil,
          isActive: packageData.isActive,
          services: packageServicesList.map((svc) => ({
            ...svc,
            price: svc.priceInPaisa / 100
          }))
        },
        salon: {
          id: salon.id,
          name: salon.name,
          address: salon.address,
          imageUrl: salon.imageUrl
        }
      });
    } catch (error) {
      console.error("Error fetching package details:", error);
      res.status(500).json({ error: "Failed to fetch package details" });
    }
  });
  console.log("\u2705 Mobile package routes registered");
}

// server/routes/cancellation.routes.ts
init_db();
init_schema();
import { eq as eq43, and as and41, sql as sql35, desc as desc32 } from "drizzle-orm";
import { z as z18 } from "zod";

// server/services/cancellationService.ts
init_db();
init_schema();
import { eq as eq42, and as and40, sql as sql34, gte as gte18, lte as lte15 } from "drizzle-orm";

// server/services/waitlistService.ts
init_db();
init_schema();
import { eq as eq41, and as and39, or as or15, desc as desc30, asc as asc7, gte as gte17, lte as lte14, inArray as inArray15, sql as sql33, isNull as isNull6 } from "drizzle-orm";
import { addDays as addDays2, addMinutes, parseISO as parseISO2, format as format2, isAfter as isAfter2, isBefore } from "date-fns";
var IST_OFFSET_MINUTES = 330;
var RESPONSE_TIMEOUT_MINUTES = 15;
var WAITLIST_EXPIRY_DAYS = 7;
var MAX_ENTRIES_PER_USER_PER_DAY = 5;
var WaitlistService = class {
  getNowIST() {
    const now = /* @__PURE__ */ new Date();
    return new Date(now.getTime() + IST_OFFSET_MINUTES * 60 * 1e3);
  }
  formatDateIST(date) {
    return format2(date, "yyyy-MM-dd");
  }
  async getUserLoyaltyPriority(userId) {
    try {
      const userPointsData = await db.select({
        tierName: loyaltyTiers.name
      }).from(userPoints).leftJoin(loyaltyTiers, eq41(userPoints.currentTierId, loyaltyTiers.id)).where(eq41(userPoints.userId, userId)).limit(1);
      if (userPointsData.length === 0 || !userPointsData[0].tierName) {
        return WAITLIST_PRIORITY.regular;
      }
      const tierName = userPointsData[0].tierName.toLowerCase();
      if (tierName.includes("elite") || tierName.includes("platinum")) {
        return WAITLIST_PRIORITY.elite;
      } else if (tierName.includes("gold")) {
        return WAITLIST_PRIORITY.gold;
      }
      return WAITLIST_PRIORITY.regular;
    } catch (error) {
      console.error("Error fetching user loyalty priority:", error);
      return WAITLIST_PRIORITY.regular;
    }
  }
  async checkDuplicateEntry(userId, salonId, serviceId, requestedDate) {
    const existing = await db.select({ id: slotWaitlist.id }).from(slotWaitlist).where(and39(
      eq41(slotWaitlist.userId, userId),
      eq41(slotWaitlist.salonId, salonId),
      eq41(slotWaitlist.serviceId, serviceId),
      eq41(slotWaitlist.requestedDate, requestedDate),
      inArray15(slotWaitlist.status, [WAITLIST_STATUS.waiting, WAITLIST_STATUS.notified])
    )).limit(1);
    return existing.length > 0;
  }
  async countUserEntriesForDate(userId, date) {
    const entries = await db.select({ count: sql33`count(*)` }).from(slotWaitlist).where(and39(
      eq41(slotWaitlist.userId, userId),
      eq41(slotWaitlist.requestedDate, date),
      inArray15(slotWaitlist.status, [WAITLIST_STATUS.waiting, WAITLIST_STATUS.notified])
    ));
    return Number(entries[0]?.count || 0);
  }
  async validateTimeWindow(start, end) {
    const [startHour, startMin] = start.split(":").map(Number);
    const [endHour, endMin] = end.split(":").map(Number);
    const startMinutes = startHour * 60 + startMin;
    const endMinutes = endHour * 60 + endMin;
    if (endMinutes <= startMinutes) {
      return { valid: false, error: "End time must be after start time" };
    }
    if (endMinutes - startMinutes < 30) {
      return { valid: false, error: "Time window must be at least 30 minutes" };
    }
    return { valid: true };
  }
  async validateEntities(salonId, serviceId, staffId) {
    const salon = await db.select({ id: salons.id, isActive: salons.isActive }).from(salons).where(eq41(salons.id, salonId)).limit(1);
    if (salon.length === 0) {
      return { valid: false, error: "Salon not found" };
    }
    if (!salon[0].isActive) {
      return { valid: false, error: "Salon is currently not accepting bookings" };
    }
    const service = await db.select({ id: services.id, salonId: services.salonId }).from(services).where(and39(eq41(services.id, serviceId), eq41(services.salonId, salonId))).limit(1);
    if (service.length === 0) {
      return { valid: false, error: "Service not found or not available at this salon" };
    }
    if (staffId) {
      const staffMember = await db.select({ id: staff.id, salonId: staff.salonId }).from(staff).where(and39(eq41(staff.id, staffId), eq41(staff.salonId, salonId))).limit(1);
      if (staffMember.length === 0) {
        return { valid: false, error: "Staff member not found or not available at this salon" };
      }
    }
    return { valid: true };
  }
  async checkSlotAvailability(salonId, serviceId, requestedDate, timeWindowStart, timeWindowEnd, staffId) {
    const requestedDateStart = parseISO2(`${requestedDate}T${timeWindowStart}:00`);
    const requestedDateEnd = parseISO2(`${requestedDate}T${timeWindowEnd}:00`);
    const baseConditions = [
      eq41(timeSlots.salonId, salonId),
      eq41(timeSlots.isBooked, 0),
      gte17(timeSlots.startDateTime, requestedDateStart),
      lte14(timeSlots.startDateTime, requestedDateEnd)
    ];
    if (staffId) {
      baseConditions.push(eq41(timeSlots.staffId, staffId));
    }
    const availableSlots = await db.select({
      slotId: timeSlots.id,
      startDateTime: timeSlots.startDateTime,
      staffId: timeSlots.staffId,
      salonId: timeSlots.salonId,
      isBooked: timeSlots.isBooked
    }).from(timeSlots).where(and39(...baseConditions));
    return availableSlots.map((s) => ({
      slotId: s.slotId,
      slotDate: format2(s.startDateTime, "yyyy-MM-dd"),
      slotTime: format2(s.startDateTime, "HH:mm"),
      staffId: s.staffId,
      salonId: s.salonId
    }));
  }
  async joinWaitlist(userId, input) {
    const { salonId, serviceId, staffId, requestedDate, timeWindowStart, timeWindowEnd, flexibilityDays } = input;
    const nowIST = this.getNowIST();
    const requestedDateParsed = parseISO2(requestedDate);
    if (isBefore(requestedDateParsed, parseISO2(this.formatDateIST(nowIST)))) {
      return { success: false, error: "Cannot join waitlist for past dates" };
    }
    const entityValidation = await this.validateEntities(salonId, serviceId, staffId);
    if (!entityValidation.valid) {
      return { success: false, error: entityValidation.error };
    }
    const timeValidation = await this.validateTimeWindow(timeWindowStart, timeWindowEnd);
    if (!timeValidation.valid) {
      return { success: false, error: timeValidation.error };
    }
    const isDuplicate = await this.checkDuplicateEntry(userId, salonId, serviceId, requestedDate);
    if (isDuplicate) {
      return { success: false, error: "You are already on the waitlist for this service on this date" };
    }
    const dailyCount = await this.countUserEntriesForDate(userId, requestedDate);
    if (dailyCount >= MAX_ENTRIES_PER_USER_PER_DAY) {
      return { success: false, error: `Maximum ${MAX_ENTRIES_PER_USER_PER_DAY} waitlist entries per date allowed` };
    }
    const availableSlots = await this.checkSlotAvailability(
      salonId,
      serviceId,
      requestedDate,
      timeWindowStart,
      timeWindowEnd,
      staffId
    );
    if (availableSlots.length > 0) {
      return {
        success: false,
        error: "Slots are actually available for this time window. Please proceed to booking.",
        availableSlots
      };
    }
    const priority = await this.getUserLoyaltyPriority(userId);
    const expiresAt = addDays2(requestedDateParsed, WAITLIST_EXPIRY_DAYS);
    const [entry] = await db.insert(slotWaitlist).values({
      userId,
      salonId,
      serviceId,
      staffId: staffId || null,
      requestedDate,
      timeWindowStart,
      timeWindowEnd,
      flexibilityDays: flexibilityDays || 0,
      priority,
      status: WAITLIST_STATUS.waiting,
      expiresAt
    }).returning();
    const position = await this.getQueuePosition(entry.id);
    const salonInfo = await this.getSalonInfo(salonId);
    const serviceInfo = await this.getServiceInfo(serviceId);
    return {
      success: true,
      waitlistEntry: {
        ...entry,
        salon: salonInfo,
        service: serviceInfo,
        position
      }
    };
  }
  async getQueuePosition(waitlistId) {
    const entry = await db.select().from(slotWaitlist).where(eq41(slotWaitlist.id, waitlistId)).limit(1);
    if (entry.length === 0) return 0;
    const { salonId, requestedDate, status, priority, createdAt } = entry[0];
    if (status !== WAITLIST_STATUS.waiting) return 0;
    const aheadEntries = await db.select({ count: sql33`count(*)` }).from(slotWaitlist).where(and39(
      eq41(slotWaitlist.salonId, salonId),
      eq41(slotWaitlist.requestedDate, requestedDate),
      eq41(slotWaitlist.status, WAITLIST_STATUS.waiting),
      or15(
        sql33`${slotWaitlist.priority} > ${priority}`,
        and39(
          eq41(slotWaitlist.priority, priority),
          sql33`${slotWaitlist.createdAt} < ${createdAt}`
        )
      )
    ));
    return Number(aheadEntries[0]?.count || 0) + 1;
  }
  async getSalonInfo(salonId) {
    const result = await db.select({
      id: salons.id,
      name: salons.name,
      imageUrl: salons.imageUrl
    }).from(salons).where(eq41(salons.id, salonId)).limit(1);
    return result[0];
  }
  async getServiceInfo(serviceId) {
    const result = await db.select({
      id: services.id,
      name: services.name,
      priceInPaisa: services.priceInPaisa,
      durationMinutes: services.durationMinutes
    }).from(services).where(eq41(services.id, serviceId)).limit(1);
    return result[0];
  }
  async getUserWaitlistEntries(userId) {
    const entries = await db.select().from(slotWaitlist).where(and39(
      eq41(slotWaitlist.userId, userId),
      inArray15(slotWaitlist.status, [WAITLIST_STATUS.waiting, WAITLIST_STATUS.notified])
    )).orderBy(asc7(slotWaitlist.requestedDate), asc7(slotWaitlist.timeWindowStart));
    const enrichedEntries = [];
    for (const entry of entries) {
      const salon = await this.getSalonInfo(entry.salonId);
      const service = await this.getServiceInfo(entry.serviceId);
      const position = entry.status === WAITLIST_STATUS.waiting ? await this.getQueuePosition(entry.id) : 0;
      let staffInfo = null;
      if (entry.staffId) {
        const staffResult = await db.select({ id: staff.id, name: staff.name }).from(staff).where(eq41(staff.id, entry.staffId)).limit(1);
        staffInfo = staffResult[0] || null;
      }
      enrichedEntries.push({
        ...entry,
        salon,
        service,
        staff: staffInfo,
        position
      });
    }
    return enrichedEntries;
  }
  async cancelWaitlistEntry(userId, waitlistId) {
    const entry = await db.select().from(slotWaitlist).where(eq41(slotWaitlist.id, waitlistId)).limit(1);
    if (entry.length === 0) {
      return { success: false, error: "Waitlist entry not found" };
    }
    if (entry[0].userId !== userId) {
      return { success: false, error: "Not authorized to cancel this entry" };
    }
    if (entry[0].status === WAITLIST_STATUS.booked) {
      return { success: false, error: "This entry has already been converted to a booking" };
    }
    if (entry[0].status === WAITLIST_STATUS.cancelled || entry[0].status === WAITLIST_STATUS.expired) {
      return { success: false, error: "This entry is already cancelled or expired" };
    }
    await db.update(slotWaitlist).set({ status: WAITLIST_STATUS.cancelled }).where(eq41(slotWaitlist.id, waitlistId));
    return { success: true };
  }
  async respondToNotification(userId, waitlistId, response) {
    const entry = await db.select().from(slotWaitlist).where(eq41(slotWaitlist.id, waitlistId)).limit(1);
    if (entry.length === 0) {
      return { success: false, error: "Waitlist entry not found" };
    }
    if (entry[0].userId !== userId) {
      return { success: false, error: "Not authorized to respond to this entry" };
    }
    if (entry[0].status !== WAITLIST_STATUS.notified) {
      return { success: false, error: "This entry is not pending a response" };
    }
    const now = /* @__PURE__ */ new Date();
    if (entry[0].responseDeadline && isAfter2(now, entry[0].responseDeadline)) {
      await db.update(slotWaitlist).set({ status: WAITLIST_STATUS.expired }).where(eq41(slotWaitlist.id, waitlistId));
      return { success: false, error: "Response deadline has passed" };
    }
    if (response === "declined") {
      await db.update(slotWaitlist).set({ status: WAITLIST_STATUS.cancelled }).where(eq41(slotWaitlist.id, waitlistId));
      await db.update(waitlistNotifications).set({
        response: "declined",
        respondedAt: now
      }).where(and39(
        eq41(waitlistNotifications.waitlistId, waitlistId),
        isNull6(waitlistNotifications.response)
      ));
      if (entry[0].notifiedSlotId) {
        await this.processNextInQueue(entry[0].notifiedSlotId);
      }
      return { success: true };
    }
    if (!entry[0].notifiedSlotId) {
      return { success: false, error: "No slot information available" };
    }
    const slot = await db.select().from(timeSlots).where(eq41(timeSlots.id, entry[0].notifiedSlotId)).limit(1);
    if (slot.length === 0) {
      return { success: false, error: "Slot no longer exists" };
    }
    if (slot[0].isBooked === 1) {
      await db.update(slotWaitlist).set({ status: WAITLIST_STATUS.expired }).where(eq41(slotWaitlist.id, waitlistId));
      return { success: false, error: "Slot is no longer available" };
    }
    const service = await this.getServiceInfo(entry[0].serviceId);
    if (!service) {
      return { success: false, error: "Service no longer available" };
    }
    const userInfo = await db.select().from(users).where(eq41(users.id, userId)).limit(1);
    if (userInfo.length === 0) {
      return { success: false, error: "User not found" };
    }
    const bookingAmount = service.priceInPaisa ?? 0;
    const slotDate = format2(slot[0].startDateTime, "yyyy-MM-dd");
    const slotTime = format2(slot[0].startDateTime, "HH:mm");
    let booking;
    try {
      [booking] = await db.insert(bookings).values({
        salonId: entry[0].salonId,
        serviceId: entry[0].serviceId,
        staffId: entry[0].staffId,
        timeSlotId: entry[0].notifiedSlotId,
        userId,
        customerName: `${userInfo[0].firstName || ""} ${userInfo[0].lastName || ""}`.trim() || "Customer",
        customerEmail: userInfo[0].email || "",
        customerPhone: userInfo[0].phone || "",
        bookingDate: slotDate,
        bookingTime: slotTime,
        status: "confirmed",
        totalAmountPaisa: bookingAmount,
        paymentMethod: "pay_at_salon"
      }).returning();
    } catch (dbError) {
      console.error("Error creating booking from waitlist:", dbError);
      return { success: false, error: "Failed to create booking. Please try again." };
    }
    await db.update(timeSlots).set({ isBooked: 1 }).where(eq41(timeSlots.id, entry[0].notifiedSlotId));
    await db.update(slotWaitlist).set({
      status: WAITLIST_STATUS.booked,
      bookedAt: now
    }).where(eq41(slotWaitlist.id, waitlistId));
    await db.update(waitlistNotifications).set({
      response: "accepted",
      respondedAt: now
    }).where(and39(
      eq41(waitlistNotifications.waitlistId, waitlistId),
      isNull6(waitlistNotifications.response)
    ));
    return {
      success: true,
      bookingId: booking.id,
      slotInfo: { date: slotDate, time: slotTime }
    };
  }
  async findMatchingWaitlistEntries(slotId) {
    const slot = await db.select().from(timeSlots).where(eq41(timeSlots.id, slotId)).limit(1);
    if (slot.length === 0) return [];
    const { salonId, startDateTime, staffId } = slot[0];
    const slotDate = format2(startDateTime, "yyyy-MM-dd");
    const slotTime = format2(startDateTime, "HH:mm");
    let entries = await db.select().from(slotWaitlist).where(and39(
      eq41(slotWaitlist.salonId, salonId),
      eq41(slotWaitlist.status, WAITLIST_STATUS.waiting),
      lte14(slotWaitlist.timeWindowStart, slotTime),
      gte17(slotWaitlist.timeWindowEnd, slotTime)
    )).orderBy(desc30(slotWaitlist.priority), asc7(slotWaitlist.createdAt));
    entries = entries.filter((entry) => {
      const requestedDate = parseISO2(entry.requestedDate);
      const slotDateParsed = parseISO2(slotDate);
      const daysDiff = Math.abs(Math.floor((slotDateParsed.getTime() - requestedDate.getTime()) / (1e3 * 60 * 60 * 24)));
      if (daysDiff > entry.flexibilityDays) return false;
      if (entry.staffId && entry.staffId !== staffId) return false;
      return true;
    });
    return entries;
  }
  async notifyWaitlistEntry(waitlistId, slotId) {
    const now = /* @__PURE__ */ new Date();
    const responseDeadline = addMinutes(now, RESPONSE_TIMEOUT_MINUTES);
    await db.update(slotWaitlist).set({
      status: WAITLIST_STATUS.notified,
      notifiedAt: now,
      notifiedSlotId: slotId,
      responseDeadline
    }).where(eq41(slotWaitlist.id, waitlistId));
    await db.insert(waitlistNotifications).values({
      waitlistId,
      slotId,
      notificationType: "push",
      sentAt: now
    });
    return true;
  }
  async processNextInQueue(slotId) {
    const slot = await db.select().from(timeSlots).where(eq41(timeSlots.id, slotId)).limit(1);
    if (slot.length === 0 || slot[0].isBooked === 1) return;
    const matchingEntries = await this.findMatchingWaitlistEntries(slotId);
    if (matchingEntries.length === 0) return;
    await this.notifyWaitlistEntry(matchingEntries[0].id, slotId);
  }
  async processSlotRelease(slotId) {
    const matchingEntries = await this.findMatchingWaitlistEntries(slotId);
    if (matchingEntries.length === 0) return;
    await this.notifyWaitlistEntry(matchingEntries[0].id, slotId);
  }
  async expireOldEntries() {
    const now = /* @__PURE__ */ new Date();
    const result = await db.update(slotWaitlist).set({ status: WAITLIST_STATUS.expired }).where(and39(
      eq41(slotWaitlist.status, WAITLIST_STATUS.waiting),
      lte14(slotWaitlist.expiresAt, now)
    )).returning({ id: slotWaitlist.id });
    return result.length;
  }
  async escalateUnrespondedNotifications() {
    const now = /* @__PURE__ */ new Date();
    const expiredNotifications = await db.select().from(slotWaitlist).where(and39(
      eq41(slotWaitlist.status, WAITLIST_STATUS.notified),
      lte14(slotWaitlist.responseDeadline, now)
    ));
    let escalatedCount = 0;
    for (const entry of expiredNotifications) {
      await db.update(slotWaitlist).set({ status: WAITLIST_STATUS.expired }).where(eq41(slotWaitlist.id, entry.id));
      await db.update(waitlistNotifications).set({
        response: "expired",
        respondedAt: now
      }).where(and39(
        eq41(waitlistNotifications.waitlistId, entry.id),
        isNull6(waitlistNotifications.response)
      ));
      if (entry.notifiedSlotId) {
        await this.processNextInQueue(entry.notifiedSlotId);
      }
      escalatedCount++;
    }
    return escalatedCount;
  }
  async getSalonWaitlistAnalytics(salonId, ownerId) {
    const salon = await db.select({ ownerId: salons.ownerId }).from(salons).where(eq41(salons.id, salonId)).limit(1);
    if (salon.length === 0 || salon[0].ownerId !== ownerId) {
      throw new Error("Not authorized to view this salon's waitlist");
    }
    const waitingEntries = await db.select().from(slotWaitlist).where(and39(
      eq41(slotWaitlist.salonId, salonId),
      inArray15(slotWaitlist.status, [WAITLIST_STATUS.waiting, WAITLIST_STATUS.notified])
    )).orderBy(desc30(slotWaitlist.createdAt)).limit(50);
    const byDate = {};
    for (const entry of waitingEntries) {
      byDate[entry.requestedDate] = (byDate[entry.requestedDate] || 0) + 1;
    }
    const serviceIds = Array.from(new Set(waitingEntries.map((e) => e.serviceId)));
    const serviceInfos = serviceIds.length > 0 ? await db.select({ id: services.id, name: services.name }).from(services).where(inArray15(services.id, serviceIds)) : [];
    const serviceMap = new Map(serviceInfos.map((s) => [s.id, s.name]));
    const byServiceMap = {};
    for (const entry of waitingEntries) {
      byServiceMap[entry.serviceId] = (byServiceMap[entry.serviceId] || 0) + 1;
    }
    const byService = Object.entries(byServiceMap).map(([serviceId, count11]) => ({
      serviceId,
      serviceName: serviceMap.get(serviceId) || "Unknown Service",
      count: count11
    }));
    const enrichedEntries = [];
    for (const entry of waitingEntries.slice(0, 10)) {
      const service = await this.getServiceInfo(entry.serviceId);
      const position = entry.status === WAITLIST_STATUS.waiting ? await this.getQueuePosition(entry.id) : 0;
      enrichedEntries.push({
        ...entry,
        service,
        position
      });
    }
    return {
      totalWaiting: waitingEntries.length,
      byDate,
      byService,
      recentEntries: enrichedEntries
    };
  }
};
var waitlistService = new WaitlistService();

// server/services/cancellationService.ts
var DEFAULT_CANCELLATION_POLICY = {
  gracePeriodHours: 24,
  tiers: [
    { hoursBeforeMin: 24, hoursBeforeMax: Infinity, feePercentage: 0 },
    { hoursBeforeMin: 12, hoursBeforeMax: 24, feePercentage: 25 },
    { hoursBeforeMin: 0, hoursBeforeMax: 12, feePercentage: 50 }
  ]
};
var CancellationService = class {
  validateReasonCode(code) {
    return code in CANCELLATION_REASON_CODES;
  }
  getReasonCategory(code) {
    return CANCELLATION_REASON_CODES[code].category;
  }
  getReasonLabel(code) {
    return CANCELLATION_REASON_CODES[code].label;
  }
  calculateHoursBeforeAppointment(bookingDate, bookingTime, cancellationTime = /* @__PURE__ */ new Date()) {
    const appointmentDateTime = /* @__PURE__ */ new Date(`${bookingDate}T${bookingTime}:00+05:30`);
    const diffMs = appointmentDateTime.getTime() - cancellationTime.getTime();
    return Math.max(0, Math.floor(diffMs / (1e3 * 60 * 60)));
  }
  calculateCancellationFee(bookingAmountPaisa, hoursBeforeAppointment, policy = DEFAULT_CANCELLATION_POLICY) {
    for (const tier of policy.tiers) {
      if (hoursBeforeAppointment >= tier.hoursBeforeMin && hoursBeforeAppointment < tier.hoursBeforeMax) {
        const feePaisa = Math.round(bookingAmountPaisa * tier.feePercentage / 100);
        return { feePaisa, feePercentage: tier.feePercentage };
      }
    }
    return { feePaisa: bookingAmountPaisa, feePercentage: 100 };
  }
  async cancelBooking(input) {
    const {
      bookingId,
      userId,
      cancelledBy,
      reasonCode,
      additionalComments,
      requestRefund = false,
      salonOwnerId
    } = input;
    if (!this.validateReasonCode(reasonCode)) {
      return { success: false, error: "Invalid cancellation reason code" };
    }
    const reasonCategory = this.getReasonCategory(reasonCode);
    return await db.transaction(async (tx) => {
      const [booking] = await tx.select().from(bookings).where(eq42(bookings.id, bookingId)).for("update");
      if (!booking) {
        return { success: false, error: "Booking not found" };
      }
      if (booking.status === "cancelled") {
        return { success: false, error: "Booking is already cancelled" };
      }
      if (booking.status === "completed") {
        return { success: false, error: "Cannot cancel a completed booking" };
      }
      if (cancelledBy === "customer" && userId && booking.userId !== userId) {
        return { success: false, error: "You can only cancel your own bookings" };
      }
      if (cancelledBy === "salon" && salonOwnerId) {
        const salon = await tx.query.salons.findFirst({
          where: eq42(salons.id, booking.salonId)
        });
        if (!salon || salon.ownerId !== salonOwnerId) {
          return { success: false, error: "You can only cancel bookings at your own salon" };
        }
      }
      const hoursBeforeAppointment = this.calculateHoursBeforeAppointment(
        booking.bookingDate,
        booking.bookingTime
      );
      const bookingAmount = booking.finalAmountPaisa ?? booking.totalAmountPaisa ?? 0;
      let cancellationFeePaisa = 0;
      let refundAmountPaisa = 0;
      if (bookingAmount <= 0) {
        cancellationFeePaisa = 0;
        refundAmountPaisa = 0;
      } else if (cancelledBy === "salon" || cancelledBy === "system") {
        cancellationFeePaisa = 0;
        refundAmountPaisa = bookingAmount;
      } else {
        const feeCalculation = this.calculateCancellationFee(
          bookingAmount,
          hoursBeforeAppointment
        );
        cancellationFeePaisa = feeCalculation.feePaisa;
        refundAmountPaisa = bookingAmount - cancellationFeePaisa;
      }
      await tx.update(bookings).set({ status: "cancelled" }).where(eq42(bookings.id, bookingId));
      const [cancellation] = await tx.insert(bookingCancellations).values({
        bookingId,
        userId: userId || booking.userId,
        cancelledBy,
        reasonCode,
        reasonCategory,
        additionalComments,
        wasRescheduled: 0,
        refundRequested: requestRefund ? 1 : 0,
        refundAmountPaisa: refundAmountPaisa > 0 ? refundAmountPaisa : null,
        cancellationFeePaisa: cancellationFeePaisa > 0 ? cancellationFeePaisa : null,
        hoursBeforeAppointment
      }).returning();
      let refundStatus = "not_applicable";
      if (requestRefund && refundAmountPaisa > 0) {
        refundStatus = "pending";
      }
      if (booking.timeSlotId) {
        setImmediate(async () => {
          try {
            await waitlistService.processSlotRelease(booking.timeSlotId);
            console.log(`[Waitlist] Processed slot release for booking ${bookingId}`);
          } catch (error) {
            console.error(`[Waitlist] Error processing slot release for booking ${bookingId}:`, error);
          }
        });
      }
      return {
        success: true,
        cancellation,
        refundStatus,
        refundAmountPaisa,
        cancellationFeePaisa
      };
    });
  }
  async getCancellationPreview(bookingId, userId) {
    const booking = await db.query.bookings.findFirst({
      where: eq42(bookings.id, bookingId)
    });
    if (!booking) return null;
    if (userId && booking.userId !== userId) return null;
    if (booking.status === "cancelled") {
      return {
        booking: { id: booking.id, status: booking.status },
        hoursBeforeAppointment: 0,
        cancellationFeePaisa: 0,
        refundAmountPaisa: 0,
        feePercentage: 0,
        policy: [],
        canCancel: false,
        cancelError: "This booking is already cancelled"
      };
    }
    if (booking.status === "completed") {
      return {
        booking: { id: booking.id, status: booking.status },
        hoursBeforeAppointment: 0,
        cancellationFeePaisa: 0,
        refundAmountPaisa: 0,
        feePercentage: 0,
        policy: [],
        canCancel: false,
        cancelError: "Cannot cancel a completed booking"
      };
    }
    const hoursBeforeAppointment = this.calculateHoursBeforeAppointment(
      booking.bookingDate,
      booking.bookingTime
    );
    const bookingAmount = booking.finalAmountPaisa ?? booking.totalAmountPaisa ?? 0;
    const { feePaisa, feePercentage } = this.calculateCancellationFee(
      bookingAmount,
      hoursBeforeAppointment
    );
    const policy = [
      { tier: "24+ hours", description: "Free cancellation" },
      { tier: "12-24 hours", description: "25% cancellation fee" },
      { tier: "Less than 12 hours", description: "50% cancellation fee" }
    ];
    return {
      booking: {
        id: booking.id,
        bookingDate: booking.bookingDate,
        bookingTime: booking.bookingTime,
        status: booking.status,
        totalAmountPaisa: booking.totalAmountPaisa,
        finalAmountPaisa: booking.finalAmountPaisa
      },
      hoursBeforeAppointment,
      cancellationFeePaisa: feePaisa,
      refundAmountPaisa: bookingAmount - feePaisa,
      feePercentage,
      policy,
      canCancel: true
    };
  }
  async getCancellationBySalonId(bookingId, salonId) {
    const booking = await db.query.bookings.findFirst({
      where: and40(eq42(bookings.id, bookingId), eq42(bookings.salonId, salonId))
    });
    if (!booking) return null;
    const cancellation = await db.query.bookingCancellations.findFirst({
      where: eq42(bookingCancellations.bookingId, bookingId)
    });
    return cancellation || null;
  }
  async getSalonCancellationAnalytics(salonId, startDate, endDate) {
    const salonBookings = await db.select({ id: bookings.id }).from(bookings).where(eq42(bookings.salonId, salonId));
    const bookingIds = salonBookings.map((b) => b.id);
    if (bookingIds.length === 0) {
      return {
        totalCancellations: 0,
        cancellationRate: 0,
        topReasons: [],
        averageHoursBeforeCancellation: 0,
        rescheduledPercentage: 0,
        refundRequestedPercentage: 0,
        byCategory: {},
        trend: []
      };
    }
    const cancellations = await db.select().from(bookingCancellations).where(
      and40(
        sql34`${bookingCancellations.bookingId} = ANY(${sql34`ARRAY[${sql34.join(
          bookingIds.map((id) => sql34`${id}`),
          sql34`, `
        )}]`})`,
        gte18(bookingCancellations.createdAt, startDate),
        lte15(bookingCancellations.createdAt, endDate)
      )
    );
    const totalBookings = bookingIds.length;
    const totalCancellations = cancellations.length;
    const cancellationRate = totalBookings > 0 ? totalCancellations / totalBookings * 100 : 0;
    const reasonCounts = {};
    const categoryCounts = {};
    let totalHours = 0;
    let rescheduledCount = 0;
    let refundRequestedCount = 0;
    for (const c of cancellations) {
      reasonCounts[c.reasonCode] = (reasonCounts[c.reasonCode] || 0) + 1;
      categoryCounts[c.reasonCategory] = (categoryCounts[c.reasonCategory] || 0) + 1;
      if (c.hoursBeforeAppointment) totalHours += c.hoursBeforeAppointment;
      if (c.wasRescheduled) rescheduledCount++;
      if (c.refundRequested) refundRequestedCount++;
    }
    const topReasons = Object.entries(reasonCounts).map(([code, count11]) => ({
      code,
      count: count11,
      percentage: totalCancellations > 0 ? count11 / totalCancellations * 100 : 0
    })).sort((a, b) => b.count - a.count).slice(0, 5);
    const averageHoursBeforeCancellation = totalCancellations > 0 ? totalHours / totalCancellations : 0;
    const rescheduledPercentage = totalCancellations > 0 ? rescheduledCount / totalCancellations * 100 : 0;
    const refundRequestedPercentage = totalCancellations > 0 ? refundRequestedCount / totalCancellations * 100 : 0;
    const trendData = {};
    for (const c of cancellations) {
      if (c.createdAt) {
        const dateKey = c.createdAt.toISOString().split("T")[0];
        trendData[dateKey] = (trendData[dateKey] || 0) + 1;
      }
    }
    const trend = Object.entries(trendData).map(([date, count11]) => ({ date, count: count11 })).sort((a, b) => a.date.localeCompare(b.date));
    return {
      totalCancellations,
      cancellationRate: Math.round(cancellationRate * 10) / 10,
      topReasons,
      averageHoursBeforeCancellation: Math.round(averageHoursBeforeCancellation * 10) / 10,
      rescheduledPercentage: Math.round(rescheduledPercentage * 10) / 10,
      refundRequestedPercentage: Math.round(refundRequestedPercentage * 10) / 10,
      byCategory: categoryCounts,
      trend
    };
  }
  getAvailableReasonCodes(cancelledBy) {
    const customerReasons = [
      "schedule_conflict",
      "found_better_price",
      "service_not_needed",
      "health_issue",
      "family_emergency",
      "travel_plans",
      "staff_unavailable",
      "long_wait_time",
      "poor_reviews",
      "booked_by_mistake",
      "weather_conditions",
      "transportation_issue",
      "financial_reason",
      "other"
    ];
    const salonReasons = [
      "staff_sick",
      "staff_emergency",
      "equipment_issue",
      "double_booking",
      "salon_closed",
      "customer_no_show_history",
      "other"
    ];
    const systemReasons = [
      "payment_failed",
      "payment_timeout",
      "slot_no_longer_available",
      "service_discontinued"
    ];
    let codes;
    switch (cancelledBy) {
      case "customer":
        codes = customerReasons;
        break;
      case "salon":
        codes = salonReasons;
        break;
      case "system":
        codes = systemReasons;
        break;
      default:
        codes = [];
    }
    return codes.map((code) => ({
      code,
      label: CANCELLATION_REASON_CODES[code].label,
      category: CANCELLATION_REASON_CODES[code].category
    }));
  }
};
var cancellationService = new CancellationService();

// server/routes/cancellation.routes.ts
var cancelBookingSchema2 = z18.object({
  reasonCode: z18.string().min(1),
  additionalComments: z18.string().max(1e3).optional(),
  requestRefund: z18.boolean().optional().default(true)
});
var analyticsQuerySchema = z18.object({
  startDate: z18.string().optional(),
  endDate: z18.string().optional(),
  groupBy: z18.enum(["reason_code", "reason_category", "day", "week", "month"]).optional()
});
function registerCancellationRoutes(app2) {
  app2.get("/api/cancellation/reasons", (req, res) => {
    try {
      const cancelledBy = req.query.type || "customer";
      if (!["customer", "salon", "system"].includes(cancelledBy)) {
        return res.status(400).json({ error: "Invalid cancellation type" });
      }
      const reasons = cancellationService.getAvailableReasonCodes(
        cancelledBy
      );
      const groupedByCategory = {};
      for (const reason of reasons) {
        if (!groupedByCategory[reason.category]) {
          groupedByCategory[reason.category] = [];
        }
        groupedByCategory[reason.category].push({
          code: reason.code,
          label: reason.label
        });
      }
      res.json({
        success: true,
        reasons,
        byCategory: groupedByCategory
      });
    } catch (error) {
      console.error("Error fetching cancellation reasons:", error);
      res.status(500).json({ error: "Failed to fetch cancellation reasons" });
    }
  });
  app2.get(
    "/api/bookings/:bookingId/cancellation-preview",
    populateUserFromSession,
    async (req, res) => {
      try {
        const { bookingId } = req.params;
        const userId = req.user?.id;
        if (!userId) {
          return res.status(401).json({ error: "Authentication required" });
        }
        const preview = await cancellationService.getCancellationPreview(
          bookingId,
          userId
        );
        if (!preview) {
          return res.status(404).json({ error: "Booking not found or access denied" });
        }
        res.json({
          success: true,
          preview: {
            bookingId: preview.booking.id,
            bookingDate: preview.booking.bookingDate,
            bookingTime: preview.booking.bookingTime,
            hoursBeforeAppointment: preview.hoursBeforeAppointment,
            cancellationFee: preview.cancellationFeePaisa / 100,
            cancellationFeePaisa: preview.cancellationFeePaisa,
            refundAmount: preview.refundAmountPaisa / 100,
            refundAmountPaisa: preview.refundAmountPaisa,
            feePercentage: preview.feePercentage,
            policy: preview.policy,
            canCancel: preview.canCancel,
            cancelError: preview.cancelError
          }
        });
      } catch (error) {
        console.error("Error getting cancellation preview:", error);
        res.status(500).json({ error: "Failed to get cancellation preview" });
      }
    }
  );
  app2.post(
    "/api/bookings/:bookingId/cancel",
    populateUserFromSession,
    async (req, res) => {
      try {
        const { bookingId } = req.params;
        const userId = req.user?.id;
        if (!userId) {
          return res.status(401).json({ error: "Authentication required" });
        }
        const parsed = cancelBookingSchema2.safeParse(req.body);
        if (!parsed.success) {
          return res.status(400).json({
            error: "Invalid request body",
            details: parsed.error.flatten()
          });
        }
        const { reasonCode, additionalComments, requestRefund } = parsed.data;
        const result = await cancellationService.cancelBooking({
          bookingId,
          userId,
          cancelledBy: "customer",
          reasonCode,
          additionalComments,
          requestRefund
        });
        if (!result.success) {
          return res.status(400).json({ error: result.error });
        }
        res.json({
          success: true,
          message: "Booking cancelled successfully",
          cancellation: {
            id: result.cancellation?.id,
            refundStatus: result.refundStatus,
            refundAmount: (result.refundAmountPaisa || 0) / 100,
            refundAmountPaisa: result.refundAmountPaisa,
            cancellationFee: (result.cancellationFeePaisa || 0) / 100,
            cancellationFeePaisa: result.cancellationFeePaisa
          }
        });
      } catch (error) {
        console.error("Error cancelling booking:", error);
        res.status(500).json({ error: "Failed to cancel booking" });
      }
    }
  );
  app2.post(
    "/api/salons/:salonId/bookings/:bookingId/cancel",
    requireSalonAccess,
    async (req, res) => {
      try {
        const { salonId, bookingId } = req.params;
        const ownerId = req.user?.id;
        if (!ownerId) {
          return res.status(401).json({ error: "Authentication required" });
        }
        const parsed = cancelBookingSchema2.safeParse(req.body);
        if (!parsed.success) {
          return res.status(400).json({
            error: "Invalid request body",
            details: parsed.error.flatten()
          });
        }
        const { reasonCode, additionalComments, requestRefund } = parsed.data;
        const booking = await db.query.bookings.findFirst({
          where: and41(eq43(bookings.id, bookingId), eq43(bookings.salonId, salonId))
        });
        if (!booking) {
          return res.status(404).json({ error: "Booking not found in this salon" });
        }
        const result = await cancellationService.cancelBooking({
          bookingId,
          userId: booking.userId || void 0,
          cancelledBy: "salon",
          reasonCode,
          additionalComments,
          requestRefund,
          salonOwnerId: ownerId
        });
        if (!result.success) {
          return res.status(400).json({ error: result.error });
        }
        res.json({
          success: true,
          message: "Booking cancelled by salon",
          cancellation: {
            id: result.cancellation?.id,
            refundStatus: result.refundStatus,
            refundAmountPaisa: result.refundAmountPaisa,
            cancellationFeePaisa: result.cancellationFeePaisa
          }
        });
      } catch (error) {
        console.error("Error cancelling booking by salon:", error);
        res.status(500).json({ error: "Failed to cancel booking" });
      }
    }
  );
  app2.get(
    "/api/salons/:salonId/cancellation-analytics",
    requireSalonAccess,
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const parsed = analyticsQuerySchema.safeParse(req.query);
        if (!parsed.success) {
          return res.status(400).json({
            error: "Invalid query parameters",
            details: parsed.error.flatten()
          });
        }
        const { startDate, endDate } = parsed.data;
        const end = endDate ? new Date(endDate) : /* @__PURE__ */ new Date();
        const start = startDate ? new Date(startDate) : new Date(end.getTime() - 30 * 24 * 60 * 60 * 1e3);
        const analytics = await cancellationService.getSalonCancellationAnalytics(
          salonId,
          start,
          end
        );
        res.json({
          success: true,
          period: {
            startDate: start.toISOString().split("T")[0],
            endDate: end.toISOString().split("T")[0]
          },
          analytics
        });
      } catch (error) {
        console.error("Error fetching cancellation analytics:", error);
        res.status(500).json({ error: "Failed to fetch cancellation analytics" });
      }
    }
  );
  app2.get(
    "/api/salons/:salonId/cancellations",
    requireSalonAccess,
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const limit = Math.min(parseInt(req.query.limit) || 20, 100);
        const offset = parseInt(req.query.offset) || 0;
        const salonBookings = await db.select({ id: bookings.id }).from(bookings).where(eq43(bookings.salonId, salonId));
        const bookingIds = salonBookings.map((b) => b.id);
        if (bookingIds.length === 0) {
          return res.json({
            success: true,
            cancellations: [],
            pagination: { total: 0, limit, offset, hasMore: false }
          });
        }
        const cancellations = await db.select().from(bookingCancellations).where(
          sql35`${bookingCancellations.bookingId} = ANY(${sql35`ARRAY[${sql35.join(
            bookingIds.map((id) => sql35`${id}`),
            sql35`, `
          )}]`})`
        ).orderBy(desc32(bookingCancellations.createdAt)).limit(limit).offset(offset);
        const [countResult] = await db.select({ count: sql35`count(*)` }).from(bookingCancellations).where(
          sql35`${bookingCancellations.bookingId} = ANY(${sql35`ARRAY[${sql35.join(
            bookingIds.map((id) => sql35`${id}`),
            sql35`, `
          )}]`})`
        );
        const total = parseInt(String(countResult?.count || 0));
        const cancellationBookingIds = cancellations.map((c) => c.bookingId);
        const relatedBookings = cancellationBookingIds.length > 0 ? await db.select({
          id: bookings.id,
          customerName: bookings.customerName,
          customerPhone: bookings.customerPhone,
          bookingDate: bookings.bookingDate,
          bookingTime: bookings.bookingTime,
          totalAmountPaisa: bookings.totalAmountPaisa
        }).from(bookings).where(sql35`${bookings.id} = ANY(${sql35`ARRAY[${sql35.join(
          cancellationBookingIds.map((id) => sql35`${id}`),
          sql35`, `
        )}]`})`) : [];
        const bookingsMap = new Map(relatedBookings.map((b) => [b.id, b]));
        const enrichedCancellations = cancellations.map((c) => {
          const booking = bookingsMap.get(c.bookingId);
          return {
            ...c,
            reasonLabel: CANCELLATION_REASON_CODES[c.reasonCode]?.label || c.reasonCode,
            booking: booking || null
          };
        });
        res.json({
          success: true,
          cancellations: enrichedCancellations,
          pagination: {
            total,
            limit,
            offset,
            hasMore: offset + cancellations.length < total
          }
        });
      } catch (error) {
        console.error("Error fetching cancellations:", error);
        res.status(500).json({ error: "Failed to fetch cancellations" });
      }
    }
  );
}
function registerMobileCancellationRoutes(app2) {
  app2.get("/api/mobile/cancellation/reasons", (req, res) => {
    try {
      const reasons = cancellationService.getAvailableReasonCodes("customer");
      const groupedByCategory = {};
      for (const reason of reasons) {
        if (!groupedByCategory[reason.category]) {
          groupedByCategory[reason.category] = [];
        }
        groupedByCategory[reason.category].push({
          code: reason.code,
          label: reason.label
        });
      }
      res.json({
        success: true,
        reasons,
        byCategory: groupedByCategory
      });
    } catch (error) {
      console.error("Error fetching cancellation reasons:", error);
      res.status(500).json({ error: "Failed to fetch cancellation reasons" });
    }
  });
  app2.get(
    "/api/mobile/bookings/:bookingId/cancellation-preview",
    authenticateMobileUser,
    async (req, res) => {
      try {
        const { bookingId } = req.params;
        const userId = req.user.id;
        const preview = await cancellationService.getCancellationPreview(
          bookingId,
          userId
        );
        if (!preview) {
          return res.status(404).json({ error: "Booking not found" });
        }
        res.json({
          success: true,
          preview: {
            bookingId: preview.booking.id,
            bookingDate: preview.booking.bookingDate,
            bookingTime: preview.booking.bookingTime,
            hoursBeforeAppointment: preview.hoursBeforeAppointment,
            cancellationFee: preview.cancellationFeePaisa / 100,
            cancellationFeePaisa: preview.cancellationFeePaisa,
            refundAmount: preview.refundAmountPaisa / 100,
            refundAmountPaisa: preview.refundAmountPaisa,
            feePercentage: preview.feePercentage,
            policy: preview.policy,
            canCancel: preview.canCancel,
            cancelError: preview.cancelError
          }
        });
      } catch (error) {
        console.error("Error getting cancellation preview:", error);
        res.status(500).json({ error: "Failed to get cancellation preview" });
      }
    }
  );
  app2.post(
    "/api/mobile/bookings/:bookingId/cancel",
    authenticateMobileUser,
    async (req, res) => {
      try {
        const { bookingId } = req.params;
        const userId = req.user.id;
        const parsed = cancelBookingSchema2.safeParse(req.body);
        if (!parsed.success) {
          return res.status(400).json({
            error: "Invalid request body",
            details: parsed.error.flatten()
          });
        }
        const { reasonCode, additionalComments, requestRefund } = parsed.data;
        const result = await cancellationService.cancelBooking({
          bookingId,
          userId,
          cancelledBy: "customer",
          reasonCode,
          additionalComments,
          requestRefund
        });
        if (!result.success) {
          return res.status(400).json({ error: result.error });
        }
        res.json({
          success: true,
          message: "Booking cancelled successfully",
          cancellation: {
            id: result.cancellation?.id,
            refundStatus: result.refundStatus,
            refundAmount: (result.refundAmountPaisa || 0) / 100,
            refundAmountPaisa: result.refundAmountPaisa,
            cancellationFee: (result.cancellationFeePaisa || 0) / 100,
            cancellationFeePaisa: result.cancellationFeePaisa
          }
        });
      } catch (error) {
        console.error("Error cancelling booking:", error);
        res.status(500).json({ error: "Failed to cancel booking" });
      }
    }
  );
}

// server/routes/waitlist.routes.ts
import { Router as Router25 } from "express";
init_schema();
import rateLimit6 from "express-rate-limit";
var router26 = Router25();
var waitlistRateLimiter = rateLimit6({
  windowMs: 60 * 1e3,
  max: 10,
  message: { error: "Too many requests. Please try again in a minute." },
  standardHeaders: true,
  legacyHeaders: false
});
function requireAuth3(req, res, next) {
  if (!req.isAuthenticated?.() || !req.user) {
    return res.status(401).json({ error: "Authentication required" });
  }
  next();
}
function handleZodError(error) {
  const issues = error.issues.map((issue) => ({
    field: issue.path.join("."),
    message: issue.message
  }));
  return { error: "Validation failed", issues };
}
router26.post("/join", waitlistRateLimiter, requireAuth3, async (req, res) => {
  try {
    const userId = req.user.id;
    const parseResult = joinWaitlistSchema.safeParse(req.body);
    if (!parseResult.success) {
      return res.status(400).json(handleZodError(parseResult.error));
    }
    const result = await waitlistService.joinWaitlist(userId, parseResult.data);
    if (!result.success) {
      if (result.availableSlots) {
        return res.status(422).json({
          error: result.error,
          availableSlots: result.availableSlots,
          code: "SLOTS_AVAILABLE"
        });
      }
      return res.status(400).json({ error: result.error });
    }
    return res.status(201).json({
      success: true,
      waitlistEntry: result.waitlistEntry
    });
  } catch (error) {
    console.error("Error joining waitlist:", error);
    return res.status(500).json({ error: "Failed to join waitlist" });
  }
});
router26.get("/my-entries", requireAuth3, async (req, res) => {
  try {
    const userId = req.user.id;
    const entries = await waitlistService.getUserWaitlistEntries(userId);
    return res.json({
      entries: entries.map((entry) => ({
        id: entry.id,
        salon: entry.salon,
        service: entry.service,
        staff: entry.staff,
        requestedDate: entry.requestedDate,
        timeWindow: `${entry.timeWindowStart} - ${entry.timeWindowEnd}`,
        flexibilityDays: entry.flexibilityDays,
        priority: entry.priority,
        position: entry.position,
        status: entry.status,
        notifiedAt: entry.notifiedAt,
        responseDeadline: entry.responseDeadline,
        expiresAt: entry.expiresAt,
        createdAt: entry.createdAt
      }))
    });
  } catch (error) {
    console.error("Error fetching waitlist entries:", error);
    return res.status(500).json({ error: "Failed to fetch waitlist entries" });
  }
});
router26.delete("/:waitlistId", requireAuth3, async (req, res) => {
  try {
    const userId = req.user.id;
    const { waitlistId } = req.params;
    if (!waitlistId) {
      return res.status(400).json({ error: "Waitlist ID is required" });
    }
    const result = await waitlistService.cancelWaitlistEntry(userId, waitlistId);
    if (!result.success) {
      return res.status(400).json({ error: result.error });
    }
    return res.json({ success: true, message: "Removed from waitlist" });
  } catch (error) {
    console.error("Error cancelling waitlist entry:", error);
    return res.status(500).json({ error: "Failed to remove from waitlist" });
  }
});
router26.post("/:waitlistId/respond", waitlistRateLimiter, requireAuth3, async (req, res) => {
  try {
    const userId = req.user.id;
    const { waitlistId } = req.params;
    if (!waitlistId) {
      return res.status(400).json({ error: "Waitlist ID is required" });
    }
    const parseResult = respondWaitlistSchema.safeParse(req.body);
    if (!parseResult.success) {
      return res.status(400).json(handleZodError(parseResult.error));
    }
    const result = await waitlistService.respondToNotification(userId, waitlistId, parseResult.data.response);
    if (!result.success) {
      return res.status(400).json({ error: result.error });
    }
    if (parseResult.data.response === "accepted") {
      return res.json({
        success: true,
        bookingId: result.bookingId,
        slotInfo: result.slotInfo,
        message: "Slot booked successfully!"
      });
    }
    return res.json({
      success: true,
      message: "Slot offer declined"
    });
  } catch (error) {
    console.error("Error responding to waitlist notification:", error);
    return res.status(500).json({ error: "Failed to respond to notification" });
  }
});
router26.get("/salons/:salonId", requireAuth3, async (req, res) => {
  try {
    const userId = req.user.id;
    const { salonId } = req.params;
    if (!salonId) {
      return res.status(400).json({ error: "Salon ID is required" });
    }
    const analytics = await waitlistService.getSalonWaitlistAnalytics(salonId, userId);
    return res.json(analytics);
  } catch (error) {
    if (error.message?.includes("Not authorized")) {
      return res.status(403).json({ error: error.message });
    }
    console.error("Error fetching salon waitlist analytics:", error);
    return res.status(500).json({ error: "Failed to fetch waitlist analytics" });
  }
});
var waitlist_routes_default = router26;

// server/routes/mobile-waitlist.routes.ts
import { Router as Router26 } from "express";
init_schema();
import rateLimit7 from "express-rate-limit";
var router27 = Router26();
var waitlistRateLimiter2 = rateLimit7({
  windowMs: 60 * 1e3,
  max: 10,
  message: { error: "Too many requests. Please try again in a minute." },
  standardHeaders: true,
  legacyHeaders: false
});
function handleZodError2(error) {
  const issues = error.issues.map((issue) => ({
    field: issue.path.join("."),
    message: issue.message
  }));
  return { error: "Validation failed", issues };
}
router27.post("/join", waitlistRateLimiter2, async (req, res) => {
  try {
    const userId = req.userId;
    if (!userId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const parseResult = joinWaitlistSchema.safeParse(req.body);
    if (!parseResult.success) {
      return res.status(400).json(handleZodError2(parseResult.error));
    }
    const result = await waitlistService.joinWaitlist(userId, parseResult.data);
    if (!result.success) {
      if (result.availableSlots) {
        return res.status(422).json({
          error: result.error,
          availableSlots: result.availableSlots,
          code: "SLOTS_AVAILABLE"
        });
      }
      return res.status(400).json({ error: result.error });
    }
    return res.status(201).json({
      success: true,
      waitlistEntry: result.waitlistEntry
    });
  } catch (error) {
    console.error("Error joining waitlist (mobile):", error);
    return res.status(500).json({ error: "Failed to join waitlist" });
  }
});
router27.get("/my-entries", async (req, res) => {
  try {
    const userId = req.userId;
    if (!userId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const entries = await waitlistService.getUserWaitlistEntries(userId);
    return res.json({
      entries: entries.map((entry) => ({
        id: entry.id,
        salon: entry.salon,
        service: entry.service,
        staff: entry.staff,
        requestedDate: entry.requestedDate,
        timeWindow: `${entry.timeWindowStart} - ${entry.timeWindowEnd}`,
        flexibilityDays: entry.flexibilityDays,
        priority: entry.priority,
        position: entry.position,
        status: entry.status,
        notifiedAt: entry.notifiedAt,
        responseDeadline: entry.responseDeadline,
        expiresAt: entry.expiresAt,
        createdAt: entry.createdAt
      }))
    });
  } catch (error) {
    console.error("Error fetching waitlist entries (mobile):", error);
    return res.status(500).json({ error: "Failed to fetch waitlist entries" });
  }
});
router27.delete("/:waitlistId", async (req, res) => {
  try {
    const userId = req.userId;
    if (!userId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const { waitlistId } = req.params;
    if (!waitlistId) {
      return res.status(400).json({ error: "Waitlist ID is required" });
    }
    const result = await waitlistService.cancelWaitlistEntry(userId, waitlistId);
    if (!result.success) {
      return res.status(400).json({ error: result.error });
    }
    return res.json({ success: true, message: "Removed from waitlist" });
  } catch (error) {
    console.error("Error cancelling waitlist entry (mobile):", error);
    return res.status(500).json({ error: "Failed to remove from waitlist" });
  }
});
router27.post("/:waitlistId/respond", waitlistRateLimiter2, async (req, res) => {
  try {
    const userId = req.userId;
    if (!userId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const { waitlistId } = req.params;
    if (!waitlistId) {
      return res.status(400).json({ error: "Waitlist ID is required" });
    }
    const parseResult = respondWaitlistSchema.safeParse(req.body);
    if (!parseResult.success) {
      return res.status(400).json(handleZodError2(parseResult.error));
    }
    const result = await waitlistService.respondToNotification(userId, waitlistId, parseResult.data.response);
    if (!result.success) {
      return res.status(400).json({ error: result.error });
    }
    if (parseResult.data.response === "accepted") {
      return res.json({
        success: true,
        bookingId: result.bookingId,
        slotInfo: result.slotInfo,
        message: "Slot booked successfully!"
      });
    }
    return res.json({
      success: true,
      message: "Slot offer declined"
    });
  } catch (error) {
    console.error("Error responding to waitlist notification (mobile):", error);
    return res.status(500).json({ error: "Failed to respond to notification" });
  }
});
var mobile_waitlist_routes_default = router27;

// server/jobs/waitlistJobs.ts
import cron from "node-cron";
init_db();
init_schema();
import { eq as eq44, and as and42, gte as gte20 } from "drizzle-orm";
import { format as format3 } from "date-fns";
var isProcessingSlots = false;
var isProcessingExpired = false;
var isProcessingEscalations = false;
async function processNewlyAvailableSlots() {
  if (isProcessingSlots) {
    console.log("[Waitlist Job] Slot processing already in progress, skipping...");
    return;
  }
  isProcessingSlots = true;
  console.log("[Waitlist Job] Processing newly available slots...");
  try {
    const now = /* @__PURE__ */ new Date();
    const recentlyFreedSlots = await db.select({
      id: timeSlots.id,
      salonId: timeSlots.salonId,
      startDateTime: timeSlots.startDateTime
    }).from(timeSlots).where(and42(
      eq44(timeSlots.isBooked, 0),
      gte20(timeSlots.startDateTime, now)
    )).limit(100);
    let processedCount = 0;
    for (const slot of recentlyFreedSlots) {
      if (!slot.salonId || !slot.startDateTime) continue;
      const matchingEntries = await waitlistService.findMatchingWaitlistEntries(slot.id);
      if (matchingEntries.length > 0) {
        const entry = matchingEntries[0];
        if (entry.status === WAITLIST_STATUS.waiting) {
          await waitlistService.notifyWaitlistEntry(entry.id, slot.id);
          processedCount++;
          const slotDate = format3(slot.startDateTime, "yyyy-MM-dd");
          const slotTime = format3(slot.startDateTime, "HH:mm");
          console.log(`[Waitlist Job] Notified user for slot ${slot.id} on ${slotDate} at ${slotTime}`);
        }
      }
    }
    console.log(`[Waitlist Job] Processed ${processedCount} slot notifications`);
  } catch (error) {
    console.error("[Waitlist Job] Error processing slots:", error);
  } finally {
    isProcessingSlots = false;
  }
}
async function expireOldWaitlistEntries() {
  if (isProcessingExpired) {
    console.log("[Waitlist Job] Expiration processing already in progress, skipping...");
    return;
  }
  isProcessingExpired = true;
  console.log("[Waitlist Job] Processing expired waitlist entries...");
  try {
    const expiredCount = await waitlistService.expireOldEntries();
    console.log(`[Waitlist Job] Expired ${expiredCount} waitlist entries`);
  } catch (error) {
    console.error("[Waitlist Job] Error expiring entries:", error);
  } finally {
    isProcessingExpired = false;
  }
}
async function escalateUnrespondedNotifications() {
  if (isProcessingEscalations) {
    console.log("[Waitlist Job] Escalation processing already in progress, skipping...");
    return;
  }
  isProcessingEscalations = true;
  console.log("[Waitlist Job] Processing unresponded notifications...");
  try {
    const escalatedCount = await waitlistService.escalateUnrespondedNotifications();
    console.log(`[Waitlist Job] Escalated ${escalatedCount} unresponded notifications`);
  } catch (error) {
    console.error("[Waitlist Job] Error escalating notifications:", error);
  } finally {
    isProcessingEscalations = false;
  }
}
function startWaitlistJobs() {
  console.log("[Waitlist Jobs] Starting waitlist background jobs...");
  cron.schedule("*/5 * * * *", async () => {
    await processNewlyAvailableSlots();
  }, { timezone: "Asia/Kolkata" });
  cron.schedule("0 * * * *", async () => {
    await expireOldWaitlistEntries();
  }, { timezone: "Asia/Kolkata" });
  cron.schedule("*/15 * * * *", async () => {
    await escalateUnrespondedNotifications();
  }, { timezone: "Asia/Kolkata" });
  console.log("[Waitlist Jobs] Background jobs scheduled:");
  console.log("  - Slot availability processing: every 5 minutes");
  console.log("  - Entry expiration: every hour");
  console.log("  - Notification escalation: every 15 minutes");
}

// server/jobs/expressRebookingJobs.ts
import cron2 from "node-cron";
function startExpressRebookingJobs() {
  console.log("[Express Rebooking Jobs] Starting background jobs...");
  cron2.schedule("0 6 * * *", async () => {
    console.log("[Express Rebooking Jobs] Running daily suggestion generation...");
    try {
      const generatedCount = await expressRebookingService.generateSuggestionsForAllUsers();
      console.log(`[Express Rebooking Jobs] Generated ${generatedCount} new suggestions`);
    } catch (error) {
      console.error("[Express Rebooking Jobs] Error generating suggestions:", error);
    }
  });
  cron2.schedule("0 * * * *", async () => {
    try {
      const expiredCount = await expressRebookingService.expireOldSuggestions();
      if (expiredCount > 0) {
        console.log(`[Express Rebooking Jobs] Expired ${expiredCount} old suggestions`);
      }
    } catch (error) {
      console.error("[Express Rebooking Jobs] Error expiring suggestions:", error);
    }
  });
  console.log("[Express Rebooking Jobs] Background jobs scheduled:");
  console.log("  - Suggestion generation: daily at 6 AM");
  console.log("  - Suggestion expiration: every hour");
}

// server/routes/dynamicPricing.routes.ts
import { Router as Router27 } from "express";

// server/services/dynamicPricing.service.ts
init_db();
init_schema();
import { eq as eq45, and as and43, gte as gte21, lte as lte17, inArray as inArray16, isNull as isNull7, or as or16, desc as desc33, asc as asc8 } from "drizzle-orm";
import { subDays, parseISO as parseISO3, getDay } from "date-fns";
var DAY_NAMES = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
var DynamicPricingService = class {
  async getDemandHeatmap(salonId) {
    const [demandData, activeRules] = await Promise.all([
      db.select().from(timeSlotDemand).where(eq45(timeSlotDemand.salonId, salonId)),
      this.getActiveRulesForSalon(salonId)
    ]);
    const heatmap = {};
    const bestTimes = [];
    for (let day = 0; day < 7; day++) {
      const dayName = DAY_NAMES[day].toLowerCase();
      heatmap[dayName] = [];
      for (let hour = 9; hour <= 20; hour++) {
        const demandEntry = demandData.find((d) => d.dayOfWeek === day && d.hourOfDay === hour);
        const demand = demandEntry?.demandLevel || DEMAND_LEVELS.medium;
        const matchingRule = this.findMatchingRule(activeRules, day, hour);
        let discount = null;
        if (matchingRule && matchingRule.adjustmentValue < 0) {
          const discountValue = Math.abs(matchingRule.adjustmentValue);
          discount = {
            type: matchingRule.adjustmentType,
            value: discountValue,
            label: matchingRule.adjustmentType === "percentage" ? `${discountValue}% off` : `\u20B9${discountValue / 100} off`
          };
          if (demand === DEMAND_LEVELS.low) {
            bestTimes.push({
              day: DAY_NAMES[day],
              time: this.formatHour(hour),
              discount: discount.label
            });
          }
        }
        heatmap[dayName].push({
          hour,
          demand,
          discount
        });
      }
    }
    const sortedBestTimes = bestTimes.sort((a, b) => {
      const discountA = parseInt(a.discount.match(/\d+/)?.[0] || "0");
      const discountB = parseInt(b.discount.match(/\d+/)?.[0] || "0");
      return discountB - discountA;
    }).slice(0, 5);
    return {
      heatmap,
      legend: {
        [DEMAND_LEVELS.peak]: { label: "Very Busy", color: "#ef4444" },
        [DEMAND_LEVELS.high]: { label: "Busy", color: "#f97316" },
        [DEMAND_LEVELS.medium]: { label: "Moderate", color: "#eab308" },
        [DEMAND_LEVELS.low]: { label: "Quiet - Discounts Available", color: "#22c55e" }
      },
      bestTimes: sortedBestTimes
    };
  }
  async getSlotsPricingForDate(salonId, date, serviceId) {
    const parsedDate = parseISO3(date);
    const dayOfWeek = getDay(parsedDate);
    const dayName = DAY_NAMES[dayOfWeek];
    const [demandData, dateOverride, activeRules, serviceInfo] = await Promise.all([
      db.select().from(timeSlotDemand).where(and43(
        eq45(timeSlotDemand.salonId, salonId),
        eq45(timeSlotDemand.dayOfWeek, dayOfWeek)
      )),
      db.select().from(demandDateOverrides).where(and43(
        eq45(demandDateOverrides.salonId, salonId),
        eq45(demandDateOverrides.overrideDate, date)
      )).limit(1),
      this.getActiveRulesForSalon(salonId),
      serviceId ? db.select({ priceInPaisa: services.priceInPaisa }).from(services).where(eq45(services.id, serviceId)).limit(1) : Promise.resolve([{ priceInPaisa: 5e4 }])
    ]);
    const basePrice = serviceInfo[0]?.priceInPaisa ?? 5e4;
    const overrideDemand = dateOverride[0]?.demandLevel;
    const existingBookings = await db.select({
      bookingTime: bookings.bookingTime
    }).from(bookings).where(and43(
      eq45(bookings.salonId, salonId),
      eq45(bookings.bookingDate, date),
      inArray16(bookings.status, ["confirmed", "pending"])
    ));
    const bookedTimes = new Set(existingBookings.map((b) => b.bookingTime));
    const slots = [];
    for (let hour = 9; hour <= 20; hour++) {
      const timeStr = `${hour.toString().padStart(2, "0")}:00`;
      const demandEntry = demandData.find((d) => d.hourOfDay === hour);
      const demand = overrideDemand || demandEntry?.demandLevel || DEMAND_LEVELS.medium;
      const available = !bookedTimes.has(timeStr);
      const { adjustedPrice, discountPercent, discountLabel, appliedRuleId } = this.calculateAdjustedPrice(basePrice, activeRules, dayOfWeek, hour, serviceId);
      const savings = adjustedPrice < basePrice ? `\u20B9${Math.round((basePrice - adjustedPrice) / 100)}` : null;
      slots.push({
        time: timeStr,
        available,
        demand,
        pricing: {
          originalPriceInPaisa: basePrice,
          adjustedPriceInPaisa: adjustedPrice,
          discountPercent,
          discountLabel,
          savings,
          appliedRuleId
        }
      });
    }
    const demandCounts = demandData.reduce((acc, d) => {
      acc[d.demandLevel] = (acc[d.demandLevel] || 0) + 1;
      return acc;
    }, {});
    let overallDemand = DEMAND_LEVELS.medium;
    if (overrideDemand) {
      overallDemand = overrideDemand;
    } else {
      const maxCount = Math.max(...Object.values(demandCounts).map(Number));
      overallDemand = Object.entries(demandCounts).find(([, count11]) => count11 === maxCount)?.[0] || DEMAND_LEVELS.medium;
    }
    return {
      date,
      dayOfWeek: dayName,
      overallDemand,
      slots
    };
  }
  async createPricingRule(salonId, ownerId, input) {
    const salon = await this.verifySalonOwnership(salonId, ownerId);
    if (!salon) {
      return { success: false, error: "Salon not found or not authorized" };
    }
    if (input.startHour >= input.endHour) {
      return { success: false, error: "End hour must be after start hour" };
    }
    if (input.adjustmentValue > 25) {
      return { success: false, error: "Maximum surcharge is 25%" };
    }
    if (input.adjustmentValue < -50) {
      return { success: false, error: "Maximum discount is 50%" };
    }
    const [rule] = await db.insert(dynamicPricingRules).values({
      salonId,
      name: input.name,
      ruleType: input.ruleType,
      dayOfWeek: input.dayOfWeek ?? null,
      startHour: input.startHour,
      endHour: input.endHour,
      adjustmentType: input.adjustmentType,
      adjustmentValue: input.adjustmentValue,
      maxDiscountPaisa: input.maxDiscountPaisa ?? null,
      minBookingValuePaisa: input.minBookingValuePaisa ?? null,
      applicableServiceIds: input.applicableServiceIds ?? null,
      validFrom: input.validFrom ? new Date(input.validFrom) : null,
      validUntil: input.validUntil ? new Date(input.validUntil) : null,
      priority: input.priority ?? 0
    }).returning();
    return { success: true, rule };
  }
  async updatePricingRule(salonId, ruleId, ownerId, input) {
    const salon = await this.verifySalonOwnership(salonId, ownerId);
    if (!salon) {
      return { success: false, error: "Salon not found or not authorized" };
    }
    const existingRule = await db.select().from(dynamicPricingRules).where(and43(
      eq45(dynamicPricingRules.id, ruleId),
      eq45(dynamicPricingRules.salonId, salonId)
    )).limit(1);
    if (existingRule.length === 0) {
      return { success: false, error: "Pricing rule not found" };
    }
    const updateData = { updatedAt: /* @__PURE__ */ new Date() };
    if (input.name !== void 0) updateData.name = input.name;
    if (input.ruleType !== void 0) updateData.ruleType = input.ruleType;
    if (input.dayOfWeek !== void 0) updateData.dayOfWeek = input.dayOfWeek;
    if (input.startHour !== void 0) updateData.startHour = input.startHour;
    if (input.endHour !== void 0) updateData.endHour = input.endHour;
    if (input.adjustmentType !== void 0) updateData.adjustmentType = input.adjustmentType;
    if (input.adjustmentValue !== void 0) updateData.adjustmentValue = input.adjustmentValue;
    if (input.maxDiscountPaisa !== void 0) updateData.maxDiscountPaisa = input.maxDiscountPaisa;
    if (input.minBookingValuePaisa !== void 0) updateData.minBookingValuePaisa = input.minBookingValuePaisa;
    if (input.applicableServiceIds !== void 0) updateData.applicableServiceIds = input.applicableServiceIds;
    if (input.validFrom !== void 0) updateData.validFrom = input.validFrom ? new Date(input.validFrom) : null;
    if (input.validUntil !== void 0) updateData.validUntil = input.validUntil ? new Date(input.validUntil) : null;
    if (input.priority !== void 0) updateData.priority = input.priority;
    if (input.isActive !== void 0) updateData.isActive = input.isActive ? 1 : 0;
    const [updatedRule] = await db.update(dynamicPricingRules).set(updateData).where(eq45(dynamicPricingRules.id, ruleId)).returning();
    return { success: true, rule: updatedRule };
  }
  async deletePricingRule(salonId, ruleId, ownerId) {
    const salon = await this.verifySalonOwnership(salonId, ownerId);
    if (!salon) {
      return { success: false, error: "Salon not found or not authorized" };
    }
    const result = await db.delete(dynamicPricingRules).where(and43(
      eq45(dynamicPricingRules.id, ruleId),
      eq45(dynamicPricingRules.salonId, salonId)
    )).returning({ id: dynamicPricingRules.id });
    if (result.length === 0) {
      return { success: false, error: "Pricing rule not found" };
    }
    return { success: true };
  }
  async getPricingRules(salonId, ownerId) {
    const salon = await this.verifySalonOwnership(salonId, ownerId);
    if (!salon) {
      return { success: false, error: "Salon not found or not authorized" };
    }
    const rules = await db.select().from(dynamicPricingRules).where(eq45(dynamicPricingRules.salonId, salonId)).orderBy(desc33(dynamicPricingRules.isActive), desc33(dynamicPricingRules.priority));
    return { success: true, rules };
  }
  async getPricingAnalytics(salonId, ownerId) {
    const salon = await this.verifySalonOwnership(salonId, ownerId);
    if (!salon) {
      return { success: false, error: "Salon not found or not authorized" };
    }
    const thirtyDaysAgo = subDays(/* @__PURE__ */ new Date(), 30);
    const [adjustmentLogs, rules] = await Promise.all([
      db.select().from(pricingAdjustmentsLog).leftJoin(bookings, eq45(pricingAdjustmentsLog.bookingId, bookings.id)).where(and43(
        eq45(bookings.salonId, salonId),
        gte21(pricingAdjustmentsLog.appliedAt, thirtyDaysAgo)
      )),
      db.select().from(dynamicPricingRules).where(eq45(dynamicPricingRules.salonId, salonId))
    ]);
    const totalDiscountedBookings = adjustmentLogs.length;
    const totalDiscountGivenPaisa = adjustmentLogs.reduce((sum4, log2) => {
      return sum4 + Math.abs(log2.pricing_adjustments_log.adjustmentAmountPaisa);
    }, 0);
    const byRuleMap = /* @__PURE__ */ new Map();
    for (const log2 of adjustmentLogs) {
      const ruleId = log2.pricing_adjustments_log.ruleId;
      const existing = byRuleMap.get(ruleId) || { bookings: 0, totalDiscountPaisa: 0 };
      existing.bookings++;
      existing.totalDiscountPaisa += Math.abs(log2.pricing_adjustments_log.adjustmentAmountPaisa);
      byRuleMap.set(ruleId, existing);
    }
    const ruleMap = new Map(rules.map((r) => [r.id, r]));
    const byRule = Array.from(byRuleMap.entries()).map(([ruleId, data]) => {
      const rule = ruleMap.get(ruleId);
      return {
        rule: { id: ruleId, name: rule?.name || "Unknown Rule" },
        bookings: data.bookings,
        totalDiscountPaisa: data.totalDiscountPaisa,
        averageDiscountPaisa: Math.round(data.totalDiscountPaisa / data.bookings),
        utilizationChange: "+15%"
      };
    });
    return {
      success: true,
      analytics: {
        summary: {
          totalDiscountedBookings,
          totalDiscountGivenPaisa,
          incrementalBookings: Math.round(totalDiscountedBookings * 0.35),
          estimatedRevenueGainPaisa: Math.round(totalDiscountGivenPaisa * 0.5)
        },
        byRule,
        demandImpact: {
          beforePricing: { offPeakUtilization: 35, peakUtilization: 95 },
          afterPricing: { offPeakUtilization: 58, peakUtilization: 90 }
        }
      }
    };
  }
  async createDemandOverride(salonId, ownerId, input) {
    const salon = await this.verifySalonOwnership(salonId, ownerId);
    if (!salon) {
      return { success: false, error: "Salon not found or not authorized" };
    }
    try {
      const [override] = await db.insert(demandDateOverrides).values({
        salonId,
        overrideDate: input.overrideDate,
        demandLevel: input.demandLevel,
        reason: input.reason,
        createdBy: ownerId
      }).returning();
      return { success: true, override };
    } catch (error) {
      if (error.code === "23505") {
        return { success: false, error: "Override already exists for this date" };
      }
      throw error;
    }
  }
  async deleteDemandOverride(salonId, overrideId, ownerId) {
    const salon = await this.verifySalonOwnership(salonId, ownerId);
    if (!salon) {
      return { success: false, error: "Salon not found or not authorized" };
    }
    const result = await db.delete(demandDateOverrides).where(and43(
      eq45(demandDateOverrides.id, overrideId),
      eq45(demandDateOverrides.salonId, salonId)
    )).returning({ id: demandDateOverrides.id });
    if (result.length === 0) {
      return { success: false, error: "Override not found" };
    }
    return { success: true };
  }
  async getDemandOverrides(salonId) {
    return db.select().from(demandDateOverrides).where(eq45(demandDateOverrides.salonId, salonId)).orderBy(asc8(demandDateOverrides.overrideDate));
  }
  async calculatePriceForBooking(salonId, serviceId, bookingDate, bookingTime, basePrice) {
    const parsedDate = parseISO3(bookingDate);
    const dayOfWeek = getDay(parsedDate);
    const hour = parseInt(bookingTime.split(":")[0]);
    const activeRules = await this.getActiveRulesForSalon(salonId);
    const { adjustedPrice, discountPercent, discountLabel, appliedRuleId, appliedRuleName } = this.calculateAdjustedPrice(basePrice, activeRules, dayOfWeek, hour, serviceId);
    return {
      originalPrice: basePrice,
      adjustedPrice,
      discountPercent,
      discountLabel,
      appliedRuleId,
      appliedRuleName: appliedRuleName || null
    };
  }
  async logPricingAdjustment(bookingId, ruleId, originalPrice, adjustedPrice, ruleName, ruleType) {
    const adjustmentAmount = adjustedPrice - originalPrice;
    const adjustmentPercent = Math.round(adjustmentAmount / originalPrice * 100);
    await db.insert(pricingAdjustmentsLog).values({
      bookingId,
      ruleId,
      originalPricePaisa: originalPrice,
      adjustedPricePaisa: adjustedPrice,
      adjustmentAmountPaisa: adjustmentAmount,
      adjustmentPercent,
      ruleName,
      ruleType
    });
  }
  async updateDemandPatterns(salonId) {
    const thirtyDaysAgo = subDays(/* @__PURE__ */ new Date(), 30);
    const bookingData = await db.select({
      bookingDate: bookings.bookingDate,
      bookingTime: bookings.bookingTime
    }).from(bookings).where(and43(
      eq45(bookings.salonId, salonId),
      gte21(bookings.createdAt, thirtyDaysAgo),
      eq45(bookings.status, "completed")
    ));
    const demandBySlot = {};
    for (const booking of bookingData) {
      if (!booking.bookingDate || !booking.bookingTime) continue;
      const date = parseISO3(booking.bookingDate);
      const day = getDay(date);
      const hour = parseInt(booking.bookingTime.split(":")[0]);
      const key = `${day}-${hour}`;
      demandBySlot[key] = (demandBySlot[key] || 0) + 1;
    }
    const counts = Object.values(demandBySlot);
    if (counts.length === 0) {
      return 0;
    }
    const sortedCounts = [...counts].sort((a, b) => a - b);
    const p25 = sortedCounts[Math.floor(sortedCounts.length * 0.25)] || 0;
    const p50 = sortedCounts[Math.floor(sortedCounts.length * 0.5)] || 0;
    const p75 = sortedCounts[Math.floor(sortedCounts.length * 0.75)] || 0;
    let updatedCount = 0;
    for (const [key, count11] of Object.entries(demandBySlot)) {
      const [day, hour] = key.split("-").map(Number);
      let demandLevel;
      if (count11 <= p25) demandLevel = DEMAND_LEVELS.low;
      else if (count11 <= p50) demandLevel = DEMAND_LEVELS.medium;
      else if (count11 <= p75) demandLevel = DEMAND_LEVELS.high;
      else demandLevel = DEMAND_LEVELS.peak;
      const totalSlots = 4;
      const utilizationPercent = Math.min(100, Math.round(count11 / totalSlots * 100));
      await db.insert(timeSlotDemand).values({
        salonId,
        dayOfWeek: day,
        hourOfDay: hour,
        demandLevel,
        bookingCount30d: count11,
        avgUtilizationPercent: utilizationPercent,
        generatedAt: /* @__PURE__ */ new Date()
      }).onConflictDoUpdate({
        target: [timeSlotDemand.salonId, timeSlotDemand.dayOfWeek, timeSlotDemand.hourOfDay],
        set: {
          demandLevel,
          bookingCount30d: count11,
          avgUtilizationPercent: utilizationPercent,
          generatedAt: /* @__PURE__ */ new Date()
        }
      });
      updatedCount++;
    }
    return updatedCount;
  }
  async updateDemandPatternsForAllSalons() {
    const activeSalons = await db.select({ id: salons.id }).from(salons).where(eq45(salons.isActive, 1)).limit(1e3);
    let totalUpdated = 0;
    for (const salon of activeSalons) {
      try {
        const updated = await this.updateDemandPatterns(salon.id);
        totalUpdated += updated;
      } catch (error) {
        console.error(`Error updating demand for salon ${salon.id}:`, error);
      }
    }
    return totalUpdated;
  }
  async getActiveRulesForSalon(salonId) {
    const now = /* @__PURE__ */ new Date();
    return db.select().from(dynamicPricingRules).where(and43(
      eq45(dynamicPricingRules.salonId, salonId),
      eq45(dynamicPricingRules.isActive, 1),
      or16(
        isNull7(dynamicPricingRules.validFrom),
        lte17(dynamicPricingRules.validFrom, now)
      ),
      or16(
        isNull7(dynamicPricingRules.validUntil),
        gte21(dynamicPricingRules.validUntil, now)
      )
    )).orderBy(desc33(dynamicPricingRules.priority));
  }
  findMatchingRule(rules, dayOfWeek, hour, serviceId) {
    for (const rule of rules) {
      if (rule.dayOfWeek !== null && rule.dayOfWeek !== dayOfWeek) {
        continue;
      }
      if (hour < rule.startHour || hour >= rule.endHour) {
        continue;
      }
      if (serviceId && rule.applicableServiceIds && rule.applicableServiceIds.length > 0) {
        if (!rule.applicableServiceIds.includes(serviceId)) {
          continue;
        }
      }
      return rule;
    }
    return null;
  }
  calculateAdjustedPrice(basePrice, rules, dayOfWeek, hour, serviceId) {
    const matchingRule = this.findMatchingRule(rules, dayOfWeek, hour, serviceId);
    if (!matchingRule) {
      return {
        adjustedPrice: basePrice,
        discountPercent: 0,
        discountLabel: null,
        appliedRuleId: null
      };
    }
    if (matchingRule.minBookingValuePaisa && basePrice < matchingRule.minBookingValuePaisa) {
      return {
        adjustedPrice: basePrice,
        discountPercent: 0,
        discountLabel: null,
        appliedRuleId: null
      };
    }
    let adjustmentAmount;
    if (matchingRule.adjustmentType === "percentage") {
      adjustmentAmount = Math.round(basePrice * matchingRule.adjustmentValue / 100);
    } else {
      adjustmentAmount = matchingRule.adjustmentValue;
    }
    if (adjustmentAmount < 0 && matchingRule.maxDiscountPaisa) {
      adjustmentAmount = Math.max(adjustmentAmount, -matchingRule.maxDiscountPaisa);
    }
    const adjustedPrice = Math.max(0, basePrice + adjustmentAmount);
    const discountPercent = adjustmentAmount < 0 ? Math.round(Math.abs(adjustmentAmount) / basePrice * 100) : 0;
    let discountLabel = null;
    if (adjustmentAmount < 0) {
      switch (matchingRule.ruleType) {
        case "off_peak_discount":
          discountLabel = "Off-Peak Discount";
          break;
        case "happy_hour":
          discountLabel = "Happy Hour Deal";
          break;
        case "seasonal":
          discountLabel = "Seasonal Offer";
          break;
        default:
          discountLabel = `${Math.abs(matchingRule.adjustmentValue)}% off`;
      }
    } else if (adjustmentAmount > 0) {
      discountLabel = "Peak Pricing";
    }
    return {
      adjustedPrice,
      discountPercent,
      discountLabel,
      appliedRuleId: matchingRule.id,
      appliedRuleName: matchingRule.name
    };
  }
  async verifySalonOwnership(salonId, ownerId) {
    const salon = await db.select({ ownerId: salons.ownerId }).from(salons).where(eq45(salons.id, salonId)).limit(1);
    return salon.length > 0 && salon[0].ownerId === ownerId;
  }
  formatHour(hour) {
    const period = hour >= 12 ? "PM" : "AM";
    const displayHour = hour > 12 ? hour - 12 : hour === 0 ? 12 : hour;
    return `${displayHour}:00 ${period}`;
  }
};
var dynamicPricingService = new DynamicPricingService();

// server/routes/dynamicPricing.routes.ts
init_schema();
import { z as z19 } from "zod";

// server/jobs/dynamicPricingJobs.ts
import cron3 from "node-cron";
var isProcessingDemand = false;
var lastDemandUpdateTime = null;
var lastDemandUpdateStatus = null;
var demandUpdateMetrics = {
  totalRuns: 0,
  successfulRuns: 0,
  failedRuns: 0,
  skippedRuns: 0,
  lastEntriesUpdated: 0,
  averageDurationMs: 0
};
function getDynamicPricingJobHealth() {
  return {
    lastRunTime: lastDemandUpdateTime?.toISOString() || null,
    lastRunStatus: lastDemandUpdateStatus,
    isCurrentlyRunning: isProcessingDemand,
    metrics: demandUpdateMetrics,
    nextScheduledRuns: {
      dailyUpdate: "02:00 IST daily",
      weeklyRefresh: "14:00 IST Sundays"
    }
  };
}
async function updateAllSalonsDemandPatterns() {
  const startTime = Date.now();
  demandUpdateMetrics.totalRuns++;
  if (isProcessingDemand) {
    console.log("[Dynamic Pricing Job] Demand update already in progress, skipping...");
    lastDemandUpdateStatus = "skipped";
    demandUpdateMetrics.skippedRuns++;
    return;
  }
  isProcessingDemand = true;
  lastDemandUpdateTime = /* @__PURE__ */ new Date();
  console.log(`[Dynamic Pricing Job] Starting demand pattern update at ${lastDemandUpdateTime.toISOString()}`);
  try {
    const updatedCount = await dynamicPricingService.updateDemandPatternsForAllSalons();
    const durationMs = Date.now() - startTime;
    lastDemandUpdateStatus = "success";
    demandUpdateMetrics.successfulRuns++;
    demandUpdateMetrics.lastEntriesUpdated = updatedCount;
    demandUpdateMetrics.averageDurationMs = Math.round(
      (demandUpdateMetrics.averageDurationMs * (demandUpdateMetrics.successfulRuns - 1) + durationMs) / demandUpdateMetrics.successfulRuns
    );
    console.log(`[Dynamic Pricing Job] SUCCESS: Updated ${updatedCount} demand entries in ${durationMs}ms`);
  } catch (error) {
    const durationMs = Date.now() - startTime;
    lastDemandUpdateStatus = "error";
    demandUpdateMetrics.failedRuns++;
    console.error(`[Dynamic Pricing Job] ERROR: Failed after ${durationMs}ms:`, error);
  } finally {
    isProcessingDemand = false;
  }
}
function startDynamicPricingJobs() {
  console.log("[Dynamic Pricing Jobs] Starting background jobs...");
  cron3.schedule("0 2 * * *", async () => {
    console.log("[Dynamic Pricing Job] Daily demand update triggered");
    await updateAllSalonsDemandPatterns();
  }, { timezone: "Asia/Kolkata" });
  cron3.schedule("0 14 * * 0", async () => {
    console.log("[Dynamic Pricing Job] Weekly demand pattern refresh triggered");
    await updateAllSalonsDemandPatterns();
  }, { timezone: "Asia/Kolkata" });
  console.log("[Dynamic Pricing Jobs] Background jobs scheduled:");
  console.log("  - Demand pattern update: daily at 2 AM IST");
  console.log("  - Weekly refresh: Sundays at 2 PM IST");
}

// server/routes/dynamicPricing.routes.ts
var router28 = Router27();
router28.get("/health", async (req, res) => {
  try {
    const jobHealth = getDynamicPricingJobHealth();
    return res.json({
      status: "healthy",
      service: "dynamic-pricing",
      jobs: jobHealth,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  } catch (error) {
    console.error("Error fetching dynamic pricing health:", error);
    return res.status(500).json({
      status: "unhealthy",
      service: "dynamic-pricing",
      error: "Failed to fetch health status"
    });
  }
});
router28.get("/salons/:salonId/demand-heatmap", async (req, res) => {
  try {
    const { salonId } = req.params;
    if (!salonId) {
      return res.status(400).json({ error: "Salon ID is required" });
    }
    const result = await dynamicPricingService.getDemandHeatmap(salonId);
    return res.json(result);
  } catch (error) {
    console.error("Error fetching demand heatmap:", error);
    return res.status(500).json({ error: "Failed to fetch demand heatmap" });
  }
});
router28.get("/salons/:salonId/slots/:date/pricing", async (req, res) => {
  try {
    const { salonId, date } = req.params;
    const { serviceId } = req.query;
    if (!salonId || !date) {
      return res.status(400).json({ error: "Salon ID and date are required" });
    }
    if (!/^\d{4}-\d{2}-\d{2}$/.test(date)) {
      return res.status(400).json({ error: "Date must be in YYYY-MM-DD format" });
    }
    const result = await dynamicPricingService.getSlotsPricingForDate(
      salonId,
      date,
      serviceId
    );
    return res.json(result);
  } catch (error) {
    console.error("Error fetching slot pricing:", error);
    return res.status(500).json({ error: "Failed to fetch slot pricing" });
  }
});
router28.post("/salons/:salonId/pricing-rules", authenticateToken, async (req, res) => {
  try {
    const { salonId } = req.params;
    const userId = req.user?.id;
    if (!userId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const validatedInput = createPricingRuleSchema.parse(req.body);
    const result = await dynamicPricingService.createPricingRule(salonId, userId, validatedInput);
    if (!result.success) {
      return res.status(400).json({ error: result.error });
    }
    return res.status(201).json(result.rule);
  } catch (error) {
    if (error instanceof z19.ZodError) {
      return res.status(400).json({ error: "Invalid input", details: error.errors });
    }
    console.error("Error creating pricing rule:", error);
    return res.status(500).json({ error: "Failed to create pricing rule" });
  }
});
router28.get("/salons/:salonId/pricing-rules", authenticateToken, async (req, res) => {
  try {
    const { salonId } = req.params;
    const userId = req.user?.id;
    if (!userId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const result = await dynamicPricingService.getPricingRules(salonId, userId);
    if (!result.success) {
      return res.status(403).json({ error: result.error });
    }
    return res.json({ rules: result.rules });
  } catch (error) {
    console.error("Error fetching pricing rules:", error);
    return res.status(500).json({ error: "Failed to fetch pricing rules" });
  }
});
router28.put("/salons/:salonId/pricing-rules/:ruleId", authenticateToken, async (req, res) => {
  try {
    const { salonId, ruleId } = req.params;
    const userId = req.user?.id;
    if (!userId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const validatedInput = updatePricingRuleSchema.parse(req.body);
    const result = await dynamicPricingService.updatePricingRule(salonId, ruleId, userId, validatedInput);
    if (!result.success) {
      return res.status(400).json({ error: result.error });
    }
    return res.json(result.rule);
  } catch (error) {
    if (error instanceof z19.ZodError) {
      return res.status(400).json({ error: "Invalid input", details: error.errors });
    }
    console.error("Error updating pricing rule:", error);
    return res.status(500).json({ error: "Failed to update pricing rule" });
  }
});
router28.delete("/salons/:salonId/pricing-rules/:ruleId", authenticateToken, async (req, res) => {
  try {
    const { salonId, ruleId } = req.params;
    const userId = req.user?.id;
    if (!userId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const result = await dynamicPricingService.deletePricingRule(salonId, ruleId, userId);
    if (!result.success) {
      return res.status(400).json({ error: result.error });
    }
    return res.json({ message: "Pricing rule deleted successfully" });
  } catch (error) {
    console.error("Error deleting pricing rule:", error);
    return res.status(500).json({ error: "Failed to delete pricing rule" });
  }
});
router28.get("/salons/:salonId/pricing-analytics", authenticateToken, async (req, res) => {
  try {
    const { salonId } = req.params;
    const userId = req.user?.id;
    if (!userId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const result = await dynamicPricingService.getPricingAnalytics(salonId, userId);
    if (!result.success) {
      return res.status(403).json({ error: result.error });
    }
    return res.json(result.analytics);
  } catch (error) {
    console.error("Error fetching pricing analytics:", error);
    return res.status(500).json({ error: "Failed to fetch pricing analytics" });
  }
});
router28.post("/salons/:salonId/demand-overrides", authenticateToken, async (req, res) => {
  try {
    const { salonId } = req.params;
    const userId = req.user?.id;
    if (!userId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const validatedInput = createDemandOverrideSchema.parse(req.body);
    const result = await dynamicPricingService.createDemandOverride(salonId, userId, validatedInput);
    if (!result.success) {
      return res.status(400).json({ error: result.error });
    }
    return res.status(201).json(result.override);
  } catch (error) {
    if (error instanceof z19.ZodError) {
      return res.status(400).json({ error: "Invalid input", details: error.errors });
    }
    console.error("Error creating demand override:", error);
    return res.status(500).json({ error: "Failed to create demand override" });
  }
});
router28.get("/salons/:salonId/demand-overrides", async (req, res) => {
  try {
    const { salonId } = req.params;
    if (!salonId) {
      return res.status(400).json({ error: "Salon ID is required" });
    }
    const overrides = await dynamicPricingService.getDemandOverrides(salonId);
    return res.json({ overrides });
  } catch (error) {
    console.error("Error fetching demand overrides:", error);
    return res.status(500).json({ error: "Failed to fetch demand overrides" });
  }
});
router28.delete("/salons/:salonId/demand-overrides/:overrideId", authenticateToken, async (req, res) => {
  try {
    const { salonId, overrideId } = req.params;
    const userId = req.user?.id;
    if (!userId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const result = await dynamicPricingService.deleteDemandOverride(salonId, overrideId, userId);
    if (!result.success) {
      return res.status(400).json({ error: result.error });
    }
    return res.json({ message: "Demand override deleted successfully" });
  } catch (error) {
    console.error("Error deleting demand override:", error);
    return res.status(500).json({ error: "Failed to delete demand override" });
  }
});
router28.post("/salons/:salonId/calculate-price", async (req, res) => {
  try {
    const { salonId } = req.params;
    const { serviceId, bookingDate, bookingTime, basePrice } = req.body;
    if (!serviceId || !bookingDate || !bookingTime || basePrice === void 0) {
      return res.status(400).json({
        error: "serviceId, bookingDate, bookingTime, and basePrice are required"
      });
    }
    const result = await dynamicPricingService.calculatePriceForBooking(
      salonId,
      serviceId,
      bookingDate,
      bookingTime,
      basePrice
    );
    return res.json(result);
  } catch (error) {
    console.error("Error calculating price:", error);
    return res.status(500).json({ error: "Failed to calculate price" });
  }
});
var dynamicPricing_routes_default = router28;
function registerMobileDynamicPricingRoutes(app2, authenticateMobile) {
  app2.get("/api/mobile/salons/:salonId/demand-heatmap", async (req, res) => {
    try {
      const { salonId } = req.params;
      const result = await dynamicPricingService.getDemandHeatmap(salonId);
      return res.json(result);
    } catch (error) {
      console.error("Error fetching demand heatmap:", error);
      return res.status(500).json({ error: "Failed to fetch demand heatmap" });
    }
  });
  app2.get("/api/mobile/salons/:salonId/slots/:date/pricing", async (req, res) => {
    try {
      const { salonId, date } = req.params;
      const { serviceId } = req.query;
      if (!/^\d{4}-\d{2}-\d{2}$/.test(date)) {
        return res.status(400).json({ error: "Date must be in YYYY-MM-DD format" });
      }
      const result = await dynamicPricingService.getSlotsPricingForDate(
        salonId,
        date,
        serviceId
      );
      return res.json(result);
    } catch (error) {
      console.error("Error fetching slot pricing:", error);
      return res.status(500).json({ error: "Failed to fetch slot pricing" });
    }
  });
  app2.post("/api/mobile/salons/:salonId/calculate-price", async (req, res) => {
    try {
      const { salonId } = req.params;
      const { serviceId, bookingDate, bookingTime, basePrice } = req.body;
      if (!serviceId || !bookingDate || !bookingTime || basePrice === void 0) {
        return res.status(400).json({
          error: "serviceId, bookingDate, bookingTime, and basePrice are required"
        });
      }
      const result = await dynamicPricingService.calculatePriceForBooking(
        salonId,
        serviceId,
        bookingDate,
        bookingTime,
        basePrice
      );
      return res.json(result);
    } catch (error) {
      console.error("Error calculating price:", error);
      return res.status(500).json({ error: "Failed to calculate price" });
    }
  });
  app2.get("/api/mobile/salons/:salonId/demand-overrides", async (req, res) => {
    try {
      const { salonId } = req.params;
      const overrides = await dynamicPricingService.getDemandOverrides(salonId);
      return res.json({ overrides });
    } catch (error) {
      console.error("Error fetching demand overrides:", error);
      return res.status(500).json({ error: "Failed to fetch demand overrides" });
    }
  });
  console.log("\u2705 Mobile Dynamic Pricing routes registered");
}

// server/jobs/serviceBundleJobs.ts
import cron4 from "node-cron";

// server/services/serviceBundle.service.ts
init_db();
init_schema();
import { eq as eq46, and as and44, desc as desc34, asc as asc9, lte as lte18, sql as sql38, inArray as inArray17 } from "drizzle-orm";
function normalizeServiceEntries(input) {
  if (input.services && input.services.length > 0) {
    return input.services;
  }
  if (input.serviceIds && input.serviceIds.length > 0) {
    return input.serviceIds.map((serviceId) => ({ serviceId, quantity: 1 }));
  }
  return [];
}
var IST_TIMEZONE = "Asia/Kolkata";
function getISTDate() {
  const formatter = new Intl.DateTimeFormat("en-CA", {
    timeZone: IST_TIMEZONE,
    year: "numeric",
    month: "2-digit",
    day: "2-digit"
  });
  return formatter.format(/* @__PURE__ */ new Date());
}
function calculateDiscountPercentage(regular, discounted) {
  if (regular <= 0) return 0;
  return Math.round((regular - discounted) / regular * 100);
}
var ServiceBundleService = class {
  async createPackage(salonId, input) {
    try {
      const serviceEntries = normalizeServiceEntries(input);
      const totalServiceCount = serviceEntries.reduce((sum4, e) => sum4 + e.quantity, 0);
      if (totalServiceCount < 2) {
        return { success: false, error: "Package must contain at least 2 service instances" };
      }
      const uniqueServiceIds = [...new Set(serviceEntries.map((e) => e.serviceId))];
      const salonServices = await db.query.services.findMany({
        where: and44(
          eq46(services.salonId, salonId),
          eq46(services.isActive, 1),
          inArray17(services.id, uniqueServiceIds)
        )
      });
      if (salonServices.length !== uniqueServiceIds.length) {
        const foundIds = new Set(salonServices.map((s) => s.id));
        const missingIds = uniqueServiceIds.filter((id) => !foundIds.has(id));
        return {
          success: false,
          error: `Some services not found or inactive: ${missingIds.join(", ")}`
        };
      }
      const serviceMap = new Map(salonServices.map((s) => [s.id, s]));
      let totalDurationMinutes = 0;
      let regularPriceInPaisa = 0;
      for (const entry of serviceEntries) {
        const service = serviceMap.get(entry.serviceId);
        if (service) {
          totalDurationMinutes += service.durationMinutes * entry.quantity;
          regularPriceInPaisa += service.priceInPaisa * entry.quantity;
        }
      }
      if (input.packagePriceInPaisa >= regularPriceInPaisa) {
        return {
          success: false,
          error: "Package price must be less than sum of individual service prices"
        };
      }
      const discountPercentage = calculateDiscountPercentage(regularPriceInPaisa, input.packagePriceInPaisa);
      if (discountPercentage > 50) {
        return {
          success: false,
          error: "Discount cannot exceed 50%"
        };
      }
      const [newPackage] = await db.insert(servicePackages).values({
        salonId,
        name: input.name,
        description: input.description || null,
        totalDurationMinutes,
        packagePriceInPaisa: input.packagePriceInPaisa,
        regularPriceInPaisa,
        discountPercentage,
        category: input.category || null,
        imageUrl: input.imageUrl || null,
        gender: input.gender || null,
        maxBookingsPerDay: input.maxBookingsPerDay || null,
        validFrom: input.validFrom || null,
        validUntil: input.validUntil || null,
        minAdvanceBookingHours: input.minAdvanceBookingHours || null,
        availableDays: input.availableDays || null,
        availableTimeStart: input.availableTimeStart || null,
        availableTimeEnd: input.availableTimeEnd || null,
        isFeatured: input.isFeatured ? 1 : 0,
        sortOrder: input.sortOrder || 0
      }).returning();
      const packageServiceEntries = serviceEntries.map((entry, index2) => ({
        packageId: newPackage.id,
        serviceId: entry.serviceId,
        salonId,
        sequenceOrder: index2 + 1,
        quantity: entry.quantity
      }));
      await db.insert(packageServices).values(packageServiceEntries);
      return { success: true, package: newPackage };
    } catch (error) {
      console.error("Error creating package:", error);
      return { success: false, error: "Failed to create package" };
    }
  }
  async updatePackage(packageId, salonId, input) {
    try {
      const existingPackage = await db.query.servicePackages.findFirst({
        where: and44(
          eq46(servicePackages.id, packageId),
          eq46(servicePackages.salonId, salonId)
        )
      });
      if (!existingPackage) {
        return { success: false, error: "Package not found" };
      }
      let totalDurationMinutes = existingPackage.totalDurationMinutes;
      let regularPriceInPaisa = existingPackage.regularPriceInPaisa;
      let discountPercentage = existingPackage.discountPercentage;
      const serviceEntries = normalizeServiceEntries(input);
      const hasServiceUpdate = serviceEntries.length > 0;
      if (hasServiceUpdate) {
        const totalServiceCount = serviceEntries.reduce((sum4, e) => sum4 + e.quantity, 0);
        if (totalServiceCount < 2) {
          return { success: false, error: "Package must contain at least 2 service instances" };
        }
        const uniqueServiceIds = [...new Set(serviceEntries.map((e) => e.serviceId))];
        const salonServices = await db.query.services.findMany({
          where: and44(
            eq46(services.salonId, salonId),
            eq46(services.isActive, 1),
            inArray17(services.id, uniqueServiceIds)
          )
        });
        if (salonServices.length !== uniqueServiceIds.length) {
          return { success: false, error: "Some services not found or inactive" };
        }
        const serviceMap = new Map(salonServices.map((s) => [s.id, s]));
        totalDurationMinutes = 0;
        regularPriceInPaisa = 0;
        for (const entry of serviceEntries) {
          const service = serviceMap.get(entry.serviceId);
          if (service) {
            totalDurationMinutes += service.durationMinutes * entry.quantity;
            regularPriceInPaisa += service.priceInPaisa * entry.quantity;
          }
        }
        await db.delete(packageServices).where(eq46(packageServices.packageId, packageId));
        const packageServiceEntries = serviceEntries.map((entry, index2) => ({
          packageId,
          serviceId: entry.serviceId,
          salonId,
          sequenceOrder: index2 + 1,
          quantity: entry.quantity
        }));
        await db.insert(packageServices).values(packageServiceEntries);
      }
      const newPackagePrice = input.packagePriceInPaisa ?? existingPackage.packagePriceInPaisa;
      if (newPackagePrice >= regularPriceInPaisa) {
        return { success: false, error: "Package price must be less than sum of individual service prices" };
      }
      discountPercentage = calculateDiscountPercentage(regularPriceInPaisa, newPackagePrice);
      if (discountPercentage > 50) {
        return { success: false, error: "Discount cannot exceed 50%" };
      }
      const [updated] = await db.update(servicePackages).set({
        name: input.name ?? existingPackage.name,
        description: input.description !== void 0 ? input.description : existingPackage.description,
        totalDurationMinutes,
        packagePriceInPaisa: newPackagePrice,
        regularPriceInPaisa,
        discountPercentage,
        category: input.category !== void 0 ? input.category : existingPackage.category,
        imageUrl: input.imageUrl !== void 0 ? input.imageUrl : existingPackage.imageUrl,
        gender: input.gender !== void 0 ? input.gender : existingPackage.gender,
        maxBookingsPerDay: input.maxBookingsPerDay !== void 0 ? input.maxBookingsPerDay : existingPackage.maxBookingsPerDay,
        validFrom: input.validFrom !== void 0 ? input.validFrom : existingPackage.validFrom,
        validUntil: input.validUntil !== void 0 ? input.validUntil : existingPackage.validUntil,
        minAdvanceBookingHours: input.minAdvanceBookingHours !== void 0 ? input.minAdvanceBookingHours : existingPackage.minAdvanceBookingHours,
        availableDays: input.availableDays !== void 0 ? input.availableDays : existingPackage.availableDays,
        availableTimeStart: input.availableTimeStart !== void 0 ? input.availableTimeStart : existingPackage.availableTimeStart,
        availableTimeEnd: input.availableTimeEnd !== void 0 ? input.availableTimeEnd : existingPackage.availableTimeEnd,
        isFeatured: input.isFeatured !== void 0 ? input.isFeatured ? 1 : 0 : existingPackage.isFeatured,
        sortOrder: input.sortOrder !== void 0 ? input.sortOrder : existingPackage.sortOrder,
        isActive: input.isActive !== void 0 ? input.isActive ? 1 : 0 : existingPackage.isActive,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq46(servicePackages.id, packageId)).returning();
      return { success: true, package: updated };
    } catch (error) {
      console.error("Error updating package:", error);
      return { success: false, error: "Failed to update package" };
    }
  }
  async deletePackage(packageId, salonId) {
    try {
      const existingPackage = await db.query.servicePackages.findFirst({
        where: and44(
          eq46(servicePackages.id, packageId),
          eq46(servicePackages.salonId, salonId)
        )
      });
      if (!existingPackage) {
        return { success: false, error: "Package not found" };
      }
      await db.update(servicePackages).set({ isActive: 0, updatedAt: /* @__PURE__ */ new Date() }).where(eq46(servicePackages.id, packageId));
      return { success: true };
    } catch (error) {
      console.error("Error deleting package:", error);
      return { success: false, error: "Failed to delete package" };
    }
  }
  async getPackageById(packageId) {
    try {
      const pkg = await db.query.servicePackages.findFirst({
        where: eq46(servicePackages.id, packageId),
        with: {
          salon: {
            columns: { id: true, name: true }
          },
          packageServices: {
            with: {
              service: true
            },
            orderBy: [asc9(packageServices.sequenceOrder)]
          }
        }
      });
      if (!pkg) return null;
      return {
        ...pkg,
        services: pkg.packageServices.map((ps) => ({
          ...ps.service,
          sequenceOrder: ps.sequenceOrder,
          quantity: ps.quantity
        })),
        savings: pkg.regularPriceInPaisa - pkg.packagePriceInPaisa,
        savingsFormatted: this.formatCurrency(pkg.regularPriceInPaisa - pkg.packagePriceInPaisa)
      };
    } catch (error) {
      console.error("Error fetching package:", error);
      return null;
    }
  }
  async getPackagesForSalon(salonId, options = {}) {
    try {
      const allPackages = await db.query.servicePackages.findMany({
        where: eq46(servicePackages.salonId, salonId),
        with: {
          packageServices: {
            with: {
              service: true
            },
            orderBy: [asc9(packageServices.sequenceOrder)]
          }
        },
        orderBy: [asc9(servicePackages.sortOrder), desc34(servicePackages.createdAt)]
      });
      const now = /* @__PURE__ */ new Date();
      const today = getISTDate();
      return allPackages.filter((pkg) => {
        if (options.activeOnly !== false && pkg.isActive !== 1) return false;
        if (options.category && pkg.category !== options.category) return false;
        if (options.gender && pkg.gender && pkg.gender !== options.gender) return false;
        if (options.featured && pkg.isFeatured !== 1) return false;
        if (!options.includeExpired) {
          if (pkg.validFrom && new Date(pkg.validFrom) > now) return false;
          if (pkg.validUntil && new Date(pkg.validUntil) < now) return false;
        }
        return true;
      }).map((pkg) => ({
        ...pkg,
        services: pkg.packageServices.map((ps) => ({
          ...ps.service,
          sequenceOrder: ps.sequenceOrder,
          quantity: ps.quantity
        })),
        savings: pkg.regularPriceInPaisa - pkg.packagePriceInPaisa,
        savingsFormatted: this.formatCurrency(pkg.regularPriceInPaisa - pkg.packagePriceInPaisa)
      }));
    } catch (error) {
      console.error("Error fetching packages:", error);
      return [];
    }
  }
  async checkPackageAvailability(packageId, date, time) {
    try {
      const pkg = await db.query.servicePackages.findFirst({
        where: eq46(servicePackages.id, packageId)
      });
      if (!pkg) {
        return { isAvailable: false, reason: "Package not found" };
      }
      if (pkg.isActive !== 1) {
        return { isAvailable: false, reason: "Package is no longer available" };
      }
      const now = /* @__PURE__ */ new Date();
      if (pkg.validFrom && new Date(pkg.validFrom) > now) {
        return { isAvailable: false, reason: "Package is not yet available" };
      }
      if (pkg.validUntil && new Date(pkg.validUntil) < now) {
        return { isAvailable: false, reason: "Package has expired" };
      }
      if (pkg.availableDays && pkg.availableDays.length > 0) {
        const bookingDate = new Date(date);
        const dayOfWeek = bookingDate.toLocaleDateString("en-US", { weekday: "short" });
        if (!pkg.availableDays.includes(dayOfWeek)) {
          return {
            isAvailable: false,
            reason: `Package is only available on ${pkg.availableDays.join(", ")}`
          };
        }
      }
      if (pkg.availableTimeStart && pkg.availableTimeEnd) {
        if (time < pkg.availableTimeStart || time > pkg.availableTimeEnd) {
          return {
            isAvailable: false,
            reason: `Package is only available between ${pkg.availableTimeStart} and ${pkg.availableTimeEnd}`
          };
        }
      }
      if (pkg.minAdvanceBookingHours) {
        const bookingDateTime = /* @__PURE__ */ new Date(`${date}T${time}:00`);
        const hoursUntilBooking = (bookingDateTime.getTime() - now.getTime()) / (1e3 * 60 * 60);
        if (hoursUntilBooking < pkg.minAdvanceBookingHours) {
          return {
            isAvailable: false,
            reason: `Package requires ${pkg.minAdvanceBookingHours} hours advance booking`
          };
        }
      }
      if (pkg.maxBookingsPerDay) {
        const dailyBookings = await db.query.packageBookings.findMany({
          where: eq46(packageBookings.packageId, packageId),
          with: {
            booking: true
          }
        });
        const todayBookings = dailyBookings.filter(
          (pb) => pb.booking?.bookingDate === date && pb.booking?.status !== "cancelled"
        ).length;
        if (todayBookings >= pkg.maxBookingsPerDay) {
          return {
            isAvailable: false,
            reason: "Maximum daily bookings for this package reached"
          };
        }
        return {
          isAvailable: true,
          dailyBookingsRemaining: pkg.maxBookingsPerDay - todayBookings
        };
      }
      return { isAvailable: true };
    } catch (error) {
      console.error("Error checking package availability:", error);
      return { isAvailable: false, reason: "Failed to check availability" };
    }
  }
  async getPackageAnalytics(salonId) {
    try {
      const packages = await db.query.servicePackages.findMany({
        where: eq46(servicePackages.salonId, salonId),
        with: {
          packageBookings: {
            with: {
              booking: true
            }
          }
        }
      });
      let totalRevenue = 0;
      let totalBookings = 0;
      let totalSavingsProvided = 0;
      const byPackage = packages.map((pkg) => {
        const completedBookings = pkg.packageBookings.filter(
          (pb) => pb.booking?.status === "completed"
        );
        const packageRevenue = completedBookings.reduce(
          (sum4, pb) => sum4 + pb.packagePriceAtBooking,
          0
        );
        const packageSavings = completedBookings.reduce(
          (sum4, pb) => sum4 + pb.savingsPaisa,
          0
        );
        totalRevenue += packageRevenue;
        totalBookings += completedBookings.length;
        totalSavingsProvided += packageSavings;
        return {
          id: pkg.id,
          name: pkg.name,
          category: pkg.category,
          bookings: completedBookings.length,
          totalBookings: pkg.bookingCount,
          revenue: packageRevenue,
          revenueFormatted: this.formatCurrency(packageRevenue),
          savingsProvided: packageSavings,
          isFeatured: pkg.isFeatured === 1,
          isActive: pkg.isActive === 1
        };
      });
      const topPackage = byPackage.reduce(
        (top, pkg) => pkg.bookings > (top?.bookings || 0) ? pkg : top,
        null
      );
      return {
        summary: {
          totalPackageRevenue: totalRevenue,
          totalPackageRevenueFormatted: this.formatCurrency(totalRevenue),
          totalPackageBookings: totalBookings,
          averagePackageValue: totalBookings > 0 ? Math.round(totalRevenue / totalBookings) : 0,
          topPackage: topPackage ? { name: topPackage.name, bookings: topPackage.bookings } : null,
          savingsProvided: totalSavingsProvided,
          savingsProvidedFormatted: this.formatCurrency(totalSavingsProvided)
        },
        byPackage: byPackage.sort((a, b) => b.bookings - a.bookings),
        categories: SERVICE_PACKAGE_CATEGORIES
      };
    } catch (error) {
      console.error("Error fetching package analytics:", error);
      return {
        summary: {
          totalPackageRevenue: 0,
          totalPackageBookings: 0,
          averagePackageValue: 0,
          topPackage: null,
          savingsProvided: 0
        },
        byPackage: [],
        categories: SERVICE_PACKAGE_CATEGORIES
      };
    }
  }
  async bookPackage(input) {
    try {
      const pkg = await this.getPackageById(input.packageId);
      if (!pkg) {
        return { success: false, error: "Package not found" };
      }
      if (pkg.isActive !== 1) {
        return { success: false, error: "Package is not active" };
      }
      if (pkg.salonId !== input.salonId) {
        return { success: false, error: "Package does not belong to this salon" };
      }
      const availability = await this.checkPackageAvailability(input.packageId, input.date, input.time);
      if (!availability.isAvailable) {
        return { success: false, error: availability.reason || "Package not available for this time" };
      }
      if (input.staffId) {
        const staffAvailable = await this.checkStaffAvailability(
          input.staffId,
          input.date,
          input.time,
          pkg.totalDurationMinutes
        );
        if (!staffAvailable.isAvailable) {
          return { success: false, error: staffAvailable.reason || "Staff not available for full package duration" };
        }
      }
      const salon = await db.query.salons.findFirst({
        where: eq46(salons.id, input.salonId)
      });
      const primaryService = pkg.services[0];
      if (!primaryService) {
        return { success: false, error: "Package has no services" };
      }
      const [newBooking] = await db.insert(bookings).values({
        salonId: input.salonId,
        serviceId: primaryService.id,
        staffId: input.staffId || null,
        userId: input.userId || null,
        packageId: input.packageId,
        customerName: input.customerName,
        customerEmail: input.customerEmail,
        customerPhone: input.customerPhone,
        salonName: salon?.name || null,
        bookingDate: input.date,
        bookingTime: input.time,
        status: "pending",
        totalAmountPaisa: pkg.packagePriceInPaisa,
        currency: "INR",
        paymentMethod: "pay_now",
        notes: input.notes || null,
        guestSessionId: input.guestSessionId || null,
        isPackageBooking: 1
      }).returning();
      const [newPackageBooking] = await db.insert(packageBookings).values({
        bookingId: newBooking.id,
        packageId: input.packageId,
        salonId: input.salonId,
        packagePriceAtBooking: pkg.packagePriceInPaisa,
        regularPriceAtBooking: pkg.regularPriceInPaisa,
        savingsPaisa: pkg.regularPriceInPaisa - pkg.packagePriceInPaisa
      }).returning();
      await this.incrementBookingCount(input.packageId);
      return {
        success: true,
        booking: newBooking,
        packageBooking: newPackageBooking
      };
    } catch (error) {
      console.error("Error booking package:", error);
      return { success: false, error: "Failed to book package" };
    }
  }
  async checkStaffAvailability(staffId, date, time, durationMinutes) {
    try {
      const staffMember = await db.query.staff.findFirst({
        where: eq46(staff.id, staffId)
      });
      if (!staffMember) {
        return { isAvailable: false, reason: "Staff member not found" };
      }
      if (staffMember.isActive !== 1) {
        return { isAvailable: false, reason: "Staff member is not active" };
      }
      const [hours, minutes] = time.split(":").map(Number);
      const startMinutes = hours * 60 + minutes;
      const endMinutes = startMinutes + durationMinutes;
      const existingBookings = await db.query.bookings.findMany({
        where: and44(
          eq46(bookings.staffId, staffId),
          eq46(bookings.bookingDate, date),
          inArray17(bookings.status, ["pending", "confirmed"])
        ),
        with: {
          service: true
        }
      });
      for (const booking of existingBookings) {
        const [bHours, bMinutes] = booking.bookingTime.split(":").map(Number);
        const bStartMinutes = bHours * 60 + bMinutes;
        const bEndMinutes = bStartMinutes + (booking.service?.durationMinutes || 30);
        if (startMinutes >= bStartMinutes && startMinutes < bEndMinutes || endMinutes > bStartMinutes && endMinutes <= bEndMinutes || startMinutes <= bStartMinutes && endMinutes >= bEndMinutes) {
          return {
            isAvailable: false,
            reason: `Staff has another booking from ${booking.bookingTime} that overlaps with this package duration`
          };
        }
      }
      return { isAvailable: true };
    } catch (error) {
      console.error("Error checking staff availability:", error);
      return { isAvailable: false, reason: "Failed to check staff availability" };
    }
  }
  async incrementBookingCount(packageId) {
    try {
      await db.update(servicePackages).set({
        bookingCount: sql38`${servicePackages.bookingCount} + 1`,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq46(servicePackages.id, packageId));
    } catch (error) {
      console.error("Error incrementing booking count:", error);
    }
  }
  async deactivatePackagesWithService(serviceId, salonId) {
    try {
      const affectedPackages = await db.query.packageServices.findMany({
        where: and44(
          eq46(packageServices.serviceId, serviceId),
          eq46(packageServices.salonId, salonId)
        )
      });
      const packageIds = [...new Set(affectedPackages.map((ps) => ps.packageId))];
      if (packageIds.length === 0) return 0;
      await db.update(servicePackages).set({ isActive: 0, updatedAt: /* @__PURE__ */ new Date() }).where(inArray17(servicePackages.id, packageIds));
      return packageIds.length;
    } catch (error) {
      console.error("Error deactivating packages:", error);
      return 0;
    }
  }
  async deactivateExpiredPackages() {
    try {
      const now = /* @__PURE__ */ new Date();
      const result = await db.update(servicePackages).set({ isActive: 0, updatedAt: now }).where(
        and44(
          eq46(servicePackages.isActive, 1),
          lte18(servicePackages.validUntil, now.toISOString())
        )
      ).returning();
      if (result.length > 0) {
        console.log(`[Service Bundles] Deactivated ${result.length} expired packages`);
      }
      return result.length;
    } catch (error) {
      console.error("Error deactivating expired packages:", error);
      return 0;
    }
  }
  formatCurrency(paisa) {
    const rupees = paisa / 100;
    return new Intl.NumberFormat("en-IN", {
      style: "currency",
      currency: "INR",
      minimumFractionDigits: 0,
      maximumFractionDigits: 0
    }).format(rupees);
  }
};
var serviceBundleService = new ServiceBundleService();

// server/jobs/serviceBundleJobs.ts
function startServiceBundleJobs() {
  console.log("[Service Bundle Jobs] Starting background jobs...");
  cron4.schedule("0 0 * * *", async () => {
    console.log("[Service Bundle Jobs] Running daily expired package cleanup...");
    try {
      const deactivatedCount = await serviceBundleService.deactivateExpiredPackages();
      console.log(`[Service Bundle Jobs] Deactivated ${deactivatedCount} expired packages`);
    } catch (error) {
      console.error("[Service Bundle Jobs] Error in expired package cleanup:", error);
    }
  }, {
    timezone: "Asia/Kolkata"
  });
  console.log("[Service Bundle Jobs] Background jobs scheduled:");
  console.log("  - Expired package cleanup: daily at midnight IST");
}

// server/jobs/departureAlertsJobs.ts
init_db();
init_schema();
import cron5 from "node-cron";
import { eq as eq51, and as and49, gt as gt5 } from "drizzle-orm";

// server/services/queueCalculator.service.ts
init_db();
init_schema();
import { eq as eq47, and as and45, gte as gte23, desc as desc35, asc as asc10, inArray as inArray18, sql as sql39 } from "drizzle-orm";
import { addMinutes as addMinutes2, differenceInMinutes as differenceInMinutes2, isAfter as isAfter3 } from "date-fns";
var IST_OFFSET_MINUTES2 = 330;
var QueueCalculatorService = class {
  getNowIST() {
    const now = /* @__PURE__ */ new Date();
    return new Date(now.getTime() + IST_OFFSET_MINUTES2 * 60 * 1e3);
  }
  getISTDate() {
    const formatter = new Intl.DateTimeFormat("en-CA", {
      timeZone: "Asia/Kolkata",
      year: "numeric",
      month: "2-digit",
      day: "2-digit"
    });
    return formatter.format(/* @__PURE__ */ new Date());
  }
  getISTTimeString() {
    const formatter = new Intl.DateTimeFormat("en-GB", {
      timeZone: "Asia/Kolkata",
      hour: "2-digit",
      minute: "2-digit",
      hour12: false
    });
    return formatter.format(/* @__PURE__ */ new Date());
  }
  parseTimeString(time) {
    const match = time.match(/^(\d{1,2}):(\d{2})$/);
    if (!match) return null;
    const hours = parseInt(match[1], 10);
    const minutes = parseInt(match[2], 10);
    if (hours < 0 || hours > 23 || minutes < 0 || minutes > 59) return null;
    return { hours, minutes };
  }
  addMinutesToTime(time, minutes) {
    const parsed = this.parseTimeString(time);
    if (!parsed) return time;
    const totalMinutes = parsed.hours * 60 + parsed.minutes + minutes;
    const newHours = Math.floor(totalMinutes / 60) % 24;
    const newMinutes = totalMinutes % 60;
    return `${newHours.toString().padStart(2, "0")}:${newMinutes.toString().padStart(2, "0")}`;
  }
  timeToMinutes(time) {
    const parsed = this.parseTimeString(time);
    if (!parsed) return 0;
    return parsed.hours * 60 + parsed.minutes;
  }
  async getStaffQueueStatus(staffId, date) {
    try {
      const targetDate = date || this.getISTDate();
      const staffData = await db.query.staff.findFirst({
        where: eq47(staff.id, staffId)
      });
      if (!staffData) {
        return null;
      }
      const currentJobCard = await db.query.jobCards.findFirst({
        where: and45(
          eq47(jobCards.assignedStaffId, staffId),
          eq47(jobCards.status, "in_service")
        ),
        orderBy: [desc35(jobCards.serviceStartAt)]
      });
      const currentTime = this.getISTTimeString();
      const upcomingBookings = await db.select({
        id: bookings.id,
        bookingTime: bookings.bookingTime,
        status: bookings.status,
        serviceDuration: services.durationMinutes
      }).from(bookings).leftJoin(services, eq47(bookings.serviceId, services.id)).where(and45(
        eq47(bookings.staffId, staffId),
        eq47(bookings.bookingDate, targetDate),
        inArray18(bookings.status, ["confirmed", "pending"]),
        gte23(bookings.bookingTime, currentTime)
      )).orderBy(asc10(bookings.bookingTime));
      const completedToday = await db.select({
        estimatedDuration: jobCardServices.estimatedDurationMinutes,
        actualDuration: jobCardServices.actualDurationMinutes
      }).from(jobCardServices).innerJoin(jobCards, eq47(jobCardServices.jobCardId, jobCards.id)).where(and45(
        eq47(jobCardServices.staffId, staffId),
        eq47(jobCardServices.status, "completed"),
        sql39`DATE(${jobCards.checkInAt}) = ${targetDate}`
      ));
      let totalOverrunPercent = 0;
      let completedCount = 0;
      for (const service of completedToday) {
        if (service.estimatedDuration && service.actualDuration && service.estimatedDuration > 0) {
          const overrun = (service.actualDuration - service.estimatedDuration) / service.estimatedDuration * 100;
          totalOverrunPercent += overrun;
          completedCount++;
        }
      }
      const avgOverrunPercent = completedCount > 0 ? totalOverrunPercent / completedCount : 0;
      let estimatedDelayMinutes = 0;
      let nextAvailableAt = null;
      if (currentJobCard && currentJobCard.serviceStartAt) {
        const expectedEndMinutes = currentJobCard.estimatedDurationMinutes || 30;
        const adjustedEnd = Math.ceil(expectedEndMinutes * (1 + avgOverrunPercent / 100));
        const expectedEndTime = addMinutes2(currentJobCard.serviceStartAt, adjustedEnd);
        const now = this.getNowIST();
        if (isAfter3(expectedEndTime, now)) {
          estimatedDelayMinutes = differenceInMinutes2(expectedEndTime, now);
          nextAvailableAt = expectedEndTime;
        }
      }
      let accumulatedDelay = estimatedDelayMinutes;
      for (const booking of upcomingBookings) {
        const duration = booking.serviceDuration || 30;
        const adjustedDuration = Math.ceil(duration * (1 + avgOverrunPercent / 100));
        accumulatedDelay += adjustedDuration - duration;
      }
      return {
        staffId,
        staffName: staffData.name,
        currentStatus: currentJobCard ? "busy" : "available",
        currentJobCardId: currentJobCard?.id || null,
        currentCustomerName: currentJobCard?.customerName || null,
        appointmentsAhead: upcomingBookings.length,
        estimatedDelayMinutes: Math.max(0, Math.round(accumulatedDelay)),
        nextAvailableAt,
        lastServiceEndAt: null,
        avgServiceOverrunPercent: Math.round(avgOverrunPercent * 100) / 100
      };
    } catch (error) {
      console.error("Error calculating staff queue status:", error);
      return null;
    }
  }
  async getSalonQueueStatus(salonId, date) {
    try {
      const targetDate = date || this.getISTDate();
      const salonStaff = await db.select({ id: staff.id, name: staff.name }).from(staff).where(and45(
        eq47(staff.salonId, salonId),
        eq47(staff.isActive, 1)
      ));
      if (salonStaff.length === 0) {
        return null;
      }
      const staffStatuses = [];
      for (const s of salonStaff) {
        const status = await this.getStaffQueueStatus(s.id, targetDate);
        if (status) {
          staffStatuses.push(status);
        }
      }
      const avgDelay = staffStatuses.length > 0 ? staffStatuses.reduce((sum4, s) => sum4 + s.estimatedDelayMinutes, 0) / staffStatuses.length : 0;
      let overallStatus = "on_time";
      if (avgDelay >= 20) {
        overallStatus = "running_behind";
      } else if (avgDelay >= 10) {
        overallStatus = "slight_delay";
      }
      return {
        salonId,
        date: targetDate,
        staff: staffStatuses,
        overallStatus,
        avgDelayMinutes: Math.round(avgDelay)
      };
    } catch (error) {
      console.error("Error getting salon queue status:", error);
      return null;
    }
  }
  async getPredictedStartTime(bookingId) {
    try {
      const booking = await db.query.bookings.findFirst({
        where: eq47(bookings.id, bookingId),
        with: {
          staff: true,
          service: true,
          salon: true
        }
      });
      if (!booking) {
        return null;
      }
      const today = this.getISTDate();
      if (booking.bookingDate !== today) {
        return {
          bookingId,
          staffId: booking.staffId,
          staffName: booking.staff?.name || null,
          originalBookingTime: booking.bookingTime,
          predictedStartTime: booking.bookingTime,
          delayMinutes: 0,
          delayReason: null,
          appointmentsAhead: 0,
          confidence: 0.5
        };
      }
      if (booking.staffId) {
        const staffStatus = await this.getStaffQueueStatus(booking.staffId, booking.bookingDate);
        if (!staffStatus) {
          return {
            bookingId,
            staffId: booking.staffId,
            staffName: booking.staff?.name || null,
            originalBookingTime: booking.bookingTime,
            predictedStartTime: booking.bookingTime,
            delayMinutes: 0,
            delayReason: null,
            appointmentsAhead: 0,
            confidence: 0.3
          };
        }
        const bookingsBeforeThis = await db.select({ count: sql39`count(*)` }).from(bookings).where(and45(
          eq47(bookings.staffId, booking.staffId),
          eq47(bookings.bookingDate, booking.bookingDate),
          inArray18(bookings.status, ["confirmed", "pending"]),
          sql39`${bookings.bookingTime} < ${booking.bookingTime}`
        ));
        const appointmentsAhead = Number(bookingsBeforeThis[0]?.count || 0);
        const currentTimeMinutes = this.timeToMinutes(this.getISTTimeString());
        const bookingTimeMinutes = this.timeToMinutes(booking.bookingTime);
        let cumulativeDelay = staffStatus.estimatedDelayMinutes;
        const adjustedOverrun = Math.max(0, staffStatus.avgServiceOverrunPercent);
        cumulativeDelay += Math.ceil(appointmentsAhead * (booking.service?.durationMinutes || 30) * adjustedOverrun / 100);
        const predictedStartTime = this.addMinutesToTime(booking.bookingTime, cumulativeDelay);
        let delayReason = null;
        if (cumulativeDelay > 0) {
          if (staffStatus.currentStatus === "busy") {
            delayReason = "service_overrun";
          } else if (appointmentsAhead > 0) {
            delayReason = "queue_behind";
          }
        }
        return {
          bookingId,
          staffId: booking.staffId,
          staffName: staffStatus.staffName,
          originalBookingTime: booking.bookingTime,
          predictedStartTime,
          delayMinutes: Math.max(0, cumulativeDelay),
          delayReason,
          appointmentsAhead,
          confidence: cumulativeDelay <= 5 ? 0.9 : cumulativeDelay <= 15 ? 0.7 : 0.5
        };
      } else {
        const salonStatus = await this.getSalonQueueStatus(booking.salonId, booking.bookingDate);
        if (!salonStatus || salonStatus.staff.length === 0) {
          return {
            bookingId,
            staffId: null,
            staffName: null,
            originalBookingTime: booking.bookingTime,
            predictedStartTime: booking.bookingTime,
            delayMinutes: 0,
            delayReason: null,
            appointmentsAhead: 0,
            confidence: 0.3
          };
        }
        const bestStaff = salonStatus.staff.reduce(
          (best, current) => current.estimatedDelayMinutes < best.estimatedDelayMinutes ? current : best
        );
        const predictedStartTime = this.addMinutesToTime(
          booking.bookingTime,
          bestStaff.estimatedDelayMinutes
        );
        return {
          bookingId,
          staffId: bestStaff.staffId,
          staffName: bestStaff.staffName,
          originalBookingTime: booking.bookingTime,
          predictedStartTime,
          delayMinutes: bestStaff.estimatedDelayMinutes,
          delayReason: bestStaff.estimatedDelayMinutes > 0 ? "queue_behind" : null,
          appointmentsAhead: bestStaff.appointmentsAhead,
          confidence: 0.6
        };
      }
    } catch (error) {
      console.error("Error predicting start time:", error);
      return null;
    }
  }
  async updateStaffQueueStatusRecord(staffId, date) {
    try {
      const targetDate = date || this.getISTDate();
      const status = await this.getStaffQueueStatus(staffId, targetDate);
      if (!status) return;
      const staffData = await db.query.staff.findFirst({
        where: eq47(staff.id, staffId),
        columns: { salonId: true }
      });
      if (!staffData) return;
      const existing = await db.select({ id: staffQueueStatus.id }).from(staffQueueStatus).where(and45(
        eq47(staffQueueStatus.staffId, staffId),
        eq47(staffQueueStatus.currentDate, targetDate)
      )).limit(1);
      const data = {
        salonId: staffData.salonId,
        staffId,
        currentDate: targetDate,
        currentJobCardId: status.currentJobCardId,
        currentStatus: status.currentStatus,
        appointmentsAhead: status.appointmentsAhead,
        estimatedDelayMinutes: status.estimatedDelayMinutes,
        lastServiceEndAt: status.lastServiceEndAt,
        nextAvailableAt: status.nextAvailableAt,
        avgServiceOverrunPercent: status.avgServiceOverrunPercent.toString()
      };
      if (existing.length > 0) {
        await db.update(staffQueueStatus).set({
          ...data,
          updatedAt: /* @__PURE__ */ new Date(),
          calculatedAt: /* @__PURE__ */ new Date()
        }).where(eq47(staffQueueStatus.id, existing[0].id));
      } else {
        await db.insert(staffQueueStatus).values(data);
      }
    } catch (error) {
      console.error("Error updating staff queue status record:", error);
    }
  }
  async recalculateAllQueuesForSalon(salonId, date) {
    try {
      const targetDate = date || this.getISTDate();
      const salonStaff = await db.select({ id: staff.id }).from(staff).where(and45(
        eq47(staff.salonId, salonId),
        eq47(staff.isActive, 1)
      ));
      for (const s of salonStaff) {
        await this.updateStaffQueueStatusRecord(s.id, targetDate);
      }
      const salonQueueStatus = await this.getSalonQueueStatus(salonId, targetDate);
      if (salonQueueStatus) {
        queueSocketService.emitSalonQueueUpdate(salonId, {
          salonId: salonQueueStatus.salonId,
          date: salonQueueStatus.date,
          staff: salonQueueStatus.staff.map((s) => ({
            staffId: s.staffId,
            staffName: s.staffName,
            currentStatus: s.currentStatus,
            appointmentsAhead: s.appointmentsAhead,
            estimatedDelayMinutes: s.estimatedDelayMinutes,
            nextAvailableAt: s.nextAvailableAt?.toISOString() || null,
            currentCustomer: s.currentCustomerName || void 0
          })),
          overallStatus: salonQueueStatus.overallStatus,
          avgDelayMinutes: salonQueueStatus.avgDelayMinutes,
          updatedAt: (/* @__PURE__ */ new Date()).toISOString()
        });
      }
    } catch (error) {
      console.error("Error recalculating salon queues:", error);
    }
  }
};
var queueCalculatorService = new QueueCalculatorService();

// server/services/departureNotification.service.ts
init_db();
init_schema();
import { eq as eq50, and as and48, gte as gte26, inArray as inArray20 } from "drizzle-orm";

// server/services/departureCalculator.service.ts
init_db();
init_schema();
import { eq as eq49, and as and47, inArray as inArray19 } from "drizzle-orm";

// server/services/mlPrediction.service.ts
init_db();
init_schema();
import { eq as eq48, and as and46, sql as sql40, desc as desc36, gte as gte24, isNull as isNull9, or as or17 } from "drizzle-orm";
var MLPredictionService = class _MLPredictionService {
  static MIN_SAMPLES_FOR_CONFIDENCE = 10;
  static HIGH_CONFIDENCE_SAMPLES = 50;
  async getEnhancedPrediction(params) {
    const date = new Date(params.bookingDate);
    const dayOfWeek = date.getDay();
    const hour = parseInt(params.bookingTime.split(":")[0], 10);
    const [staffPattern, servicePattern] = await Promise.all([
      this.getStaffPerformancePattern(params.staffId, params.serviceId, dayOfWeek),
      this.getServiceTimingPattern(params.salonId, params.serviceId, dayOfWeek, hour)
    ]);
    const staffSpeedFactor = staffPattern?.speedFactor || 1;
    const timeOfDayFactor = this.getTimeOfDaySpeedFactor(staffPattern, hour);
    const historicalOverrun = servicePattern?.avgOverrunMinutes || 0;
    const dayAdjustment = this.getDayOfWeekAdjustment(dayOfWeek);
    const queueFactor = 1 + params.queuePosition * 0.02;
    const adjustedDuration = Math.round(
      params.baseDurationMinutes * staffSpeedFactor * timeOfDayFactor * dayAdjustment * queueFactor
    );
    const predictedDelay = Math.round(
      historicalOverrun * params.queuePosition * (1 / Math.max(staffPattern?.consistencyScore || 0.5, 0.3))
    );
    const confidence = this.calculateConfidence(staffPattern, servicePattern);
    return {
      predictedDelayMinutes: Math.max(0, predictedDelay),
      predictedDurationMinutes: adjustedDuration,
      confidence,
      factors: {
        staffSpeedFactor,
        dayOfWeekAdjustment: dayAdjustment,
        timeOfDayAdjustment: timeOfDayFactor,
        historicalOverrunMinutes: historicalOverrun,
        queuePositionFactor: queueFactor
      },
      predictionType: confidence > 0.6 ? "ml_enhanced" : "staff_adjusted"
    };
  }
  async getPersonalizedBuffer(userId) {
    const [customerPref] = await db.select().from(customerTimingPreferences).where(eq48(customerTimingPreferences.userId, userId)).limit(1);
    if (!customerPref || customerPref.visitCount < 3) {
      return {
        recommendedBufferMinutes: 15,
        confidence: 0.3,
        reason: "Default buffer (insufficient visit history)"
      };
    }
    const lateRate = parseFloat(customerPref.lateArrivalRate?.toString() || "0");
    const avgLate = parseFloat(customerPref.avgLateMinutes?.toString() || "0");
    const avgArrival = parseFloat(customerPref.avgArrivalMinutesBeforeAppt?.toString() || "0");
    let buffer = 15;
    let reason = "Based on your arrival patterns";
    if (lateRate > 0.3) {
      buffer = Math.min(30, Math.round(avgLate + 10));
      reason = "Extra buffer recommended based on your history";
    } else if (avgArrival > 20) {
      buffer = Math.max(10, Math.round(avgArrival - 5));
      reason = "You typically arrive early - adjusted buffer";
    } else if (avgArrival < 5 && lateRate < 0.1) {
      buffer = 12;
      reason = "You arrive on time - minimal buffer needed";
    }
    return {
      recommendedBufferMinutes: buffer,
      confidence: parseFloat(customerPref.bufferConfidenceScore?.toString() || "0.5"),
      reason
    };
  }
  async aggregateServiceTimingAnalytics(salonId) {
    const thirtyDaysAgo = /* @__PURE__ */ new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
    const completedServices = await db.select({
      serviceId: jobCardServices.serviceId,
      dayOfWeek: sql40`EXTRACT(DOW FROM ${jobCards.serviceStartAt})`.as("dow"),
      hourBlock: sql40`EXTRACT(HOUR FROM ${jobCards.serviceStartAt})`.as("hour"),
      estimatedDuration: jobCardServices.estimatedDurationMinutes,
      actualDuration: jobCardServices.actualDurationMinutes
    }).from(jobCardServices).innerJoin(jobCards, eq48(jobCardServices.jobCardId, jobCards.id)).where(
      and46(
        eq48(jobCards.salonId, salonId),
        eq48(jobCardServices.status, "completed"),
        gte24(jobCards.serviceStartAt, thirtyDaysAgo)
      )
    );
    const grouped = /* @__PURE__ */ new Map();
    for (const svc of completedServices) {
      if (!svc.serviceId || svc.dayOfWeek === null || svc.hourBlock === null) continue;
      const key = `${svc.serviceId}:${svc.dayOfWeek}:${svc.hourBlock}`;
      if (!grouped.has(key)) {
        grouped.set(key, { samples: [], estimated: [], overruns: [] });
      }
      const data = grouped.get(key);
      if (svc.actualDuration) {
        data.samples.push(svc.actualDuration);
        if (svc.estimatedDuration) {
          data.overruns.push(Math.max(0, svc.actualDuration - svc.estimatedDuration));
          data.estimated.push(svc.estimatedDuration);
        }
      }
    }
    for (const [key, data] of Array.from(grouped.entries())) {
      const [serviceId, dayOfWeek, hourBlock] = key.split(":");
      if (data.samples.length < 3) continue;
      const avg2 = data.samples.reduce((a, b) => a + b, 0) / data.samples.length;
      const variance = data.samples.reduce((sum4, val) => sum4 + Math.pow(val - avg2, 2), 0) / data.samples.length;
      const stdDev = Math.sqrt(variance);
      const avgOverrun = data.overruns.length > 0 ? data.overruns.reduce((a, b) => a + b, 0) / data.overruns.length : 0;
      const overrunRate = data.overruns.length > 0 ? data.overruns.filter((o) => o > 0).length / data.overruns.length : 0;
      const confidence = Math.min(1, data.samples.length / _MLPredictionService.HIGH_CONFIDENCE_SAMPLES);
      await db.insert(serviceTimingAnalytics).values({
        salonId,
        serviceId,
        dayOfWeek: parseInt(dayOfWeek),
        hourBlock: parseInt(hourBlock),
        sampleCount: data.samples.length,
        avgDurationMinutes: avg2.toFixed(2),
        stdDevMinutes: stdDev.toFixed(2),
        minDurationMinutes: Math.min(...data.samples),
        maxDurationMinutes: Math.max(...data.samples),
        avgOverrunMinutes: avgOverrun.toFixed(2),
        overrunRate: overrunRate.toFixed(4),
        confidenceScore: confidence.toFixed(2),
        lastCalculatedAt: /* @__PURE__ */ new Date()
      }).onConflictDoUpdate({
        target: [serviceTimingAnalytics.salonId, serviceTimingAnalytics.serviceId, serviceTimingAnalytics.dayOfWeek, serviceTimingAnalytics.hourBlock],
        set: {
          sampleCount: data.samples.length,
          avgDurationMinutes: avg2.toFixed(2),
          stdDevMinutes: stdDev.toFixed(2),
          minDurationMinutes: Math.min(...data.samples),
          maxDurationMinutes: Math.max(...data.samples),
          avgOverrunMinutes: avgOverrun.toFixed(2),
          overrunRate: overrunRate.toFixed(4),
          confidenceScore: confidence.toFixed(2),
          lastCalculatedAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }
      });
    }
    console.log(`[ML] Aggregated service timing analytics for salon ${salonId}: ${grouped.size} time slots`);
  }
  async aggregateStaffPerformancePatterns(salonId) {
    const thirtyDaysAgo = /* @__PURE__ */ new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
    const completedServices = await db.select({
      staffId: jobCardServices.staffId,
      serviceId: jobCardServices.serviceId,
      dayOfWeek: sql40`EXTRACT(DOW FROM ${jobCards.serviceStartAt})`.as("dow"),
      hour: sql40`EXTRACT(HOUR FROM ${jobCards.serviceStartAt})`.as("hour"),
      estimatedDuration: jobCardServices.estimatedDurationMinutes,
      actualDuration: jobCardServices.actualDurationMinutes,
      checkInAt: jobCards.checkInAt,
      actualStart: jobCards.serviceStartAt
    }).from(jobCardServices).innerJoin(jobCards, eq48(jobCardServices.jobCardId, jobCards.id)).where(
      and46(
        eq48(jobCards.salonId, salonId),
        eq48(jobCardServices.status, "completed"),
        gte24(jobCards.serviceStartAt, thirtyDaysAgo)
      )
    );
    const staffData = /* @__PURE__ */ new Map();
    for (const svc of completedServices) {
      if (!svc.staffId || !svc.actualDuration || !svc.estimatedDuration) continue;
      const key = `${svc.staffId}:${svc.serviceId || "all"}`;
      if (!staffData.has(key)) {
        staffData.set(key, { services: [], byDayOfWeek: /* @__PURE__ */ new Map() });
      }
      const data = staffData.get(key);
      const lateStart = svc.checkInAt && svc.actualStart ? Math.max(0, (new Date(svc.actualStart).getTime() - new Date(svc.checkInAt).getTime()) / 6e4) : 0;
      data.services.push({
        duration: svc.actualDuration,
        estimated: svc.estimatedDuration,
        hour: svc.hour || 12,
        lateStart
      });
      if (svc.dayOfWeek !== null) {
        if (!data.byDayOfWeek.has(svc.dayOfWeek)) {
          data.byDayOfWeek.set(svc.dayOfWeek, []);
        }
        data.byDayOfWeek.get(svc.dayOfWeek).push(svc.actualDuration / svc.estimatedDuration);
      }
    }
    for (const [key, data] of Array.from(staffData.entries())) {
      const [staffId, serviceId] = key.split(":");
      if (data.services.length < 5) continue;
      const avgDuration = data.services.reduce((a, b) => a + b.duration, 0) / data.services.length;
      const avgEstimated = data.services.reduce((a, b) => a + b.estimated, 0) / data.services.length;
      const speedFactor = avgDuration / avgEstimated;
      const lateStarts = data.services.filter((s) => s.lateStart > 5);
      const lateStartRate = lateStarts.length / data.services.length;
      const avgLateStart = lateStarts.length > 0 ? lateStarts.reduce((a, b) => a + b.lateStart, 0) / lateStarts.length : 0;
      const ratios = data.services.map((s) => s.duration / s.estimated);
      const avgRatio = ratios.reduce((a, b) => a + b, 0) / ratios.length;
      const variance = ratios.reduce((sum4, val) => sum4 + Math.pow(val - avgRatio, 2), 0) / ratios.length;
      const consistencyScore = Math.max(0, 1 - Math.sqrt(variance));
      const morning = data.services.filter((s) => s.hour < 12);
      const afternoon = data.services.filter((s) => s.hour >= 12 && s.hour < 17);
      const evening = data.services.filter((s) => s.hour >= 17);
      const morningFactor = morning.length > 2 ? morning.reduce((a, b) => a + b.duration / b.estimated, 0) / morning.length : 1;
      const afternoonFactor = afternoon.length > 2 ? afternoon.reduce((a, b) => a + b.duration / b.estimated, 0) / afternoon.length : 1;
      const eveningFactor = evening.length > 2 ? evening.reduce((a, b) => a + b.duration / b.estimated, 0) / evening.length : 1;
      const confidence = Math.min(1, data.services.length / _MLPredictionService.HIGH_CONFIDENCE_SAMPLES);
      await db.insert(staffPerformancePatterns).values({
        salonId,
        staffId,
        serviceId: serviceId === "all" ? null : serviceId,
        dayOfWeek: null,
        sampleCount: data.services.length,
        avgDurationMinutes: avgDuration.toFixed(2),
        speedFactor: speedFactor.toFixed(2),
        consistencyScore: consistencyScore.toFixed(2),
        lateStartRate: lateStartRate.toFixed(4),
        avgLateStartMinutes: avgLateStart.toFixed(2),
        morningSpeedFactor: morningFactor.toFixed(2),
        afternoonSpeedFactor: afternoonFactor.toFixed(2),
        eveningSpeedFactor: eveningFactor.toFixed(2),
        confidenceScore: confidence.toFixed(2),
        lastCalculatedAt: /* @__PURE__ */ new Date()
      }).onConflictDoUpdate({
        target: [staffPerformancePatterns.staffId, staffPerformancePatterns.serviceId, staffPerformancePatterns.dayOfWeek],
        set: {
          sampleCount: data.services.length,
          avgDurationMinutes: avgDuration.toFixed(2),
          speedFactor: speedFactor.toFixed(2),
          consistencyScore: consistencyScore.toFixed(2),
          lateStartRate: lateStartRate.toFixed(4),
          avgLateStartMinutes: avgLateStart.toFixed(2),
          morningSpeedFactor: morningFactor.toFixed(2),
          afternoonSpeedFactor: afternoonFactor.toFixed(2),
          eveningSpeedFactor: eveningFactor.toFixed(2),
          confidenceScore: confidence.toFixed(2),
          lastCalculatedAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }
      });
    }
    console.log(`[ML] Aggregated staff performance patterns for salon ${salonId}: ${staffData.size} staff/service combinations`);
  }
  async updateCustomerTimingPreferences(userId) {
    const sixMonthsAgo = /* @__PURE__ */ new Date();
    sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);
    const customerBookings = await db.select({
      bookingTime: bookings.bookingTime,
      checkInAt: jobCards.checkInAt,
      serviceStartAt: jobCards.serviceStartAt
    }).from(bookings).leftJoin(jobCards, eq48(jobCards.bookingId, bookings.id)).where(
      and46(
        eq48(bookings.userId, userId),
        eq48(bookings.status, "completed"),
        gte24(bookings.createdAt, sixMonthsAgo)
      )
    );
    if (customerBookings.length < 3) return;
    const arrivals = [];
    const lateArrivals = [];
    for (const booking of customerBookings) {
      if (!booking.checkInAt || !booking.bookingTime) continue;
      const [hours, minutes] = booking.bookingTime.split(":").map(Number);
      const scheduledTime = new Date(booking.checkInAt);
      scheduledTime.setHours(hours, minutes, 0, 0);
      const arrivalDiff = (scheduledTime.getTime() - new Date(booking.checkInAt).getTime()) / 6e4;
      arrivals.push(arrivalDiff);
      if (arrivalDiff < 0) {
        lateArrivals.push(Math.abs(arrivalDiff));
      }
    }
    const avgArrival = arrivals.length > 0 ? arrivals.reduce((a, b) => a + b, 0) / arrivals.length : 0;
    const lateRate = lateArrivals.length / arrivals.length;
    const avgLate = lateArrivals.length > 0 ? lateArrivals.reduce((a, b) => a + b, 0) / lateArrivals.length : 0;
    let recommendedBuffer = 15;
    if (lateRate > 0.3) {
      recommendedBuffer = Math.min(30, Math.round(avgLate + 10));
    } else if (avgArrival > 15) {
      recommendedBuffer = Math.max(10, Math.round(avgArrival - 5));
    } else if (avgArrival < 5 && lateRate < 0.1) {
      recommendedBuffer = 12;
    }
    const confidence = Math.min(1, arrivals.length / 20);
    await db.insert(customerTimingPreferences).values({
      userId,
      visitCount: arrivals.length,
      avgArrivalMinutesBeforeAppt: avgArrival.toFixed(2),
      lateArrivalRate: lateRate.toFixed(4),
      avgLateMinutes: avgLate.toFixed(2),
      recommendedBufferMinutes: recommendedBuffer,
      bufferConfidenceScore: confidence.toFixed(2),
      lastCalculatedAt: /* @__PURE__ */ new Date()
    }).onConflictDoUpdate({
      target: customerTimingPreferences.userId,
      set: {
        visitCount: arrivals.length,
        avgArrivalMinutesBeforeAppt: avgArrival.toFixed(2),
        lateArrivalRate: lateRate.toFixed(4),
        avgLateMinutes: avgLate.toFixed(2),
        recommendedBufferMinutes: recommendedBuffer,
        bufferConfidenceScore: confidence.toFixed(2),
        lastCalculatedAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      }
    });
    console.log(`[ML] Updated customer timing preferences for user ${userId}`);
  }
  async logPredictionAccuracy(params) {
    const startTimeError = params.actualStartTime && params.predictedStartTime ? this.calculateTimeError(params.predictedStartTime, params.actualStartTime) : null;
    const delayError = params.actualDelayMinutes !== void 0 ? params.predictedDelayMinutes - params.actualDelayMinutes : null;
    const durationError = params.actualDurationMinutes && params.predictedDurationMinutes ? params.predictedDurationMinutes - params.actualDurationMinutes : null;
    await db.insert(predictionAccuracyLogs).values({
      bookingId: params.bookingId,
      departureAlertId: params.departureAlertId,
      salonId: params.salonId,
      staffId: params.staffId,
      predictionType: params.predictionType,
      predictedStartTime: params.predictedStartTime,
      predictedDelayMinutes: params.predictedDelayMinutes,
      predictedDurationMinutes: params.predictedDurationMinutes,
      actualStartTime: params.actualStartTime,
      actualDelayMinutes: params.actualDelayMinutes,
      actualDurationMinutes: params.actualDurationMinutes,
      startTimeErrorMinutes: startTimeError,
      delayErrorMinutes: delayError,
      durationErrorMinutes: durationError,
      factorsUsed: params.factorsUsed
    });
  }
  async getStaffPerformancePattern(staffId, serviceId, dayOfWeek) {
    const [pattern] = await db.select().from(staffPerformancePatterns).where(
      and46(
        eq48(staffPerformancePatterns.staffId, staffId),
        or17(
          eq48(staffPerformancePatterns.serviceId, serviceId),
          isNull9(staffPerformancePatterns.serviceId)
        )
      )
    ).orderBy(desc36(staffPerformancePatterns.sampleCount)).limit(1);
    return pattern ? {
      speedFactor: parseFloat(pattern.speedFactor?.toString() || "1"),
      consistencyScore: parseFloat(pattern.consistencyScore?.toString() || "0.5"),
      morningSpeedFactor: parseFloat(pattern.morningSpeedFactor?.toString() || "1"),
      afternoonSpeedFactor: parseFloat(pattern.afternoonSpeedFactor?.toString() || "1"),
      eveningSpeedFactor: parseFloat(pattern.eveningSpeedFactor?.toString() || "1"),
      sampleCount: pattern.sampleCount
    } : null;
  }
  async getServiceTimingPattern(salonId, serviceId, dayOfWeek, hour) {
    const [pattern] = await db.select().from(serviceTimingAnalytics).where(
      and46(
        eq48(serviceTimingAnalytics.salonId, salonId),
        eq48(serviceTimingAnalytics.serviceId, serviceId),
        eq48(serviceTimingAnalytics.dayOfWeek, dayOfWeek),
        eq48(serviceTimingAnalytics.hourBlock, hour)
      )
    ).limit(1);
    return pattern ? {
      avgOverrunMinutes: parseFloat(pattern.avgOverrunMinutes?.toString() || "0"),
      overrunRate: parseFloat(pattern.overrunRate?.toString() || "0"),
      sampleCount: pattern.sampleCount
    } : null;
  }
  getTimeOfDaySpeedFactor(pattern, hour) {
    if (!pattern) return 1;
    if (hour < 12) return pattern.morningSpeedFactor;
    if (hour < 17) return pattern.afternoonSpeedFactor;
    return pattern.eveningSpeedFactor;
  }
  getDayOfWeekAdjustment(dayOfWeek) {
    const adjustments = {
      0: 1.05,
      // Sunday - slightly slower
      1: 0.98,
      // Monday
      2: 0.97,
      // Tuesday
      3: 0.98,
      // Wednesday
      4: 1,
      // Thursday
      5: 1.03,
      // Friday - busier
      6: 1.05
      // Saturday - busier
    };
    return adjustments[dayOfWeek] || 1;
  }
  calculateConfidence(staffPattern, servicePattern) {
    const staffSamples = staffPattern?.sampleCount || 0;
    const serviceSamples = servicePattern?.sampleCount || 0;
    const staffConfidence = Math.min(1, staffSamples / _MLPredictionService.HIGH_CONFIDENCE_SAMPLES);
    const serviceConfidence = Math.min(1, serviceSamples / _MLPredictionService.HIGH_CONFIDENCE_SAMPLES);
    return staffConfidence * 0.6 + serviceConfidence * 0.4;
  }
  calculateTimeError(predicted, actual) {
    const [predH, predM] = predicted.split(":").map(Number);
    const [actH, actM] = actual.split(":").map(Number);
    return predH * 60 + predM - (actH * 60 + actM);
  }
};
var mlPredictionService = new MLPredictionService();

// server/constants/subscription.ts
var PREMIUM_TIER_IDS = ["premium", "enterprise", "professional"];

// server/services/departureCalculator.service.ts
var DEFAULT_TRAVEL_MINUTES = 20;
var DepartureCalculatorService = class {
  getISTTimeString() {
    const formatter = new Intl.DateTimeFormat("en-GB", {
      timeZone: "Asia/Kolkata",
      hour: "2-digit",
      minute: "2-digit",
      hour12: false
    });
    return formatter.format(/* @__PURE__ */ new Date());
  }
  getISTDate() {
    const formatter = new Intl.DateTimeFormat("en-CA", {
      timeZone: "Asia/Kolkata",
      year: "numeric",
      month: "2-digit",
      day: "2-digit"
    });
    return formatter.format(/* @__PURE__ */ new Date());
  }
  parseTimeString(time) {
    const match = time.match(/^(\d{1,2}):(\d{2})$/);
    if (!match) return null;
    const hours = parseInt(match[1], 10);
    const minutes = parseInt(match[2], 10);
    if (hours < 0 || hours > 23 || minutes < 0 || minutes > 59) return null;
    return { hours, minutes };
  }
  timeToMinutes(time) {
    const parsed = this.parseTimeString(time);
    if (!parsed) return 0;
    return parsed.hours * 60 + parsed.minutes;
  }
  minutesToTime(minutes) {
    const normalizedMinutes = (minutes % 1440 + 1440) % 1440;
    const hours = Math.floor(normalizedMinutes / 60);
    const mins = normalizedMinutes % 60;
    return `${hours.toString().padStart(2, "0")}:${mins.toString().padStart(2, "0")}`;
  }
  subtractMinutesFromTime(time, minutes) {
    const timeMinutes = this.timeToMinutes(time);
    return this.minutesToTime(timeMinutes - minutes);
  }
  async isSalonPremium(salonId) {
    try {
      const subscription = await db.query.salonSubscriptions.findFirst({
        where: and47(
          eq49(salonSubscriptions.salonId, salonId),
          eq49(salonSubscriptions.status, "active"),
          inArray19(salonSubscriptions.tierId, PREMIUM_TIER_IDS)
        )
      });
      return !!subscription;
    } catch (error) {
      console.error("Error checking salon premium status:", error);
      return false;
    }
  }
  async getCustomerDepartureLocation(userId, preferredLabel) {
    try {
      const prefs = await db.query.customerDeparturePreferences.findFirst({
        where: eq49(customerDeparturePreferences.userId, userId)
      });
      const locationLabel = preferredLabel || prefs?.defaultLocationLabel || "home";
      if (locationLabel === "ask_each_time") {
        return null;
      }
      const savedLocation = await db.query.userSavedLocations.findFirst({
        where: and47(
          eq49(userSavedLocations.userId, userId),
          eq49(userSavedLocations.label, locationLabel)
        )
      });
      if (savedLocation) {
        return {
          label: savedLocation.label,
          latitude: parseFloat(savedLocation.latitude),
          longitude: parseFloat(savedLocation.longitude)
        };
      }
      const anyLocation = await db.query.userSavedLocations.findFirst({
        where: eq49(userSavedLocations.userId, userId)
      });
      if (anyLocation) {
        return {
          label: anyLocation.label,
          latitude: parseFloat(anyLocation.latitude),
          longitude: parseFloat(anyLocation.longitude)
        };
      }
      return null;
    } catch (error) {
      console.error("Error getting customer departure location:", error);
      return null;
    }
  }
  async estimateTravelTime(origin, destination) {
    const R = 6371;
    const dLat = (destination.lat - origin.lat) * Math.PI / 180;
    const dLon = (destination.lng - origin.lng) * Math.PI / 180;
    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(origin.lat * Math.PI / 180) * Math.cos(destination.lat * Math.PI / 180) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    const distanceKm = R * c;
    const avgSpeedKmH = distanceKm < 5 ? 20 : distanceKm < 15 ? 25 : 30;
    const travelMinutes = Math.ceil(distanceKm / avgSpeedKmH * 60);
    return Math.max(10, Math.min(120, travelMinutes));
  }
  async getSalonDepartureSettings(salonId) {
    try {
      const settings = await db.query.departureAlertSettings.findFirst({
        where: eq49(departureAlertSettings.salonId, salonId)
      });
      if (settings) {
        return {
          isEnabled: settings.isEnabled === 1,
          firstAlertMinutesBefore: settings.firstAlertMinutesBefore,
          updateIntervalMinutes: settings.updateIntervalMinutes,
          minDelayToNotify: settings.minDelayToNotify,
          defaultBufferMinutes: settings.defaultBufferMinutes,
          useTrafficData: settings.useTrafficData === 1,
          considerHistoricalOverrun: settings.considerHistoricalOverrun === 1
        };
      }
      return {
        isEnabled: true,
        firstAlertMinutesBefore: 60,
        updateIntervalMinutes: 15,
        minDelayToNotify: 10,
        defaultBufferMinutes: 10,
        useTrafficData: false,
        considerHistoricalOverrun: true
      };
    } catch (error) {
      console.error("Error getting salon departure settings:", error);
      return {
        isEnabled: true,
        firstAlertMinutesBefore: 60,
        updateIntervalMinutes: 15,
        minDelayToNotify: 10,
        defaultBufferMinutes: 10,
        useTrafficData: false,
        considerHistoricalOverrun: true
      };
    }
  }
  async getCustomerPreferences(userId) {
    try {
      const prefs = await db.query.customerDeparturePreferences.findFirst({
        where: eq49(customerDeparturePreferences.userId, userId)
      });
      if (prefs) {
        return {
          receiveAlerts: prefs.receiveAlerts === 1,
          preferredBufferMinutes: prefs.preferredBufferMinutes || 15,
          preferredChannel: prefs.preferredChannel || "push"
        };
      }
      return {
        receiveAlerts: true,
        preferredBufferMinutes: 15,
        preferredChannel: "push"
      };
    } catch (error) {
      console.error("Error getting customer preferences:", error);
      return {
        receiveAlerts: true,
        preferredBufferMinutes: 15,
        preferredChannel: "push"
      };
    }
  }
  async calculateDepartureTime(bookingId) {
    try {
      const booking = await db.query.bookings.findFirst({
        where: eq49(bookings.id, bookingId),
        with: {
          salon: true,
          staff: true
        }
      });
      if (!booking || !booking.userId) {
        return null;
      }
      const salonSettings = await this.getSalonDepartureSettings(booking.salonId);
      if (!salonSettings.isEnabled) {
        return null;
      }
      const customerPrefs = await this.getCustomerPreferences(booking.userId);
      if (!customerPrefs.receiveAlerts) {
        return null;
      }
      const prediction = await queueCalculatorService.getPredictedStartTime(bookingId);
      if (!prediction) {
        return null;
      }
      const departureLocation = await this.getCustomerDepartureLocation(booking.userId);
      let estimatedTravelMinutes = DEFAULT_TRAVEL_MINUTES;
      if (departureLocation?.latitude && departureLocation?.longitude && booking.salon) {
        const salonLat = booking.salon.latitude ? parseFloat(booking.salon.latitude) : null;
        const salonLng = booking.salon.longitude ? parseFloat(booking.salon.longitude) : null;
        if (salonLat && salonLng) {
          estimatedTravelMinutes = await this.estimateTravelTime(
            { lat: departureLocation.latitude, lng: departureLocation.longitude },
            { lat: salonLat, lng: salonLng }
          );
        }
      }
      let mlEnhancement = {};
      const isPremium = await this.isSalonPremium(booking.salonId);
      if (isPremium && prediction.staffId) {
        try {
          const mlPrediction = await mlPredictionService.getEnhancedPrediction({
            bookingId,
            staffId: prediction.staffId,
            serviceId: booking.serviceId || "",
            salonId: booking.salonId,
            bookingTime: booking.bookingTime,
            bookingDate: booking.bookingDate,
            queuePosition: prediction.appointmentsAhead,
            baseDurationMinutes: 30
            // Default, will be refined by ML
          });
          if (mlPrediction.confidence > 0.4) {
            mlEnhancement = {
              predictedDelayMinutes: mlPrediction.predictedDelayMinutes,
              predictedDurationMinutes: mlPrediction.predictedDurationMinutes,
              confidence: mlPrediction.confidence,
              factors: mlPrediction.factors,
              predictionType: mlPrediction.predictionType
            };
            if (mlPrediction.confidence > prediction.confidence) {
              const mlDelay = Math.max(prediction.delayMinutes, mlPrediction.predictedDelayMinutes);
              prediction.delayMinutes = mlDelay;
              const originalTimeMinutes = this.timeToMinutes(booking.bookingTime);
              const newPredictedTimeMinutes = originalTimeMinutes + mlDelay;
              prediction.predictedStartTime = this.minutesToTime(newPredictedTimeMinutes);
            }
          }
          const personalizedBuffer = await mlPredictionService.getPersonalizedBuffer(booking.userId);
          if (personalizedBuffer.confidence > 0.5) {
            mlEnhancement.personalizedBuffer = personalizedBuffer.recommendedBufferMinutes;
          }
        } catch (error) {
          console.error("[ML] Error getting ML predictions for premium salon:", error);
        }
      }
      const bufferMinutes = Math.max(
        salonSettings.defaultBufferMinutes,
        mlEnhancement.personalizedBuffer || customerPrefs.preferredBufferMinutes
      );
      const totalLeadTime = estimatedTravelMinutes + bufferMinutes;
      const suggestedDepartureTime = this.subtractMinutesFromTime(
        prediction.predictedStartTime,
        totalLeadTime
      );
      let alertType = "on_time";
      let priority = "normal";
      if (prediction.delayMinutes === 0) {
        alertType = "on_time";
        priority = "normal";
      } else if (prediction.delayMinutes < salonSettings.minDelayToNotify) {
        alertType = "on_time";
        priority = "low";
      } else if (prediction.delayMinutes < 20) {
        alertType = "delay_update";
        priority = "normal";
      } else if (prediction.delayMinutes < 40) {
        alertType = "delay_update";
        priority = "high";
      } else {
        alertType = "delay_update";
        priority = "urgent";
      }
      return {
        bookingId,
        userId: booking.userId,
        salonId: booking.salonId,
        staffId: prediction.staffId,
        originalBookingTime: booking.bookingTime,
        bookingDate: booking.bookingDate,
        predictedStartTime: prediction.predictedStartTime,
        delayMinutes: prediction.delayMinutes,
        delayReason: prediction.delayReason,
        suggestedDepartureTime,
        estimatedTravelMinutes,
        bufferMinutes,
        departureLocation: departureLocation ? {
          label: departureLocation.label,
          latitude: departureLocation.latitude,
          longitude: departureLocation.longitude
        } : null,
        alertType,
        priority,
        calculationDetails: {
          appointmentsAhead: prediction.appointmentsAhead,
          confidence: prediction.confidence,
          salonSettings,
          customerPrefs,
          isPremium,
          mlEnhancement: Object.keys(mlEnhancement).length > 0 ? mlEnhancement : void 0
        }
      };
    } catch (error) {
      console.error("Error calculating departure time:", error);
      return null;
    }
  }
  async createOrUpdateDepartureAlert(recommendation) {
    try {
      const existingAlert = await db.query.departureAlerts.findFirst({
        where: and47(
          eq49(departureAlerts.bookingId, recommendation.bookingId),
          eq49(departureAlerts.bookingDate, recommendation.bookingDate)
        )
      });
      const alertData = {
        bookingId: recommendation.bookingId,
        userId: recommendation.userId,
        salonId: recommendation.salonId,
        staffId: recommendation.staffId,
        originalBookingTime: recommendation.originalBookingTime,
        bookingDate: recommendation.bookingDate,
        predictedStartTime: recommendation.predictedStartTime,
        delayMinutes: recommendation.delayMinutes,
        delayReason: recommendation.delayReason,
        suggestedDepartureTime: recommendation.suggestedDepartureTime,
        estimatedTravelMinutes: recommendation.estimatedTravelMinutes,
        bufferMinutes: recommendation.bufferMinutes,
        departureLocationLabel: recommendation.departureLocation?.label || null,
        departureLatitude: recommendation.departureLocation?.latitude?.toString() || null,
        departureLongitude: recommendation.departureLocation?.longitude?.toString() || null,
        alertType: recommendation.alertType,
        priority: recommendation.priority,
        calculationDetails: recommendation.calculationDetails,
        notificationSent: 0
      };
      if (existingAlert) {
        const hasSignificantChange = Math.abs(existingAlert.delayMinutes - recommendation.delayMinutes) >= 5 || existingAlert.alertType !== recommendation.alertType;
        if (hasSignificantChange) {
          await db.update(departureAlerts).set({
            ...alertData,
            alertType: existingAlert.notificationSent === 1 ? "delay_update" : alertData.alertType,
            notificationSent: 0,
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq49(departureAlerts.id, existingAlert.id));
          return db.query.departureAlerts.findFirst({
            where: eq49(departureAlerts.id, existingAlert.id)
          });
        }
        return existingAlert;
      } else {
        const [newAlert] = await db.insert(departureAlerts).values(alertData).returning();
        return newAlert;
      }
    } catch (error) {
      console.error("Error creating/updating departure alert:", error);
      return null;
    }
  }
  async getDepartureStatusForBooking(bookingId) {
    try {
      const recommendation = await this.calculateDepartureTime(bookingId);
      if (!recommendation) {
        return null;
      }
      let staffStatus = null;
      if (recommendation.staffId) {
        const queueStatus = await queueCalculatorService.getStaffQueueStatus(recommendation.staffId);
        if (queueStatus) {
          staffStatus = {
            name: queueStatus.staffName,
            currentStatus: queueStatus.currentStatus,
            appointmentsAhead: queueStatus.appointmentsAhead
          };
        }
      }
      return {
        bookingId,
        originalTime: recommendation.originalBookingTime,
        predictedStartTime: recommendation.predictedStartTime,
        delayMinutes: recommendation.delayMinutes,
        delayReason: recommendation.delayReason,
        suggestedDeparture: {
          time: recommendation.suggestedDepartureTime,
          fromLocation: recommendation.departureLocation?.label || null,
          estimatedTravelMinutes: recommendation.estimatedTravelMinutes,
          bufferMinutes: recommendation.bufferMinutes
        },
        staffStatus,
        lastUpdated: /* @__PURE__ */ new Date()
      };
    } catch (error) {
      console.error("Error getting departure status:", error);
      return null;
    }
  }
};
var departureCalculatorService = new DepartureCalculatorService();

// server/services/departureNotification.service.ts
var NOTIFICATION_TEMPLATES = {
  initial_reminder: {
    title: "Time to get ready!",
    body: "Your appointment at {salonName} is at {time}. Leave by {departureTime} to arrive on time."
  },
  on_time: {
    title: "Your appointment is on schedule",
    body: "Your {time} appointment at {salonName} is on track. Suggested departure: {departureTime}"
  },
  delay_update: {
    title: "Schedule Update",
    body: "Your stylist {staffName} is running ~{delay} min behind. New suggested departure: {departureTime}"
  },
  earlier_available: {
    title: "Good news!",
    body: "Your stylist is ahead of schedule! You can leave {minutes} min earlier if convenient."
  },
  staff_change: {
    title: "Staff Update",
    body: "{originalStaff} is unavailable. {newStaff} will serve you at {time}. Tap to confirm."
  }
};
var DepartureNotificationService = class {
  getISTDate() {
    const formatter = new Intl.DateTimeFormat("en-CA", {
      timeZone: "Asia/Kolkata",
      year: "numeric",
      month: "2-digit",
      day: "2-digit"
    });
    return formatter.format(/* @__PURE__ */ new Date());
  }
  getISTTimeString() {
    const formatter = new Intl.DateTimeFormat("en-GB", {
      timeZone: "Asia/Kolkata",
      hour: "2-digit",
      minute: "2-digit",
      hour12: false
    });
    return formatter.format(/* @__PURE__ */ new Date());
  }
  parseTimeString(time) {
    const match = time.match(/^(\d{1,2}):(\d{2})$/);
    if (!match) return null;
    const hours = parseInt(match[1], 10);
    const minutes = parseInt(match[2], 10);
    if (hours < 0 || hours > 23 || minutes < 0 || minutes > 59) return null;
    return { hours, minutes };
  }
  timeToMinutes(time) {
    const parsed = this.parseTimeString(time);
    if (!parsed) return 0;
    return parsed.hours * 60 + parsed.minutes;
  }
  formatTimeFor12Hour(time) {
    const parsed = this.parseTimeString(time);
    if (!parsed) return time;
    const period = parsed.hours >= 12 ? "PM" : "AM";
    const displayHours = parsed.hours % 12 || 12;
    return `${displayHours}:${parsed.minutes.toString().padStart(2, "0")} ${period}`;
  }
  formatNotificationMessage(template, params) {
    let title = template.title;
    let body = template.body;
    for (const [key, value] of Object.entries(params)) {
      const placeholder = `{${key}}`;
      title = title.replace(new RegExp(placeholder, "g"), String(value));
      body = body.replace(new RegExp(placeholder, "g"), String(value));
    }
    return { title, body };
  }
  async sendDepartureAlert(alertId) {
    try {
      const alert = await db.query.departureAlerts.findFirst({
        where: eq50(departureAlerts.id, alertId)
      });
      if (!alert) {
        console.error("Departure alert not found:", alertId);
        return false;
      }
      if (alert.notificationSent === 1) {
        console.log("Notification already sent for alert:", alertId);
        return true;
      }
      const booking = await db.query.bookings.findFirst({
        where: eq50(bookings.id, alert.bookingId),
        with: {
          salon: true,
          staff: true
        }
      });
      if (!booking) {
        console.error("Booking not found for alert:", alertId);
        return false;
      }
      const templateKey = alert.alertType;
      const template = NOTIFICATION_TEMPLATES[templateKey] || NOTIFICATION_TEMPLATES.on_time;
      const { title, body } = this.formatNotificationMessage(template, {
        salonName: booking.salon?.name || "the salon",
        time: this.formatTimeFor12Hour(alert.originalBookingTime),
        departureTime: this.formatTimeFor12Hour(alert.suggestedDepartureTime),
        staffName: booking.staff?.name || "your stylist",
        delay: alert.delayMinutes,
        minutes: Math.abs(alert.delayMinutes)
      });
      await db.insert(userNotifications).values({
        userId: alert.userId,
        title,
        message: body,
        type: "departure_alert",
        referenceId: alert.bookingId,
        referenceType: "booking",
        isRead: 0
      });
      const customerPrefs = await db.query.customerDeparturePreferences.findFirst({
        where: eq50(customerDeparturePreferences.userId, alert.userId)
      });
      const preferredChannel = customerPrefs?.preferredChannel || "push";
      let sentVia = "in_app";
      let messageId = null;
      if (preferredChannel === "sms" || preferredChannel === "all") {
        const user = await db.query.users.findFirst({
          where: eq50(users.id, alert.userId)
        });
        if (user?.phone) {
          try {
            const smsResult = await sendMessage({
              to: user.phone,
              message: `${title}

${body}`,
              channel: "sms"
            });
            if (smsResult.success) {
              sentVia = "sms";
              messageId = smsResult.messageSid || null;
            }
          } catch (error) {
            console.error("Error sending SMS:", error);
          }
        }
      }
      await db.update(departureAlerts).set({
        notificationSent: 1,
        sentAt: /* @__PURE__ */ new Date(),
        sentVia,
        messageId,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq50(departureAlerts.id, alertId));
      queueSocketService.emitDepartureStatusUpdate(alert.userId, alert.bookingId, {
        bookingId: alert.bookingId,
        userId: alert.userId,
        originalTime: alert.originalBookingTime,
        predictedStartTime: alert.predictedStartTime,
        delayMinutes: alert.delayMinutes,
        delayReason: alert.delayReason || void 0,
        suggestedDepartureTime: alert.suggestedDepartureTime,
        staffName: booking.staff?.name || void 0,
        staffStatus: void 0,
        appointmentsAhead: void 0
      });
      return true;
    } catch (error) {
      console.error("Error sending departure alert:", error);
      return false;
    }
  }
  async processPendingAlerts() {
    const results = { processed: 0, sent: 0, errors: 0 };
    try {
      const today = this.getISTDate();
      const currentTime = this.getISTTimeString();
      const currentMinutes = this.timeToMinutes(currentTime);
      const pendingAlerts = await db.select().from(departureAlerts).where(and48(
        eq50(departureAlerts.bookingDate, today),
        eq50(departureAlerts.notificationSent, 0),
        eq50(departureAlerts.customerAcknowledged, 0)
      ));
      for (const alert of pendingAlerts) {
        results.processed++;
        const departureMinutes = this.timeToMinutes(alert.suggestedDepartureTime);
        const minutesUntilDeparture = departureMinutes - currentMinutes;
        const settings = await departureCalculatorService.getSalonDepartureSettings(alert.salonId);
        const sendWindowMinutes = settings.firstAlertMinutesBefore;
        if (minutesUntilDeparture <= sendWindowMinutes && minutesUntilDeparture > -30) {
          const success = await this.sendDepartureAlert(alert.id);
          if (success) {
            results.sent++;
          } else {
            results.errors++;
          }
        }
      }
      return results;
    } catch (error) {
      console.error("Error processing pending alerts:", error);
      return results;
    }
  }
  async recalculateAndUpdateAlerts() {
    const results = { updated: 0, created: 0, errors: 0 };
    try {
      const today = this.getISTDate();
      const currentTime = this.getISTTimeString();
      const currentMinutes = this.timeToMinutes(currentTime);
      const upcomingBookings = await db.select({
        id: bookings.id,
        bookingTime: bookings.bookingTime,
        salonId: bookings.salonId
      }).from(bookings).where(and48(
        eq50(bookings.bookingDate, today),
        inArray20(bookings.status, ["confirmed", "pending"]),
        gte26(bookings.bookingTime, currentTime)
      ));
      for (const booking of upcomingBookings) {
        try {
          const bookingMinutes = this.timeToMinutes(booking.bookingTime);
          const minutesUntilBooking = bookingMinutes - currentMinutes;
          if (minutesUntilBooking <= 180 && minutesUntilBooking > 0) {
            const recommendation = await departureCalculatorService.calculateDepartureTime(booking.id);
            if (recommendation) {
              const existingAlert = await db.query.departureAlerts.findFirst({
                where: and48(
                  eq50(departureAlerts.bookingId, booking.id),
                  eq50(departureAlerts.bookingDate, today)
                )
              });
              await departureCalculatorService.createOrUpdateDepartureAlert(recommendation);
              if (existingAlert) {
                results.updated++;
              } else {
                results.created++;
              }
            }
          }
        } catch (error) {
          console.error("Error processing booking:", booking.id, error);
          results.errors++;
        }
      }
      return results;
    } catch (error) {
      console.error("Error recalculating alerts:", error);
      return results;
    }
  }
  async acknowledgeAlert(alertId, userId, response, actualDepartureTime) {
    try {
      const alert = await db.query.departureAlerts.findFirst({
        where: and48(
          eq50(departureAlerts.id, alertId),
          eq50(departureAlerts.userId, userId)
        )
      });
      if (!alert) {
        return false;
      }
      await db.update(departureAlerts).set({
        customerAcknowledged: 1,
        acknowledgedAt: /* @__PURE__ */ new Date(),
        customerResponse: response,
        actualDepartureTime: actualDepartureTime || null,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq50(departureAlerts.id, alertId));
      return true;
    } catch (error) {
      console.error("Error acknowledging alert:", error);
      return false;
    }
  }
  async getAlertsForUser(userId, date) {
    try {
      const targetDate = date || this.getISTDate();
      return await db.select().from(departureAlerts).where(and48(
        eq50(departureAlerts.userId, userId),
        eq50(departureAlerts.bookingDate, targetDate)
      ));
    } catch (error) {
      console.error("Error getting user alerts:", error);
      return [];
    }
  }
  async sendDelayUpdateIfNeeded(bookingId, previousDelay, newDelay) {
    try {
      const delayChange = newDelay - previousDelay;
      if (Math.abs(delayChange) < 10) {
        return false;
      }
      const today = this.getISTDate();
      const alert = await db.query.departureAlerts.findFirst({
        where: and48(
          eq50(departureAlerts.bookingId, bookingId),
          eq50(departureAlerts.bookingDate, today)
        )
      });
      if (!alert) {
        return false;
      }
      if (alert.notificationSent === 0) {
        return false;
      }
      const recommendation = await departureCalculatorService.calculateDepartureTime(bookingId);
      if (!recommendation) {
        return false;
      }
      recommendation.alertType = delayChange < 0 ? "earlier_available" : "delay_update";
      await departureCalculatorService.createOrUpdateDepartureAlert(recommendation);
      const updatedAlert = await db.query.departureAlerts.findFirst({
        where: and48(
          eq50(departureAlerts.bookingId, bookingId),
          eq50(departureAlerts.bookingDate, today)
        )
      });
      if (updatedAlert) {
        await this.sendDepartureAlert(updatedAlert.id);
        if (delayChange > 0) {
          queueSocketService.emitDelayAlert(updatedAlert.userId, bookingId, {
            delayMinutes: newDelay,
            newDepartureTime: recommendation.suggestedDepartureTime,
            reason: recommendation.delayReason || void 0
          });
        } else if (delayChange < 0) {
          queueSocketService.emitQueueCaughtUp(updatedAlert.userId, bookingId, {
            newDepartureTime: recommendation.suggestedDepartureTime,
            minutesSaved: Math.abs(delayChange)
          });
        }
      }
      return true;
    } catch (error) {
      console.error("Error sending delay update:", error);
      return false;
    }
  }
};
var departureNotificationService = new DepartureNotificationService();

// server/jobs/departureAlertsJobs.ts
var isRecalculatingQueues = false;
var isProcessingAlerts = false;
var BATCH_SIZE = 100;
async function recalculateAllQueues() {
  if (isRecalculatingQueues) {
    console.log("[Departure Job] Queue recalculation already in progress, skipping...");
    return;
  }
  isRecalculatingQueues = true;
  console.log("[Departure Job] Recalculating staff queues...");
  try {
    let salonCount = 0;
    let staffCount = 0;
    let lastSalonId = "";
    let hasMoreSalons = true;
    while (hasMoreSalons) {
      const activeSalons = await db.select({ id: salons.id }).from(salons).where(
        lastSalonId ? and49(eq51(salons.isActive, 1), gt5(salons.id, lastSalonId)) : eq51(salons.isActive, 1)
      ).orderBy(salons.id).limit(BATCH_SIZE);
      if (activeSalons.length === 0) {
        hasMoreSalons = false;
        break;
      }
      for (const salon of activeSalons) {
        try {
          const salonStaff = await db.select({ id: staff.id }).from(staff).where(and49(
            eq51(staff.salonId, salon.id),
            eq51(staff.isActive, 1)
          ));
          for (const s of salonStaff) {
            await queueCalculatorService.updateStaffQueueStatusRecord(s.id);
            staffCount++;
          }
          salonCount++;
        } catch (error) {
          console.error(`[Departure Job] Error processing salon ${salon.id}:`, error);
        }
      }
      lastSalonId = activeSalons[activeSalons.length - 1].id;
      if (activeSalons.length < BATCH_SIZE) {
        hasMoreSalons = false;
      }
    }
    console.log(`[Departure Job] Recalculated queues for ${staffCount} staff across ${salonCount} salons`);
  } catch (error) {
    console.error("[Departure Job] Error recalculating queues:", error);
  } finally {
    isRecalculatingQueues = false;
  }
}
async function processAndSendDepartureAlerts() {
  if (isProcessingAlerts) {
    console.log("[Departure Job] Alert processing already in progress, skipping...");
    return;
  }
  isProcessingAlerts = true;
  console.log("[Departure Job] Processing departure alerts...");
  try {
    const updateResults = await departureNotificationService.recalculateAndUpdateAlerts();
    console.log(`[Departure Job] Created ${updateResults.created} new alerts, updated ${updateResults.updated} existing alerts`);
    const sendResults = await departureNotificationService.processPendingAlerts();
    console.log(`[Departure Job] Sent ${sendResults.sent}/${sendResults.processed} departure notifications`);
    if (updateResults.errors > 0 || sendResults.errors > 0) {
      console.warn(`[Departure Job] Encountered ${updateResults.errors + sendResults.errors} errors during processing`);
    }
  } catch (error) {
    console.error("[Departure Job] Error processing alerts:", error);
  } finally {
    isProcessingAlerts = false;
  }
}
function startDepartureAlertsJobs() {
  console.log("[Departure Job] Starting Smart Departure Alerts background jobs...");
  cron5.schedule("*/5 * * * *", async () => {
    console.log("[Departure Job] Running scheduled queue recalculation...");
    await recalculateAllQueues();
  });
  cron5.schedule("*/5 * * * *", async () => {
    console.log("[Departure Job] Running scheduled alert processing...");
    await processAndSendDepartureAlerts();
  });
  console.log("[Departure Job] \u2705 Queue recalculation job scheduled (every 5 minutes)");
  console.log("[Departure Job] \u2705 Departure alert processing job scheduled (every 5 minutes)");
}

// server/jobs/mlAnalyticsJobs.ts
init_db();
init_schema();
import cron6 from "node-cron";
import { eq as eq52, and as and50, inArray as inArray21 } from "drizzle-orm";
async function aggregateMLAnalytics() {
  console.log("[ML Analytics Job] Starting ML analytics aggregation...");
  try {
    const premiumSalons = await db.select({ id: salons.id }).from(salons).innerJoin(salonSubscriptions, eq52(salonSubscriptions.salonId, salons.id)).where(
      and50(
        eq52(salons.isActive, 1),
        eq52(salonSubscriptions.status, "active"),
        inArray21(salonSubscriptions.tierId, PREMIUM_TIER_IDS)
      )
    ).limit(100);
    console.log(`[ML Analytics Job] Processing ${premiumSalons.length} premium salons`);
    for (const salon of premiumSalons) {
      try {
        await mlPredictionService.aggregateServiceTimingAnalytics(salon.id);
        await mlPredictionService.aggregateStaffPerformancePatterns(salon.id);
      } catch (error) {
        console.error(`[ML Analytics Job] Error processing salon ${salon.id}:`, error);
      }
    }
    console.log("[ML Analytics Job] ML analytics aggregation complete");
  } catch (error) {
    console.error("[ML Analytics Job] Error in ML analytics aggregation:", error);
  }
}
async function cleanupOldPredictionLogs() {
  console.log("[ML Analytics Job] Cleaning up old prediction logs...");
  try {
    const ninetyDaysAgo = /* @__PURE__ */ new Date();
    ninetyDaysAgo.setDate(ninetyDaysAgo.getDate() - 90);
    await db.execute(`
      DELETE FROM prediction_accuracy_logs 
      WHERE created_at < '${ninetyDaysAgo.toISOString()}'
    `);
    console.log("[ML Analytics Job] Old prediction logs cleaned up");
  } catch (error) {
    console.error("[ML Analytics Job] Error cleaning up prediction logs:", error);
  }
}
function startMLAnalyticsJobs() {
  console.log("[ML Analytics Jobs] Starting ML analytics background jobs...");
  cron6.schedule("0 3 * * *", async () => {
    await aggregateMLAnalytics();
  });
  console.log("[ML Analytics Jobs] \u2705 Daily ML aggregation scheduled (3 AM IST)");
  cron6.schedule("0 4 * * 0", async () => {
    await cleanupOldPredictionLogs();
  });
  console.log("[ML Analytics Jobs] \u2705 Weekly log cleanup scheduled (Sundays 4 AM)");
  console.log("\u2705 ML Analytics background jobs started");
}

// server/routes/late-arrival.routes.ts
import { Router as Router28 } from "express";

// server/services/lateArrival.service.ts
init_db();
init_schema();
import { eq as eq53, and as and51, desc as desc37, gte as gte27 } from "drizzle-orm";
var IST_TIMEZONE2 = "Asia/Kolkata";
function getISTDate2() {
  const formatter = new Intl.DateTimeFormat("en-CA", {
    timeZone: IST_TIMEZONE2,
    year: "numeric",
    month: "2-digit",
    day: "2-digit"
  });
  return formatter.format(/* @__PURE__ */ new Date());
}
function getISTTimeString() {
  const formatter = new Intl.DateTimeFormat("en-GB", {
    timeZone: IST_TIMEZONE2,
    hour: "2-digit",
    minute: "2-digit",
    hour12: false
  });
  return formatter.format(/* @__PURE__ */ new Date());
}
function parseTimeString(time) {
  const match = time.match(/^(\d{1,2}):(\d{2})$/);
  if (!match) return null;
  const hours = parseInt(match[1], 10);
  const minutes = parseInt(match[2], 10);
  if (hours < 0 || hours > 23 || minutes < 0 || minutes > 59) return null;
  return { hours, minutes };
}
function calculateEstimatedArrivalTime(bookingTime, delayMinutes) {
  const parsed = parseTimeString(bookingTime);
  if (!parsed) return bookingTime;
  const totalMinutes = parsed.hours * 60 + parsed.minutes + delayMinutes;
  const newHours = Math.floor(totalMinutes / 60) % 24;
  const newMinutes = totalMinutes % 60;
  return `${newHours.toString().padStart(2, "0")}:${newMinutes.toString().padStart(2, "0")}`;
}
function hasBookingTimePassed(bookingTime) {
  const parsed = parseTimeString(bookingTime);
  if (!parsed) return false;
  const currentTime = getISTTimeString();
  const currentParsed = parseTimeString(currentTime);
  if (!currentParsed) return false;
  const bookingMinutes = parsed.hours * 60 + parsed.minutes;
  const currentMinutes = currentParsed.hours * 60 + currentParsed.minutes;
  return currentMinutes > bookingMinutes + 60;
}
function formatTimeForDisplay(time) {
  const [hours, minutes] = time.split(":").map(Number);
  const period = hours >= 12 ? "PM" : "AM";
  const displayHours = hours % 12 || 12;
  return `${displayHours}:${minutes.toString().padStart(2, "0")} ${period}`;
}
var LateArrivalService = class {
  async createLateNotification(userId, input) {
    try {
      const booking = await db.query.bookings.findFirst({
        where: eq53(bookings.id, input.bookingId),
        with: {
          salon: true
        }
      });
      if (!booking) {
        return { success: false, error: "Booking not found" };
      }
      if (booking.userId !== userId) {
        return { success: false, error: "You can only notify for your own bookings" };
      }
      if (booking.status !== "confirmed" && booking.status !== "pending") {
        return { success: false, error: "Cannot send late notification for this booking status" };
      }
      const today = getISTDate2();
      if (booking.bookingDate !== today) {
        return { success: false, error: "Late notifications can only be sent for today's bookings" };
      }
      if (hasBookingTimePassed(booking.bookingTime)) {
        return { success: false, error: "Your appointment time has already passed" };
      }
      const validDelay = LATE_ARRIVAL_DELAY_OPTIONS.find(
        (opt) => opt.value === input.estimatedDelayMinutes
      );
      if (!validDelay) {
        return { success: false, error: "Invalid delay time selected" };
      }
      const fiveMinutesAgo = new Date(Date.now() - 5 * 60 * 1e3);
      const recentNotification = await db.query.lateArrivalNotifications.findFirst({
        where: and51(
          eq53(lateArrivalNotifications.bookingId, input.bookingId),
          gte27(lateArrivalNotifications.createdAt, fiveMinutesAgo)
        )
      });
      if (recentNotification && recentNotification.estimatedDelayMinutes === input.estimatedDelayMinutes) {
        return { success: false, error: "You recently sent a notification with this delay time. Please wait a few minutes." };
      }
      const existingNotification = await db.query.lateArrivalNotifications.findFirst({
        where: and51(
          eq53(lateArrivalNotifications.bookingId, input.bookingId),
          eq53(lateArrivalNotifications.salonAcknowledged, 0)
        )
      });
      if (existingNotification) {
        const [updated] = await db.update(lateArrivalNotifications).set({
          estimatedDelayMinutes: input.estimatedDelayMinutes,
          estimatedArrivalTime: calculateEstimatedArrivalTime(
            booking.bookingTime,
            input.estimatedDelayMinutes
          ),
          customerMessage: input.customerMessage || null,
          salonNotified: 0,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq53(lateArrivalNotifications.id, existingNotification.id)).returning();
        await this.notifySalon(updated, booking);
        return { success: true, notification: updated };
      }
      const estimatedArrivalTime = calculateEstimatedArrivalTime(
        booking.bookingTime,
        input.estimatedDelayMinutes
      );
      const [notification] = await db.insert(lateArrivalNotifications).values({
        bookingId: input.bookingId,
        salonId: booking.salonId,
        userId,
        estimatedDelayMinutes: input.estimatedDelayMinutes,
        originalBookingTime: booking.bookingTime,
        estimatedArrivalTime,
        customerMessage: input.customerMessage || null
      }).returning();
      await this.notifySalon(notification, booking);
      return { success: true, notification };
    } catch (error) {
      console.error("Error creating late notification:", error);
      return { success: false, error: "Failed to create late notification" };
    }
  }
  async notifySalon(notification, booking) {
    try {
      const salon = await db.query.salons.findFirst({
        where: eq53(salons.id, notification.salonId)
      });
      if (!salon) return;
      const customerName = booking.customerName || "A customer";
      const delayLabel = LATE_ARRIVAL_DELAY_OPTIONS.find(
        (opt) => opt.value === notification.estimatedDelayMinutes
      )?.label || `${notification.estimatedDelayMinutes} minutes`;
      const originalTimeDisplay = formatTimeForDisplay(notification.originalBookingTime);
      const newTimeDisplay = formatTimeForDisplay(notification.estimatedArrivalTime);
      const message = `\u{1F550} Late Arrival Alert

${customerName} is running ${delayLabel} late for their ${originalTimeDisplay} appointment.

New estimated arrival: ${newTimeDisplay}${notification.customerMessage ? `

Message: "${notification.customerMessage}"` : ""}

Booking ID: ${notification.bookingId.slice(0, 8)}`;
      let notificationChannel = null;
      let messageSid = null;
      if (salon.phone) {
        try {
          const smsResult = await sendMessage({
            to: salon.phone,
            message,
            channel: "sms"
          });
          if (smsResult.success) {
            notificationChannel = "sms";
            messageSid = smsResult.messageSid || null;
          }
        } catch (smsError) {
          console.log("SMS notification failed, falling back to in-app:", smsError);
        }
      }
      if (!notificationChannel) {
        notificationChannel = "in_app";
      }
      if (salon.ownerId) {
        await db.insert(userNotifications).values({
          userId: salon.ownerId,
          title: "Customer Running Late",
          message: `${customerName} will arrive ${delayLabel} late for their ${originalTimeDisplay} appointment. New ETA: ${newTimeDisplay}`,
          type: "booking",
          referenceId: notification.bookingId,
          referenceType: "late_arrival"
        });
      }
      await db.update(lateArrivalNotifications).set({
        salonNotified: 1,
        salonNotifiedAt: /* @__PURE__ */ new Date(),
        notificationChannel,
        notificationMessageSid: messageSid,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq53(lateArrivalNotifications.id, notification.id));
    } catch (error) {
      console.error("Error notifying salon:", error);
    }
  }
  /**
   * Acknowledge a late arrival notification from the salon side.
   * 
   * DESIGN DECISION: Booking status is NOT automatically updated when salon responds "cancelled".
   * Reasons:
   * 1. Avoid unexpected payment/refund issues from automated cancellations
   * 2. Salon may still want to accommodate or reschedule manually
   * 3. Customer should be notified and take action themselves via normal cancellation flow
   * 4. Reduces complexity and potential for disputes
   * 
   * The customer is notified of the salon's response and can cancel/reschedule themselves.
   */
  async acknowledgeLateArrival(notificationId, acknowledgedByUserId, input) {
    try {
      const notification = await db.query.lateArrivalNotifications.findFirst({
        where: eq53(lateArrivalNotifications.id, notificationId)
      });
      if (!notification) {
        return { success: false, error: "Notification not found" };
      }
      if (notification.salonAcknowledged === 1) {
        return { success: false, error: "Notification already acknowledged" };
      }
      const [updated] = await db.update(lateArrivalNotifications).set({
        salonAcknowledged: 1,
        salonAcknowledgedAt: /* @__PURE__ */ new Date(),
        salonAcknowledgedBy: acknowledgedByUserId,
        salonResponse: input.response,
        salonResponseNote: input.responseNote || null,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq53(lateArrivalNotifications.id, notificationId)).returning();
      if (notification.userId) {
        let responseMessage = "";
        switch (input.response) {
          case "acknowledged":
            responseMessage = "The salon has acknowledged your late arrival notification. See you soon!";
            break;
          case "rescheduled":
            responseMessage = `The salon has noted your delay. ${input.responseNote || "They may contact you about rescheduling."}`;
            break;
          case "cancelled":
            responseMessage = `Due to scheduling constraints, your appointment may need to be rescheduled. ${input.responseNote || "The salon will contact you shortly."}`;
            break;
        }
        await db.insert(userNotifications).values({
          userId: notification.userId,
          title: "Late Arrival Update",
          message: responseMessage,
          type: "booking",
          referenceId: notification.bookingId,
          referenceType: "late_arrival_response"
        });
      }
      return { success: true, notification: updated };
    } catch (error) {
      console.error("Error acknowledging late arrival:", error);
      return { success: false, error: "Failed to acknowledge notification" };
    }
  }
  async getLateNotificationById(notificationId) {
    const notification = await db.query.lateArrivalNotifications.findFirst({
      where: eq53(lateArrivalNotifications.id, notificationId)
    });
    return notification || null;
  }
  async getLateNotificationsForBooking(bookingId) {
    return db.query.lateArrivalNotifications.findMany({
      where: eq53(lateArrivalNotifications.bookingId, bookingId),
      orderBy: [desc37(lateArrivalNotifications.createdAt)]
    });
  }
  async getPendingLateNotificationsForSalon(salonId) {
    const today = getISTDate2();
    const notifications = await db.query.lateArrivalNotifications.findMany({
      where: and51(
        eq53(lateArrivalNotifications.salonId, salonId),
        eq53(lateArrivalNotifications.salonAcknowledged, 0)
      ),
      with: {
        booking: true,
        user: {
          columns: {
            id: true,
            firstName: true,
            lastName: true,
            phone: true
          }
        }
      },
      orderBy: [desc37(lateArrivalNotifications.createdAt)]
    });
    return notifications.filter((n) => n.booking?.bookingDate === today);
  }
  async getLateNotificationHistory(salonId, limit = 50) {
    return db.query.lateArrivalNotifications.findMany({
      where: eq53(lateArrivalNotifications.salonId, salonId),
      with: {
        booking: true,
        user: {
          columns: {
            id: true,
            firstName: true,
            lastName: true
          }
        }
      },
      orderBy: [desc37(lateArrivalNotifications.createdAt)],
      limit
    });
  }
  async getCustomerLateNotificationHistory(userId) {
    return db.query.lateArrivalNotifications.findMany({
      where: eq53(lateArrivalNotifications.userId, userId),
      with: {
        booking: true,
        salon: {
          columns: {
            id: true,
            name: true
          }
        }
      },
      orderBy: [desc37(lateArrivalNotifications.createdAt)],
      limit: 20
    });
  }
  async canSendLateNotification(userId, bookingId) {
    const booking = await db.query.bookings.findFirst({
      where: eq53(bookings.id, bookingId),
      with: {
        salon: {
          columns: {
            id: true,
            name: true
          }
        }
      }
    });
    if (!booking) {
      return { canSend: false, reason: "Booking not found" };
    }
    if (booking.userId !== userId) {
      return { canSend: false, reason: "Not your booking" };
    }
    if (booking.status !== "confirmed" && booking.status !== "pending") {
      return { canSend: false, reason: "Booking is not active" };
    }
    const today = getISTDate2();
    if (booking.bookingDate !== today) {
      return { canSend: false, reason: "Late notifications can only be sent for today's appointments" };
    }
    if (hasBookingTimePassed(booking.bookingTime)) {
      return { canSend: false, reason: "Your appointment time has already passed" };
    }
    return { canSend: true, booking };
  }
};
var lateArrivalService = new LateArrivalService();

// server/routes/late-arrival.routes.ts
init_rbacService();
init_schema();
import { z as z20 } from "zod";
var router29 = Router28();
router29.get("/delay-options", (req, res) => {
  res.json({
    success: true,
    options: LATE_ARRIVAL_DELAY_OPTIONS
  });
});
router29.get("/bookings/:bookingId/can-notify", authenticateToken, async (req, res) => {
  try {
    const userId = req.user?.id;
    const { bookingId } = req.params;
    if (!userId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const result = await lateArrivalService.canSendLateNotification(userId, bookingId);
    return res.json(result);
  } catch (error) {
    console.error("Error checking late notification eligibility:", error);
    return res.status(500).json({ error: "Failed to check eligibility" });
  }
});
router29.post("/notify", authenticateToken, async (req, res) => {
  try {
    const userId = req.user?.id;
    if (!userId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const validatedInput = createLateArrivalNotificationSchema.parse(req.body);
    const result = await lateArrivalService.createLateNotification(userId, validatedInput);
    if (!result.success) {
      return res.status(400).json({ error: result.error });
    }
    return res.status(201).json({
      success: true,
      message: "Late arrival notification sent to salon",
      notification: result.notification
    });
  } catch (error) {
    if (error instanceof z20.ZodError) {
      return res.status(400).json({ error: "Invalid input", details: error.errors });
    }
    console.error("Error creating late notification:", error);
    return res.status(500).json({ error: "Failed to send notification" });
  }
});
router29.get("/bookings/:bookingId/history", authenticateToken, async (req, res) => {
  try {
    const { bookingId } = req.params;
    const notifications = await lateArrivalService.getLateNotificationsForBooking(bookingId);
    return res.json({ success: true, notifications });
  } catch (error) {
    console.error("Error fetching late notification history:", error);
    return res.status(500).json({ error: "Failed to fetch history" });
  }
});
router29.get("/customer/history", authenticateToken, async (req, res) => {
  try {
    const userId = req.user?.id;
    if (!userId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const notifications = await lateArrivalService.getCustomerLateNotificationHistory(userId);
    return res.json({ success: true, notifications });
  } catch (error) {
    console.error("Error fetching customer notification history:", error);
    return res.status(500).json({ error: "Failed to fetch history" });
  }
});
router29.get("/salons/:salonId/pending", authenticateToken, requireSalonAccess(), async (req, res) => {
  try {
    const { salonId } = req.params;
    const notifications = await lateArrivalService.getPendingLateNotificationsForSalon(salonId);
    return res.json({ success: true, notifications });
  } catch (error) {
    console.error("Error fetching pending notifications:", error);
    return res.status(500).json({ error: "Failed to fetch notifications" });
  }
});
router29.get("/salons/:salonId/history", authenticateToken, requireSalonAccess(), async (req, res) => {
  try {
    const { salonId } = req.params;
    const limit = parseInt(req.query.limit) || 50;
    const notifications = await lateArrivalService.getLateNotificationHistory(salonId, limit);
    return res.json({ success: true, notifications });
  } catch (error) {
    console.error("Error fetching notification history:", error);
    return res.status(500).json({ error: "Failed to fetch history" });
  }
});
router29.post("/:notificationId/acknowledge", authenticateToken, async (req, res) => {
  try {
    const userId = req.user?.id;
    const { notificationId } = req.params;
    if (!userId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const notification = await lateArrivalService.getLateNotificationById(notificationId);
    if (!notification) {
      return res.status(404).json({ error: "Notification not found" });
    }
    const userSalons = await rbacService.getSalonsForUser(userId);
    const allowedRoles = ["business_owner", "owner", "manager", "shop_admin"];
    const salonAccess = userSalons.find((s) => s.salonId === notification.salonId);
    if (!salonAccess || !allowedRoles.includes(salonAccess.role)) {
      return res.status(403).json({ error: "Not authorized to acknowledge this notification" });
    }
    const validatedInput = acknowledgeLateArrivalSchema.parse(req.body);
    const result = await lateArrivalService.acknowledgeLateArrival(
      notificationId,
      userId,
      validatedInput
    );
    if (!result.success) {
      return res.status(400).json({ error: result.error });
    }
    return res.json({
      success: true,
      message: "Notification acknowledged",
      notification: result.notification
    });
  } catch (error) {
    if (error instanceof z20.ZodError) {
      return res.status(400).json({ error: "Invalid input", details: error.errors });
    }
    console.error("Error acknowledging notification:", error);
    return res.status(500).json({ error: "Failed to acknowledge notification" });
  }
});
var late_arrival_routes_default = router29;
var mobileRouter = Router28();
mobileRouter.get("/delay-options", (req, res) => {
  res.json({
    success: true,
    options: LATE_ARRIVAL_DELAY_OPTIONS
  });
});
mobileRouter.get("/bookings/:bookingId/can-notify", authenticateMobileUser, async (req, res) => {
  try {
    const userId = req.user?.id;
    const { bookingId } = req.params;
    if (!userId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const result = await lateArrivalService.canSendLateNotification(userId, bookingId);
    return res.json(result);
  } catch (error) {
    console.error("Error checking late notification eligibility:", error);
    return res.status(500).json({ error: "Failed to check eligibility" });
  }
});
mobileRouter.post("/notify", authenticateMobileUser, async (req, res) => {
  try {
    const userId = req.user?.id;
    if (!userId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const validatedInput = createLateArrivalNotificationSchema.parse(req.body);
    const result = await lateArrivalService.createLateNotification(userId, validatedInput);
    if (!result.success) {
      return res.status(400).json({ error: result.error });
    }
    return res.status(201).json({
      success: true,
      message: "Late arrival notification sent to salon",
      notification: result.notification
    });
  } catch (error) {
    if (error instanceof z20.ZodError) {
      return res.status(400).json({ error: "Invalid input", details: error.errors });
    }
    console.error("Error creating late notification:", error);
    return res.status(500).json({ error: "Failed to send notification" });
  }
});
mobileRouter.get("/customer/history", authenticateMobileUser, async (req, res) => {
  try {
    const userId = req.user?.id;
    if (!userId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const notifications = await lateArrivalService.getCustomerLateNotificationHistory(userId);
    return res.json({ success: true, notifications });
  } catch (error) {
    console.error("Error fetching customer notification history:", error);
    return res.status(500).json({ error: "Failed to fetch history" });
  }
});

// server/routes/serviceBundle.routes.ts
import { Router as Router29 } from "express";
init_rbacService();
init_schema();
import { z as z21 } from "zod";
var router30 = Router29();
router30.get("/categories", (req, res) => {
  res.json({
    success: true,
    categories: SERVICE_PACKAGE_CATEGORIES
  });
});
router30.get("/salons/:salonId/packages", async (req, res) => {
  try {
    const { salonId } = req.params;
    const { category, gender, featured } = req.query;
    const packages = await serviceBundleService.getPackagesForSalon(salonId, {
      category,
      gender,
      featured: featured === "true",
      activeOnly: true
    });
    const categories = [...new Set(packages.map((p) => p.category).filter(Boolean))];
    return res.json({
      success: true,
      packages,
      categories,
      totalCount: packages.length
    });
  } catch (error) {
    console.error("Error fetching packages:", error);
    return res.status(500).json({ error: "Failed to fetch packages" });
  }
});
router30.get("/packages/:packageId", async (req, res) => {
  try {
    const { packageId } = req.params;
    const pkg = await serviceBundleService.getPackageById(packageId);
    if (!pkg) {
      return res.status(404).json({ error: "Package not found" });
    }
    return res.json({
      success: true,
      package: pkg
    });
  } catch (error) {
    console.error("Error fetching package:", error);
    return res.status(500).json({ error: "Failed to fetch package" });
  }
});
router30.get("/packages/:packageId/availability", async (req, res) => {
  try {
    const { packageId } = req.params;
    const { date, time } = req.query;
    if (!date || !time) {
      return res.status(400).json({ error: "Date and time are required" });
    }
    const availability = await serviceBundleService.checkPackageAvailability(
      packageId,
      date,
      time
    );
    return res.json({
      success: true,
      ...availability
    });
  } catch (error) {
    console.error("Error checking availability:", error);
    return res.status(500).json({ error: "Failed to check availability" });
  }
});
router30.post("/salons/:salonId/packages", authenticateToken, requireSalonAccess(), async (req, res) => {
  try {
    const userId = req.user?.id;
    const { salonId } = req.params;
    if (!userId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const userSalons = await rbacService.getSalonsForUser(userId);
    const salonAccess = userSalons.find((s) => s.salonId === salonId);
    const allowedRoles = ["business_owner", "owner", "manager", "shop_admin"];
    if (!salonAccess || !allowedRoles.includes(salonAccess.role)) {
      return res.status(403).json({ error: "Not authorized to create packages for this salon" });
    }
    const validatedInput = createServicePackageSchema.parse(req.body);
    const result = await serviceBundleService.createPackage(salonId, {
      ...validatedInput,
      validFrom: validatedInput.validFrom ? new Date(validatedInput.validFrom) : null,
      validUntil: validatedInput.validUntil ? new Date(validatedInput.validUntil) : null
    });
    if (!result.success) {
      return res.status(400).json({ error: result.error });
    }
    return res.status(201).json({
      success: true,
      message: "Package created successfully",
      package: result.package
    });
  } catch (error) {
    if (error instanceof z21.ZodError) {
      return res.status(400).json({ error: "Invalid input", details: error.errors });
    }
    console.error("Error creating package:", error);
    return res.status(500).json({ error: "Failed to create package" });
  }
});
router30.put("/packages/:packageId", authenticateToken, async (req, res) => {
  try {
    const userId = req.user?.id;
    const { packageId } = req.params;
    if (!userId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const pkg = await serviceBundleService.getPackageById(packageId);
    if (!pkg) {
      return res.status(404).json({ error: "Package not found" });
    }
    const userSalons = await rbacService.getSalonsForUser(userId);
    const salonAccess = userSalons.find((s) => s.salonId === pkg.salonId);
    const allowedRoles = ["business_owner", "owner", "manager", "shop_admin"];
    if (!salonAccess || !allowedRoles.includes(salonAccess.role)) {
      return res.status(403).json({ error: "Not authorized to update this package" });
    }
    const validatedInput = updateServicePackageSchema.parse(req.body);
    const result = await serviceBundleService.updatePackage(packageId, pkg.salonId, {
      ...validatedInput,
      validFrom: validatedInput.validFrom ? new Date(validatedInput.validFrom) : void 0,
      validUntil: validatedInput.validUntil ? new Date(validatedInput.validUntil) : void 0
    });
    if (!result.success) {
      return res.status(400).json({ error: result.error });
    }
    return res.json({
      success: true,
      message: "Package updated successfully",
      package: result.package
    });
  } catch (error) {
    if (error instanceof z21.ZodError) {
      return res.status(400).json({ error: "Invalid input", details: error.errors });
    }
    console.error("Error updating package:", error);
    return res.status(500).json({ error: "Failed to update package" });
  }
});
router30.delete("/packages/:packageId", authenticateToken, async (req, res) => {
  try {
    const userId = req.user?.id;
    const { packageId } = req.params;
    if (!userId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const pkg = await serviceBundleService.getPackageById(packageId);
    if (!pkg) {
      return res.status(404).json({ error: "Package not found" });
    }
    const userSalons = await rbacService.getSalonsForUser(userId);
    const salonAccess = userSalons.find((s) => s.salonId === pkg.salonId);
    const allowedRoles = ["business_owner", "owner", "manager"];
    if (!salonAccess || !allowedRoles.includes(salonAccess.role)) {
      return res.status(403).json({ error: "Not authorized to delete this package" });
    }
    const result = await serviceBundleService.deletePackage(packageId, pkg.salonId);
    if (!result.success) {
      return res.status(400).json({ error: result.error });
    }
    return res.json({
      success: true,
      message: "Package deactivated successfully"
    });
  } catch (error) {
    console.error("Error deleting package:", error);
    return res.status(500).json({ error: "Failed to delete package" });
  }
});
router30.get("/salons/:salonId/packages/manage", authenticateToken, requireSalonAccess(), async (req, res) => {
  try {
    const { salonId } = req.params;
    const packages = await serviceBundleService.getPackagesForSalon(salonId, {
      activeOnly: false,
      includeExpired: true
    });
    return res.json({
      success: true,
      packages,
      categories: SERVICE_PACKAGE_CATEGORIES
    });
  } catch (error) {
    console.error("Error fetching packages for management:", error);
    return res.status(500).json({ error: "Failed to fetch packages" });
  }
});
router30.get("/salons/:salonId/packages/analytics", authenticateToken, requireSalonAccess(), async (req, res) => {
  try {
    const { salonId } = req.params;
    const analytics = await serviceBundleService.getPackageAnalytics(salonId);
    return res.json({
      success: true,
      ...analytics
    });
  } catch (error) {
    console.error("Error fetching package analytics:", error);
    return res.status(500).json({ error: "Failed to fetch analytics" });
  }
});
router30.post("/packages/book", authenticateToken, async (req, res) => {
  try {
    const parsed = bookPackageSchema.safeParse(req.body);
    if (!parsed.success) {
      return res.status(400).json({
        error: "Invalid booking data",
        details: parsed.error.errors
      });
    }
    const { packageId, salonId, date, time, staffId, notes } = parsed.data;
    if (!req.body.customerName || !req.body.customerEmail || !req.body.customerPhone) {
      return res.status(400).json({ error: "Customer name, email, and phone are required" });
    }
    const result = await serviceBundleService.bookPackage({
      packageId,
      salonId,
      userId: req.user?.id,
      customerName: req.body.customerName,
      customerEmail: req.body.customerEmail,
      customerPhone: req.body.customerPhone,
      date,
      time,
      staffId,
      notes
    });
    if (!result.success) {
      return res.status(400).json({ error: result.error });
    }
    return res.status(201).json({
      success: true,
      booking: result.booking,
      packageBooking: result.packageBooking,
      message: "Package booked successfully"
    });
  } catch (error) {
    console.error("Error booking package:", error);
    return res.status(500).json({ error: "Failed to book package" });
  }
});
var serviceBundle_routes_default = router30;
var mobileRouter2 = Router29();
mobileRouter2.get("/categories", (req, res) => {
  res.json({
    success: true,
    categories: SERVICE_PACKAGE_CATEGORIES
  });
});
mobileRouter2.get("/salons/:salonId/packages", async (req, res) => {
  try {
    const { salonId } = req.params;
    const { category, gender, featured } = req.query;
    const packages = await serviceBundleService.getPackagesForSalon(salonId, {
      category,
      gender,
      featured: featured === "true",
      activeOnly: true
    });
    const categories = [...new Set(packages.map((p) => p.category).filter(Boolean))];
    return res.json({
      success: true,
      packages,
      categories,
      totalCount: packages.length
    });
  } catch (error) {
    console.error("Error fetching packages:", error);
    return res.status(500).json({ error: "Failed to fetch packages" });
  }
});
mobileRouter2.get("/packages/:packageId", async (req, res) => {
  try {
    const { packageId } = req.params;
    const pkg = await serviceBundleService.getPackageById(packageId);
    if (!pkg) {
      return res.status(404).json({ error: "Package not found" });
    }
    return res.json({
      success: true,
      package: pkg
    });
  } catch (error) {
    console.error("Error fetching package:", error);
    return res.status(500).json({ error: "Failed to fetch package" });
  }
});
mobileRouter2.get("/packages/:packageId/availability", authenticateMobileUser, async (req, res) => {
  try {
    const { packageId } = req.params;
    const { date, time } = req.query;
    if (!date || !time) {
      return res.status(400).json({ error: "Date and time are required" });
    }
    const availability = await serviceBundleService.checkPackageAvailability(
      packageId,
      date,
      time
    );
    return res.json({
      success: true,
      ...availability
    });
  } catch (error) {
    console.error("Error checking availability:", error);
    return res.status(500).json({ error: "Failed to check availability" });
  }
});
mobileRouter2.post("/packages/book", authenticateMobileUser, async (req, res) => {
  try {
    const parsed = bookPackageSchema.safeParse(req.body);
    if (!parsed.success) {
      return res.status(400).json({
        error: "Invalid booking data",
        details: parsed.error.errors
      });
    }
    const { packageId, salonId, date, time, staffId, notes } = parsed.data;
    if (!req.body.customerName || !req.body.customerEmail || !req.body.customerPhone) {
      return res.status(400).json({ error: "Customer name, email, and phone are required" });
    }
    const result = await serviceBundleService.bookPackage({
      packageId,
      salonId,
      userId: req.user?.id,
      customerName: req.body.customerName,
      customerEmail: req.body.customerEmail,
      customerPhone: req.body.customerPhone,
      date,
      time,
      staffId,
      notes
    });
    if (!result.success) {
      return res.status(400).json({ error: result.error });
    }
    return res.status(201).json({
      success: true,
      booking: result.booking,
      packageBooking: result.packageBooking,
      message: "Package booked successfully"
    });
  } catch (error) {
    console.error("Error booking package:", error);
    return res.status(500).json({ error: "Failed to book package" });
  }
});

// server/routes/departure-alerts.routes.ts
init_db();
init_schema();
import { Router as Router30 } from "express";
import { eq as eq54 } from "drizzle-orm";
var router31 = Router30();
router31.get("/bookings/:bookingId/departure-status", authenticateToken, async (req, res) => {
  try {
    const userId = req.user?.id;
    const { bookingId } = req.params;
    if (!userId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    if (!bookingId) {
      return res.status(400).json({ error: "Booking ID is required" });
    }
    const booking = await db.query.bookings.findFirst({
      where: eq54(bookings.id, bookingId)
    });
    if (!booking) {
      return res.status(404).json({ error: "Booking not found" });
    }
    if (booking.userId !== userId) {
      return res.status(403).json({ error: "Access denied - not your booking" });
    }
    const status = await departureCalculatorService.getDepartureStatusForBooking(bookingId);
    if (!status) {
      return res.status(404).json({ error: "Unable to calculate departure status for this booking" });
    }
    return res.json(status);
  } catch (error) {
    console.error("Error getting departure status:", error);
    return res.status(500).json({ error: "Failed to get departure status" });
  }
});
router31.get("/departure-alerts", authenticateToken, async (req, res) => {
  try {
    const userId = req.user?.id;
    if (!userId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const { date } = req.query;
    const alerts = await departureNotificationService.getAlertsForUser(userId, date);
    return res.json({ alerts });
  } catch (error) {
    console.error("Error getting departure alerts:", error);
    return res.status(500).json({ error: "Failed to get departure alerts" });
  }
});
router31.post("/departure-alerts/:alertId/acknowledge", authenticateToken, async (req, res) => {
  try {
    const userId = req.user?.id;
    if (!userId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const { alertId } = req.params;
    const parseResult = acknowledgeDepartureAlertSchema.safeParse(req.body);
    if (!parseResult.success) {
      return res.status(400).json({
        error: "Invalid request body",
        details: parseResult.error.flatten()
      });
    }
    const { response, actualDepartureTime } = parseResult.data;
    const success = await departureNotificationService.acknowledgeAlert(
      alertId,
      userId,
      response,
      actualDepartureTime
    );
    if (!success) {
      return res.status(404).json({ error: "Alert not found or access denied" });
    }
    return res.json({ success: true, message: "Alert acknowledged" });
  } catch (error) {
    console.error("Error acknowledging alert:", error);
    return res.status(500).json({ error: "Failed to acknowledge alert" });
  }
});
router31.get("/customers/departure-preferences", authenticateToken, async (req, res) => {
  try {
    const userId = req.user?.id;
    if (!userId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const prefs = await db.query.customerDeparturePreferences.findFirst({
      where: eq54(customerDeparturePreferences.userId, userId)
    });
    if (!prefs) {
      return res.json({
        receiveAlerts: true,
        defaultLocationLabel: "home",
        preferredBufferMinutes: 15,
        reminderTimingPreference: "60_minutes",
        preferredChannel: "push",
        quietHoursStart: null,
        quietHoursEnd: null
      });
    }
    return res.json({
      receiveAlerts: prefs.receiveAlerts === 1,
      defaultLocationLabel: prefs.defaultLocationLabel,
      preferredBufferMinutes: prefs.preferredBufferMinutes,
      reminderTimingPreference: prefs.reminderTimingPreference,
      preferredChannel: prefs.preferredChannel,
      quietHoursStart: prefs.quietHoursStart,
      quietHoursEnd: prefs.quietHoursEnd
    });
  } catch (error) {
    console.error("Error getting departure preferences:", error);
    return res.status(500).json({ error: "Failed to get departure preferences" });
  }
});
router31.put("/customers/departure-preferences", authenticateToken, async (req, res) => {
  try {
    const userId = req.user?.id;
    if (!userId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const parseResult = updateDeparturePreferencesSchema.safeParse(req.body);
    if (!parseResult.success) {
      return res.status(400).json({
        error: "Invalid request body",
        details: parseResult.error.flatten()
      });
    }
    const data = parseResult.data;
    const existing = await db.query.customerDeparturePreferences.findFirst({
      where: eq54(customerDeparturePreferences.userId, userId)
    });
    const updateData = {
      receiveAlerts: data.receiveAlerts !== void 0 ? data.receiveAlerts ? 1 : 0 : void 0,
      defaultLocationLabel: data.defaultLocationLabel,
      preferredBufferMinutes: data.preferredBufferMinutes,
      reminderTimingPreference: data.reminderTimingPreference,
      preferredChannel: data.preferredChannel,
      quietHoursStart: data.quietHoursStart,
      quietHoursEnd: data.quietHoursEnd,
      updatedAt: /* @__PURE__ */ new Date()
    };
    Object.keys(updateData).forEach((key) => {
      if (updateData[key] === void 0) {
        delete updateData[key];
      }
    });
    if (existing) {
      await db.update(customerDeparturePreferences).set(updateData).where(eq54(customerDeparturePreferences.id, existing.id));
    } else {
      await db.insert(customerDeparturePreferences).values({
        userId,
        receiveAlerts: data.receiveAlerts !== void 0 ? data.receiveAlerts ? 1 : 0 : 1,
        defaultLocationLabel: data.defaultLocationLabel || "home",
        preferredBufferMinutes: data.preferredBufferMinutes || 15,
        reminderTimingPreference: data.reminderTimingPreference || "60_minutes",
        preferredChannel: data.preferredChannel || "push",
        quietHoursStart: data.quietHoursStart || null,
        quietHoursEnd: data.quietHoursEnd || null
      });
    }
    return res.json({ success: true, message: "Preferences updated" });
  } catch (error) {
    console.error("Error updating departure preferences:", error);
    return res.status(500).json({ error: "Failed to update departure preferences" });
  }
});
router31.get("/salons/:salonId/queue-status", authenticateToken, async (req, res) => {
  try {
    const { salonId } = req.params;
    const { date } = req.query;
    if (!salonId) {
      return res.status(400).json({ error: "Salon ID is required" });
    }
    const status = await queueCalculatorService.getSalonQueueStatus(salonId, date);
    if (!status) {
      return res.status(404).json({ error: "Salon not found or no staff available" });
    }
    return res.json(status);
  } catch (error) {
    console.error("Error getting salon queue status:", error);
    return res.status(500).json({ error: "Failed to get salon queue status" });
  }
});
router31.get("/staff/:staffId/queue-status", authenticateToken, async (req, res) => {
  try {
    const { staffId } = req.params;
    const { date } = req.query;
    if (!staffId) {
      return res.status(400).json({ error: "Staff ID is required" });
    }
    const status = await queueCalculatorService.getStaffQueueStatus(staffId, date);
    if (!status) {
      return res.status(404).json({ error: "Staff not found" });
    }
    return res.json(status);
  } catch (error) {
    console.error("Error getting staff queue status:", error);
    return res.status(500).json({ error: "Failed to get staff queue status" });
  }
});
router31.get("/salons/:salonId/departure-settings", authenticateToken, requireSalonAccess(), async (req, res) => {
  try {
    const { salonId } = req.params;
    if (!salonId) {
      return res.status(400).json({ error: "Salon ID is required" });
    }
    const settings = await departureCalculatorService.getSalonDepartureSettings(salonId);
    return res.json(settings);
  } catch (error) {
    console.error("Error getting salon departure settings:", error);
    return res.status(500).json({ error: "Failed to get departure settings" });
  }
});
router31.put("/salons/:salonId/departure-settings", authenticateToken, requireSalonAccess(), async (req, res) => {
  try {
    const { salonId } = req.params;
    if (!salonId) {
      return res.status(400).json({ error: "Salon ID is required" });
    }
    const parseResult = updateSalonDepartureSettingsSchema.safeParse(req.body);
    if (!parseResult.success) {
      return res.status(400).json({
        error: "Invalid request body",
        details: parseResult.error.flatten()
      });
    }
    const data = parseResult.data;
    const existing = await db.query.departureAlertSettings.findFirst({
      where: eq54(departureAlertSettings.salonId, salonId)
    });
    const updateData = {
      isEnabled: data.isEnabled !== void 0 ? data.isEnabled ? 1 : 0 : void 0,
      firstAlertMinutesBefore: data.firstAlertMinutesBefore,
      updateIntervalMinutes: data.updateIntervalMinutes,
      minDelayToNotify: data.minDelayToNotify,
      defaultBufferMinutes: data.defaultBufferMinutes,
      enablePushNotifications: data.enablePushNotifications !== void 0 ? data.enablePushNotifications ? 1 : 0 : void 0,
      enableSmsNotifications: data.enableSmsNotifications !== void 0 ? data.enableSmsNotifications ? 1 : 0 : void 0,
      enableWhatsappNotifications: data.enableWhatsappNotifications !== void 0 ? data.enableWhatsappNotifications ? 1 : 0 : void 0,
      useTrafficData: data.useTrafficData !== void 0 ? data.useTrafficData ? 1 : 0 : void 0,
      considerHistoricalOverrun: data.considerHistoricalOverrun !== void 0 ? data.considerHistoricalOverrun ? 1 : 0 : void 0,
      autoReassignStaff: data.autoReassignStaff !== void 0 ? data.autoReassignStaff ? 1 : 0 : void 0,
      updatedAt: /* @__PURE__ */ new Date()
    };
    Object.keys(updateData).forEach((key) => {
      if (updateData[key] === void 0) {
        delete updateData[key];
      }
    });
    if (existing) {
      await db.update(departureAlertSettings).set(updateData).where(eq54(departureAlertSettings.id, existing.id));
    } else {
      await db.insert(departureAlertSettings).values({
        salonId,
        isEnabled: data.isEnabled !== void 0 ? data.isEnabled ? 1 : 0 : 1,
        firstAlertMinutesBefore: data.firstAlertMinutesBefore || 60,
        updateIntervalMinutes: data.updateIntervalMinutes || 15,
        minDelayToNotify: data.minDelayToNotify || 10,
        defaultBufferMinutes: data.defaultBufferMinutes || 10,
        enablePushNotifications: data.enablePushNotifications !== void 0 ? data.enablePushNotifications ? 1 : 0 : 1,
        enableSmsNotifications: data.enableSmsNotifications !== void 0 ? data.enableSmsNotifications ? 1 : 0 : 0,
        enableWhatsappNotifications: data.enableWhatsappNotifications !== void 0 ? data.enableWhatsappNotifications ? 1 : 0 : 0,
        useTrafficData: data.useTrafficData !== void 0 ? data.useTrafficData ? 1 : 0 : 0,
        considerHistoricalOverrun: data.considerHistoricalOverrun !== void 0 ? data.considerHistoricalOverrun ? 1 : 0 : 1,
        autoReassignStaff: data.autoReassignStaff !== void 0 ? data.autoReassignStaff ? 1 : 0 : 0
      });
    }
    return res.json({ success: true, message: "Settings updated" });
  } catch (error) {
    console.error("Error updating salon departure settings:", error);
    return res.status(500).json({ error: "Failed to update departure settings" });
  }
});
var mobileDepartureAlertsRouter = Router30();
mobileDepartureAlertsRouter.get("/departure-status/:bookingId", authenticateMobileUser, async (req, res) => {
  try {
    const userId = req.userId;
    const { bookingId } = req.params;
    if (!userId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    if (!bookingId) {
      return res.status(400).json({ error: "Booking ID is required" });
    }
    const booking = await db.query.bookings.findFirst({
      where: eq54(bookings.id, bookingId)
    });
    if (!booking) {
      return res.status(404).json({ error: "Booking not found" });
    }
    if (booking.userId !== userId) {
      return res.status(403).json({ error: "Access denied - not your booking" });
    }
    const status = await departureCalculatorService.getDepartureStatusForBooking(bookingId);
    if (!status) {
      return res.status(404).json({ success: false, error: "Unable to calculate departure status for this booking" });
    }
    return res.json({ success: true, status });
  } catch (error) {
    console.error("Error getting departure status:", error);
    return res.status(500).json({ success: false, error: "Failed to get departure status" });
  }
});
mobileDepartureAlertsRouter.get("/alerts", authenticateMobileUser, async (req, res) => {
  try {
    const userId = req.userId;
    if (!userId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const { date } = req.query;
    const alerts = await departureNotificationService.getAlertsForUser(userId, date);
    return res.json({ alerts });
  } catch (error) {
    console.error("Error getting departure alerts:", error);
    return res.status(500).json({ error: "Failed to get departure alerts" });
  }
});
mobileDepartureAlertsRouter.post("/alerts/:alertId/acknowledge", authenticateMobileUser, async (req, res) => {
  try {
    const userId = req.userId;
    if (!userId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const { alertId } = req.params;
    const parseResult = acknowledgeDepartureAlertSchema.safeParse(req.body);
    if (!parseResult.success) {
      return res.status(400).json({
        error: "Invalid request body",
        details: parseResult.error.flatten()
      });
    }
    const { response, actualDepartureTime } = parseResult.data;
    const success = await departureNotificationService.acknowledgeAlert(
      alertId,
      userId,
      response,
      actualDepartureTime
    );
    if (!success) {
      return res.status(404).json({ error: "Alert not found or access denied" });
    }
    return res.json({ success: true, message: "Alert acknowledged" });
  } catch (error) {
    console.error("Error acknowledging alert:", error);
    return res.status(500).json({ error: "Failed to acknowledge alert" });
  }
});
mobileDepartureAlertsRouter.get("/preferences", authenticateMobileUser, async (req, res) => {
  try {
    const userId = req.userId;
    if (!userId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const prefs = await db.query.customerDeparturePreferences.findFirst({
      where: eq54(customerDeparturePreferences.userId, userId)
    });
    if (!prefs) {
      return res.json({
        success: true,
        preferences: {
          receiveAlerts: true,
          defaultLocationLabel: "home",
          preferredBufferMinutes: 15,
          reminderTimingPreference: "60_minutes",
          preferredChannel: "push",
          quietHoursStart: null,
          quietHoursEnd: null
        }
      });
    }
    return res.json({
      success: true,
      preferences: {
        receiveAlerts: prefs.receiveAlerts === 1,
        defaultLocationLabel: prefs.defaultLocationLabel,
        preferredBufferMinutes: prefs.preferredBufferMinutes,
        reminderTimingPreference: prefs.reminderTimingPreference,
        preferredChannel: prefs.preferredChannel,
        quietHoursStart: prefs.quietHoursStart,
        quietHoursEnd: prefs.quietHoursEnd
      }
    });
  } catch (error) {
    console.error("Error getting departure preferences:", error);
    return res.status(500).json({ success: false, error: "Failed to get departure preferences" });
  }
});
mobileDepartureAlertsRouter.put("/preferences", authenticateMobileUser, async (req, res) => {
  try {
    const userId = req.userId;
    if (!userId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const parseResult = updateDeparturePreferencesSchema.safeParse(req.body);
    if (!parseResult.success) {
      return res.status(400).json({
        error: "Invalid request body",
        details: parseResult.error.flatten()
      });
    }
    const data = parseResult.data;
    const existing = await db.query.customerDeparturePreferences.findFirst({
      where: eq54(customerDeparturePreferences.userId, userId)
    });
    const updateData = {
      receiveAlerts: data.receiveAlerts !== void 0 ? data.receiveAlerts ? 1 : 0 : void 0,
      defaultLocationLabel: data.defaultLocationLabel,
      preferredBufferMinutes: data.preferredBufferMinutes,
      reminderTimingPreference: data.reminderTimingPreference,
      preferredChannel: data.preferredChannel,
      quietHoursStart: data.quietHoursStart,
      quietHoursEnd: data.quietHoursEnd,
      updatedAt: /* @__PURE__ */ new Date()
    };
    Object.keys(updateData).forEach((key) => {
      if (updateData[key] === void 0) {
        delete updateData[key];
      }
    });
    if (existing) {
      await db.update(customerDeparturePreferences).set(updateData).where(eq54(customerDeparturePreferences.id, existing.id));
    } else {
      await db.insert(customerDeparturePreferences).values({
        userId,
        receiveAlerts: data.receiveAlerts !== void 0 ? data.receiveAlerts ? 1 : 0 : 1,
        defaultLocationLabel: data.defaultLocationLabel || "home",
        preferredBufferMinutes: data.preferredBufferMinutes || 15,
        reminderTimingPreference: data.reminderTimingPreference || "60_minutes",
        preferredChannel: data.preferredChannel || "push",
        quietHoursStart: data.quietHoursStart || null,
        quietHoursEnd: data.quietHoursEnd || null
      });
    }
    const updatedPrefs = await db.query.customerDeparturePreferences.findFirst({
      where: eq54(customerDeparturePreferences.userId, userId)
    });
    return res.json({
      success: true,
      message: "Preferences updated",
      preferences: updatedPrefs ? {
        receiveAlerts: updatedPrefs.receiveAlerts === 1,
        defaultLocationLabel: updatedPrefs.defaultLocationLabel,
        preferredBufferMinutes: updatedPrefs.preferredBufferMinutes,
        reminderTimingPreference: updatedPrefs.reminderTimingPreference,
        preferredChannel: updatedPrefs.preferredChannel,
        quietHoursStart: updatedPrefs.quietHoursStart,
        quietHoursEnd: updatedPrefs.quietHoursEnd
      } : null
    });
  } catch (error) {
    console.error("Error updating departure preferences:", error);
    return res.status(500).json({ success: false, error: "Failed to update departure preferences" });
  }
});
var departure_alerts_routes_default = router31;

// server/routes/membership.routes.ts
import { Router as Router31 } from "express";

// server/services/membership.service.ts
init_db();
init_schema();
import { eq as eq55, and as and53, desc as desc38, sql as sql42, gte as gte28, lte as lte22, count as count9, sum as sum3 } from "drizzle-orm";
var MembershipService = class {
  async createPlan(salonId, input) {
    try {
      const { includedServices, ...planData } = input;
      if (planData.planType === "packaged" && (!includedServices || includedServices.length === 0)) {
        return { success: false, error: "Packaged plans must include at least one service" };
      }
      if (planData.planType === "discount") {
        if (!planData.discountPercentage) {
          return { success: false, error: "Discount plans must specify a discount percentage" };
        }
        if (planData.discountPercentage < 1 || planData.discountPercentage > 100) {
          return { success: false, error: "Discount percentage must be between 1 and 100" };
        }
      }
      if (planData.planType === "credit" && !planData.creditAmountInPaisa) {
        return { success: false, error: "Credit plans must specify a credit amount" };
      }
      if (includedServices && includedServices.length > 0) {
        const serviceIds = includedServices.map((s) => s.serviceId);
        const salonServices = await db.select({ id: services.id }).from(services).where(and53(
          eq55(services.salonId, salonId),
          sql42`${services.id} = ANY(${serviceIds})`
        ));
        const validServiceIds = new Set(salonServices.map((s) => s.id));
        const invalidServices = serviceIds.filter((id) => !validServiceIds.has(id));
        if (invalidServices.length > 0) {
          return { success: false, error: `Services not found in this salon: ${invalidServices.join(", ")}` };
        }
      }
      const [plan] = await db.insert(membershipPlans).values({
        ...planData,
        salonId
      }).returning();
      if (includedServices && includedServices.length > 0 && planData.planType === "packaged") {
        const serviceEntries = includedServices.map((s) => ({
          planId: plan.id,
          serviceId: s.serviceId,
          salonId,
          quantityPerMonth: s.quantityPerMonth,
          isUnlimited: s.isUnlimited ? 1 : 0
        }));
        await db.insert(membershipPlanServices).values(serviceEntries);
      }
      return { success: true, plan };
    } catch (error) {
      console.error("Error creating membership plan:", error);
      return { success: false, error: "Failed to create membership plan" };
    }
  }
  async getPlansForSalon(salonId, options = {}) {
    const { activeOnly = true, includeServices = true } = options;
    let whereClause = eq55(membershipPlans.salonId, salonId);
    if (activeOnly) {
      whereClause = and53(eq55(membershipPlans.salonId, salonId), eq55(membershipPlans.isActive, 1));
    }
    const plans = await db.select().from(membershipPlans).where(whereClause).orderBy(membershipPlans.sortOrder);
    if (includeServices) {
      const plansWithServices = await Promise.all(
        plans.map(async (plan) => {
          if (plan.planType === "packaged") {
            const includedServices = await db.select({
              id: membershipPlanServices.id,
              serviceId: membershipPlanServices.serviceId,
              quantityPerMonth: membershipPlanServices.quantityPerMonth,
              isUnlimited: membershipPlanServices.isUnlimited,
              serviceName: services.name,
              servicePrice: services.priceInPaisa
            }).from(membershipPlanServices).leftJoin(services, eq55(membershipPlanServices.serviceId, services.id)).where(eq55(membershipPlanServices.planId, plan.id));
            return { ...plan, includedServices };
          }
          return plan;
        })
      );
      return plansWithServices;
    }
    return plans;
  }
  async getPlanById(planId) {
    const [plan] = await db.select().from(membershipPlans).where(eq55(membershipPlans.id, planId));
    if (!plan) return null;
    if (plan.planType === "packaged") {
      const includedServices = await db.select({
        id: membershipPlanServices.id,
        serviceId: membershipPlanServices.serviceId,
        quantityPerMonth: membershipPlanServices.quantityPerMonth,
        isUnlimited: membershipPlanServices.isUnlimited,
        serviceName: services.name,
        servicePrice: services.priceInPaisa
      }).from(membershipPlanServices).leftJoin(services, eq55(membershipPlanServices.serviceId, services.id)).where(eq55(membershipPlanServices.planId, plan.id));
      return { ...plan, includedServices };
    }
    return plan;
  }
  async updatePlan(planId, salonId, input) {
    try {
      const { includedServices, ...planData } = input;
      const [existingPlan] = await db.select().from(membershipPlans).where(and53(eq55(membershipPlans.id, planId), eq55(membershipPlans.salonId, salonId)));
      if (!existingPlan) {
        return { success: false, error: "Plan not found" };
      }
      const effectivePlanType = planData.planType || existingPlan.planType;
      if (effectivePlanType === "packaged") {
        if (includedServices !== void 0 && includedServices.length === 0) {
          return { success: false, error: "Packaged plans must include at least one service" };
        }
        if (planData.planType === "packaged" && existingPlan.planType !== "packaged" && (!includedServices || includedServices.length === 0)) {
          return { success: false, error: "Packaged plans must include at least one service" };
        }
      }
      if (effectivePlanType === "discount") {
        const effectiveDiscount = planData.discountPercentage ?? existingPlan.discountPercentage;
        if (!effectiveDiscount) {
          return { success: false, error: "Discount plans must specify a discount percentage" };
        }
        if (planData.discountPercentage !== void 0 && (planData.discountPercentage < 1 || planData.discountPercentage > 100)) {
          return { success: false, error: "Discount percentage must be between 1 and 100" };
        }
      }
      if (effectivePlanType === "credit") {
        const effectiveCredit = planData.creditAmountInPaisa ?? existingPlan.creditAmountInPaisa;
        if (!effectiveCredit) {
          return { success: false, error: "Credit plans must specify a credit amount" };
        }
      }
      if (includedServices && includedServices.length > 0) {
        const serviceIds = includedServices.map((s) => s.serviceId);
        const salonServices = await db.select({ id: services.id }).from(services).where(and53(
          eq55(services.salonId, salonId),
          sql42`${services.id} = ANY(${serviceIds})`
        ));
        const validServiceIds = new Set(salonServices.map((s) => s.id));
        const invalidServices = serviceIds.filter((id) => !validServiceIds.has(id));
        if (invalidServices.length > 0) {
          return { success: false, error: `Services not found in this salon: ${invalidServices.join(", ")}` };
        }
      }
      const [updatedPlan] = await db.update(membershipPlans).set({
        ...planData,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq55(membershipPlans.id, planId)).returning();
      if (effectivePlanType === "packaged") {
        if (includedServices !== void 0) {
          await db.delete(membershipPlanServices).where(eq55(membershipPlanServices.planId, planId));
          if (includedServices.length > 0) {
            const serviceEntries = includedServices.map((s) => ({
              planId,
              serviceId: s.serviceId,
              salonId,
              quantityPerMonth: s.quantityPerMonth,
              isUnlimited: s.isUnlimited ? 1 : 0
            }));
            await db.insert(membershipPlanServices).values(serviceEntries);
          }
        }
      } else if (existingPlan.planType === "packaged" && planData.planType && planData.planType !== "packaged") {
        await db.delete(membershipPlanServices).where(eq55(membershipPlanServices.planId, planId));
      }
      return { success: true, plan: updatedPlan };
    } catch (error) {
      console.error("Error updating membership plan:", error);
      return { success: false, error: "Failed to update membership plan" };
    }
  }
  async deletePlan(planId, salonId) {
    try {
      const [existingPlan] = await db.select().from(membershipPlans).where(and53(eq55(membershipPlans.id, planId), eq55(membershipPlans.salonId, salonId)));
      if (!existingPlan) {
        return { success: false, error: "Plan not found" };
      }
      const activeMembers = await db.select({ count: count9() }).from(customerMemberships).where(and53(
        eq55(customerMemberships.planId, planId),
        eq55(customerMemberships.status, "active")
      ));
      if (activeMembers[0].count > 0) {
        await db.update(membershipPlans).set({ isActive: 0, updatedAt: /* @__PURE__ */ new Date() }).where(eq55(membershipPlans.id, planId));
        return { success: true };
      }
      await db.delete(membershipPlans).where(eq55(membershipPlans.id, planId));
      return { success: true };
    } catch (error) {
      console.error("Error deleting membership plan:", error);
      return { success: false, error: "Failed to delete membership plan" };
    }
  }
  async getMembersForSalon(salonId, options = {}) {
    const { status, limit = 50, offset = 0 } = options;
    let whereClause = eq55(customerMemberships.salonId, salonId);
    if (status) {
      whereClause = and53(whereClause, eq55(customerMemberships.status, status));
    }
    const members = await db.select({
      membership: customerMemberships,
      customer: {
        id: users.id,
        firstName: users.firstName,
        lastName: users.lastName,
        email: users.email,
        phone: users.phone,
        profileImageUrl: users.profileImageUrl
      },
      plan: {
        id: membershipPlans.id,
        name: membershipPlans.name,
        planType: membershipPlans.planType
      }
    }).from(customerMemberships).leftJoin(users, eq55(customerMemberships.customerId, users.id)).leftJoin(membershipPlans, eq55(customerMemberships.planId, membershipPlans.id)).where(whereClause).orderBy(desc38(customerMemberships.createdAt)).limit(limit).offset(offset);
    const [totalCount] = await db.select({ count: count9() }).from(customerMemberships).where(whereClause);
    return {
      members,
      totalCount: totalCount.count,
      limit,
      offset
    };
  }
  async getMembershipAnalytics(salonId) {
    const now = /* @__PURE__ */ new Date();
    const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1e3);
    const [activeMembersResult] = await db.select({ count: count9() }).from(customerMemberships).where(and53(
      eq55(customerMemberships.salonId, salonId),
      eq55(customerMemberships.status, "active")
    ));
    const [totalMembersResult] = await db.select({ count: count9() }).from(customerMemberships).where(eq55(customerMemberships.salonId, salonId));
    const [revenueResult] = await db.select({ total: sum3(membershipPayments.amountInPaisa) }).from(membershipPayments).where(and53(
      eq55(membershipPayments.salonId, salonId),
      eq55(membershipPayments.paymentStatus, "completed")
    ));
    const [monthlyRevenueResult] = await db.select({ total: sum3(membershipPayments.amountInPaisa) }).from(membershipPayments).where(and53(
      eq55(membershipPayments.salonId, salonId),
      eq55(membershipPayments.paymentStatus, "completed"),
      gte28(membershipPayments.paidAt, thirtyDaysAgo)
    ));
    const [newMembersResult] = await db.select({ count: count9() }).from(customerMemberships).where(and53(
      eq55(customerMemberships.salonId, salonId),
      gte28(customerMemberships.createdAt, thirtyDaysAgo)
    ));
    const [cancelledResult] = await db.select({ count: count9() }).from(customerMemberships).where(and53(
      eq55(customerMemberships.salonId, salonId),
      eq55(customerMemberships.status, "cancelled"),
      gte28(customerMemberships.cancelledAt, thirtyDaysAgo)
    ));
    const membersByPlan = await db.select({
      planId: membershipPlans.id,
      planName: membershipPlans.name,
      planType: membershipPlans.planType,
      count: count9()
    }).from(customerMemberships).leftJoin(membershipPlans, eq55(customerMemberships.planId, membershipPlans.id)).where(and53(
      eq55(customerMemberships.salonId, salonId),
      eq55(customerMemberships.status, "active")
    )).groupBy(membershipPlans.id, membershipPlans.name, membershipPlans.planType);
    const churnRate = totalMembersResult.count > 0 ? cancelledResult.count / totalMembersResult.count * 100 : 0;
    return {
      activeMembers: activeMembersResult.count,
      totalMembers: totalMembersResult.count,
      totalRevenue: revenueResult.total ? Number(revenueResult.total) : 0,
      monthlyRevenue: monthlyRevenueResult.total ? Number(monthlyRevenueResult.total) : 0,
      newMembersThisMonth: newMembersResult.count,
      cancelledThisMonth: cancelledResult.count,
      churnRate: Math.round(churnRate * 100) / 100,
      membersByPlan
    };
  }
  async getCustomerMemberships(customerId) {
    const memberships = await db.select({
      membership: customerMemberships,
      plan: {
        id: membershipPlans.id,
        name: membershipPlans.name,
        planType: membershipPlans.planType,
        durationMonths: membershipPlans.durationMonths,
        priceInPaisa: membershipPlans.priceInPaisa,
        discountPercentage: membershipPlans.discountPercentage,
        creditAmountInPaisa: membershipPlans.creditAmountInPaisa,
        bonusPercentage: membershipPlans.bonusPercentage,
        priorityBooking: membershipPlans.priorityBooking
      },
      salon: {
        id: salons.id,
        name: salons.name,
        address: salons.address,
        city: salons.city
      }
    }).from(customerMemberships).leftJoin(membershipPlans, eq55(customerMemberships.planId, membershipPlans.id)).leftJoin(salons, eq55(customerMemberships.salonId, salons.id)).where(eq55(customerMemberships.customerId, customerId)).orderBy(desc38(customerMemberships.createdAt));
    return memberships;
  }
  async getCustomerMembershipById(membershipId, customerId) {
    const [membership] = await db.select({
      membership: customerMemberships,
      plan: membershipPlans,
      salon: {
        id: salons.id,
        name: salons.name,
        address: salons.address
      }
    }).from(customerMemberships).leftJoin(membershipPlans, eq55(customerMemberships.planId, membershipPlans.id)).leftJoin(salons, eq55(customerMemberships.salonId, salons.id)).where(and53(
      eq55(customerMemberships.id, membershipId),
      eq55(customerMemberships.customerId, customerId)
    ));
    if (!membership) return null;
    if (membership.plan?.planType === "packaged") {
      const usage = await this.getServiceUsageForMembership(membershipId);
      return { ...membership, usage };
    }
    if (membership.plan?.planType === "credit") {
      const transactions = await db.select().from(membershipCreditTransactions).where(eq55(membershipCreditTransactions.membershipId, membershipId)).orderBy(desc38(membershipCreditTransactions.createdAt)).limit(10);
      return { ...membership, recentTransactions: transactions };
    }
    return membership;
  }
  async getServiceUsageForMembership(membershipId) {
    const currentMonth = /* @__PURE__ */ new Date();
    currentMonth.setDate(1);
    currentMonth.setHours(0, 0, 0, 0);
    const usage = await db.select({
      serviceId: membershipServiceUsage.serviceId,
      serviceName: services.name,
      quantityUsed: sql42`SUM(${membershipServiceUsage.quantityUsed})`.as("quantity_used")
    }).from(membershipServiceUsage).leftJoin(services, eq55(membershipServiceUsage.serviceId, services.id)).where(and53(
      eq55(membershipServiceUsage.membershipId, membershipId),
      gte28(membershipServiceUsage.usageMonth, currentMonth)
    )).groupBy(membershipServiceUsage.serviceId, services.name);
    return usage;
  }
  async pauseMembership(membershipId, customerId) {
    try {
      const [membership] = await db.select().from(customerMemberships).where(and53(
        eq55(customerMemberships.id, membershipId),
        eq55(customerMemberships.customerId, customerId)
      ));
      if (!membership) {
        return { success: false, error: "Membership not found" };
      }
      if (membership.status !== "active") {
        return { success: false, error: "Only active memberships can be paused" };
      }
      await db.update(customerMemberships).set({ status: "paused", pausedAt: /* @__PURE__ */ new Date(), updatedAt: /* @__PURE__ */ new Date() }).where(eq55(customerMemberships.id, membershipId));
      return { success: true };
    } catch (error) {
      console.error("Error pausing membership:", error);
      return { success: false, error: "Failed to pause membership" };
    }
  }
  async resumeMembership(membershipId, customerId) {
    try {
      const [membership] = await db.select().from(customerMemberships).where(and53(
        eq55(customerMemberships.id, membershipId),
        eq55(customerMemberships.customerId, customerId)
      ));
      if (!membership) {
        return { success: false, error: "Membership not found" };
      }
      if (membership.status !== "paused") {
        return { success: false, error: "Only paused memberships can be resumed" };
      }
      await db.update(customerMemberships).set({ status: "active", pausedAt: null, updatedAt: /* @__PURE__ */ new Date() }).where(eq55(customerMemberships.id, membershipId));
      return { success: true };
    } catch (error) {
      console.error("Error resuming membership:", error);
      return { success: false, error: "Failed to resume membership" };
    }
  }
  async cancelMembership(membershipId, customerId) {
    try {
      const [membership] = await db.select().from(customerMemberships).where(and53(
        eq55(customerMemberships.id, membershipId),
        eq55(customerMemberships.customerId, customerId)
      ));
      if (!membership) {
        return { success: false, error: "Membership not found" };
      }
      if (membership.status === "cancelled" || membership.status === "expired") {
        return { success: false, error: "Membership is already cancelled or expired" };
      }
      await db.update(customerMemberships).set({ status: "cancelled", cancelledAt: /* @__PURE__ */ new Date(), updatedAt: /* @__PURE__ */ new Date() }).where(eq55(customerMemberships.id, membershipId));
      await db.update(salons).set({
        activeMembersCount: sql42`GREATEST(COALESCE(${salons.activeMembersCount}, 0) - 1, 0)`,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq55(salons.id, membership.salonId));
      const [otherActiveMemberships] = await db.select({ count: count9() }).from(customerMemberships).where(and53(
        eq55(customerMemberships.customerId, customerId),
        eq55(customerMemberships.status, "active")
      ));
      if (otherActiveMemberships.count === 0) {
        await db.update(users).set({ hasActiveMembership: 0, updatedAt: /* @__PURE__ */ new Date() }).where(eq55(users.id, customerId));
      }
      return { success: true };
    } catch (error) {
      console.error("Error cancelling membership:", error);
      return { success: false, error: "Failed to cancel membership" };
    }
  }
  async getAvailablePlansForCustomer(salonId) {
    const plans = await this.getPlansForSalon(salonId, { activeOnly: true, includeServices: true });
    const now = /* @__PURE__ */ new Date();
    return plans.filter((plan) => {
      if (plan.validFrom && new Date(plan.validFrom) > now) return false;
      if (plan.validUntil && new Date(plan.validUntil) < now) return false;
      return true;
    });
  }
  async purchaseMembership(customerId, planId, paymentDetails) {
    try {
      const plan = await this.getPlanById(planId);
      if (!plan) {
        return { success: false, error: "Membership plan not found" };
      }
      if (!plan.isActive) {
        return { success: false, error: "This membership plan is no longer available" };
      }
      const now = /* @__PURE__ */ new Date();
      if (plan.validFrom && new Date(plan.validFrom) > now) {
        return { success: false, error: "This plan is not yet available" };
      }
      if (plan.validUntil && new Date(plan.validUntil) < now) {
        return { success: false, error: "This plan has expired" };
      }
      if (plan.maxMembers) {
        const [memberCount] = await db.select({ count: count9() }).from(customerMemberships).where(and53(
          eq55(customerMemberships.planId, planId),
          eq55(customerMemberships.status, "active")
        ));
        if (memberCount.count >= plan.maxMembers) {
          return { success: false, error: "This plan has reached its maximum member limit" };
        }
      }
      const existingMembership = await db.select().from(customerMemberships).where(and53(
        eq55(customerMemberships.customerId, customerId),
        eq55(customerMemberships.salonId, plan.salonId),
        eq55(customerMemberships.status, "active")
      ));
      if (existingMembership.length > 0) {
        return { success: false, error: "You already have an active membership at this salon" };
      }
      const startDate = /* @__PURE__ */ new Date();
      const endDate = /* @__PURE__ */ new Date();
      endDate.setMonth(endDate.getMonth() + plan.durationMonths);
      let initialCredits = 0;
      if (plan.planType === "credit" && plan.creditAmountInPaisa) {
        const bonusMultiplier = plan.bonusPercentage ? 1 + plan.bonusPercentage / 100 : 1;
        initialCredits = Math.round(plan.creditAmountInPaisa * bonusMultiplier);
      }
      const nextBillingDate = plan.billingType === "monthly" ? new Date(startDate.getTime() + 30 * 24 * 60 * 60 * 1e3) : null;
      const [membership] = await db.insert(customerMemberships).values({
        customerId,
        salonId: plan.salonId,
        planId,
        status: "active",
        startDate,
        endDate,
        nextBillingDate,
        creditBalanceInPaisa: initialCredits,
        totalCreditsEarnedInPaisa: initialCredits,
        totalCreditsUsedInPaisa: 0,
        totalPaidInPaisa: plan.priceInPaisa,
        autoRenew: 0
      }).returning();
      await db.insert(membershipPayments).values({
        membershipId: membership.id,
        customerId,
        salonId: plan.salonId,
        amountInPaisa: plan.priceInPaisa,
        paymentType: "initial",
        razorpayPaymentId: paymentDetails.razorpayPaymentId || null,
        razorpayOrderId: paymentDetails.razorpayOrderId || null,
        paymentStatus: "completed",
        paidAt: /* @__PURE__ */ new Date()
      });
      if (initialCredits > 0) {
        await db.insert(membershipCreditTransactions).values({
          membershipId: membership.id,
          transactionType: "credit_added",
          amountInPaisa: initialCredits,
          balanceAfterInPaisa: initialCredits,
          description: "Initial credits on membership purchase"
        });
      }
      await db.update(users).set({ hasActiveMembership: 1, updatedAt: /* @__PURE__ */ new Date() }).where(eq55(users.id, customerId));
      await db.update(salons).set({
        activeMembersCount: sql42`COALESCE(${salons.activeMembersCount}, 0) + 1`,
        updatedAt: /* @__PURE__ */ new Date()
      }).where(eq55(salons.id, plan.salonId));
      return {
        success: true,
        membership: {
          ...membership,
          plan: {
            id: plan.id,
            name: plan.name,
            planType: plan.planType
          }
        }
      };
    } catch (error) {
      console.error("Error purchasing membership:", error);
      return { success: false, error: "Failed to purchase membership" };
    }
  }
  // ============= BOOKING INTEGRATION METHODS =============
  async getActiveMembershipForBooking(customerId, salonId) {
    const [membership] = await db.select({
      membership: customerMemberships,
      plan: membershipPlans
    }).from(customerMemberships).leftJoin(membershipPlans, eq55(customerMemberships.planId, membershipPlans.id)).where(and53(
      eq55(customerMemberships.customerId, customerId),
      eq55(customerMemberships.salonId, salonId),
      eq55(customerMemberships.status, "active"),
      lte22(customerMemberships.startDate, /* @__PURE__ */ new Date()),
      gte28(customerMemberships.endDate, /* @__PURE__ */ new Date())
    ));
    return membership || null;
  }
  async calculateMembershipBenefits(customerId, salonId, serviceIds, originalTotalInPaisa) {
    const membership = await this.getActiveMembershipForBooking(customerId, salonId);
    if (!membership || !membership.plan) {
      return {
        hasMembership: false,
        discountAmount: 0,
        finalAmount: originalTotalInPaisa
      };
    }
    const { membership: customerMembership, plan } = membership;
    if (plan.planType === "discount" && plan.discountPercentage) {
      const discountAmount = Math.round(originalTotalInPaisa * plan.discountPercentage / 100);
      return {
        hasMembership: true,
        membershipId: customerMembership.id,
        planType: "discount",
        planName: plan.name,
        discountAmount,
        discountPercentage: plan.discountPercentage,
        finalAmount: originalTotalInPaisa - discountAmount,
        message: `${plan.discountPercentage}% member discount applied`
      };
    }
    if (plan.planType === "credit") {
      const creditBalance = customerMembership.creditBalanceInPaisa;
      const creditToUse = Math.min(creditBalance, originalTotalInPaisa);
      return {
        hasMembership: true,
        membershipId: customerMembership.id,
        planType: "credit",
        planName: plan.name,
        discountAmount: 0,
        creditBalance,
        creditToUse,
        finalAmount: originalTotalInPaisa - creditToUse,
        message: creditToUse > 0 ? `Using \u20B9${(creditToUse / 100).toFixed(0)} from your beauty bank` : "No credits available"
      };
    }
    if (plan.planType === "packaged") {
      const includedServices = await db.select({
        serviceId: membershipPlanServices.serviceId,
        quantityPerMonth: membershipPlanServices.quantityPerMonth,
        isUnlimited: membershipPlanServices.isUnlimited,
        serviceName: services.name,
        servicePrice: services.priceInPaisa
      }).from(membershipPlanServices).leftJoin(services, eq55(membershipPlanServices.serviceId, services.id)).where(eq55(membershipPlanServices.planId, plan.id));
      const currentMonth = /* @__PURE__ */ new Date();
      currentMonth.setDate(1);
      currentMonth.setHours(0, 0, 0, 0);
      const usageThisMonth = await db.select({
        serviceId: membershipServiceUsage.serviceId,
        totalUsed: sql42`SUM(${membershipServiceUsage.quantityUsed})`.as("total_used")
      }).from(membershipServiceUsage).where(and53(
        eq55(membershipServiceUsage.membershipId, customerMembership.id),
        gte28(membershipServiceUsage.usageMonth, currentMonth)
      )).groupBy(membershipServiceUsage.serviceId);
      const usageMap = new Map(usageThisMonth.map((u) => [u.serviceId, u.totalUsed]));
      let totalDiscount = 0;
      const includedServicesUsed = [];
      for (const serviceId of serviceIds) {
        const includedService = includedServices.find((s) => s.serviceId === serviceId);
        if (includedService) {
          const usedCount = usageMap.get(serviceId) || 0;
          const canUse = includedService.isUnlimited === 1 || usedCount < includedService.quantityPerMonth;
          if (canUse) {
            totalDiscount += includedService.servicePrice || 0;
            includedServicesUsed.push({
              serviceId,
              serviceName: includedService.serviceName || "",
              isFree: true
            });
            usageMap.set(serviceId, usedCount + 1);
          } else {
            includedServicesUsed.push({
              serviceId,
              serviceName: includedService.serviceName || "",
              isFree: false
            });
          }
        }
      }
      return {
        hasMembership: true,
        membershipId: customerMembership.id,
        planType: "packaged",
        planName: plan.name,
        discountAmount: totalDiscount,
        finalAmount: Math.max(0, originalTotalInPaisa - totalDiscount),
        includedServicesUsed,
        message: totalDiscount > 0 ? `Included services from your ${plan.name} package` : "Package services quota exceeded for this month"
      };
    }
    return {
      hasMembership: true,
      membershipId: customerMembership.id,
      planType: plan.planType,
      planName: plan.name,
      discountAmount: 0,
      finalAmount: originalTotalInPaisa
    };
  }
  async applyMembershipToBooking(membershipId, bookingId, serviceIds, amountUsedInPaisa, planType) {
    try {
      if (planType === "credit" && amountUsedInPaisa > 0) {
        const [membership] = await db.select().from(customerMemberships).where(eq55(customerMemberships.id, membershipId));
        if (!membership) {
          return { success: false, error: "Membership not found" };
        }
        const newBalance = membership.creditBalanceInPaisa - amountUsedInPaisa;
        if (newBalance < 0) {
          return { success: false, error: "Insufficient credit balance" };
        }
        await db.update(customerMemberships).set({
          creditBalanceInPaisa: newBalance,
          totalCreditsUsedInPaisa: membership.totalCreditsUsedInPaisa + amountUsedInPaisa,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq55(customerMemberships.id, membershipId));
        await db.insert(membershipCreditTransactions).values({
          membershipId,
          bookingId,
          transactionType: "credit_used",
          amountInPaisa: amountUsedInPaisa,
          balanceAfterInPaisa: newBalance,
          description: `Used for booking ${bookingId}`
        });
      }
      if (planType === "packaged") {
        const currentMonth = /* @__PURE__ */ new Date();
        currentMonth.setDate(1);
        currentMonth.setHours(0, 0, 0, 0);
        for (const serviceId of serviceIds) {
          await db.insert(membershipServiceUsage).values({
            membershipId,
            serviceId,
            bookingId,
            quantityUsed: 1,
            usageMonth: currentMonth
          });
        }
      }
      return { success: true };
    } catch (error) {
      console.error("Error applying membership to booking:", error);
      return { success: false, error: "Failed to apply membership benefits" };
    }
  }
};
var membershipService = new MembershipService();

// server/routes/membership.routes.ts
init_rbacService();
init_schema();
import { z as z22 } from "zod";
var router32 = Router31();
var createMembershipPlanSchema = insertMembershipPlanSchema.omit({ salonId: true }).extend({
  includedServices: z22.array(z22.object({
    serviceId: z22.string(),
    quantityPerMonth: z22.number().int().positive(),
    isUnlimited: z22.boolean().optional()
  })).optional()
});
var updateMembershipPlanSchema = createMembershipPlanSchema.partial();
router32.post("/salons/:salonId/membership-plans", authenticateToken, requireSalonAccess(), async (req, res) => {
  try {
    const userId = req.user?.id;
    const { salonId } = req.params;
    if (!userId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const userSalons = await rbacService.getSalonsForUser(userId);
    const salonAccess = userSalons.find((s) => s.salonId === salonId);
    const allowedRoles = ["business_owner", "owner", "manager", "shop_admin"];
    if (!salonAccess || !allowedRoles.includes(salonAccess.role)) {
      return res.status(403).json({ error: "Not authorized to create membership plans for this salon" });
    }
    const validatedInput = createMembershipPlanSchema.parse(req.body);
    const result = await membershipService.createPlan(salonId, {
      ...validatedInput,
      validFrom: validatedInput.validFrom ? new Date(validatedInput.validFrom) : null,
      validUntil: validatedInput.validUntil ? new Date(validatedInput.validUntil) : null
    });
    if (!result.success) {
      return res.status(400).json({ error: result.error });
    }
    return res.status(201).json({
      success: true,
      message: "Membership plan created successfully",
      plan: result.plan
    });
  } catch (error) {
    if (error instanceof z22.ZodError) {
      return res.status(400).json({ error: "Invalid input", details: error.errors });
    }
    console.error("Error creating membership plan:", error);
    return res.status(500).json({ error: "Failed to create membership plan" });
  }
});
router32.get("/salons/:salonId/membership-plans", async (req, res) => {
  try {
    const { salonId } = req.params;
    const { active } = req.query;
    const plans = await membershipService.getPlansForSalon(salonId, {
      activeOnly: active !== "false",
      includeServices: true
    });
    return res.json({
      success: true,
      plans,
      totalCount: plans.length
    });
  } catch (error) {
    console.error("Error fetching membership plans:", error);
    return res.status(500).json({ error: "Failed to fetch membership plans" });
  }
});
router32.get("/salons/:salonId/membership-plans/manage", authenticateToken, requireSalonAccess(), async (req, res) => {
  try {
    const { salonId } = req.params;
    const plans = await membershipService.getPlansForSalon(salonId, {
      activeOnly: false,
      includeServices: true
    });
    return res.json({
      success: true,
      plans,
      totalCount: plans.length
    });
  } catch (error) {
    console.error("Error fetching membership plans for management:", error);
    return res.status(500).json({ error: "Failed to fetch membership plans" });
  }
});
router32.get("/membership-plans/:planId", async (req, res) => {
  try {
    const { planId } = req.params;
    const plan = await membershipService.getPlanById(planId);
    if (!plan) {
      return res.status(404).json({ error: "Membership plan not found" });
    }
    return res.json({
      success: true,
      plan
    });
  } catch (error) {
    console.error("Error fetching membership plan:", error);
    return res.status(500).json({ error: "Failed to fetch membership plan" });
  }
});
router32.put("/membership-plans/:planId", authenticateToken, async (req, res) => {
  try {
    const userId = req.user?.id;
    const { planId } = req.params;
    if (!userId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const plan = await membershipService.getPlanById(planId);
    if (!plan) {
      return res.status(404).json({ error: "Membership plan not found" });
    }
    const userSalons = await rbacService.getSalonsForUser(userId);
    const salonAccess = userSalons.find((s) => s.salonId === plan.salonId);
    const allowedRoles = ["business_owner", "owner", "manager", "shop_admin"];
    if (!salonAccess || !allowedRoles.includes(salonAccess.role)) {
      return res.status(403).json({ error: "Not authorized to update this membership plan" });
    }
    const validatedInput = updateMembershipPlanSchema.parse(req.body);
    const result = await membershipService.updatePlan(planId, plan.salonId, {
      ...validatedInput,
      validFrom: validatedInput.validFrom ? new Date(validatedInput.validFrom) : void 0,
      validUntil: validatedInput.validUntil ? new Date(validatedInput.validUntil) : void 0
    });
    if (!result.success) {
      return res.status(400).json({ error: result.error });
    }
    return res.json({
      success: true,
      message: "Membership plan updated successfully",
      plan: result.plan
    });
  } catch (error) {
    if (error instanceof z22.ZodError) {
      return res.status(400).json({ error: "Invalid input", details: error.errors });
    }
    console.error("Error updating membership plan:", error);
    return res.status(500).json({ error: "Failed to update membership plan" });
  }
});
router32.delete("/membership-plans/:planId", authenticateToken, async (req, res) => {
  try {
    const userId = req.user?.id;
    const { planId } = req.params;
    if (!userId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const plan = await membershipService.getPlanById(planId);
    if (!plan) {
      return res.status(404).json({ error: "Membership plan not found" });
    }
    const userSalons = await rbacService.getSalonsForUser(userId);
    const salonAccess = userSalons.find((s) => s.salonId === plan.salonId);
    const allowedRoles = ["business_owner", "owner", "manager"];
    if (!salonAccess || !allowedRoles.includes(salonAccess.role)) {
      return res.status(403).json({ error: "Not authorized to delete this membership plan" });
    }
    const result = await membershipService.deletePlan(planId, plan.salonId);
    if (!result.success) {
      return res.status(400).json({ error: result.error });
    }
    return res.json({
      success: true,
      message: "Membership plan deleted successfully"
    });
  } catch (error) {
    console.error("Error deleting membership plan:", error);
    return res.status(500).json({ error: "Failed to delete membership plan" });
  }
});
router32.get("/salons/:salonId/members", authenticateToken, requireSalonAccess(), async (req, res) => {
  try {
    const { salonId } = req.params;
    const { status, limit, offset } = req.query;
    const result = await membershipService.getMembersForSalon(salonId, {
      status,
      limit: limit ? parseInt(limit) : void 0,
      offset: offset ? parseInt(offset) : void 0
    });
    return res.json({
      success: true,
      ...result
    });
  } catch (error) {
    console.error("Error fetching members:", error);
    return res.status(500).json({ error: "Failed to fetch members" });
  }
});
router32.get("/salons/:salonId/membership-analytics", authenticateToken, requireSalonAccess(), async (req, res) => {
  try {
    const { salonId } = req.params;
    const analytics = await membershipService.getMembershipAnalytics(salonId);
    return res.json({
      success: true,
      ...analytics
    });
  } catch (error) {
    console.error("Error fetching membership analytics:", error);
    return res.status(500).json({ error: "Failed to fetch analytics" });
  }
});
router32.get("/salons/:salonId/memberships/available", async (req, res) => {
  try {
    const { salonId } = req.params;
    const plans = await membershipService.getAvailablePlansForCustomer(salonId);
    return res.json({
      success: true,
      plans,
      totalCount: plans.length
    });
  } catch (error) {
    console.error("Error fetching available plans:", error);
    return res.status(500).json({ error: "Failed to fetch available plans" });
  }
});
router32.get("/my/memberships", authenticateToken, async (req, res) => {
  try {
    const userId = req.user?.id;
    if (!userId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const rawMemberships = await membershipService.getCustomerMemberships(userId);
    const memberships = rawMemberships.map((item) => ({
      id: item.membership.id,
      planId: item.membership.planId,
      customerId: item.membership.customerId,
      salonId: item.membership.salonId,
      status: item.membership.status,
      startDate: item.membership.startDate,
      endDate: item.membership.endDate,
      creditBalanceInPaisa: item.membership.creditBalanceInPaisa,
      remainingCreditsInPaisa: item.membership.creditBalanceInPaisa,
      // alias for mobile app
      pausedAt: item.membership.pausedAt,
      resumeDate: item.membership.resumeDate,
      resumedAt: item.membership.resumedAt,
      cancelledAt: item.membership.cancelledAt,
      createdAt: item.membership.createdAt,
      plan: {
        id: item.plan?.id,
        name: item.plan?.name,
        planType: item.plan?.planType,
        durationMonths: item.plan?.durationMonths,
        priceInPaisa: item.plan?.priceInPaisa,
        discountPercentage: item.plan?.discountPercentage,
        creditAmountInPaisa: item.plan?.creditAmountInPaisa,
        bonusPercentage: item.plan?.bonusPercentage,
        priorityBooking: item.plan?.priorityBooking
      },
      salon: {
        id: item.salon?.id,
        name: item.salon?.name,
        address: item.salon?.address,
        city: item.salon?.city
      }
    }));
    return res.json({
      success: true,
      memberships
    });
  } catch (error) {
    console.error("Error fetching customer memberships:", error);
    return res.status(500).json({ error: "Failed to fetch memberships" });
  }
});
router32.get("/my/memberships/:membershipId", authenticateToken, async (req, res) => {
  try {
    const userId = req.user?.id;
    const { membershipId } = req.params;
    if (!userId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const membership = await membershipService.getCustomerMembershipById(membershipId, userId);
    if (!membership) {
      return res.status(404).json({ error: "Membership not found" });
    }
    return res.json({
      success: true,
      membership
    });
  } catch (error) {
    console.error("Error fetching membership details:", error);
    return res.status(500).json({ error: "Failed to fetch membership" });
  }
});
router32.post("/my/memberships/:membershipId/pause", authenticateToken, async (req, res) => {
  try {
    const userId = req.user?.id;
    const { membershipId } = req.params;
    if (!userId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const result = await membershipService.pauseMembership(membershipId, userId);
    if (!result.success) {
      return res.status(400).json({ error: result.error });
    }
    return res.json({
      success: true,
      message: "Membership paused successfully"
    });
  } catch (error) {
    console.error("Error pausing membership:", error);
    return res.status(500).json({ error: "Failed to pause membership" });
  }
});
router32.post("/my/memberships/:membershipId/resume", authenticateToken, async (req, res) => {
  try {
    const userId = req.user?.id;
    const { membershipId } = req.params;
    if (!userId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const result = await membershipService.resumeMembership(membershipId, userId);
    if (!result.success) {
      return res.status(400).json({ error: result.error });
    }
    return res.json({
      success: true,
      message: "Membership resumed successfully"
    });
  } catch (error) {
    console.error("Error resuming membership:", error);
    return res.status(500).json({ error: "Failed to resume membership" });
  }
});
router32.post("/my/memberships/:membershipId/cancel", authenticateToken, async (req, res) => {
  try {
    const userId = req.user?.id;
    const { membershipId } = req.params;
    if (!userId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const result = await membershipService.cancelMembership(membershipId, userId);
    if (!result.success) {
      return res.status(400).json({ error: result.error });
    }
    return res.json({
      success: true,
      message: "Membership cancelled successfully"
    });
  } catch (error) {
    console.error("Error cancelling membership:", error);
    return res.status(500).json({ error: "Failed to cancel membership" });
  }
});
var purchaseMembershipSchema = z22.object({
  planId: z22.string(),
  razorpayPaymentId: z22.string().optional(),
  razorpayOrderId: z22.string().optional()
});
var calculateBenefitsSchema = z22.object({
  serviceIds: z22.array(z22.string()).min(1),
  originalTotalInPaisa: z22.number().int().positive()
});
router32.post("/salons/:salonId/calculate-membership-benefits", authenticateToken, async (req, res) => {
  try {
    const userId = req.user?.id;
    const { salonId } = req.params;
    if (!userId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const validatedInput = calculateBenefitsSchema.parse(req.body);
    const benefits = await membershipService.calculateMembershipBenefits(
      userId,
      salonId,
      validatedInput.serviceIds,
      validatedInput.originalTotalInPaisa
    );
    return res.json({
      success: true,
      ...benefits
    });
  } catch (error) {
    if (error instanceof z22.ZodError) {
      return res.status(400).json({ error: "Invalid input", details: error.errors });
    }
    console.error("Error calculating membership benefits:", error);
    return res.status(500).json({ error: "Failed to calculate membership benefits" });
  }
});
router32.post("/memberships/purchase", authenticateToken, async (req, res) => {
  try {
    const userId = req.user?.id;
    if (!userId) {
      return res.status(401).json({ error: "Authentication required" });
    }
    const validatedInput = purchaseMembershipSchema.parse(req.body);
    const result = await membershipService.purchaseMembership(
      userId,
      validatedInput.planId,
      {
        razorpayPaymentId: validatedInput.razorpayPaymentId,
        razorpayOrderId: validatedInput.razorpayOrderId
      }
    );
    if (!result.success) {
      return res.status(400).json({ error: result.error });
    }
    return res.status(201).json({
      success: true,
      message: "Membership purchased successfully",
      membership: result.membership
    });
  } catch (error) {
    if (error instanceof z22.ZodError) {
      return res.status(400).json({ error: "Invalid input", details: error.errors });
    }
    console.error("Error purchasing membership:", error);
    return res.status(500).json({ error: "Failed to purchase membership" });
  }
});
var membership_routes_default = router32;

// server/routes/premiumAnalytics.ts
import { Router as Router32 } from "express";

// server/services/mlAnalytics.service.ts
init_db();
init_schema();
import { eq as eq56, and as and54, sql as sql43, gte as gte29, lte as lte23, count as count10 } from "drizzle-orm";
var MLAnalyticsService = class {
  async isSalonPremium(salonId) {
    const [subscription] = await db.select().from(salonSubscriptions).where(
      and54(
        eq56(salonSubscriptions.salonId, salonId),
        eq56(salonSubscriptions.status, "active")
      )
    ).limit(1);
    if (!subscription) return false;
    return PREMIUM_TIER_IDS.includes(subscription.tierId);
  }
  async getOverviewKPIs(salonId, dateRange) {
    const currentPeriodData = await db.select({
      totalPredictions: count10(predictionAccuracyLogs.id),
      avgAccuracy: sql43`AVG(CASE 
          WHEN ${predictionAccuracyLogs.startTimeErrorMinutes} IS NOT NULL 
          THEN GREATEST(0, 1 - ABS(${predictionAccuracyLogs.startTimeErrorMinutes}::numeric) / 30)
          ELSE 0.85 
        END)`
    }).from(predictionAccuracyLogs).where(
      and54(
        eq56(predictionAccuracyLogs.salonId, salonId),
        gte29(predictionAccuracyLogs.createdAt, new Date(dateRange.startDate)),
        lte23(predictionAccuracyLogs.createdAt, new Date(dateRange.endDate))
      )
    );
    const previousPeriodStart = new Date(dateRange.startDate);
    const daysDiff = Math.ceil((new Date(dateRange.endDate).getTime() - new Date(dateRange.startDate).getTime()) / (1e3 * 60 * 60 * 24));
    previousPeriodStart.setDate(previousPeriodStart.getDate() - daysDiff);
    const previousPeriodData = await db.select({
      totalPredictions: count10(predictionAccuracyLogs.id),
      avgAccuracy: sql43`AVG(CASE 
          WHEN ${predictionAccuracyLogs.startTimeErrorMinutes} IS NOT NULL 
          THEN GREATEST(0, 1 - ABS(${predictionAccuracyLogs.startTimeErrorMinutes}::numeric) / 30)
          ELSE 0.85 
        END)`
    }).from(predictionAccuracyLogs).where(
      and54(
        eq56(predictionAccuracyLogs.salonId, salonId),
        gte29(predictionAccuracyLogs.createdAt, previousPeriodStart),
        lte23(predictionAccuracyLogs.createdAt, new Date(dateRange.startDate))
      )
    );
    const activeStaff = await db.select({ count: count10(staffPerformancePatterns.staffId) }).from(staffPerformancePatterns).where(
      and54(
        eq56(staffPerformancePatterns.salonId, salonId),
        gte29(staffPerformancePatterns.updatedAt, new Date(dateRange.startDate)),
        lte23(staffPerformancePatterns.updatedAt, new Date(dateRange.endDate))
      )
    ).groupBy(staffPerformancePatterns.staffId);
    const overrunData = await db.select({
      avgOverrun: sql43`AVG(${serviceTimingAnalytics.avgOverrunMinutes}::numeric)`
    }).from(serviceTimingAnalytics).where(
      and54(
        eq56(serviceTimingAnalytics.salonId, salonId),
        gte29(serviceTimingAnalytics.updatedAt, new Date(dateRange.startDate)),
        lte23(serviceTimingAnalytics.updatedAt, new Date(dateRange.endDate))
      )
    );
    const prevOverrunData = await db.select({
      avgOverrun: sql43`AVG(${serviceTimingAnalytics.avgOverrunMinutes}::numeric)`
    }).from(serviceTimingAnalytics).where(
      and54(
        eq56(serviceTimingAnalytics.salonId, salonId),
        gte29(serviceTimingAnalytics.updatedAt, previousPeriodStart),
        lte23(serviceTimingAnalytics.updatedAt, new Date(dateRange.startDate))
      )
    );
    const currentAccuracy = currentPeriodData[0]?.avgAccuracy || 0;
    const previousAccuracy = previousPeriodData[0]?.avgAccuracy || 0;
    const currentPredictions = currentPeriodData[0]?.totalPredictions || 0;
    const previousPredictions = previousPeriodData[0]?.totalPredictions || 0;
    const currentOverrun = overrunData[0]?.avgOverrun || 0;
    const previousOverrun = prevOverrunData[0]?.avgOverrun || 0;
    return {
      predictionAccuracy: parseFloat((currentAccuracy * 100).toFixed(1)),
      totalPredictions: currentPredictions,
      activeStaffTracked: activeStaff.length,
      avgServiceOverrun: parseFloat(currentOverrun.toFixed(1)),
      trendsVsLastPeriod: {
        accuracy: parseFloat(((currentAccuracy - previousAccuracy) * 100).toFixed(1)),
        predictions: currentPredictions - previousPredictions,
        overrun: parseFloat((currentOverrun - previousOverrun).toFixed(1))
      }
    };
  }
  async getPredictionAccuracyTrend(salonId, dateRange) {
    const dailyAccuracy = await db.select({
      date: sql43`DATE(${predictionAccuracyLogs.createdAt})::text`,
      avgAccuracy: sql43`AVG(CASE 
          WHEN ${predictionAccuracyLogs.startTimeErrorMinutes} IS NOT NULL 
          THEN GREATEST(0, 1 - ABS(${predictionAccuracyLogs.startTimeErrorMinutes}::numeric) / 30)
          ELSE 0.85 
        END)`,
      avgConfidence: sql43`AVG(CASE 
          WHEN ${predictionAccuracyLogs.predictionType} = 'ml_enhanced' THEN 0.8
          WHEN ${predictionAccuracyLogs.predictionType} = 'staff_adjusted' THEN 0.6
          ELSE 0.5
        END)`,
      samples: count10(predictionAccuracyLogs.id)
    }).from(predictionAccuracyLogs).where(
      and54(
        eq56(predictionAccuracyLogs.salonId, salonId),
        gte29(predictionAccuracyLogs.createdAt, new Date(dateRange.startDate)),
        lte23(predictionAccuracyLogs.createdAt, new Date(dateRange.endDate))
      )
    ).groupBy(sql43`DATE(${predictionAccuracyLogs.createdAt})`).orderBy(sql43`DATE(${predictionAccuracyLogs.createdAt})`);
    const trend = dailyAccuracy.map((row) => ({
      date: row.date,
      accuracy: parseFloat((row.avgAccuracy * 100).toFixed(1)),
      confidence: parseFloat(row.avgConfidence.toFixed(2)),
      samples: row.samples
    }));
    const allAccuracies = trend.map((t) => t.accuracy);
    const avgAccuracy = allAccuracies.length > 0 ? allAccuracies.reduce((a, b) => a + b, 0) / allAccuracies.length : 85;
    return {
      trend,
      summary: {
        avgAccuracy: parseFloat(avgAccuracy.toFixed(1)),
        minAccuracy: allAccuracies.length > 0 ? Math.min(...allAccuracies) : 80,
        maxAccuracy: allAccuracies.length > 0 ? Math.max(...allAccuracies) : 90,
        targetAccuracy: 85
      }
    };
  }
  async getStaffPerformance(salonId, dateRange) {
    const staffData = await db.select({
      staffId: staffPerformancePatterns.staffId,
      staffName: staff.name,
      speedFactor: sql43`AVG(${staffPerformancePatterns.speedFactor}::numeric)`,
      consistencyScore: sql43`AVG(${staffPerformancePatterns.consistencyScore}::numeric)`,
      totalServices: sql43`SUM(${staffPerformancePatterns.sampleCount})`
    }).from(staffPerformancePatterns).leftJoin(staff, eq56(staffPerformancePatterns.staffId, staff.id)).where(
      and54(
        eq56(staffPerformancePatterns.salonId, salonId),
        gte29(staffPerformancePatterns.updatedAt, new Date(dateRange.startDate)),
        lte23(staffPerformancePatterns.updatedAt, new Date(dateRange.endDate))
      )
    ).groupBy(staffPerformancePatterns.staffId, staff.name);
    const historyData = await db.select({
      staffId: staffPerformancePatterns.staffId,
      date: sql43`DATE(${staffPerformancePatterns.updatedAt})::text`,
      speedFactor: sql43`AVG(${staffPerformancePatterns.speedFactor}::numeric)`
    }).from(staffPerformancePatterns).where(
      and54(
        eq56(staffPerformancePatterns.salonId, salonId),
        gte29(staffPerformancePatterns.updatedAt, new Date(dateRange.startDate)),
        lte23(staffPerformancePatterns.updatedAt, new Date(dateRange.endDate))
      )
    ).groupBy(staffPerformancePatterns.staffId, sql43`DATE(${staffPerformancePatterns.updatedAt})`).orderBy(sql43`DATE(${staffPerformancePatterns.updatedAt})`);
    const historyByStaff = /* @__PURE__ */ new Map();
    historyData.forEach((row) => {
      const staffHistory = historyByStaff.get(row.staffId) || [];
      staffHistory.push({
        date: row.date,
        speedFactor: parseFloat((row.speedFactor || 1).toFixed(2))
      });
      historyByStaff.set(row.staffId, staffHistory);
    });
    const staffPerformance = staffData.map((row) => {
      const speedFactor = parseFloat(row.speedFactor?.toString() || "1.0");
      const history = historyByStaff.get(row.staffId) || [];
      let trend = "stable";
      if (history.length >= 2) {
        const recent = history.slice(-3);
        const first = recent[0].speedFactor;
        const last = recent[recent.length - 1].speedFactor;
        if (last < first - 0.05) trend = "improving";
        else if (last > first + 0.05) trend = "declining";
      } else {
        trend = speedFactor < 0.95 ? "improving" : speedFactor > 1.05 ? "declining" : "stable";
      }
      return {
        staffId: row.staffId,
        name: row.staffName || "Unknown Staff",
        speedFactor: parseFloat(speedFactor.toFixed(2)),
        consistencyScore: parseFloat((row.consistencyScore || 0).toFixed(2)),
        totalServices: row.totalServices || 0,
        trend,
        history
      };
    });
    return { staff: staffPerformance };
  }
  async getServiceTimingHeatmap(salonId, dateRange) {
    const heatmapData = await db.select({
      dayOfWeek: serviceTimingAnalytics.dayOfWeek,
      hourOfDay: serviceTimingAnalytics.hourBlock,
      avgOverrun: sql43`AVG(${serviceTimingAnalytics.avgOverrunMinutes}::numeric)`,
      samples: sql43`SUM(${serviceTimingAnalytics.sampleCount})`
    }).from(serviceTimingAnalytics).where(
      and54(
        eq56(serviceTimingAnalytics.salonId, salonId),
        gte29(serviceTimingAnalytics.updatedAt, new Date(dateRange.startDate)),
        lte23(serviceTimingAnalytics.updatedAt, new Date(dateRange.endDate))
      )
    ).groupBy(serviceTimingAnalytics.dayOfWeek, serviceTimingAnalytics.hourBlock).orderBy(serviceTimingAnalytics.dayOfWeek, serviceTimingAnalytics.hourBlock);
    const heatmap = heatmapData.map((row) => ({
      dayOfWeek: row.dayOfWeek,
      hourOfDay: row.hourOfDay,
      avgOverrun: parseFloat((row.avgOverrun || 0).toFixed(1)),
      samples: row.samples || 0
    }));
    let busiestDay = 0, busiestHour = 0, calmestDay = 0, calmestHour = 0;
    let maxSamples = 0, minSamples = Infinity;
    heatmap.forEach((cell) => {
      if (cell.samples > maxSamples) {
        maxSamples = cell.samples;
        busiestDay = cell.dayOfWeek;
        busiestHour = cell.hourOfDay;
      }
      if (cell.samples < minSamples && cell.samples > 0) {
        minSamples = cell.samples;
        calmestDay = cell.dayOfWeek;
        calmestHour = cell.hourOfDay;
      }
    });
    return {
      heatmap,
      summary: { busiestDay, busiestHour, calmestDay, calmestHour }
    };
  }
  async getServiceTypeTrends(salonId) {
    const serviceData = await db.select({
      serviceId: serviceTimingAnalytics.serviceId,
      serviceName: services.name,
      avgOverrun: sql43`AVG(${serviceTimingAnalytics.avgOverrunMinutes}::numeric)`,
      sampleCount: sql43`SUM(${serviceTimingAnalytics.sampleCount})`
    }).from(serviceTimingAnalytics).leftJoin(services, eq56(serviceTimingAnalytics.serviceId, services.id)).where(eq56(serviceTimingAnalytics.salonId, salonId)).groupBy(serviceTimingAnalytics.serviceId, services.name).orderBy(sql43`AVG(${serviceTimingAnalytics.avgOverrunMinutes}::numeric) DESC`);
    const serviceTrends = serviceData.map((row) => {
      const avgOverrun = parseFloat((row.avgOverrun || 0).toFixed(1));
      return {
        serviceId: row.serviceId,
        serviceName: row.serviceName || "Unknown Service",
        avgOverrun,
        sampleCount: row.sampleCount || 0,
        trend: avgOverrun > 3 ? "over" : avgOverrun < -3 ? "under" : "ontime"
      };
    });
    return { services: serviceTrends };
  }
  getDataFreshness() {
    const now = /* @__PURE__ */ new Date();
    now.setHours(3, 0, 0, 0);
    if (/* @__PURE__ */ new Date() < now) {
      now.setDate(now.getDate() - 1);
    }
    return now.toISOString();
  }
};
var mlAnalyticsService = new MLAnalyticsService();

// server/routes/premiumAnalytics.ts
init_db();
init_schema();
import { eq as eq57, and as and55 } from "drizzle-orm";
var router33 = Router32();
function requireAuth4(req, res, next) {
  if (!req.user?.id) {
    return res.status(401).json({ success: false, error: "Authentication required" });
  }
  next();
}
async function verifySalonAccess(req, res, next) {
  const userId = req.user?.id;
  const salonId = req.query.salonId;
  if (!userId) {
    return res.status(401).json({ success: false, error: "Unauthorized" });
  }
  if (!salonId) {
    return res.status(400).json({ success: false, error: "salonId is required" });
  }
  const [salon] = await db.select().from(salons).where(eq57(salons.id, salonId)).limit(1);
  if (!salon) {
    return res.status(404).json({ success: false, error: "Salon not found" });
  }
  if (salon.ownerId !== userId) {
    const [staffAccess] = await db.select().from(staff).where(
      and55(
        eq57(staff.salonId, salonId),
        eq57(staff.userId, userId)
      )
    ).limit(1);
    if (!staffAccess) {
      return res.status(403).json({ success: false, error: "Access denied to this salon" });
    }
  }
  next();
}
async function verifyPremiumTier(req, res, next) {
  const salonId = req.query.salonId;
  const isPremium = await mlAnalyticsService.isSalonPremium(salonId);
  if (!isPremium) {
    return res.status(403).json({
      success: false,
      error: "ML Analytics is a premium feature",
      upgradeRequired: true
    });
  }
  next();
}
function getDateRange(req) {
  const endDate = req.query.endDate || (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
  let startDate = req.query.startDate;
  if (!startDate) {
    const days = parseInt(req.query.days) || 7;
    const start = new Date(endDate);
    start.setDate(start.getDate() - days);
    startDate = start.toISOString().split("T")[0];
  }
  return { startDate, endDate };
}
router33.get(
  "/dashboard/overview",
  populateUserFromSession,
  requireAuth4,
  verifySalonAccess,
  verifyPremiumTier,
  async (req, res) => {
    try {
      const salonId = req.query.salonId;
      const dateRange = getDateRange(req);
      const data = await mlAnalyticsService.getOverviewKPIs(salonId, dateRange);
      res.json({
        success: true,
        data,
        meta: {
          salonId,
          dateRange,
          dataFreshness: mlAnalyticsService.getDataFreshness()
        }
      });
    } catch (error) {
      console.error("Error fetching overview KPIs:", error);
      res.status(500).json({ success: false, error: "Failed to fetch analytics" });
    }
  }
);
router33.get(
  "/predictions/accuracy",
  populateUserFromSession,
  requireAuth4,
  verifySalonAccess,
  verifyPremiumTier,
  async (req, res) => {
    try {
      const salonId = req.query.salonId;
      const dateRange = getDateRange(req);
      const data = await mlAnalyticsService.getPredictionAccuracyTrend(salonId, dateRange);
      res.json({
        success: true,
        data,
        meta: {
          salonId,
          dateRange,
          dataFreshness: mlAnalyticsService.getDataFreshness()
        }
      });
    } catch (error) {
      console.error("Error fetching prediction accuracy:", error);
      res.status(500).json({ success: false, error: "Failed to fetch accuracy data" });
    }
  }
);
router33.get(
  "/staff/performance",
  populateUserFromSession,
  requireAuth4,
  verifySalonAccess,
  verifyPremiumTier,
  async (req, res) => {
    try {
      const salonId = req.query.salonId;
      const dateRange = getDateRange(req);
      const data = await mlAnalyticsService.getStaffPerformance(salonId, dateRange);
      res.json({
        success: true,
        data,
        meta: {
          salonId,
          dateRange,
          dataFreshness: mlAnalyticsService.getDataFreshness()
        }
      });
    } catch (error) {
      console.error("Error fetching staff performance:", error);
      res.status(500).json({ success: false, error: "Failed to fetch staff data" });
    }
  }
);
router33.get(
  "/services/timing-trends",
  populateUserFromSession,
  requireAuth4,
  verifySalonAccess,
  verifyPremiumTier,
  async (req, res) => {
    try {
      const salonId = req.query.salonId;
      const dateRange = getDateRange(req);
      const [heatmapData, serviceTrends] = await Promise.all([
        mlAnalyticsService.getServiceTimingHeatmap(salonId, dateRange),
        mlAnalyticsService.getServiceTypeTrends(salonId)
      ]);
      res.json({
        success: true,
        data: {
          heatmap: heatmapData.heatmap,
          summary: heatmapData.summary,
          services: serviceTrends.services
        },
        meta: {
          salonId,
          dateRange,
          dataFreshness: mlAnalyticsService.getDataFreshness()
        }
      });
    } catch (error) {
      console.error("Error fetching timing trends:", error);
      res.status(500).json({ success: false, error: "Failed to fetch timing data" });
    }
  }
);
var premiumAnalytics_default = router33;

// server/routes.ts
init_schema();
init_emailService();
init_communicationService();

// server/schedulingService.ts
init_storage();
init_communicationService();
import cron7 from "node-cron";
var SchedulingService = class {
  jobs = /* @__PURE__ */ new Map();
  processingInterval = null;
  constructor() {
    this.startProcessing();
  }
  // Start the main processing loop
  startProcessing() {
    this.processingInterval = setInterval(async () => {
      await this.processScheduledMessages();
    }, 6e4);
    console.log("Message scheduling service started");
  }
  // Stop the processing loop
  stop() {
    if (this.processingInterval) {
      clearInterval(this.processingInterval);
      this.processingInterval = null;
    }
    this.jobs.forEach((job) => {
      job.task.destroy();
    });
    this.jobs.clear();
    console.log("Message scheduling service stopped");
  }
  // Main processing method to handle scheduled messages
  async processScheduledMessages() {
    try {
      const dueMessages = await storage.getScheduledMessagesDue(/* @__PURE__ */ new Date());
      if (dueMessages.length === 0) {
        return;
      }
      console.log(`Processing ${dueMessages.length} scheduled messages`);
      for (const message of dueMessages) {
        await this.processScheduledMessage(message);
      }
    } catch (error) {
      console.error("Error processing scheduled messages:", error);
    }
  }
  // Process a single scheduled message
  async processScheduledMessage(scheduledMessage) {
    try {
      const sendRequest = {
        to: scheduledMessage.recipient,
        channel: scheduledMessage.channel,
        templateId: scheduledMessage.templateId || void 0,
        customContent: scheduledMessage.templateId ? void 0 : {
          subject: scheduledMessage.subject || void 0,
          body: scheduledMessage.content
        },
        variables: scheduledMessage.variables ? JSON.parse(scheduledMessage.variables) : {},
        salonId: scheduledMessage.salonId,
        customerId: scheduledMessage.customerId || void 0,
        bookingId: scheduledMessage.bookingId || void 0,
        campaignId: scheduledMessage.campaignId || void 0,
        type: scheduledMessage.type
      };
      const result = await communicationService.sendMessage(sendRequest);
      if (result.success) {
        await storage.markScheduledMessageSent(scheduledMessage.id, result.providerId);
        console.log(`Scheduled message ${scheduledMessage.id} sent successfully`);
      } else {
        await storage.markScheduledMessageFailed(scheduledMessage.id, result.error || "Unknown error");
        console.error(`Failed to send scheduled message ${scheduledMessage.id}:`, result.error);
      }
    } catch (error) {
      console.error(`Error processing scheduled message ${scheduledMessage.id}:`, error);
      try {
        await storage.markScheduledMessageFailed(
          scheduledMessage.id,
          error instanceof Error ? error.message : "Processing error"
        );
      } catch (updateError) {
        console.error("Error updating failed message status:", updateError);
      }
    }
  }
  // Schedule a one-time message
  async scheduleMessage(params) {
    const scheduledMessage = await storage.createScheduledMessage({
      salonId: params.salonId,
      customerId: params.customerId || null,
      bookingId: params.bookingId || null,
      campaignId: params.campaignId || null,
      templateId: params.templateId || null,
      type: params.type,
      channel: params.channel,
      recipient: params.recipient,
      subject: params.subject || null,
      content: params.content,
      variables: params.variables ? JSON.stringify(params.variables) : null,
      scheduledFor: params.scheduledFor,
      status: "scheduled"
    });
    return scheduledMessage;
  }
  // Schedule recurring campaign messages
  async scheduleRecurringCampaign(params) {
    if (!cron7.validate(params.cronExpression)) {
      throw new Error("Invalid cron expression");
    }
    const task = cron7.schedule(params.cronExpression, async () => {
      await this.executeCampaignCron(params);
    }, {
      scheduled: false
      // Don't start immediately
    });
    const jobId = `campaign-${params.campaignId}`;
    this.jobs.set(jobId, {
      id: jobId,
      cronExpression: params.cronExpression,
      task,
      messageId: params.campaignId
    });
    task.start();
    return jobId;
  }
  // Execute a campaign cron job
  async executeCampaignCron(params) {
    try {
      console.log(`Executing recurring campaign ${params.campaignId}`);
      const campaign = await storage.getCommunicationCampaign(params.campaignId);
      if (!campaign || campaign.status !== "active") {
        console.log(`Campaign ${params.campaignId} is not active, skipping`);
        return;
      }
      const customers = await storage.getCustomersInSegment(params.segmentId, params.salonId);
      for (const customer of customers) {
        if (customer.email) {
          await this.scheduleMessage({
            salonId: params.salonId,
            customerId: customer.id,
            campaignId: params.campaignId,
            templateId: params.templateId,
            type: "campaign",
            channel: "email",
            recipient: customer.email,
            content: "",
            scheduledFor: /* @__PURE__ */ new Date()
            // Send immediately
          });
        }
      }
      console.log(`Scheduled ${customers.length} messages for campaign ${params.campaignId}`);
    } catch (error) {
      console.error(`Error executing campaign cron ${params.campaignId}:`, error);
    }
  }
  // Cancel a recurring job
  cancelRecurringJob(jobId) {
    const job = this.jobs.get(jobId);
    if (job) {
      job.task.destroy();
      this.jobs.delete(jobId);
      return true;
    }
    return false;
  }
  // Schedule booking reminders
  async scheduleBookingReminders(bookingId) {
    try {
      const booking = await storage.getBooking(bookingId);
      if (!booking) {
        throw new Error("Booking not found");
      }
      const preferences = await storage.getCommunicationPreferences(booking.customerEmail, booking.salonId);
      if (preferences?.bookingNotifications === false) {
        console.log(`Customer ${booking.customerEmail} has disabled booking notifications`);
        return;
      }
      const bookingDate = new Date(booking.date);
      const salon = await storage.getSalon(booking.salonId);
      const service = await storage.getService(booking.serviceId);
      const variables = {
        customer_name: booking.customerName,
        salon_name: salon?.name || "Your Salon",
        service_name: service?.name || "Service",
        booking_date: bookingDate.toLocaleDateString(),
        booking_time: booking.time,
        staff_name: booking.staffId ? "Your stylist" : "Our team"
        // Would need to get actual staff name
      };
      const reminder24h = new Date(bookingDate.getTime() - 24 * 60 * 60 * 1e3);
      if (reminder24h > /* @__PURE__ */ new Date()) {
        await this.scheduleMessage({
          salonId: booking.salonId,
          customerId: booking.customerEmail,
          bookingId: booking.id,
          type: "booking_reminder",
          channel: preferences?.preferredChannel || "email",
          recipient: booking.customerEmail,
          subject: "Appointment Reminder - {{salon_name}}",
          content: "Hi {{customer_name}}, you have an appointment tomorrow at {{booking_time}} for {{service_name}}. We look forward to seeing you!",
          variables,
          scheduledFor: reminder24h
        });
      }
      const reminder2h = new Date(bookingDate.getTime() - 2 * 60 * 60 * 1e3);
      if (reminder2h > /* @__PURE__ */ new Date()) {
        await this.scheduleMessage({
          salonId: booking.salonId,
          customerId: booking.customerEmail,
          bookingId: booking.id,
          type: "booking_reminder",
          channel: "sms",
          // SMS for urgent reminders
          recipient: booking.customerEmail,
          // Would use phone if available
          content: "Reminder: Appointment at {{salon_name}} in 2 hours ({{booking_time}}) for {{service_name}}",
          variables,
          scheduledFor: reminder2h
        });
      }
      console.log(`Scheduled reminders for booking ${bookingId}`);
    } catch (error) {
      console.error("Error scheduling booking reminders:", error);
    }
  }
  // Get status of all jobs
  getJobStatus() {
    const status = [];
    for (const [id, job] of this.jobs) {
      status.push({
        id,
        cronExpression: job.cronExpression,
        running: job.task.getStatus() === "scheduled",
        messageId: job.messageId
      });
    }
    return status;
  }
};
var schedulingService = new SchedulingService();
process.on("SIGINT", () => {
  console.log("Shutting down scheduling service...");
  schedulingService.stop();
  process.exit(0);
});
process.on("SIGTERM", () => {
  console.log("Shutting down scheduling service...");
  schedulingService.stop();
  process.exit(0);
});

// server/middleware/rateLimiting.ts
import rateLimit8, { ipKeyGenerator } from "express-rate-limit";
var communicationRateLimits = {
  // Send individual messages - stricter limit
  sendMessage: rateLimit8({
    windowMs: 15 * 60 * 1e3,
    // 15 minutes
    max: 50,
    // limit each IP to 50 requests per windowMs
    message: {
      error: "Too many message send requests. Please try again later.",
      retryAfter: "15 minutes"
    },
    standardHeaders: true,
    legacyHeaders: false,
    keyGenerator: (req) => {
      const userId = req.user?.id;
      return userId || ipKeyGenerator(req.ip || "unknown-ip");
    }
  }),
  // Campaign sending - even stricter limit
  sendCampaign: rateLimit8({
    windowMs: 60 * 60 * 1e3,
    // 1 hour
    max: 10,
    // limit to 10 campaign sends per hour
    message: {
      error: "Too many campaign send requests. Please try again later.",
      retryAfter: "1 hour"
    },
    standardHeaders: true,
    legacyHeaders: false,
    keyGenerator: (req) => {
      const userId = req.user?.id;
      return `campaign:${userId || ipKeyGenerator(req.ip || "unknown-ip")}`;
    }
  }),
  // Template and configuration operations - moderate limit
  templateOperations: rateLimit8({
    windowMs: 15 * 60 * 1e3,
    // 15 minutes
    max: 100,
    // 100 requests per 15 minutes
    message: {
      error: "Too many template operation requests. Please try again later.",
      retryAfter: "15 minutes"
    },
    standardHeaders: true,
    legacyHeaders: false,
    keyGenerator: (req) => {
      const userId = req.user?.id;
      return `templates:${userId || ipKeyGenerator(req.ip || "unknown-ip")}`;
    }
  }),
  // Analytics and read operations - generous limit
  analytics: rateLimit8({
    windowMs: 15 * 60 * 1e3,
    // 15 minutes
    max: 200,
    // 200 requests per 15 minutes
    message: {
      error: "Too many analytics requests. Please try again later.",
      retryAfter: "15 minutes"
    },
    standardHeaders: true,
    legacyHeaders: false,
    keyGenerator: (req) => {
      const userId = req.user?.id;
      return `analytics:${userId || ipKeyGenerator(req.ip || "unknown-ip")}`;
    }
  }),
  // Places API operations - moderate limit to prevent abuse
  placesApi: rateLimit8({
    windowMs: 15 * 60 * 1e3,
    // 15 minutes
    max: 150,
    // 150 requests per 15 minutes (10 per minute average)
    message: {
      error: "Too many places API requests. Please try again later.",
      retryAfter: "15 minutes"
    },
    standardHeaders: true,
    legacyHeaders: false,
    keyGenerator: (req) => {
      const userId = req.user?.id;
      return `places:${userId || ipKeyGenerator(req.ip || "unknown-ip")}`;
    }
  }),
  // User existence checks - strict limit to prevent enumeration attacks
  strict: rateLimit8({
    windowMs: 60 * 1e3,
    // 1 minute
    max: 10,
    // 10 requests per minute
    message: {
      error: "Too many requests. Please try again later.",
      retryAfter: "1 minute"
    },
    standardHeaders: true,
    legacyHeaders: false,
    keyGenerator: (req) => {
      return ipKeyGenerator(req.ip || "unknown-ip");
    }
  })
};
var webhookRateLimit = rateLimit8({
  windowMs: 5 * 60 * 1e3,
  // 5 minutes
  max: 1e3,
  // Allow many webhook calls
  message: "Too many webhook requests",
  standardHeaders: true,
  legacyHeaders: false,
  keyGenerator: (req) => {
    return req.get("User-Agent") || ipKeyGenerator(req.ip || "unknown-ip");
  }
});
var spikeProtection = rateLimit8({
  windowMs: 1e3,
  // 1 second
  max: 10,
  // 10 requests per second
  message: "Request rate too high. Please slow down.",
  standardHeaders: true,
  legacyHeaders: false
});

// server/routes.ts
import rateLimit9 from "express-rate-limit";
var { salons: salons10 } = schema_exports;
async function registerRoutes(app2) {
  await initializeServices();
  const sessionTtl = 30 * 24 * 60 * 60 * 1e3;
  if (!process.env.SESSION_SECRET) {
    throw new Error("SESSION_SECRET environment variable is required");
  }
  if (!process.env.DATABASE_URL) {
    throw new Error("DATABASE_URL environment variable is required for session storage");
  }
  const PgSession = connectPgSimple(session);
  const pgPool = new pg.Pool({
    connectionString: process.env.DATABASE_URL,
    ssl: { rejectUnauthorized: false }
    // Required for Neon
  });
  const sessionStore = new PgSession({
    pool: pgPool,
    tableName: "user_sessions",
    // Table name for sessions
    createTableIfMissing: true,
    // Auto-create the session table
    pruneSessionInterval: 60 * 15
    // Prune expired sessions every 15 minutes
  });
  app2.use(
    session({
      secret: process.env.SESSION_SECRET,
      store: sessionStore,
      resave: false,
      saveUninitialized: false,
      cookie: {
        httpOnly: true,
        secure: process.env.NODE_ENV === "production",
        sameSite: "lax",
        // CSRF protection for session-authenticated endpoints
        maxAge: sessionTtl,
        path: "/"
      }
    })
  );
  let razorpay7 = null;
  if (process.env.RAZORPAY_KEY_ID && process.env.RAZORPAY_KEY_SECRET) {
    razorpay7 = new Razorpay8({
      key_id: process.env.RAZORPAY_KEY_ID,
      key_secret: process.env.RAZORPAY_KEY_SECRET
    });
  } else {
    console.warn(
      "Razorpay keys not configured - payment functionality disabled"
    );
  }
  const isAuthenticated = async (req, res, next) => {
    const userId = req.session?.userId;
    if (!userId) {
      res.status(401).json({ message: "Unauthorized" });
      return;
    }
    try {
      const user = await storage.getUserById(userId);
      if (!user) {
        res.status(401).json({ message: "User not found" });
        return;
      }
      const userRoles2 = await storage.getUserRoles(userId);
      const orgMemberships = await storage.getUserOrganizations(userId);
      req.user = {
        id: userId,
        email: user.email ?? "",
        roles: userRoles2.map((role) => role.name),
        orgMemberships
      };
      next();
    } catch (error) {
      console.error("Authentication error:", error);
      res.status(401).json({ message: "Authentication failed" });
    }
  };
  async function validateAndCalculateOffer(offerId, userId, serviceAmount, salonId) {
    try {
      const offer = await storage.getOfferById(offerId);
      if (!offer) {
        return {
          isValid: false,
          discountAmount: 0,
          finalAmount: serviceAmount,
          cashbackAmount: 0,
          reason: "Offer not found"
        };
      }
      if (!offer.isPlatformWide && offer.salonId !== salonId) {
        return {
          isValid: false,
          discountAmount: 0,
          finalAmount: serviceAmount,
          cashbackAmount: 0,
          reason: "Offer does not apply to this salon"
        };
      }
      if (!offer.isActive) {
        return {
          isValid: false,
          discountAmount: 0,
          finalAmount: serviceAmount,
          cashbackAmount: 0,
          reason: "Offer is inactive"
        };
      }
      if (offer.approvalStatus !== "approved") {
        return {
          isValid: false,
          discountAmount: 0,
          finalAmount: serviceAmount,
          cashbackAmount: 0,
          reason: "Offer is not approved"
        };
      }
      const now = /* @__PURE__ */ new Date();
      const validFrom = new Date(offer.validFrom);
      const validUntil = new Date(offer.validUntil);
      if (now < validFrom) {
        return {
          isValid: false,
          discountAmount: 0,
          finalAmount: serviceAmount,
          cashbackAmount: 0,
          reason: "Offer not yet valid"
        };
      }
      if (now > validUntil) {
        return {
          isValid: false,
          discountAmount: 0,
          finalAmount: serviceAmount,
          cashbackAmount: 0,
          reason: "Offer has expired"
        };
      }
      if (offer.minimumPurchase && serviceAmount < offer.minimumPurchase) {
        return {
          isValid: false,
          discountAmount: 0,
          finalAmount: serviceAmount,
          cashbackAmount: 0,
          reason: `Minimum purchase of \u20B9${(offer.minimumPurchase / 100).toFixed(2)} required`
        };
      }
      if (userId) {
        const eligibility = await storage.getUserOfferEligibility(
          userId,
          offerId
        );
        if (!eligibility.eligible) {
          return {
            isValid: false,
            discountAmount: 0,
            finalAmount: serviceAmount,
            cashbackAmount: 0,
            reason: eligibility.reason || "User not eligible for this offer"
          };
        }
      }
      let discountAmount = 0;
      if (offer.discountType === "percentage") {
        discountAmount = Math.floor(
          serviceAmount * offer.discountValue / 100
        );
        if (offer.maxDiscount && discountAmount > offer.maxDiscount) {
          discountAmount = offer.maxDiscount;
        }
      } else if (offer.discountType === "fixed") {
        discountAmount = offer.discountValue;
      }
      if (discountAmount > serviceAmount) {
        discountAmount = serviceAmount;
      }
      const finalAmount = serviceAmount - discountAmount;
      return {
        isValid: true,
        discountAmount,
        finalAmount,
        cashbackAmount: 0,
        // Will be calculated separately for launch offers
        offer
      };
    } catch (error) {
      console.error("Error validating offer:", error);
      return {
        isValid: false,
        discountAmount: 0,
        finalAmount: serviceAmount,
        cashbackAmount: 0,
        reason: "Error validating offer"
      };
    }
  }
  async function calculateLaunchOfferCashback(userId, offerId, serviceAmount) {
    try {
      const launchOffers2 = await storage.getActiveLaunchOffers();
      const launchOffer = launchOffers2.find((o) => o.id === offerId);
      if (!launchOffer) {
        return 0;
      }
      let cashbackAmount = 0;
      if (launchOffer.walletCashbackPercent) {
        cashbackAmount = Math.floor(
          serviceAmount * launchOffer.walletCashbackPercent / 100
        );
      } else if (launchOffer.walletBonusInPaisa) {
        cashbackAmount = launchOffer.walletBonusInPaisa;
      }
      return cashbackAmount;
    } catch (error) {
      console.error("Error calculating launch offer cashback:", error);
      return 0;
    }
  }
  app2.get("/api/auth/user", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      }
      const userRoles2 = await storage.getUserRoles(user.id);
      const orgMemberships = await storage.getUserOrganizations(user.id);
      res.json({
        id: user.id,
        email: user.email,
        firstName: user.firstName,
        lastName: user.lastName,
        phone: user.phone,
        phoneVerified: user.phoneVerified === 1,
        profileImageUrl: user.profileImageUrl,
        workPreference: user.workPreference,
        businessCategory: user.businessCategory,
        roles: userRoles2.map((role) => role.name),
        orgMemberships
      });
    } catch (error) {
      console.error("Error fetching user:", error);
      res.status(500).json({ message: "Failed to fetch user" });
    }
  });
  app2.get("/api/chat/token", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.id;
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }
      const chatToken = generateAccessToken(userId, user.email || "");
      res.json({
        token: chatToken,
        expiresIn: 900,
        // 15 minutes in seconds
        userId: user.id,
        userName: `${user.firstName || ""} ${user.lastName || ""}`.trim() || "User",
        userAvatar: user.profileImageUrl
      });
    } catch (error) {
      console.error("Error generating chat token:", error);
      res.status(500).json({ error: "Failed to generate chat token" });
    }
  });
  app2.post("/api/auth/register", async (req, res) => {
    try {
      const {
        email,
        password,
        firstName,
        lastName,
        phone,
        userType,
        workPreference,
        panNumber,
        gstNumber,
        firebaseToken,
        phoneVerified
      } = req.body;
      if (!email || !password) {
        return res.status(400).json({ error: "Email and password are required" });
      }
      const existingUser = await storage.getUserByEmail(email);
      if (existingUser) {
        return res.status(400).json({ error: "User with this email already exists" });
      }
      let verifiedPhoneNumber = null;
      let isPhoneVerified = 0;
      if (firebaseToken && phoneVerified) {
        try {
          console.log("\u{1F510} Verifying Firebase token for registration...");
          const decodedToken = await verifyFirebaseToken(firebaseToken);
          if (decodedToken) {
            verifiedPhoneNumber = getPhoneNumberFromToken(decodedToken);
            if (verifiedPhoneNumber && phone && verifiedPhoneNumber !== phone) {
              return res.status(400).json({
                error: "Phone number mismatch. The verified phone number does not match the provided phone."
              });
            }
            isPhoneVerified = 1;
            console.log(
              "\u2705 Firebase token verified successfully. Phone verified:",
              verifiedPhoneNumber
            );
          }
        } catch (error) {
          console.error(
            "\u274C Firebase token verification failed:",
            error.message
          );
          return res.status(400).json({
            error: error.message || "Failed to verify phone number. Please try again."
          });
        }
      }
      const bcrypt = await import("bcryptjs");
      const hashedPassword = await bcrypt.default.hash(password, 10);
      const userData = {
        email,
        password: hashedPassword,
        firstName: firstName || "",
        lastName: lastName || "",
        phone: verifiedPhoneNumber || phone || null,
        workPreference: workPreference || null,
        businessCategory: null,
        // Will be set during business setup wizard
        businessName: null,
        // Will be set when selecting business template
        panNumber: panNumber || null,
        gstNumber: gstNumber || null,
        emailVerified: 0,
        phoneVerified: isPhoneVerified,
        isActive: 1
      };
      const newUser = await storage.createUser(userData);
      const roleName = userType === "owner" ? "owner" : "customer";
      let role = await storage.getRoleByName(roleName);
      if (!role) {
        role = await storage.createRole({
          name: roleName,
          description: userType === "owner" ? "Business owner" : "Customer"
        });
      }
      await storage.assignUserRole(newUser.id, role.id);
      if (userType === "owner") {
        try {
          const orgData = {
            name: `${firstName || "My"} Business Organization`,
            description: "Business organization for salon management",
            ownerUserId: newUser.id,
            status: "active"
          };
          const newOrg = await storage.createOrganization(orgData);
          await storage.addUserToOrganization(newOrg.id, newUser.id, "owner");
          const salonData = {
            name: "",
            // Empty - user will provide during Business Info step
            organizationId: newOrg.id,
            ownerId: newUser.id,
            address: "",
            city: "",
            state: "",
            zipCode: "",
            // Use zipCode instead of postalCode
            phone: phone || "",
            email,
            category: "",
            // Empty - user will select during Business Info step
            priceRange: "",
            // Empty - will be set during setup
            description: ""
            // Empty - user will provide during Business Info step
          };
          const newSalon = await storage.createSalon(salonData);
          console.log(
            `Auto-created organization ${newOrg.id} and salon ${newSalon.id} for business owner ${newUser.id}`
          );
        } catch (orgError) {
          console.error(
            "Failed to auto-create organization/salon for business owner:",
            orgError
          );
        }
      }
      req.session.userId = newUser.id;
      console.log(
        "Session established successfully after registration for user:",
        newUser.id
      );
      const roles2 = await storage.getUserRoles(newUser.id);
      const isOwner = roles2.some((role2) => role2.name === "owner");
      const isCustomer = roles2.some((role2) => role2.name === "customer");
      let redirectUrl = "/";
      if (isOwner) {
        redirectUrl = "/business/dashboard";
      } else if (isCustomer) {
        redirectUrl = "/customer/dashboard";
      }
      try {
        const verificationToken = crypto12.randomBytes(32).toString("hex");
        const hashedToken = crypto12.createHash("sha256").update(verificationToken).digest("hex");
        const verificationExpiry = /* @__PURE__ */ new Date();
        verificationExpiry.setHours(verificationExpiry.getHours() + 24);
        await storage.saveEmailVerificationToken(
          newUser.id,
          hashedToken,
          verificationExpiry
        );
        const baseUrl = process.env.APP_BASE_URL || (process.env.REPLIT_DOMAINS ? `https://${process.env.REPLIT_DOMAINS.split(",")[0]}` : "http://localhost:5000");
        const verificationLink = `${baseUrl}/api/auth/verify-email?token=${verificationToken}`;
        const isBusinessUser = userType === "owner";
        if (isBusinessUser) {
          const { sendBusinessWelcomeVerificationEmail: sendBusinessWelcomeVerificationEmail2 } = await Promise.resolve().then(() => (init_sendgrid(), sendgrid_exports));
          await sendBusinessWelcomeVerificationEmail2(
            newUser.email || "",
            verificationLink,
            newUser.firstName || void 0
          );
          console.log(
            "\u2705 Business welcome + verification email sent to:",
            newUser.email
          );
        } else {
          const { sendWelcomeVerificationEmail: sendWelcomeVerificationEmail2 } = await Promise.resolve().then(() => (init_sendgrid(), sendgrid_exports));
          await sendWelcomeVerificationEmail2(
            newUser.email || "",
            verificationLink,
            newUser.firstName || void 0
          );
          console.log(
            "\u2705 Customer welcome + verification email sent to:",
            newUser.email
          );
        }
      } catch (emailError) {
        console.error(
          "\u274C Email verification sending failed (non-blocking):",
          emailError
        );
      }
      const { password: _, ...userResponse } = newUser;
      res.status(200).json({
        success: true,
        user: userResponse,
        message: "Welcome to Stylemate! Your account has been created successfully.",
        requiresVerification: false,
        // Allow immediate access
        authenticated: true,
        redirect: redirectUrl
        // Consistent role-based redirect
      });
    } catch (error) {
      console.error("Registration error:", error);
      res.status(500).json({ error: "Failed to create account. Please try again." });
    }
  });
  app2.get("/api/auth/verify-email", async (req, res) => {
    try {
      const { token } = req.query;
      if (!token || typeof token !== "string") {
        return res.redirect("/email-verification-expired?error=invalid");
      }
      console.log("\u{1F510} Verifying email with token...");
      const hashedToken = crypto12.createHash("sha256").update(token).digest("hex");
      const user = await storage.getUserByEmailVerificationToken(hashedToken);
      if (!user) {
        console.log("\u274C Invalid verification token");
        return res.redirect("/email-verification-expired?error=invalid");
      }
      if (user.emailVerified === 1) {
        console.log("\u2705 Email already verified, redirecting to success page");
        return res.redirect("/email-verified?already=true");
      }
      if (!user.emailVerificationExpiry || /* @__PURE__ */ new Date() > user.emailVerificationExpiry) {
        console.log("\u23F0 Verification token has expired");
        return res.redirect("/email-verification-expired?error=expired");
      }
      await storage.markEmailAsVerified(user.id);
      console.log("\u2705 Email verified successfully for user:", user.email);
      return res.redirect("/email-verified");
    } catch (error) {
      console.error("\u274C Email verification error:", error);
      return res.redirect("/email-verification-expired?error=unknown");
    }
  });
  app2.post("/api/auth/resend-verification", async (req, res) => {
    try {
      const { email } = req.body;
      const userId = req.session?.userId;
      let user;
      if (userId) {
        user = await storage.getUserById(userId);
      } else if (email) {
        user = await storage.getUserByEmail(email);
      } else {
        return res.status(400).json({
          error: "Please provide your email address or log in to resend verification email."
        });
      }
      if (!user || !user.email) {
        return res.status(404).json({ error: "User not found" });
      }
      if (user.emailVerified === 1) {
        return res.status(400).json({
          error: "Email is already verified"
        });
      }
      if (user.emailVerificationSentAt) {
        const timeSinceLastSent = Date.now() - user.emailVerificationSentAt.getTime();
        const cooldownPeriod = 60 * 1e3;
        if (timeSinceLastSent < cooldownPeriod) {
          const remainingSeconds = Math.ceil(
            (cooldownPeriod - timeSinceLastSent) / 1e3
          );
          return res.status(429).json({
            error: `Please wait ${remainingSeconds} seconds before requesting another verification email.`,
            remainingSeconds
          });
        }
      }
      console.log("\u{1F4E7} Resending verification email to:", user.email);
      const verificationToken = crypto12.randomBytes(32).toString("hex");
      const hashedToken = crypto12.createHash("sha256").update(verificationToken).digest("hex");
      const verificationExpiry = /* @__PURE__ */ new Date();
      verificationExpiry.setHours(verificationExpiry.getHours() + 24);
      await storage.saveEmailVerificationToken(
        user.id,
        hashedToken,
        verificationExpiry
      );
      const baseUrl = process.env.APP_BASE_URL || (process.env.REPLIT_DOMAINS ? `https://${process.env.REPLIT_DOMAINS.split(",")[0]}` : "http://localhost:5000");
      const verificationLink = `${baseUrl}/api/auth/verify-email?token=${verificationToken}`;
      const isBusinessUser = user.workPreference !== null || user.businessCategory !== null;
      if (isBusinessUser) {
        const { sendBusinessWelcomeVerificationEmail: sendBusinessWelcomeVerificationEmail2 } = await Promise.resolve().then(() => (init_sendgrid(), sendgrid_exports));
        await sendBusinessWelcomeVerificationEmail2(
          user.email,
          verificationLink,
          user.firstName || void 0
        );
      } else {
        const { sendWelcomeVerificationEmail: sendWelcomeVerificationEmail2 } = await Promise.resolve().then(() => (init_sendgrid(), sendgrid_exports));
        await sendWelcomeVerificationEmail2(
          user.email,
          verificationLink,
          user.firstName || void 0
        );
      }
      console.log("\u2705 Verification email resent successfully to:", user.email);
      res.json({
        success: true,
        message: "Verification email sent! Please check your inbox.",
        emailSent: true
      });
    } catch (error) {
      console.error("\u274C Error resending verification email:", error);
      res.status(500).json({
        error: "Failed to resend verification email. Please try again later."
      });
    }
  });
  app2.post("/api/logout", (req, res) => {
    if (req.session) {
      req.session.destroy((err) => {
        if (err) {
          console.error("Logout error:", err);
          return res.status(500).json({ error: "Failed to logout" });
        }
        res.json({ success: true, message: "Logged out successfully" });
      });
    } else {
      res.json({ success: true, message: "Already logged out" });
    }
  });
  app2.post(
    "/api/auth/check-user-exists",
    communicationRateLimits.strict,
    async (req, res) => {
      try {
        const { email, phone } = req.body;
        if (!email && !phone) {
          return res.status(400).json({
            error: "Email or phone number is required"
          });
        }
        await new Promise((resolve) => setTimeout(resolve, 200));
        let userExists = false;
        let hasAccount = false;
        if (email) {
          const user = await storage.getUserByEmail(email);
          if (user) {
            userExists = true;
            hasAccount = !!user.password || user.emailVerified === 1;
          }
        }
        if (!userExists && phone) {
          const user = await storage.getUserByPhone(phone);
          if (user) {
            userExists = true;
            hasAccount = !!user.password || user.phoneVerified === 1;
          }
        }
        res.json({
          exists: userExists,
          hasAccount,
          // Suggest action based on account status
          suggestedAction: hasAccount ? "login" : "guest"
        });
      } catch (error) {
        console.error("Error checking user existence:", error);
        res.json({
          exists: false,
          hasAccount: false,
          suggestedAction: "guest"
        });
      }
    }
  );
  app2.post("/api/organizations", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.id;
      const { name, description } = req.body;
      if (!name) {
        return res.status(400).json({ error: "Organization name is required" });
      }
      const orgData = {
        name,
        description: description || "",
        ownerUserId: userId,
        status: "active"
      };
      const newOrg = await storage.createOrganization(orgData);
      await storage.addUserToOrganization(newOrg.id, userId, "owner");
      const salonData = {
        name: name + " Salon",
        description: "Your business salon",
        address: "Please update your address",
        city: "Please update",
        state: "Please update",
        zipCode: "00000",
        phone: "Please update your phone",
        email: req.user.email || "Please update",
        category: "hair_salon",
        priceRange: "$$",
        orgId: newOrg.id,
        ownerId: userId,
        isActive: 1
      };
      const newSalon = await storage.createSalon(salonData);
      res.status(201).json({
        success: true,
        organization: newOrg,
        salon: newSalon,
        message: "Organization and salon created successfully"
      });
    } catch (error) {
      console.error("Error creating organization:", error);
      res.status(500).json({ error: "Failed to create organization. Please try again." });
    }
  });
  app2.post("/api/salons", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.id;
      const {
        name,
        category,
        description,
        address,
        city,
        state,
        zipCode,
        phone,
        email,
        priceRange
      } = req.body;
      if (!name) {
        return res.status(400).json({ error: "Salon name is required" });
      }
      const userOrgs = await storage.getUserOrganizations(userId);
      let orgId = userOrgs[0]?.organization?.id;
      if (!orgId) {
        const newOrg = await storage.createOrganization({
          name: `${req.user.firstName || "Business"} Organization`,
          description: "Business organization for salon management",
          ownerUserId: userId,
          status: "active"
        });
        await storage.addUserToOrganization(newOrg.id, userId, "owner");
        orgId = newOrg.id;
      }
      const salonData = {
        name,
        description: description || "",
        address: address || "To be configured",
        city: city || "To be configured",
        state: state || "To be configured",
        zipCode: zipCode || "00000",
        phone: phone || "0000000000",
        email: email || req.user.email || "configure@stylemate.com",
        category: category || "hair_salon",
        priceRange: priceRange || "$$",
        orgId,
        ownerId: userId,
        isActive: 1
      };
      const newSalon = await storage.createSalon(salonData);
      res.status(201).json(newSalon);
    } catch (error) {
      console.error("Error creating salon:", error);
      res.status(500).json({ error: "Failed to create salon. Please try again." });
    }
  });
  app2.post("/api/auth/login", async (req, res) => {
    try {
      const { email, password, loginType } = req.body;
      if (!email || !password) {
        return res.status(400).json({ error: "Email and password are required" });
      }
      const user = await storage.getUserByEmail(email);
      if (!user) {
        return res.status(401).json({ error: "Invalid email or password" });
      }
      if (!user.password) {
        return res.status(401).json({
          error: "This account was created with social authentication. Please contact support to set a password."
        });
      }
      const bcrypt = await import("bcryptjs");
      const isValidPassword = await bcrypt.default.compare(
        password,
        user.password
      );
      if (!isValidPassword) {
        return res.status(401).json({ error: "Invalid email or password" });
      }
      const isBusinessUser = !!(user.workPreference || user.businessCategory || user.businessName);
      if (loginType === "customer" && isBusinessUser) {
        return res.status(403).json({
          error: "This is a business account. Please use the business login portal.",
          redirectTo: "/login/business"
        });
      }
      if (loginType === "business" && !isBusinessUser) {
        return res.status(403).json({
          error: "This is a customer account. Please use the customer login portal.",
          redirectTo: "/login/customer"
        });
      }
      req.session.userId = user.id;
      const accessToken = generateAccessToken(user.id, user.email);
      const deviceInfo = req.headers["user-agent"];
      const ipAddress = req.ip || req.connection.remoteAddress;
      const { token: refreshToken } = await generateRefreshToken(
        user.id,
        deviceInfo,
        ipAddress
      );
      res.cookie("refreshToken", refreshToken, {
        httpOnly: true,
        secure: process.env.NODE_ENV === "production",
        sameSite: "lax",
        // Changed from 'strict' to prevent cookie loss on page reload
        maxAge: 7 * 24 * 60 * 60 * 1e3,
        // 7 days
        path: "/"
      });
      const roles2 = await storage.getUserRoles(user.id);
      const isSuperAdmin = roles2.some((role) => role.name === "super_admin");
      const isOwner = roles2.some((role) => role.name === "owner");
      const isCustomer = roles2.some((role) => role.name === "customer");
      let redirectUrl = "/";
      if (isSuperAdmin) {
        redirectUrl = "/admin/dashboard";
      } else if (isOwner) {
        redirectUrl = "/business/dashboard";
      } else if (isCustomer) {
        redirectUrl = "/customer/dashboard";
      }
      const { password: _, ...userResponse } = user;
      res.json({
        success: true,
        user: userResponse,
        accessToken,
        // Mobile apps can use this token
        message: "Login successful",
        authenticated: true,
        redirect: redirectUrl
      });
    } catch (error) {
      console.error("Login error:", error);
      res.status(500).json({ error: "Login failed. Please try again." });
    }
  });
  app2.post("/api/auth/refresh", async (req, res) => {
    try {
      const refreshToken = req.cookies?.refreshToken;
      if (!refreshToken) {
        return res.status(401).json({ error: "No refresh token provided" });
      }
      const decoded = await verifyRefreshToken(refreshToken);
      const user = await storage.getUserById(decoded.userId);
      if (!user) {
        return res.status(401).json({ error: "User not found" });
      }
      const newAccessToken = generateAccessToken(user.id, user.email);
      const deviceInfo = req.headers["user-agent"];
      const ipAddress = req.ip || req.connection.remoteAddress;
      const { token: newRefreshToken } = await generateRefreshToken(
        user.id,
        deviceInfo,
        ipAddress
      );
      await revokeRefreshToken(decoded.tokenId);
      res.cookie("refreshToken", newRefreshToken, {
        httpOnly: true,
        secure: process.env.NODE_ENV === "production",
        sameSite: "lax",
        // Changed from 'strict' to prevent cookie loss on page reload
        maxAge: 7 * 24 * 60 * 60 * 1e3,
        // 7 days
        path: "/"
      });
      res.json({
        success: true,
        accessToken: newAccessToken,
        message: "Token refreshed successfully"
      });
    } catch (error) {
      console.error("Token refresh error:", error);
      res.status(401).json({ error: error.message || "Invalid or expired refresh token" });
    }
  });
  app2.post("/api/auth/logout", async (req, res) => {
    try {
      const refreshToken = req.cookies?.refreshToken;
      if (refreshToken) {
        try {
          const decoded = await verifyRefreshToken(refreshToken);
          await revokeRefreshToken(decoded.tokenId);
        } catch (error) {
          console.warn("Error revoking refresh token during logout:", error);
        }
      }
      res.clearCookie("refreshToken", {
        httpOnly: true,
        secure: process.env.NODE_ENV === "production",
        sameSite: "strict",
        path: "/"
      });
      if (req.session) {
        req.session.destroy((err) => {
          if (err) {
            console.error("Session destruction error:", err);
          }
        });
      }
      res.json({
        success: true,
        message: "Logged out successfully"
      });
    } catch (error) {
      console.error("Logout error:", error);
      res.status(500).json({ error: "Logout failed. Please try again." });
    }
  });
  app2.post("/api/auth/logout-all", async (req, res) => {
    try {
      const userId = req.session?.userId;
      if (!userId) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      await revokeAllUserTokens(userId);
      res.clearCookie("refreshToken", {
        httpOnly: true,
        secure: process.env.NODE_ENV === "production",
        sameSite: "strict",
        path: "/"
      });
      if (req.session) {
        req.session.destroy((err) => {
          if (err) {
            console.error("Session destruction error:", err);
          }
        });
      }
      res.json({
        success: true,
        message: "Logged out from all devices successfully"
      });
    } catch (error) {
      console.error("Logout all error:", error);
      res.status(500).json({ error: "Failed to logout from all devices" });
    }
  });
  app2.post("/api/auth/send-password-reset", async (req, res) => {
    try {
      const { email } = req.body;
      if (!email) {
        return res.status(400).json({ error: "Email is required" });
      }
      const user = await storage.getUserByEmail(email);
      const successMessage = "If an account exists with this email, you will receive a password reset link.";
      if (!user) {
        return res.json({ message: successMessage });
      }
      const { randomUUID: randomUUID2, createHash } = await import("crypto");
      const resetToken = randomUUID2();
      const resetExpiry = new Date(Date.now() + 36e5);
      const hashedToken = createHash("sha256").update(resetToken).digest("hex");
      await storage.savePasswordResetToken(user.id, hashedToken, resetExpiry);
      let baseUrl = process.env.APP_BASE_URL;
      if (!baseUrl && process.env.REPLIT_DOMAINS) {
        const domains = process.env.REPLIT_DOMAINS.split(",");
        baseUrl = `https://${domains[0].trim()}`;
      }
      if (!baseUrl) {
        baseUrl = "http://localhost:5000";
      }
      const resetLink = `${baseUrl}/reset-password?token=${resetToken}`;
      const { sendPasswordResetEmail: sendPasswordResetEmail2 } = await Promise.resolve().then(() => (init_sendgrid(), sendgrid_exports));
      try {
        await sendPasswordResetEmail2(email, resetLink, user.firstName);
        console.log(`[Password Reset] Email sent to ${email}`);
      } catch (emailError) {
        console.error("[Password Reset] Email error:", emailError);
      }
      return res.json({ message: successMessage });
    } catch (error) {
      console.error("[Password Reset] Error:", error);
      return res.status(500).json({ error: "Failed to process password reset request" });
    }
  });
  app2.post("/api/auth/verify-reset-token", async (req, res) => {
    try {
      const { token } = req.body;
      if (!token) {
        return res.status(400).json({ error: "Token is required" });
      }
      const { createHash } = await import("crypto");
      const hashedToken = createHash("sha256").update(token).digest("hex");
      const user = await storage.getUserByPasswordResetToken(hashedToken);
      if (!user || !user.passwordResetToken || !user.passwordResetExpiry) {
        return res.status(400).json({ error: "Invalid or expired token" });
      }
      if (new Date(user.passwordResetExpiry) < /* @__PURE__ */ new Date()) {
        await storage.clearPasswordResetToken(user.id);
        return res.status(400).json({
          error: "Token has expired. Please request a new password reset."
        });
      }
      return res.json({
        valid: true,
        email: user.email
      });
    } catch (error) {
      console.error("[Verify Reset Token] Error:", error);
      return res.status(500).json({ error: "Failed to verify token" });
    }
  });
  app2.post("/api/auth/request-password-reset", async (req, res) => {
    try {
      const { email } = req.body;
      if (!email) {
        return res.status(400).json({ error: "Email is required" });
      }
      const user = await storage.getUserByEmail(email);
      const successMessage = "If an account exists with this email, you will receive a password reset link.";
      if (!user) {
        return res.json({ message: successMessage });
      }
      const { randomUUID: randomUUID2, createHash } = await import("crypto");
      const resetToken = randomUUID2();
      const resetExpiry = new Date(Date.now() + 36e5);
      const hashedToken = createHash("sha256").update(resetToken).digest("hex");
      await storage.savePasswordResetToken(user.id, hashedToken, resetExpiry);
      let baseUrl = process.env.APP_BASE_URL;
      if (!baseUrl && process.env.REPLIT_DOMAINS) {
        const domains = process.env.REPLIT_DOMAINS.split(",");
        baseUrl = `https://${domains[0].trim()}`;
      }
      if (!baseUrl) {
        baseUrl = "http://localhost:5000";
      }
      const resetLink = `${baseUrl}/reset-password?token=${resetToken}`;
      const { sendPasswordResetEmail: sendPasswordResetEmail2 } = await Promise.resolve().then(() => (init_sendgrid(), sendgrid_exports));
      try {
        await sendPasswordResetEmail2(email, resetLink, user.firstName);
        console.log(`[Password Reset] Email sent to ${email}`);
      } catch (emailError) {
        console.error("[Password Reset] Email error:", emailError);
      }
      return res.json({ message: successMessage });
    } catch (error) {
      console.error("[Password Reset] Error:", error);
      return res.status(500).json({ error: "Failed to process password reset request" });
    }
  });
  app2.post("/api/auth/confirm-password-reset", async (req, res) => {
    try {
      const { token, newPassword } = req.body;
      if (!token || !newPassword) {
        return res.status(400).json({ error: "Token and new password are required" });
      }
      if (newPassword.length < 6) {
        return res.status(400).json({ error: "Password must be at least 6 characters long" });
      }
      const { createHash } = await import("crypto");
      const hashedToken = createHash("sha256").update(token).digest("hex");
      const user = await storage.getUserByPasswordResetToken(hashedToken);
      if (!user || !user.passwordResetToken || !user.passwordResetExpiry) {
        return res.status(400).json({ error: "Invalid or expired token" });
      }
      if (new Date(user.passwordResetExpiry) < /* @__PURE__ */ new Date()) {
        await storage.clearPasswordResetToken(user.id);
        return res.status(400).json({ error: "Token has expired" });
      }
      const bcrypt = await import("bcryptjs");
      const hashedPassword = await bcrypt.default.hash(newPassword, 10);
      await storage.updateUserPassword(user.id, hashedPassword);
      await storage.clearPasswordResetToken(user.id);
      const { sendPasswordChangedEmail: sendPasswordChangedEmail2 } = await Promise.resolve().then(() => (init_sendgrid(), sendgrid_exports));
      try {
        await sendPasswordChangedEmail2(user.email, user.firstName);
      } catch (emailError) {
        console.error("[Password Changed Email] Error:", emailError);
      }
      return res.json({
        message: "Password successfully reset. You can now login with your new password."
      });
    } catch (error) {
      console.error("[Confirm Password Reset] Error:", error);
      return res.status(500).json({ error: "Failed to reset password" });
    }
  });
  app2.post("/api/auth/reset-password-via-phone", async (req, res) => {
    try {
      const { firebaseToken, phoneNumber, newPassword } = req.body;
      if (!firebaseToken || !phoneNumber || !newPassword) {
        return res.status(400).json({
          error: "Firebase token, phone number, and new password are required"
        });
      }
      if (newPassword.length < 8) {
        return res.status(400).json({ error: "Password must be at least 8 characters long" });
      }
      const { verifyFirebaseToken: verifyFirebaseToken2, getPhoneNumberFromToken: getPhoneNumberFromToken2 } = await Promise.resolve().then(() => (init_firebaseAdmin(), firebaseAdmin_exports));
      try {
        const decodedToken = await verifyFirebaseToken2(firebaseToken);
        const tokenPhone = getPhoneNumberFromToken2(decodedToken);
        if (!tokenPhone) {
          return res.status(400).json({ error: "Firebase token does not contain a phone number" });
        }
        const normalizePhone = (phone) => phone.replace(/\D/g, "");
        if (normalizePhone(tokenPhone) !== normalizePhone(phoneNumber)) {
          return res.status(400).json({ error: "Phone number mismatch" });
        }
        const user = await storage.getUserByPhone(phoneNumber);
        if (!user) {
          return res.status(404).json({ error: "No account found with this phone number" });
        }
        const bcrypt = await import("bcryptjs");
        const hashedPassword = await bcrypt.default.hash(newPassword, 10);
        await storage.updateUserPassword(user.id, hashedPassword);
        if (user.email) {
          const { sendPasswordChangedEmail: sendPasswordChangedEmail2 } = await Promise.resolve().then(() => (init_sendgrid(), sendgrid_exports));
          try {
            await sendPasswordChangedEmail2(user.email, user.firstName);
          } catch (emailError) {
            console.error("[Password Changed Email] Error:", emailError);
          }
        }
        console.log(
          `[Password Reset via Phone] Password reset successful for user ${user.id}`
        );
        return res.json({
          success: true,
          message: "Password successfully reset. You can now login with your new password."
        });
      } catch (firebaseError) {
        console.error("[Firebase Verification] Error:", firebaseError);
        return res.status(400).json({ error: "Invalid or expired Firebase token" });
      }
    } catch (error) {
      console.error("[Reset Password via Phone] Error:", error);
      return res.status(500).json({ error: "Failed to reset password" });
    }
  });
  app2.get("/api/salon-details/:salonId", async (req, res) => {
    try {
      const { salonId } = req.params;
      const salon = await storage.getSalon(salonId);
      if (!salon) {
        return res.status(404).json({ error: "Salon not found" });
      }
      const mediaAssets2 = await storage.getMediaAssetsBySalonId(salonId);
      const primaryImage = mediaAssets2?.find(
        (asset) => asset.type === "image" && asset.isPrimary === 1
      )?.url || mediaAssets2?.find((asset) => asset.type === "image")?.url || "";
      const salonWithImage = {
        ...salon,
        image: primaryImage,
        openTime: salon.openTime || "09:00",
        closeTime: salon.closeTime || "18:00"
      };
      res.json(salonWithImage);
    } catch (error) {
      console.error("Error fetching salon:", error);
      res.status(500).json({ error: "Failed to fetch salon" });
    }
  });
  app2.get("/api/salons/:salonId", async (req, res) => {
    try {
      const { salonId } = req.params;
      const salon = await storage.getSalon(salonId);
      if (!salon) {
        return res.status(404).json({ error: "Salon not found" });
      }
      const mediaAssets2 = await storage.getMediaAssetsBySalonId(salonId);
      const primaryImage = mediaAssets2?.find(
        (asset) => asset.type === "image" && asset.isPrimary === 1
      )?.url || mediaAssets2?.find((asset) => asset.type === "image")?.url || "";
      const salonWithImage = {
        ...salon,
        image: primaryImage,
        openTime: salon.openTime || "09:00",
        closeTime: salon.closeTime || "18:00"
      };
      res.json(salonWithImage);
    } catch (error) {
      console.error("Error fetching salon:", error);
      res.status(500).json({ error: "Failed to fetch salon" });
    }
  });
  app2.get("/api/salons/:salonId/nearby", async (req, res) => {
    try {
      const { salonId } = req.params;
      const limit = parseInt(req.query.limit) || 6;
      const currentSalon = await storage.getSalon(salonId);
      if (!currentSalon) {
        return res.status(404).json({ error: "Salon not found" });
      }
      if (!currentSalon.latitude || !currentSalon.longitude) {
        return res.json([]);
      }
      const currentLat = parseFloat(currentSalon.latitude);
      const currentLng = parseFloat(currentSalon.longitude);
      const maxDistanceKm = 3;
      const nearbySalons = await db.select({
        id: salons10.id,
        name: salons10.name,
        description: salons10.description,
        address: salons10.address,
        city: salons10.city,
        state: salons10.state,
        zipCode: salons10.zipCode,
        latitude: salons10.latitude,
        longitude: salons10.longitude,
        phone: salons10.phone,
        email: salons10.email,
        website: salons10.website,
        category: salons10.category,
        priceRange: salons10.priceRange,
        rating: salons10.rating,
        reviewCount: salons10.reviewCount,
        googleRating: salons10.googleRating,
        googleReviewCount: salons10.googleReviewCount,
        imageUrl: salons10.imageUrl,
        imageUrls: salons10.imageUrls,
        openTime: salons10.openTime,
        closeTime: salons10.closeTime,
        distance: sql44`
            6371 * acos(
              cos(radians(${currentLat})) * 
              cos(radians(CAST(${salons10.latitude} AS FLOAT))) * 
              cos(radians(CAST(${salons10.longitude} AS FLOAT)) - radians(${currentLng})) + 
              sin(radians(${currentLat})) * 
              sin(radians(CAST(${salons10.latitude} AS FLOAT)))
            )
          `.as("distance_km")
      }).from(salons10).where(
        and56(
          eq58(salons10.isActive, 1),
          ne5(salons10.id, salonId),
          isNotNull3(salons10.latitude),
          isNotNull3(salons10.longitude),
          // Only include salons within maxDistanceKm radius
          sql44`6371 * acos(
              cos(radians(${currentLat})) * 
              cos(radians(CAST(${salons10.latitude} AS FLOAT))) * 
              cos(radians(CAST(${salons10.longitude} AS FLOAT)) - radians(${currentLng})) + 
              sin(radians(${currentLat})) * 
              sin(radians(CAST(${salons10.latitude} AS FLOAT)))
            ) <= ${maxDistanceKm}`
        )
      ).orderBy(sql44`distance_km`).limit(limit);
      const salonsWithImages = await Promise.all(
        nearbySalons.map(async (salon) => {
          const mediaAssets2 = await storage.getMediaAssetsBySalonId(salon.id);
          const safeAssets = mediaAssets2 ?? [];
          const imageTypes = ["gallery", "cover", "logo"];
          const primaryImageUrl = safeAssets.find(
            (asset) => imageTypes.includes(asset.assetType) && asset.isPrimary === 1
          )?.url || safeAssets.find(
            (asset) => imageTypes.includes(asset.assetType)
          )?.url || "";
          const imageUrls = safeAssets.filter((asset) => imageTypes.includes(asset.assetType)).map((asset) => asset.url).slice(0, 4);
          const finalImageUrls = imageUrls.length > 0 ? imageUrls : Array.isArray(salon.imageUrls) ? salon.imageUrls : [];
          const hasGoogleReviews = salon.googleReviewCount && salon.googleReviewCount > 0;
          return {
            ...salon,
            image: primaryImageUrl,
            imageUrls: finalImageUrls,
            distance_km: Number(salon.distance) || 0,
            hasGoogleReviews
          };
        })
      );
      res.json(salonsWithImages);
    } catch (error) {
      console.error("Error fetching nearby salons:", error);
      res.status(500).json({ error: "Failed to fetch nearby salons" });
    }
  });
  app2.get(
    "/api/salons/:salonId/manage",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const salon = await storage.getSalon(salonId);
        if (!salon) {
          return res.status(404).json({ error: "Salon not found" });
        }
        res.json(salon);
      } catch (error) {
        console.error("Error fetching salon:", error);
        res.status(500).json({ error: "Failed to fetch salon" });
      }
    }
  );
  app2.put(
    "/api/salons/:salonId",
    isAuthenticated,
    requireSalonAccess(["owner", "manager"], "settings.shop"),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const partialSchema = insertSalonSchema.partial();
        const validationResult = partialSchema.safeParse(req.body);
        if (!validationResult.success) {
          return res.status(400).json({
            error: "Invalid input",
            details: validationResult.error.issues
          });
        }
        const {
          isActive,
          disabledBySuperAdmin,
          disabledReason,
          disabledAt,
          disabledBy,
          approvalStatus,
          approvedAt,
          approvedBy,
          rejectionReason,
          ...safeData
        } = validationResult.data;
        if (isActive !== void 0 || approvalStatus !== void 0) {
          console.log(`Blocked attempt to update protected fields by salon owner for salon ${salonId}`);
        }
        await storage.updateSalon(salonId, safeData);
        const updatedSalon = await storage.getSalon(salonId);
        res.json(updatedSalon);
      } catch (error) {
        console.error("Error updating salon:", error);
        res.status(500).json({ error: "Failed to update salon" });
      }
    }
  );
  app2.post(
    "/api/salons/:salonId/toggle-status",
    isAuthenticated,
    requireSalonAccess(["owner"]),
    requireBusinessOwner(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const { isActive, reason } = req.body;
        const userId = req.user.id;
        if (typeof isActive !== "boolean") {
          return res.status(400).json({ error: "isActive must be a boolean" });
        }
        const salon = await storage.getSalon(salonId);
        if (!salon) {
          return res.status(404).json({ error: "Salon not found" });
        }
        if (isActive && salon.disabledBySuperAdmin === 1) {
          return res.status(403).json({
            error: "This salon was disabled by a platform administrator. Please contact support to re-enable your salon.",
            disabledReason: salon.disabledReason,
            disabledAt: salon.disabledAt,
            disabledBySuperAdmin: true
          });
        }
        await storage.toggleSalonStatus(salonId, isActive, {
          disabledBySuperAdmin: false,
          disabledReason: reason || (isActive ? null : "Temporarily paused by owner"),
          disabledBy: isActive ? void 0 : userId
        });
        res.json({
          success: true,
          message: isActive ? "Salon enabled successfully" : "Salon temporarily paused",
          isActive
        });
      } catch (error) {
        console.error("Error toggling salon status:", error);
        if (error.message && error.message.includes("platform administrator")) {
          return res.status(403).json({
            error: error.message,
            disabledBySuperAdmin: true
          });
        }
        res.status(500).json({ error: "Failed to update salon status" });
      }
    }
  );
  app2.delete(
    "/api/salons/:salonId",
    isAuthenticated,
    requireSalonAccess(["owner"]),
    requireBusinessOwner(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const userId = req.user.id;
        const orgMemberships = await storage.getUserOrganizations(userId);
        const allSalons = await storage.getSalons();
        const accessibleSalons = allSalons.filter((salon) => {
          if (salon.ownerId === userId) return true;
          if (salon.orgId) {
            return orgMemberships.some(
              (membership) => membership.orgId === salon.orgId && ["owner", "manager"].includes(membership.orgRole)
            );
          }
          return false;
        });
        if (accessibleSalons.length <= 1) {
          return res.status(400).json({
            error: "Cannot delete your only salon. You must have at least one salon."
          });
        }
        await storage.deleteSalon(salonId);
        res.json({
          success: true,
          message: "Salon deleted successfully",
          remainingSalons: accessibleSalons.length - 1
        });
      } catch (error) {
        console.error("Error deleting salon:", error);
        res.status(500).json({ error: "Failed to delete salon" });
      }
    }
  );
  app2.get(
    "/api/salons/:salonId/setup-status",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const [
          salon,
          services6,
          staff5,
          bookingSettings2,
          payoutAccount,
          mediaAssets2
        ] = await Promise.all([
          storage.getSalon(salonId),
          storage.getServicesBySalonId(salonId),
          storage.getStaffBySalonId(salonId),
          storage.getBookingSettings(salonId),
          storage.getPayoutAccount(salonId),
          storage.getMediaAssetsBySalonId(salonId)
        ]);
        if (!salon) {
          return res.status(404).json({ error: "Salon not found" });
        }
        const setupStatus = {
          businessInfo: {
            completed: !!(salon.name && salon.category),
            requiredFields: ["name", "category"],
            missingFields: []
          },
          locationContact: {
            completed: !!(salon.address && salon.city && salon.state && salon.zipCode && salon.latitude && salon.longitude && salon.phone && salon.email),
            requiredFields: [
              "address",
              "city",
              "state",
              "zipCode",
              "latitude",
              "longitude",
              "phone",
              "email"
            ],
            missingFields: []
          },
          services: {
            completed: services6 && services6.length > 0,
            count: services6?.length || 0,
            message: services6 && services6.length > 0 ? `${services6.length} service(s) added` : "No services added yet"
          },
          staff: {
            completed: staff5 && staff5.length > 0,
            count: staff5?.length || 0,
            message: staff5 && staff5.length > 0 ? `${staff5.length} team member(s) added` : "No staff added yet"
          },
          resources: {
            completed: true,
            // Optional step
            optional: true,
            message: "Resources are optional"
          },
          bookingSettings: {
            completed: !!bookingSettings2,
            message: bookingSettings2 ? "Booking settings configured" : "Booking settings not configured"
          },
          paymentSetup: {
            completed: !!payoutAccount,
            optional: true,
            // Optional - salon can publish and configure payments later
            message: payoutAccount ? "Payment account configured" : "Payment not configured - bookings will work but payments disabled"
          },
          media: {
            completed: mediaAssets2 && mediaAssets2.length > 0,
            count: mediaAssets2?.length || 0,
            message: mediaAssets2 && mediaAssets2.length > 0 ? `${mediaAssets2.length} photo(s) uploaded` : "No photos uploaded yet"
          }
        };
        if (!setupStatus.businessInfo.completed) {
          setupStatus.businessInfo.missingFields = setupStatus.businessInfo.requiredFields.filter(
            (field) => !salon[field]
          );
        }
        if (!setupStatus.locationContact.completed) {
          setupStatus.locationContact.missingFields = setupStatus.locationContact.requiredFields.filter(
            (field) => !salon[field]
          );
        }
        const requiredSteps = [
          "businessInfo",
          "locationContact",
          "services",
          "staff",
          "bookingSettings",
          "media"
        ];
        const completedSteps = requiredSteps.filter(
          (step) => setupStatus[step].completed
        );
        const isSetupComplete = completedSteps.length === requiredSteps.length;
        const progressData = {
          businessInfo: {
            completed: setupStatus.businessInfo.completed,
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          },
          locationContact: {
            completed: setupStatus.locationContact.completed,
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          },
          services: {
            completed: setupStatus.services.completed,
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          },
          staff: {
            completed: setupStatus.staff.completed,
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          },
          resources: {
            completed: setupStatus.resources.completed,
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          },
          bookingSettings: {
            completed: setupStatus.bookingSettings.completed,
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          },
          paymentSetup: {
            completed: setupStatus.paymentSetup.completed,
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          },
          media: {
            completed: setupStatus.media.completed,
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          },
          lastUpdated: (/* @__PURE__ */ new Date()).toISOString(),
          isComplete: isSetupComplete
        };
        await storage.updateSalon(salonId, { setupProgress: progressData });
        res.json({
          salonId,
          isSetupComplete,
          completedSteps: completedSteps.length,
          totalSteps: requiredSteps.length,
          progress: Math.round(
            completedSteps.length / requiredSteps.length * 100
          ),
          steps: setupStatus
        });
      } catch (error) {
        console.error("Error fetching salon setup status:", error);
        res.status(500).json({ error: "Failed to fetch setup status" });
      }
    }
  );
  app2.get(
    "/api/salons/:salonId/product-categories/public",
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const allCategories = await storage.getProductCategoriesBySalonId(salonId);
        const sanitizedCategories = allCategories.filter((cat) => cat.isActive === 1).map((cat) => ({
          id: cat.id,
          name: cat.name,
          description: cat.description,
          parentCategoryId: cat.parentCategoryId
        }));
        res.json({ categories: sanitizedCategories });
      } catch (error) {
        console.error("Error fetching public product categories:", error);
        res.status(500).json({ error: "Failed to fetch product categories" });
      }
    }
  );
  app2.get(
    "/api/salons/:salonId/product-categories",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const categories = await storage.getProductCategoriesBySalonId(salonId);
        res.json(categories);
      } catch (error) {
        console.error("Error fetching product categories:", error);
        res.status(500).json({ error: "Failed to fetch product categories" });
      }
    }
  );
  app2.post(
    "/api/salons/:salonId/product-categories",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const category = await storage.createProductCategory({
          ...req.body,
          salonId
        });
        res.status(201).json(category);
      } catch (error) {
        console.error("Error creating product category:", error);
        res.status(400).json({
          error: error.message || "Failed to create product category"
        });
      }
    }
  );
  app2.put(
    "/api/salons/:salonId/product-categories/:categoryId",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId, categoryId } = req.params;
        await storage.updateProductCategory(categoryId, salonId, req.body);
        res.json({ success: true, message: "Category updated successfully" });
      } catch (error) {
        console.error("Error updating product category:", error);
        res.status(400).json({
          error: error.message || "Failed to update product category"
        });
      }
    }
  );
  app2.delete(
    "/api/salons/:salonId/product-categories/:categoryId",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId, categoryId } = req.params;
        await storage.deleteProductCategory(categoryId, salonId);
        res.json({ success: true, message: "Category deleted successfully" });
      } catch (error) {
        console.error("Error deleting product category:", error);
        res.status(400).json({
          error: error.message || "Failed to delete product category"
        });
      }
    }
  );
  app2.post(
    "/api/salons/:salonId/product-categories/init-defaults",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const categories = await storage.createDefaultProductCategories(salonId);
        res.status(201).json({
          success: true,
          categories,
          message: "Default categories created successfully"
        });
      } catch (error) {
        console.error("Error creating default categories:", error);
        res.status(400).json({
          error: error.message || "Failed to create default categories"
        });
      }
    }
  );
  app2.get(
    "/api/salons/:salonId/vendors",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const vendors2 = await storage.getVendorsBySalonId(salonId);
        res.json(vendors2);
      } catch (error) {
        console.error("Error fetching vendors:", error);
        res.status(500).json({ error: "Failed to fetch vendors" });
      }
    }
  );
  app2.post(
    "/api/salons/:salonId/vendors",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const vendor = await storage.createVendor({ ...req.body, salonId });
        res.status(201).json(vendor);
      } catch (error) {
        console.error("Error creating vendor:", error);
        res.status(400).json({ error: error.message || "Failed to create vendor" });
      }
    }
  );
  app2.put(
    "/api/salons/:salonId/vendors/:vendorId",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId, vendorId } = req.params;
        await storage.updateVendor(vendorId, salonId, req.body);
        res.json({ success: true, message: "Vendor updated successfully" });
      } catch (error) {
        console.error("Error updating vendor:", error);
        res.status(400).json({ error: error.message || "Failed to update vendor" });
      }
    }
  );
  app2.delete(
    "/api/salons/:salonId/vendors/:vendorId",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId, vendorId } = req.params;
        await storage.deleteVendor(vendorId, salonId);
        res.json({ success: true, message: "Vendor deleted successfully" });
      } catch (error) {
        console.error("Error deleting vendor:", error);
        res.status(400).json({ error: error.message || "Failed to delete vendor" });
      }
    }
  );
  app2.get(
    "/api/salons/:salonId/products",
    isAuthenticated,
    requireSalonAccess(["owner", "manager"], "products.view"),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const filters = {
          categoryId: req.query.categoryId,
          vendorId: req.query.vendorId,
          lowStock: req.query.lowStock === "true",
          search: req.query.search,
          isActive: req.query.isActive !== void 0 ? req.query.isActive === "true" : void 0
        };
        const productsData = await storage.getProductsBySalonId(
          salonId,
          filters
        );
        const productIds = productsData.map((p) => p.id);
        let retailConfigs = [];
        if (productIds.length > 0) {
          retailConfigs = await db.select().from(productRetailConfig).where(inArray22(productRetailConfig.productId, productIds));
        }
        const products2 = productsData.map((product) => {
          const retailConfig = retailConfigs.find(
            (rc) => rc.productId === product.id
          );
          return {
            ...product,
            retailDescription: retailConfig?.retailDescription,
            retailStockAllocated: retailConfig?.retailStockAllocated,
            featured: retailConfig?.featured
          };
        });
        res.json(products2);
      } catch (error) {
        console.error("Error fetching products:", error);
        res.status(500).json({ error: "Failed to fetch products" });
      }
    }
  );
  app2.get(
    "/api/salons/:salonId/products/low-stock",
    isAuthenticated,
    requireSalonAccess(["owner", "manager"], "products.view"),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const products2 = await storage.getLowStockProducts(salonId);
        res.json(products2);
      } catch (error) {
        console.error("Error fetching low stock products:", error);
        res.status(500).json({ error: "Failed to fetch low stock products" });
      }
    }
  );
  app2.post(
    "/api/salons/:salonId/products",
    isAuthenticated,
    requireSalonAccess(["owner", "manager"], "products.manage"),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const product = await storage.createProduct({ ...req.body, salonId });
        res.status(201).json(product);
      } catch (error) {
        console.error("Error creating product:", error);
        res.status(400).json({ error: error.message || "Failed to create product" });
      }
    }
  );
  app2.put(
    "/api/salons/:salonId/products/:productId",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId, productId } = req.params;
        await storage.updateProduct(productId, salonId, req.body);
        res.json({ success: true, message: "Product updated successfully" });
      } catch (error) {
        console.error("Error updating product:", error);
        res.status(400).json({ error: error.message || "Failed to update product" });
      }
    }
  );
  app2.put(
    "/api/salons/:salonId/products/:productId/retail-config",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId, productId } = req.params;
        const configSchema = z23.object({
          availableForRetail: z23.boolean(),
          retailPriceInPaisa: z23.number().int().min(0).optional(),
          retailDescription: z23.string().optional(),
          featured: z23.boolean().optional()
        });
        const validated = configSchema.parse(req.body);
        await storage.configureProductForRetail(productId, salonId, validated);
        res.json({
          success: true,
          message: "Product retail configuration updated successfully"
        });
      } catch (error) {
        console.error("Error configuring product for retail:", error);
        if (error.name === "ZodError") {
          res.status(400).json({ error: "Invalid retail configuration data" });
        } else {
          res.status(400).json({
            error: error.message || "Failed to configure product for retail"
          });
        }
      }
    }
  );
  app2.put(
    "/api/salons/:salonId/products/:productId/allocate-retail-stock",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId, productId } = req.params;
        const allocationSchema = z23.object({
          retailStockAllocated: z23.number().min(0, "Stock allocation must be 0 or greater").finite("Stock allocation must be a valid number"),
          retailPriceInPaisa: z23.number().int().min(1, "Retail price must be at least \u20B90.01").optional(),
          // Customer-facing price
          useAllocatedStock: z23.number().int().min(0).max(1).optional(),
          // 0=warehouse stock, 1=allocated stock
          lowStockThreshold: z23.number().min(0).finite().optional()
          // Alert threshold
        });
        const validated = allocationSchema.parse(req.body);
        const product = await storage.getProductByIdForSalon(
          productId,
          salonId,
          true
        );
        if (!product) {
          return res.status(404).json({
            error: "Product not found or does not belong to this salon"
          });
        }
        const totalStock = parseFloat(String(product.currentStock || 0));
        if (validated.retailStockAllocated > totalStock) {
          return res.status(400).json({
            error: `Cannot allocate more than available stock (${totalStock} ${product.unit})`,
            available: totalStock
          });
        }
        await storage.allocateRetailStock(productId, salonId, validated);
        res.json({
          success: true,
          message: "Retail stock allocation updated successfully"
        });
      } catch (error) {
        console.error("Error allocating retail stock:", error);
        if (error.name === "ZodError") {
          res.status(400).json({ error: "Invalid stock allocation data" });
        } else {
          res.status(400).json({
            error: error.message || "Failed to allocate retail stock"
          });
        }
      }
    }
  );
  app2.delete(
    "/api/salons/:salonId/products/:productId",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId, productId } = req.params;
        await storage.deleteProduct(productId, salonId);
        res.json({ success: true, message: "Product deleted successfully" });
      } catch (error) {
        console.error("Error deleting product:", error);
        res.status(400).json({ error: error.message || "Failed to delete product" });
      }
    }
  );
  app2.get(
    "/api/salons/:salonId/stock-movements",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const filters = {
          productId: req.query.productId,
          type: req.query.type,
          startDate: req.query.startDate,
          endDate: req.query.endDate,
          limit: req.query.limit ? parseInt(req.query.limit) : void 0
        };
        const movements = await storage.getStockMovementsBySalonId(
          salonId,
          filters
        );
        res.json(movements);
      } catch (error) {
        console.error("Error fetching stock movements:", error);
        res.status(500).json({ error: "Failed to fetch stock movements" });
      }
    }
  );
  app2.get(
    "/api/salons/:salonId/products/:productId/stock-movements",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId, productId } = req.params;
        const movements = await storage.getStockMovementsByProduct(
          productId,
          salonId
        );
        res.json(movements);
      } catch (error) {
        console.error("Error fetching product stock movements:", error);
        res.status(500).json({ error: "Failed to fetch product stock movements" });
      }
    }
  );
  app2.post(
    "/api/salons/:salonId/stock-movements",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const { allowNegativeStock, ...movementData } = req.body;
        const movement = await storage.createStockMovement(
          { ...movementData, salonId, staffId: req.user.id },
          { allowNegativeStock }
        );
        res.status(201).json(movement);
      } catch (error) {
        console.error("Error creating stock movement:", error);
        res.status(400).json({ error: error.message || "Failed to create stock movement" });
      }
    }
  );
  app2.get(
    "/api/salons/:salonId/purchase-orders",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const filters = {
          status: req.query.status,
          vendorId: req.query.vendorId,
          startDate: req.query.startDate,
          endDate: req.query.endDate,
          limit: req.query.limit ? parseInt(req.query.limit) : void 0
        };
        console.log("\u{1F50D} Fetching purchase orders with filters:", {
          salonId,
          filters
        });
        const orders = await storage.getPurchaseOrdersBySalonId(
          salonId,
          filters
        );
        console.log("\u{1F4E6} Raw orders from database:", orders.length, orders);
        const transformedOrders = await Promise.all(
          orders.map(async (order) => {
            const vendor = await storage.getVendor(order.vendorId, salonId);
            const transformed = {
              id: order.id,
              poNumber: order.orderNumber,
              vendorId: order.vendorId,
              vendorName: vendor?.name || "Unknown Vendor",
              orderDate: order.orderDate,
              expectedDeliveryDate: order.expectedDeliveryDate,
              status: order.status,
              totalAmount: order.totalInPaisa,
              createdAt: order.createdAt
            };
            console.log("\u2705 Transformed order:", transformed);
            return transformed;
          })
        );
        console.log("\u{1F4E4} Sending transformed orders:", transformedOrders.length);
        res.json(transformedOrders);
      } catch (error) {
        console.error("\u274C Error fetching purchase orders:", error);
        res.status(500).json({ error: "Failed to fetch purchase orders" });
      }
    }
  );
  app2.get(
    "/api/salons/:salonId/purchase-orders/:orderId",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId, orderId } = req.params;
        const [order, items] = await Promise.all([
          storage.getPurchaseOrder(orderId, salonId),
          storage.getPurchaseOrderItems(orderId, salonId)
        ]);
        if (!order) {
          return res.status(404).json({ error: "Purchase order not found" });
        }
        const vendor = await storage.getVendor(order.vendorId, salonId);
        const transformedOrder = {
          id: order.id,
          poNumber: order.orderNumber,
          vendorId: order.vendorId,
          vendorName: vendor?.name || "Unknown Vendor",
          orderDate: order.orderDate,
          expectedDeliveryDate: order.expectedDeliveryDate,
          actualDeliveryDate: order.actualDeliveryDate,
          status: order.status,
          totalAmount: order.totalInPaisa,
          subtotalInPaisa: order.subtotalInPaisa,
          taxInPaisa: order.taxInPaisa,
          shippingInPaisa: order.shippingInPaisa,
          discountInPaisa: order.discountInPaisa,
          notes: order.notes,
          createdAt: order.createdAt,
          updatedAt: order.updatedAt
        };
        const transformedItems = items.map((item) => ({
          id: item.id,
          productId: item.productId,
          product_name: item.product_name,
          sku: item.sku,
          quantity: item.quantity,
          unit: item.unit,
          unitCostInPaisa: item.unitCostInPaisa,
          totalCostInPaisa: item.totalCostInPaisa
        }));
        res.json({ ...transformedOrder, items: transformedItems });
      } catch (error) {
        console.error("Error fetching purchase order:", error);
        res.status(500).json({ error: "Failed to fetch purchase order" });
      }
    }
  );
  app2.post(
    "/api/salons/:salonId/purchase-orders",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const { items, vendor_id, expected_delivery_date, ...rest } = req.body;
        if (!items || items.length === 0) {
          return res.status(400).json({ error: "Purchase order must have at least one item" });
        }
        const deliveryDate = expected_delivery_date ? new Date(expected_delivery_date) : null;
        const orderData = {
          vendorId: vendor_id,
          expectedDeliveryDate: deliveryDate,
          ...rest,
          salonId,
          createdBy: req.user.id
        };
        const itemsData = items.map((item) => ({
          productId: item.product_id,
          quantity: item.quantity,
          unit: item.unit || "units",
          unitCostInPaisa: item.unit_price,
          totalCostInPaisa: item.quantity * item.unit_price
        }));
        const result = await storage.createPurchaseOrder(orderData, itemsData);
        res.status(201).json(result);
      } catch (error) {
        console.error("Error creating purchase order:", error);
        res.status(400).json({ error: error.message || "Failed to create purchase order" });
      }
    }
  );
  app2.put(
    "/api/salons/:salonId/purchase-orders/:orderId/approve",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId, orderId } = req.params;
        await storage.approvePurchaseOrder(orderId, salonId, req.user.id);
        res.json({
          success: true,
          message: "Purchase order approved successfully"
        });
      } catch (error) {
        console.error("Error approving purchase order:", error);
        res.status(400).json({ error: error.message || "Failed to approve purchase order" });
      }
    }
  );
  app2.post(
    "/api/salons/:salonId/purchase-orders/:orderId/receive",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId, orderId } = req.params;
        const { receivedItems } = req.body;
        console.log("\u{1F4E6} Receiving PO:", { orderId, salonId, receivedItems });
        if (!receivedItems || receivedItems.length === 0) {
          return res.status(400).json({ error: "Received items are required" });
        }
        await storage.receivePurchaseOrder(
          orderId,
          salonId,
          req.user.id,
          receivedItems
        );
        res.json({
          success: true,
          message: "Purchase order received successfully"
        });
      } catch (error) {
        console.error("\u274C Error receiving purchase order:", error);
        res.status(400).json({ error: error.message || "Failed to receive purchase order" });
      }
    }
  );
  app2.post(
    "/api/salons/:salonId/purchase-orders/:orderId/confirm",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId, orderId } = req.params;
        const po = await storage.getPurchaseOrder(orderId, salonId);
        if (!po) {
          return res.status(404).json({ error: "Purchase order not found" });
        }
        await storage.updatePurchaseOrderStatus(orderId, "confirmed");
        res.json({
          success: true,
          status: "confirmed",
          message: "Purchase order confirmed successfully"
        });
      } catch (error) {
        console.error("Error confirming purchase order:", error);
        res.status(400).json({ error: error.message || "Failed to confirm purchase order" });
      }
    }
  );
  app2.post(
    "/api/salons/:salonId/purchase-orders/:orderId/deliver",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId, orderId } = req.params;
        const po = await storage.getPurchaseOrder(orderId, salonId);
        if (!po) {
          return res.status(404).json({ error: "Purchase order not found" });
        }
        await storage.updatePurchaseOrderStatus(orderId, "delivered");
        res.json({
          success: true,
          status: "delivered",
          message: "Purchase order marked as delivered successfully"
        });
      } catch (error) {
        console.error("Error marking purchase order as delivered:", error);
        res.status(400).json({ error: error.message || "Failed to mark as delivered" });
      }
    }
  );
  app2.delete(
    "/api/salons/:salonId/purchase-orders/:orderId",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId, orderId } = req.params;
        await storage.deletePurchaseOrder(orderId, salonId);
        res.json({
          success: true,
          message: "Purchase order deleted successfully"
        });
      } catch (error) {
        console.error("Error deleting purchase order:", error);
        res.status(400).json({ error: error.message || "Failed to delete purchase order" });
      }
    }
  );
  app2.get("/verify-email", async (req, res) => {
    try {
      const { token } = req.query;
      if (!token || typeof token !== "string") {
        return res.status(400).send(`
          <html>
            <head><title>Invalid Token</title></head>
            <body style="font-family: Arial, sans-serif; text-align: center; padding: 50px;">
              <h1 style="color: #e74c3c;">Invalid Verification Link</h1>
              <p>The verification link is invalid or missing.</p>
              <a href="/" style="color: #8b5cf6; text-decoration: none;">Return to Stylemate</a>
            </body>
          </html>
        `);
      }
      const verification = await storage.verifyEmailToken(token);
      if (!verification.success) {
        return res.status(400).send(`
          <html>
            <head><title>Verification Failed</title></head>
            <body style="font-family: Arial, sans-serif; text-align: center; padding: 50px;">
              <h1 style="color: #e74c3c;">Verification Failed</h1>
              <p>The verification link has expired or is invalid.</p>
              <a href="/join" style="color: #8b5cf6; text-decoration: none;">Sign up again</a>
            </body>
          </html>
        `);
      }
      if (verification.userId) {
        await storage.markEmailAsVerified(verification.userId);
      }
      res.send(`
        <html>
          <head>
            <title>Email Verified - Stylemate</title>
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
          </head>
          <body style="font-family: Arial, sans-serif; background-color: #f5f5f5; margin: 0; padding: 0;">
            <div style="max-width: 400px; margin: 50px auto; background: white; padding: 40px 20px; text-align: center; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
              <div style="margin-bottom: 30px;">
                <div style="width: 80px; height: 80px; background-color: #22c55e; border-radius: 50%; margin: 0 auto 20px; position: relative;">
                  <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-size: 40px; line-height: 1;">\u2713</div>
                </div>
                <h1 style="color: #333; font-size: 24px; margin: 0;">Email address verified!</h1>
              </div>
              <p style="color: #666; margin-bottom: 30px; line-height: 1.5;">
                Thanks for verifying your email address. You can now go to Stylemate and manage your ${verification.userId ? "account" : "bookings"} in one place.
              </p>
              <a href="/" style="background-color: #333; color: white; padding: 12px 30px; text-decoration: none; border-radius: 6px; display: inline-block; font-weight: bold;">
                Go to Stylemate
              </a>
            </div>
          </body>
        </html>
      `);
    } catch (error) {
      console.error("Email verification error:", error);
      res.status(500).send(`
        <html>
          <head><title>Error</title></head>
          <body style="font-family: Arial, sans-serif; text-align: center; padding: 50px;">
            <h1 style="color: #e74c3c;">Verification Error</h1>
            <p>Something went wrong. Please try again.</p>
            <a href="/" style="color: #8b5cf6; text-decoration: none;">Return to Stylemate</a>
          </body>
        </html>
      `);
    }
  });
  app2.post("/api/auth/resend-verification", async (req, res) => {
    try {
      const { email } = req.body;
      if (!email) {
        return res.status(400).json({ error: "Email is required" });
      }
      const user = await storage.getUserByEmail(email);
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }
      if (user.emailVerified === 1) {
        return res.status(400).json({ error: "Email is already verified" });
      }
      const verificationToken = await storage.createVerificationToken(
        user.email || "",
        user.id
      );
      const emailSent = await sendVerificationEmail(
        user.email || "",
        user.firstName || "User",
        verificationToken
      );
      res.json({
        success: true,
        message: "Verification email sent successfully",
        emailSent
      });
    } catch (error) {
      console.error("Resend verification error:", error);
      res.status(500).json({ error: "Failed to resend verification email" });
    }
  });
  app2.post("/api/auth/check-profile-completion-disabled", async (req, res) => {
    try {
      const { email } = req.body;
      if (!email) {
        return res.status(400).json({ error: "Email is required" });
      }
      const user = await storage.getUserByEmail(email);
      if (!user) {
        return res.status(404).json({
          exists: false,
          message: "User not found"
        });
      }
      const roles2 = await storage.getUserRoles(user.id);
      const isOwner = roles2.some((role) => role.name === "owner");
      if (!isOwner) {
        return res.json({
          exists: true,
          isOwner: false,
          message: "User exists but is not a business owner"
        });
      }
      const userOrganizations = await storage.getUserOrganizations(user.id);
      const salonIds = [];
      for (const org of userOrganizations) {
        const orgSalons = await storage.getSalonsByOrgId(org.orgId);
        salonIds.push(...orgSalons.map((salon) => salon.id));
      }
      if (salonIds.length === 0) {
        return res.json({
          exists: true,
          isOwner: true,
          hasProfile: false,
          profileComplete: false,
          message: "Business owner exists but no salon profile created",
          nextStep: "business-info",
          resumeUrl: "/business/setup"
        });
      }
      const primarySalonId = salonIds[0];
      const readinessCheck = await storage.checkBusinessReadiness(primarySalonId);
      let nextStep = "review-publish";
      if (readinessCheck.missingRequirements.includes(
        "Complete salon basic information"
      )) {
        nextStep = "business-info";
      } else if (readinessCheck.missingRequirements.includes("Add at least one service")) {
        nextStep = "services";
      } else if (readinessCheck.missingRequirements.includes(
        "Add at least one staff member"
      )) {
        nextStep = "staff";
      } else if (readinessCheck.missingRequirements.includes(
        "Configure booking settings"
      )) {
        nextStep = "booking-settings";
      } else if (readinessCheck.missingRequirements.includes("Configure payout account")) {
        nextStep = "payment-setup";
      }
      return res.json({
        exists: true,
        isOwner: true,
        hasProfile: true,
        profileComplete: readinessCheck.isReady,
        salonId: primarySalonId,
        missingRequirements: readinessCheck.missingRequirements,
        nextStep,
        resumeUrl: `/business/setup?step=${nextStep}&salonId=${primarySalonId}`,
        message: readinessCheck.isReady ? "Business profile is complete" : `Business profile needs completion: ${readinessCheck.missingRequirements.join(", ")}`
      });
    } catch (error) {
      console.error("Profile completion check error:", error);
      res.status(500).json({ error: "Failed to check profile completion status" });
    }
  });
  app2.get(
    "/api/user/saved-locations",
    isAuthenticated,
    async (req, res) => {
      try {
        if (!req.user) {
          return res.status(401).json({ error: "User not authenticated" });
        }
        const userId = req.user.id;
        const savedLocations = await storage.getUserSavedLocationsByUserId(userId);
        res.json({
          success: true,
          savedLocations
        });
      } catch (error) {
        console.error("Error fetching saved locations:", error);
        res.status(500).json({
          error: "Failed to fetch saved locations",
          message: "Please try again later"
        });
      }
    }
  );
  app2.post(
    "/api/user/saved-locations",
    isAuthenticated,
    async (req, res) => {
      try {
        if (!req.user) {
          return res.status(401).json({ error: "User not authenticated" });
        }
        const userId = req.user.id;
        const locationData = {
          ...req.body,
          userId
        };
        const validation = insertUserSavedLocationSchema.safeParse(locationData);
        if (!validation.success) {
          return res.status(400).json({
            error: "Invalid location data",
            details: validation.error.errors.map((err) => ({
              field: err.path.join("."),
              message: err.message
            }))
          });
        }
        const validatedData = validation.data;
        if (["home", "office"].includes(validatedData.label)) {
          const existing = await storage.getUserSavedLocationByUserIdAndLabel(
            userId,
            validatedData.label
          );
          if (existing) {
            return res.status(409).json({
              error: `You already have a ${validatedData.label} location saved`,
              message: `Please update your existing ${validatedData.label} location instead`
            });
          }
        }
        const newLocation = await storage.createUserSavedLocation(validatedData);
        res.status(201).json({
          success: true,
          savedLocation: newLocation,
          message: "Location saved successfully"
        });
      } catch (error) {
        console.error("Error creating saved location:", error);
        res.status(500).json({
          error: "Failed to save location",
          message: "Please try again later"
        });
      }
    }
  );
  app2.put(
    "/api/user/saved-locations/:locationId",
    isAuthenticated,
    async (req, res) => {
      try {
        if (!req.user) {
          return res.status(401).json({ error: "User not authenticated" });
        }
        const userId = req.user.id;
        const { locationId } = req.params;
        const existingLocation = await storage.getUserSavedLocation(locationId);
        if (!existingLocation) {
          return res.status(404).json({
            error: "Saved location not found"
          });
        }
        if (existingLocation.userId !== userId) {
          return res.status(403).json({
            error: "Access denied",
            message: "You can only update your own saved locations"
          });
        }
        const partialSchema = insertUserSavedLocationSchema.omit({ userId: true }).partial();
        const validation = partialSchema.safeParse(req.body);
        if (!validation.success) {
          return res.status(400).json({
            error: "Invalid location data",
            details: validation.error.errors.map((err) => ({
              field: err.path.join("."),
              message: err.message
            }))
          });
        }
        await storage.updateUserSavedLocation(locationId, validation.data);
        const updatedLocation = await storage.getUserSavedLocation(locationId);
        res.json({
          success: true,
          savedLocation: updatedLocation,
          message: "Location updated successfully"
        });
      } catch (error) {
        console.error("Error updating saved location:", error);
        res.status(500).json({
          error: "Failed to update location",
          message: "Please try again later"
        });
      }
    }
  );
  app2.delete(
    "/api/user/saved-locations/:locationId",
    isAuthenticated,
    async (req, res) => {
      try {
        if (!req.user) {
          return res.status(401).json({ error: "User not authenticated" });
        }
        const userId = req.user.id;
        const { locationId } = req.params;
        const existingLocation = await storage.getUserSavedLocation(locationId);
        if (!existingLocation) {
          return res.status(404).json({
            error: "Saved location not found"
          });
        }
        if (existingLocation.userId !== userId) {
          return res.status(403).json({
            error: "Access denied",
            message: "You can only delete your own saved locations"
          });
        }
        await storage.deleteUserSavedLocation(locationId);
        res.json({
          success: true,
          message: "Location deleted successfully"
        });
      } catch (error) {
        console.error("Error deleting saved location:", error);
        res.status(500).json({
          error: "Failed to delete location",
          message: "Please try again later"
        });
      }
    }
  );
  app2.get("/api/test/debug-salons", async (req, res) => {
    try {
      const allSalons = await storage.getAllSalons();
      res.json({
        count: allSalons.length,
        salons: allSalons.map((s) => ({
          id: s.id,
          name: s.name,
          location: s.location,
          latitude: s.latitude,
          longitude: s.longitude,
          category: s.category
        }))
      });
    } catch (error) {
      console.error("Error getting salons:", error);
      res.status(500).json({
        error: "Failed to get salons",
        message: error.message
      });
    }
  });
  app2.post("/api/test/update-salons-location", async (req, res) => {
    try {
      const updates = [
        {
          id: "1dcdf672-8daa-4109-9194-a540b219f844",
          // AULNOVA Organization Salon
          location: "Nirala Estate, Greater Noida West, Uttar Pradesh",
          address: "Shop no 101, Nirala Estate, Greater Noida West",
          latitude: "28.5368704",
          longitude: "77.3918726"
        },
        {
          id: "91e3f720-b6b8-4530-8be2-ca18b58cec5e",
          // Gold Coast Hair Studio
          location: "Nirala Estate, Tech Zone IV, Greater Noida West, Uttar Pradesh",
          address: "Shop no 102, Nirala Estate, Tech Zone IV, Greater Noida West",
          latitude: "28.5360",
          longitude: "77.3920"
        },
        {
          id: "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
          // Michigan Avenue Spa
          location: "Sector 1, Greater Noida West, Uttar Pradesh",
          address: "Shop no 103, Sector 1, Greater Noida West",
          latitude: "28.5370",
          longitude: "77.3930"
        },
        {
          id: "d509a5b0-6155-41e7-94db-8a8dd6c6c905",
          // John Organization Salon
          location: "Sector 2, Greater Noida West, Uttar Pradesh",
          address: "Shop no 104, Sector 2, Greater Noida West",
          latitude: "28.5350",
          longitude: "77.3900"
        },
        {
          id: "400e5b87-1d2a-4c7b-bce7-da2f2047f897",
          // Michigan Avenue Spa (Chicago -> Greater Noida)
          location: "Sector 3, Greater Noida West, Uttar Pradesh",
          address: "Shop no 105, Sector 3, Greater Noida West",
          latitude: "28.5340",
          longitude: "77.3940"
        },
        {
          id: "8ec1a7ca-6305-4999-a0b4-24257f727d21",
          // Magnificent Mile Nails (Chicago -> Greater Noida)
          location: "Sector 4, Greater Noida West, Uttar Pradesh",
          address: "Shop no 106, Sector 4, Greater Noida West",
          latitude: "28.5880",
          longitude: "77.4390"
        }
      ];
      const updatedSalons = [];
      for (const update of updates) {
        try {
          await storage.updateSalon(update.id, {
            location: update.location,
            address: update.address,
            latitude: update.latitude,
            longitude: update.longitude
          });
          updatedSalons.push(update);
          console.log(`Updated salon location: ${update.id}`);
        } catch (error) {
          console.log(`Failed to update salon ${update.id}:`, error.message);
        }
      }
      const sampleImages = [
        {
          salonId: "1dcdf672-8daa-4109-9194-a540b219f844",
          // AULNOVA Organization Salon
          type: "image",
          url: "https://images.unsplash.com/photo-1560066984-138dadb4c035?w=400&h=300&fit=crop&crop=center",
          altText: "AULNOVA Organization Salon interior",
          isPrimary: 1
        },
        {
          salonId: "1dcdf672-8daa-4109-9194-a540b219f844",
          // AULNOVA Organization Salon - Additional images
          type: "image",
          url: "https://images.unsplash.com/photo-1487412947147-5cebf100ffc2?w=400&h=300&fit=crop&crop=center",
          altText: "Hair styling station",
          isPrimary: 0
        },
        {
          salonId: "1dcdf672-8daa-4109-9194-a540b219f844",
          // AULNOVA Organization Salon - Additional images
          type: "image",
          url: "https://images.unsplash.com/photo-1522337360788-8b13de7a37e?w=400&h=300&fit=crop&crop=center",
          altText: "Salon reception area",
          isPrimary: 0
        },
        {
          salonId: "1dcdf672-8daa-4109-9194-a540b219f844",
          // AULNOVA Organization Salon - Additional images
          type: "image",
          url: "https://images.unsplash.com/photo-1516975080664-ed2fc6a32937?w=400&h=300&fit=crop&crop=center",
          altText: "Nail art station",
          isPrimary: 0
        },
        {
          salonId: "91e3f720-b6b8-4530-8be2-ca18b58cec5e",
          // Gold Coast Hair Studio
          type: "image",
          url: "https://images.unsplash.com/photo-1522337360788-8b13dee7a37e?w=400&h=300&fit=crop&crop=center",
          altText: "Gold Coast Hair Studio interior",
          isPrimary: 1
        },
        {
          salonId: "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
          // Michigan Avenue Spa
          type: "image",
          url: "https://images.unsplash.com/photo-1516975080664-ed2fc6a32937?w=400&h=300&fit=crop&crop=center",
          altText: "Michigan Avenue Spa interior",
          isPrimary: 1
        },
        {
          salonId: "d509a5b0-6155-41e7-94db-8a8dd6c6c905",
          // John Organization Salon
          type: "image",
          url: "https://images.unsplash.com/photo-1540555700478-4be289fbecef?w=400&h=300&fit=crop&crop=center",
          altText: "John Organization Salon interior",
          isPrimary: 1
        },
        {
          salonId: "400e5b87-1d2a-4c7b-bce7-da2f2047f897",
          // Michigan Avenue Spa (Chicago -> Greater Noida)
          type: "image",
          url: "https://images.unsplash.com/photo-1571019613454-1cb2f99b2d8b?w=400&h=300&fit=crop&crop=center",
          altText: "Michigan Avenue Spa interior",
          isPrimary: 1
        },
        {
          salonId: "8ec1a7ca-6305-4999-a0b4-24257f727d21",
          // Magnificent Mile Nails
          type: "image",
          url: "https://images.unsplash.com/photo-1604654894610-df63bc536371?w=400&h=300&fit=crop&crop=center",
          altText: "Magnificent Mile Nails interior",
          isPrimary: 1
        }
      ];
      for (const image of sampleImages) {
        try {
          const existingImages = await storage.getMediaAssetsBySalonId(
            image.salonId
          );
          if (existingImages.length === 0) {
            await storage.createMediaAsset(image);
            console.log(`Added image for salon: ${image.salonId}`);
          }
        } catch (error) {
          console.log(
            `Failed to add image for salon ${image.salonId}:`,
            error.message
          );
        }
      }
      res.json({
        message: "Salon locations and images updated successfully",
        count: updatedSalons.length,
        updates: updatedSalons
      });
    } catch (error) {
      console.error("Error updating salon locations:", error);
      res.status(500).json({
        error: "Failed to update salon locations",
        message: error.message
      });
    }
  });
  app2.post("/api/test/create-availability-patterns", async (req, res) => {
    try {
      const salonIds = [
        "1dcdf672-8daa-4109-9194-a540b219f844",
        // AULNOVA Organization Salon
        "91e3f720-b6b8-4530-8be2-ca18b58cec5e",
        // Gold Coast Hair Studio
        "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
        // Michigan Avenue Spa
        "d509a5b0-6155-41e7-94db-8a8dd6c6c905",
        // John Organization Salon
        "400e5b87-1d2a-4c7b-bce7-da2f2047f897",
        // Michigan Avenue Spa (Chicago -> Greater Noida)
        "8ec1a7ca-6305-4999-a0b4-24257f727d21"
        // Magnificent Mile Nails
      ];
      const createdPatterns = [];
      for (const salonId of salonIds) {
        const staff5 = await storage.getStaffBySalonId(salonId);
        const patterns = [
          {
            dayOfWeek: 1,
            patternName: "Monday Hours",
            startTime: "09:00",
            endTime: "18:00"
          },
          {
            dayOfWeek: 2,
            patternName: "Tuesday Hours",
            startTime: "09:00",
            endTime: "18:00"
          },
          {
            dayOfWeek: 3,
            patternName: "Wednesday Hours",
            startTime: "09:00",
            endTime: "18:00"
          },
          {
            dayOfWeek: 4,
            patternName: "Thursday Hours",
            startTime: "09:00",
            endTime: "18:00"
          },
          {
            dayOfWeek: 5,
            patternName: "Friday Hours",
            startTime: "09:00",
            endTime: "18:00"
          },
          {
            dayOfWeek: 6,
            patternName: "Saturday Hours",
            startTime: "10:00",
            endTime: "16:00"
          },
          {
            dayOfWeek: 0,
            patternName: "Sunday Hours",
            startTime: "10:00",
            endTime: "16:00"
          }
        ];
        for (const pattern of patterns) {
          const salonPattern = {
            salonId,
            staffId: null,
            // General salon availability
            patternName: pattern.patternName,
            dayOfWeek: pattern.dayOfWeek,
            startTime: pattern.startTime,
            endTime: pattern.endTime,
            slotDurationMinutes: 30,
            isActive: 1
          };
          try {
            const createdPattern = await storage.createAvailabilityPattern(salonPattern);
            createdPatterns.push(createdPattern);
            const startDate = /* @__PURE__ */ new Date();
            const endDate = /* @__PURE__ */ new Date();
            endDate.setDate(endDate.getDate() + 90);
            await storage.generateTimeSlotsFromPattern(
              createdPattern.id,
              startDate,
              endDate
            );
          } catch (error) {
            console.log(
              `Failed to create pattern for salon ${salonId}:`,
              error.message
            );
          }
        }
        for (const staffMember of staff5) {
          for (const pattern of patterns) {
            const staffPattern = {
              salonId,
              staffId: staffMember.id,
              patternName: `${staffMember.name} - ${pattern.patternName}`,
              dayOfWeek: pattern.dayOfWeek,
              startTime: pattern.startTime,
              endTime: pattern.endTime,
              slotDurationMinutes: 30,
              isActive: 1
            };
            try {
              const createdPattern = await storage.createAvailabilityPattern(staffPattern);
              createdPatterns.push(createdPattern);
              const startDate = /* @__PURE__ */ new Date();
              const endDate = /* @__PURE__ */ new Date();
              endDate.setDate(endDate.getDate() + 90);
              await storage.generateTimeSlotsFromPattern(
                createdPattern.id,
                startDate,
                endDate
              );
            } catch (error) {
              console.log(
                `Failed to create staff pattern for ${staffMember.name}:`,
                error.message
              );
            }
          }
        }
      }
      res.json({
        message: "Availability patterns and time slots created successfully",
        patternsCreated: createdPatterns.length,
        patterns: createdPatterns.slice(0, 10)
        // Show first 10 patterns as example
      });
    } catch (error) {
      console.error("Error creating availability patterns:", error);
      res.status(500).json({
        error: "Failed to create availability patterns",
        message: error.message
      });
    }
  });
  app2.post("/api/test/create-time-slots", async (req, res) => {
    try {
      const today = /* @__PURE__ */ new Date();
      const tomorrow = new Date(today);
      tomorrow.setDate(tomorrow.getDate() + 1);
      const salonIds = [
        "1dcdf672-8daa-4109-9194-a540b219f844",
        // AULNOVA Organization Salon
        "91e3f720-b6b8-4530-8be2-ca18b58cec5e",
        // Gold Coast Hair Studio
        "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
        // Michigan Avenue Spa
        "d509a5b0-6155-41e7-94db-8a8dd6c6c905",
        // John Organization Salon
        "400e5b87-1d2a-4c7b-bce7-da2f2047f897",
        // Michigan Avenue Spa (Chicago -> Greater Noida)
        "8ec1a7ca-6305-4999-a0b4-24257f727d21"
        // Magnificent Mile Nails
      ];
      const createdSlots = [];
      for (const salonId of salonIds) {
        const dates = [today, tomorrow];
        for (const date of dates) {
          for (let hour = 9; hour < 12; hour++) {
            const startTime = new Date(date);
            startTime.setHours(hour, 0, 0, 0);
            const endTime = new Date(startTime);
            endTime.setHours(hour + 1, 0, 0, 0);
            const timeSlot = {
              salonId,
              startDateTime: startTime.toISOString(),
              endDateTime: endTime.toISOString(),
              isBooked: 0,
              isBlocked: 0
            };
            try {
              const createdSlot = await storage.createTimeSlot(timeSlot);
              createdSlots.push(createdSlot);
            } catch (error) {
              console.log(
                `Failed to create time slot for salon ${salonId}:`,
                error.message
              );
            }
          }
          for (let hour = 14; hour < 18; hour++) {
            const startTime = new Date(date);
            startTime.setHours(hour, 0, 0, 0);
            const endTime = new Date(startTime);
            endTime.setHours(hour + 1, 0, 0, 0);
            const timeSlot = {
              salonId,
              startDateTime: startTime.toISOString(),
              endDateTime: endTime.toISOString(),
              isBooked: 0,
              isBlocked: 0
            };
            try {
              const createdSlot = await storage.createTimeSlot(timeSlot);
              createdSlots.push(createdSlot);
            } catch (error) {
              console.log(
                `Failed to create time slot for salon ${salonId}:`,
                error.message
              );
            }
          }
          for (let hour = 19; hour < 21; hour++) {
            const startTime = new Date(date);
            startTime.setHours(hour, 0, 0, 0);
            const endTime = new Date(startTime);
            endTime.setHours(hour + 1, 0, 0, 0);
            const timeSlot = {
              salonId,
              startDateTime: startTime.toISOString(),
              endDateTime: endTime.toISOString(),
              isBooked: 0,
              isBlocked: 0
            };
            try {
              const createdSlot = await storage.createTimeSlot(timeSlot);
              createdSlots.push(createdSlot);
            } catch (error) {
              console.log(
                `Failed to create time slot for salon ${salonId}:`,
                error.message
              );
            }
          }
        }
      }
      res.json({
        message: "Time slots created successfully",
        count: createdSlots.length,
        slots: createdSlots.slice(0, 10)
        // Show first 10 slots as example
      });
    } catch (error) {
      console.error("Error creating time slots:", error);
      res.status(500).json({
        error: "Failed to create time slots",
        message: error.message
      });
    }
  });
  let redisClient = null;
  const CACHE_DURATION = 5 * 60;
  try {
    const redisUrl = process.env.REDIS_URL;
    if (redisUrl) {
      redisClient = createClient({ url: redisUrl });
      redisClient.on(
        "error",
        (err) => console.error("Redis Client Error:", err)
      );
      redisClient.on(
        "connect",
        () => console.log("\u2705 Redis connected successfully")
      );
      redisClient.connect();
    } else {
      console.log(
        "\u26A0\uFE0F  REDIS_URL not found. Location search will use in-memory cache only."
      );
      console.log("   Add REDIS_URL to your .env file for better performance.");
    }
  } catch (error) {
    console.error(
      "Redis connection error:",
      error instanceof Error ? error.message : String(error)
    );
  }
  const locationSearchCache = /* @__PURE__ */ new Map();
  const googlePlacesKey = process.env.GOOGLE_PLACES_API_KEY;
  if (!googlePlacesKey) {
    console.log(
      "\u26A0\uFE0F  GOOGLE_PLACES_API_KEY not found. Add it to your .env file for better location search."
    );
    console.log("   Get your API key at: https://console.cloud.google.com/");
  } else {
    console.log(
      "\u2705 Google Places API configured - location search will use Google Places API"
    );
  }
  app2.get(
    "/api/locations/search",
    communicationRateLimits.analytics,
    async (req, res) => {
      res.setHeader("Cache-Control", "no-cache, no-store, must-revalidate");
      res.setHeader("Pragma", "no-cache");
      res.setHeader("Expires", "0");
      try {
        const query = req.query.q;
        if (!query || query.length < 2) {
          return res.json({ results: [] });
        }
        const cacheKey = `location_search:${query.toLowerCase().trim()}`;
        let cached = null;
        if (redisClient) {
          try {
            const cachedData = await redisClient.get(cacheKey);
            if (cachedData) {
              cached = JSON.parse(cachedData);
              console.log(`\u{1F680} Redis cache hit for: "${query}"`);
              return res.json({ results: cached.results });
            }
          } catch (error) {
            console.error("Redis cache read error:", error);
          }
        } else {
          const inMemoryCached = locationSearchCache.get(cacheKey);
          if (inMemoryCached && Date.now() - inMemoryCached.timestamp < CACHE_DURATION * 1e3) {
            console.log(`\u{1F680} In-memory cache hit for: "${query}"`);
            return res.json({ results: inMemoryCached.results });
          }
        }
        const queryParams = {
          q: query,
          lat: req.query.lat,
          lng: req.query.lng,
          countrycode: req.query.countrycode
        };
        Object.keys(queryParams).forEach((key) => {
          const value = queryParams[key];
          if (value === void 0) {
            delete queryParams[key];
          }
        });
        const validation = placesAutocompleteSchema.safeParse(queryParams);
        if (!validation.success) {
          return res.status(400).json({
            error: "Invalid parameters",
            details: validation.error.errors.map((err) => ({
              field: err.path.join("."),
              message: err.message
            }))
          });
        }
        const validatedParams = validation.data;
        let suggestions = [];
        const searchQuery = validatedParams.q.toLowerCase().trim();
        const delhiNCRLocations = [
          // Delhi - Central & South
          {
            name: "Connaught Place",
            area: "New Delhi",
            coords: { lat: 28.6315, lng: 77.2167 },
            state: "Delhi",
            country: "India",
            priority: 1
          },
          {
            name: "Karol Bagh",
            area: "New Delhi",
            coords: { lat: 28.6517, lng: 77.1909 },
            state: "Delhi",
            country: "India",
            priority: 1
          },
          {
            name: "Lajpat Nagar",
            area: "New Delhi",
            coords: { lat: 28.5679, lng: 77.2431 },
            state: "Delhi",
            country: "India",
            priority: 1
          },
          {
            name: "Rajouri Garden",
            area: "New Delhi",
            coords: { lat: 28.6408, lng: 77.1214 },
            state: "Delhi",
            country: "India",
            priority: 1
          },
          {
            name: "Pitampura",
            area: "New Delhi",
            coords: { lat: 28.7, lng: 77.1333 },
            state: "Delhi",
            country: "India",
            priority: 1
          },
          {
            name: "Rohini",
            area: "New Delhi",
            coords: { lat: 28.7433, lng: 77.1028 },
            state: "Delhi",
            country: "India",
            priority: 1
          },
          {
            name: "Dwarka",
            area: "New Delhi",
            coords: { lat: 28.5921, lng: 77.0465 },
            state: "Delhi",
            country: "India",
            priority: 1
          },
          {
            name: "Vasant Kunj",
            area: "New Delhi",
            coords: { lat: 28.5425, lng: 77.1528 },
            state: "Delhi",
            country: "India",
            priority: 1
          },
          {
            name: "Saket",
            area: "New Delhi",
            coords: { lat: 28.5245, lng: 77.2069 },
            state: "Delhi",
            country: "India",
            priority: 1
          },
          {
            name: "Greater Kailash",
            area: "New Delhi",
            coords: { lat: 28.548, lng: 77.24 },
            state: "Delhi",
            country: "India",
            priority: 1
          },
          // Gurgaon/Gurugram
          {
            name: "Cyber City",
            area: "Gurugram",
            coords: { lat: 28.496, lng: 77.09 },
            state: "Haryana",
            country: "India",
            priority: 1
          },
          {
            name: "Sector 29",
            area: "Gurugram",
            coords: { lat: 28.45, lng: 77.03 },
            state: "Haryana",
            country: "India",
            priority: 1
          },
          {
            name: "Sector 14",
            area: "Gurugram",
            coords: { lat: 28.46, lng: 77.04 },
            state: "Haryana",
            country: "India",
            priority: 1
          },
          {
            name: "Sector 15",
            area: "Gurugram",
            coords: { lat: 28.47, lng: 77.05 },
            state: "Haryana",
            country: "India",
            priority: 1
          },
          {
            name: "Sector 18",
            area: "Gurugram",
            coords: { lat: 28.48, lng: 77.06 },
            state: "Haryana",
            country: "India",
            priority: 1
          },
          {
            name: "Sector 25",
            area: "Gurugram",
            coords: { lat: 28.49, lng: 77.07 },
            state: "Haryana",
            country: "India",
            priority: 1
          },
          {
            name: "Sector 26",
            area: "Gurugram",
            coords: { lat: 28.5, lng: 77.08 },
            state: "Haryana",
            country: "India",
            priority: 1
          },
          {
            name: "Sector 27",
            area: "Gurugram",
            coords: { lat: 28.51, lng: 77.09 },
            state: "Haryana",
            country: "India",
            priority: 1
          },
          {
            name: "Sector 28",
            area: "Gurugram",
            coords: { lat: 28.52, lng: 77.1 },
            state: "Haryana",
            country: "India",
            priority: 1
          },
          {
            name: "Sector 30",
            area: "Gurugram",
            coords: { lat: 28.53, lng: 77.11 },
            state: "Haryana",
            country: "India",
            priority: 1
          },
          // Noida
          {
            name: "Sector 18",
            area: "Noida",
            coords: { lat: 28.59, lng: 77.32 },
            state: "Uttar Pradesh",
            country: "India",
            priority: 1
          },
          {
            name: "Sector 62",
            area: "Noida",
            coords: { lat: 28.6, lng: 77.33 },
            state: "Uttar Pradesh",
            country: "India",
            priority: 1
          },
          {
            name: "Sector 63",
            area: "Noida",
            coords: { lat: 28.61, lng: 77.34 },
            state: "Uttar Pradesh",
            country: "India",
            priority: 1
          },
          {
            name: "Sector 64",
            area: "Noida",
            coords: { lat: 28.62, lng: 77.35 },
            state: "Uttar Pradesh",
            country: "India",
            priority: 1
          },
          {
            name: "Sector 65",
            area: "Noida",
            coords: { lat: 28.63, lng: 77.36 },
            state: "Uttar Pradesh",
            country: "India",
            priority: 1
          },
          {
            name: "Sector 66",
            area: "Noida",
            coords: { lat: 28.64, lng: 77.37 },
            state: "Uttar Pradesh",
            country: "India",
            priority: 1
          },
          {
            name: "Sector 67",
            area: "Noida",
            coords: { lat: 28.65, lng: 77.38 },
            state: "Uttar Pradesh",
            country: "India",
            priority: 1
          },
          {
            name: "Sector 68",
            area: "Noida",
            coords: { lat: 28.66, lng: 77.39 },
            state: "Uttar Pradesh",
            country: "India",
            priority: 1
          },
          {
            name: "Sector 69",
            area: "Noida",
            coords: { lat: 28.67, lng: 77.4 },
            state: "Uttar Pradesh",
            country: "India",
            priority: 1
          },
          {
            name: "Sector 70",
            area: "Noida",
            coords: { lat: 28.68, lng: 77.41 },
            state: "Uttar Pradesh",
            country: "India",
            priority: 1
          },
          // Greater Noida - Nirala Estate
          {
            name: "Nirala Estate",
            area: "Tech Zone IV, Patwari, Greater Noida",
            coords: { lat: 28.5355, lng: 77.391 },
            state: "Uttar Pradesh",
            country: "India",
            priority: 1
          },
          {
            name: "Nirala Estate Phase 1",
            area: "Greater Noida West Road, Tech Zone IV",
            coords: { lat: 28.536, lng: 77.392 },
            state: "Uttar Pradesh",
            country: "India",
            priority: 1
          },
          {
            name: "Nirala Estate Phase 3",
            area: "Tech Zone IV, Patwari",
            coords: { lat: 28.535, lng: 77.39 },
            state: "Uttar Pradesh",
            country: "India",
            priority: 1
          },
          {
            name: "Nirala Estate Main Gate",
            area: "Patwari, Greater Noida",
            coords: { lat: 28.5365, lng: 77.3915 },
            state: "Uttar Pradesh",
            country: "India",
            priority: 1
          },
          // Greater Noida - Nirala Aspire (matching Fresha.com results)
          {
            name: "Nirala Aspire",
            area: "Sector 16, Panchsheel Greens 2, Greater Noida",
            coords: { lat: 28.5355, lng: 77.391 },
            state: "Uttar Pradesh",
            country: "India",
            priority: 1
          },
          {
            name: "Nirala Aspire",
            area: "Greater Noida West, Panchsheel Greens 2, Ghaziabad",
            coords: { lat: 28.536, lng: 77.392 },
            state: "Uttar Pradesh",
            country: "India",
            priority: 1
          },
          {
            name: "NIRALA ASPIRE",
            area: "Panchsheel Greens 2, Greater Noida",
            coords: { lat: 28.535, lng: 77.39 },
            state: "Uttar Pradesh",
            country: "India",
            priority: 1
          },
          {
            name: "Nirala Aspire Tower A-6",
            area: "Panchsheel Greens 2, Ithaira, Ghaziabad",
            coords: { lat: 28.5364, lng: 77.3924 },
            state: "Uttar Pradesh",
            country: "India",
            priority: 1
          },
          {
            name: "Nirala Aspire Tower D-5",
            area: "Nirala Aspire, Sector 16, Panchsheel Greens 2, Ithaira",
            coords: { lat: 28.5366, lng: 77.3926 },
            state: "Uttar Pradesh",
            country: "India",
            priority: 1
          },
          {
            name: "Nirala Aspire Tower B-3",
            area: "Panchsheel Greens 2, Greater Noida",
            coords: { lat: 28.5368, lng: 77.3928 },
            state: "Uttar Pradesh",
            country: "India",
            priority: 1
          },
          {
            name: "Nirala Aspire Tower C-7",
            area: "Sector 16, Panchsheel Greens 2, Greater Noida",
            coords: { lat: 28.537, lng: 77.393 },
            state: "Uttar Pradesh",
            country: "India",
            priority: 1
          },
          {
            name: "Sector Alpha 1",
            area: "Greater Noida",
            coords: { lat: 28.54, lng: 77.4 },
            state: "Uttar Pradesh",
            country: "India",
            priority: 1
          },
          {
            name: "Sector Alpha 2",
            area: "Greater Noida",
            coords: { lat: 28.55, lng: 77.41 },
            state: "Uttar Pradesh",
            country: "India",
            priority: 1
          },
          {
            name: "Sector Beta 1",
            area: "Greater Noida",
            coords: { lat: 28.56, lng: 77.42 },
            state: "Uttar Pradesh",
            country: "India",
            priority: 1
          },
          {
            name: "Sector Beta 2",
            area: "Greater Noida",
            coords: { lat: 28.57, lng: 77.43 },
            state: "Uttar Pradesh",
            country: "India",
            priority: 1
          },
          {
            name: "Sector Gamma 1",
            area: "Greater Noida",
            coords: { lat: 28.58, lng: 77.44 },
            state: "Uttar Pradesh",
            country: "India",
            priority: 1
          },
          {
            name: "Sector Gamma 2",
            area: "Greater Noida",
            coords: { lat: 28.59, lng: 77.45 },
            state: "Uttar Pradesh",
            country: "India",
            priority: 1
          },
          // Faridabad
          {
            name: "Sector 15",
            area: "Faridabad",
            coords: { lat: 28.4, lng: 77.3 },
            state: "Haryana",
            country: "India",
            priority: 1
          },
          {
            name: "Sector 16",
            area: "Faridabad",
            coords: { lat: 28.41, lng: 77.31 },
            state: "Haryana",
            country: "India",
            priority: 1
          },
          {
            name: "Sector 17",
            area: "Faridabad",
            coords: { lat: 28.42, lng: 77.32 },
            state: "Haryana",
            country: "India",
            priority: 1
          },
          {
            name: "Sector 18",
            area: "Faridabad",
            coords: { lat: 28.43, lng: 77.33 },
            state: "Haryana",
            country: "India",
            priority: 1
          },
          {
            name: "Sector 19",
            area: "Faridabad",
            coords: { lat: 28.44, lng: 77.34 },
            state: "Haryana",
            country: "India",
            priority: 1
          },
          {
            name: "Sector 20",
            area: "Faridabad",
            coords: { lat: 28.45, lng: 77.35 },
            state: "Haryana",
            country: "India",
            priority: 1
          },
          // Ghaziabad
          {
            name: "Vaishali",
            area: "Ghaziabad",
            coords: { lat: 28.65, lng: 77.35 },
            state: "Uttar Pradesh",
            country: "India",
            priority: 1
          },
          {
            name: "Indirapuram",
            area: "Ghaziabad",
            coords: { lat: 28.64, lng: 77.36 },
            state: "Uttar Pradesh",
            country: "India",
            priority: 1
          },
          {
            name: "Crossings Republik",
            area: "Ghaziabad",
            coords: { lat: 28.63, lng: 77.37 },
            state: "Uttar Pradesh",
            country: "India",
            priority: 1
          },
          {
            name: "Raj Nagar",
            area: "Ghaziabad",
            coords: { lat: 28.62, lng: 77.38 },
            state: "Uttar Pradesh",
            country: "India",
            priority: 1
          },
          {
            name: "Kaushambi",
            area: "Ghaziabad",
            coords: { lat: 28.61, lng: 77.39 },
            state: "Uttar Pradesh",
            country: "India",
            priority: 1
          },
          // Popular landmarks and malls
          {
            name: "Trident Embassy",
            area: "Gurugram",
            coords: { lat: 28.496, lng: 77.09 },
            state: "Haryana",
            country: "India",
            priority: 2
          },
          {
            name: "Select City Walk",
            area: "Saket, New Delhi",
            coords: { lat: 28.5245, lng: 77.2069 },
            state: "Delhi",
            country: "India",
            priority: 2
          },
          {
            name: "DLF Cyber Hub",
            area: "Gurugram",
            coords: { lat: 28.496, lng: 77.09 },
            state: "Haryana",
            country: "India",
            priority: 2
          },
          {
            name: "Ambience Mall",
            area: "Gurugram",
            coords: { lat: 28.5, lng: 77.1 },
            state: "Haryana",
            country: "India",
            priority: 2
          },
          {
            name: "Pacific Mall",
            area: "Tagore Garden, New Delhi",
            coords: { lat: 28.6408, lng: 77.1214 },
            state: "Delhi",
            country: "India",
            priority: 2
          },
          {
            name: "Metro Walk",
            area: "Rohini, New Delhi",
            coords: { lat: 28.7433, lng: 77.1028 },
            state: "Delhi",
            country: "India",
            priority: 2
          },
          {
            name: "Cross River Mall",
            area: "Sector 18, Noida",
            coords: { lat: 28.59, lng: 77.32 },
            state: "Uttar Pradesh",
            country: "India",
            priority: 2
          },
          {
            name: "Great India Place",
            area: "Sector 18, Noida",
            coords: { lat: 28.59, lng: 77.32 },
            state: "Uttar Pradesh",
            country: "India",
            priority: 2
          },
          {
            name: "Logix City Centre",
            area: "Sector 32, Noida",
            coords: { lat: 28.6, lng: 77.33 },
            state: "Uttar Pradesh",
            country: "India",
            priority: 2
          },
          {
            name: "DLF Mall of India",
            area: "Sector 18, Noida",
            coords: { lat: 28.5682, lng: 77.325 },
            state: "Uttar Pradesh",
            country: "India",
            priority: 2
          }
        ];
        const searchResults = delhiNCRLocations.filter((loc) => {
          const searchTerms = searchQuery.split(" ").filter((term) => term.length > 0);
          const fullText = `${loc.name} ${loc.area} ${loc.state} ${loc.country}`.toLowerCase();
          return searchTerms.every((term) => {
            const lowerTerm = term.toLowerCase();
            if (fullText.includes(lowerTerm)) return true;
            if (lowerTerm === "aspir" && fullText.includes("aspire"))
              return true;
            if (lowerTerm === "aspire" && fullText.includes("aspir"))
              return true;
            if (lowerTerm === "sec" && fullText.includes("sector")) return true;
            if (lowerTerm === "sector" && fullText.includes("sec")) return true;
            if (lowerTerm === "gr" && fullText.includes("greater")) return true;
            if (lowerTerm === "greater" && fullText.includes("gr")) return true;
            if (lowerTerm === "noida" && fullText.includes("noida"))
              return true;
            if (lowerTerm === "delhi" && fullText.includes("delhi"))
              return true;
            return false;
          });
        });
        suggestions = searchResults.sort((a, b) => {
          if (a.priority !== b.priority) {
            return a.priority - b.priority;
          }
          const aExactMatch = a.name.toLowerCase().includes(searchQuery);
          const bExactMatch = b.name.toLowerCase().includes(searchQuery);
          if (aExactMatch && !bExactMatch) return -1;
          if (!aExactMatch && bExactMatch) return 1;
          return 0;
        }).slice(0, parseInt(queryParams.limit) || 10).map((loc, index2) => ({
          id: `delhi-ncr-${index2}`,
          title: `${loc.name}, ${loc.area}`,
          subtitle: `${loc.state}, ${loc.country}`,
          address: `${loc.name}, ${loc.area}, ${loc.state}, ${loc.country}`,
          coords: loc.coords
        }));
        if (suggestions.length > 0) {
          console.log(
            `\u2705 Found ${suggestions.length} Delhi NCR locations for "${searchQuery}"`
          );
          const cacheData = {
            results: suggestions,
            timestamp: Date.now()
          };
          if (redisClient) {
            try {
              await redisClient.setEx(
                cacheKey,
                CACHE_DURATION,
                JSON.stringify(cacheData)
              );
              console.log(`\u{1F4BE} Cached in Redis: "${searchQuery}"`);
            } catch (error) {
              console.error("Redis cache write error:", error);
              locationSearchCache.set(cacheKey, cacheData);
            }
          } else {
            locationSearchCache.set(cacheKey, cacheData);
            console.log(`\u{1F4BE} Cached in memory: "${searchQuery}"`);
          }
          return res.json({ results: suggestions });
        }
        try {
          const googlePlacesKey2 = process.env.GOOGLE_PLACES_API_KEY;
          if (!googlePlacesKey2) {
            console.log(
              "Google Places API key not found, using fallback locations"
            );
            throw new Error("Google Places API key not configured");
          }
          const googleUrl = "https://maps.googleapis.com/maps/api/place/autocomplete/json";
          const googleParams = new URLSearchParams({
            input: validatedParams.q,
            key: googlePlacesKey2,
            types: "establishment|geocode",
            language: "en",
            components: "country:in",
            // Focus on India
            location: "28.6139,77.2090",
            // Delhi coordinates for ranking
            radius: "50000"
            // 50km radius around Delhi
          });
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 3e3);
          const googleResponse = await fetch(`${googleUrl}?${googleParams}`, {
            signal: controller.signal,
            headers: {
              Accept: "application/json",
              "User-Agent": "Stylemate/1.0"
            }
          });
          clearTimeout(timeoutId);
          if (googleResponse.ok) {
            const data = await googleResponse.json();
            if (data.status === "OK" && data.predictions) {
              const placeDetailsPromises = data.predictions.slice(0, 8).map(async (prediction) => {
                try {
                  const detailsUrl = "https://maps.googleapis.com/maps/api/place/details/json";
                  const detailsParams = new URLSearchParams({
                    place_id: prediction.place_id,
                    key: googlePlacesKey2,
                    fields: "formatted_address,geometry,name,address_components"
                  });
                  const detailsResponse = await fetch(
                    `${detailsUrl}?${detailsParams}`
                  );
                  const detailsData = await detailsResponse.json();
                  if (detailsData.status === "OK" && detailsData.result) {
                    const place = detailsData.result;
                    const coords = place.geometry?.location;
                    const components = place.address_components || [];
                    const city = components.find(
                      (c) => c.types.includes("locality")
                    )?.long_name || "";
                    const state = components.find(
                      (c) => c.types.includes("administrative_area_level_1")
                    )?.long_name || "";
                    const country = components.find((c) => c.types.includes("country"))?.long_name || "";
                    return {
                      id: prediction.place_id,
                      title: prediction.structured_formatting?.main_text || place.name || prediction.description,
                      subtitle: prediction.structured_formatting?.secondary_text || [city, state, country].filter(Boolean).join(", "),
                      address: place.formatted_address || prediction.description,
                      coords: coords ? {
                        lat: coords.lat,
                        lng: coords.lng
                      } : null
                    };
                  }
                } catch (error) {
                  console.error("Error fetching place details:", error);
                }
                return {
                  id: prediction.place_id,
                  title: prediction.structured_formatting?.main_text || prediction.description.split(",")[0],
                  subtitle: prediction.structured_formatting?.secondary_text || prediction.description,
                  address: prediction.description,
                  coords: null
                };
              });
              suggestions = (await Promise.all(placeDetailsPromises)).filter(
                (s) => s.coords
              );
              console.log(
                `\u2705 Google Places found ${suggestions.length} results for "${validatedParams.q}"`
              );
              const cacheData = {
                results: suggestions,
                timestamp: Date.now()
              };
              if (redisClient) {
                try {
                  await redisClient.setEx(
                    cacheKey,
                    CACHE_DURATION,
                    JSON.stringify(cacheData)
                  );
                  console.log(
                    `\u{1F4BE} Cached Google Places in Redis: "${validatedParams.q}"`
                  );
                } catch (error) {
                  console.error("Redis cache write error:", error);
                  locationSearchCache.set(cacheKey, cacheData);
                }
              } else {
                locationSearchCache.set(cacheKey, cacheData);
                console.log(
                  `\u{1F4BE} Cached Google Places in memory: "${validatedParams.q}"`
                );
              }
            } else {
              console.log(
                `Google Places API error: ${data.status} - ${data.error_message || "Unknown error"}`
              );
              throw new Error(`Google Places API error: ${data.status}`);
            }
          } else {
            throw new Error(
              `Google Places API HTTP error: ${googleResponse.status}`
            );
          }
        } catch (googleError) {
          console.error("Google Places search error:", googleError);
          const fallbackQuery = validatedParams.q.toLowerCase();
          const delhiNCRLocations2 = [
            // Delhi - Central & South
            {
              name: "Connaught Place",
              area: "New Delhi",
              coords: { lat: 28.6315, lng: 77.2167 },
              state: "Delhi",
              country: "India",
              priority: 1
            },
            {
              name: "Karol Bagh",
              area: "New Delhi",
              coords: { lat: 28.6517, lng: 77.1909 },
              state: "Delhi",
              country: "India",
              priority: 1
            },
            {
              name: "Lajpat Nagar",
              area: "New Delhi",
              coords: { lat: 28.5679, lng: 77.2431 },
              state: "Delhi",
              country: "India",
              priority: 1
            },
            {
              name: "Rajouri Garden",
              area: "New Delhi",
              coords: { lat: 28.6408, lng: 77.1214 },
              state: "Delhi",
              country: "India",
              priority: 1
            },
            {
              name: "Pitampura",
              area: "New Delhi",
              coords: { lat: 28.7, lng: 77.1333 },
              state: "Delhi",
              country: "India",
              priority: 1
            },
            {
              name: "Rohini",
              area: "New Delhi",
              coords: { lat: 28.7433, lng: 77.1028 },
              state: "Delhi",
              country: "India",
              priority: 1
            },
            {
              name: "Dwarka",
              area: "New Delhi",
              coords: { lat: 28.5921, lng: 77.0465 },
              state: "Delhi",
              country: "India",
              priority: 1
            },
            {
              name: "Vasant Kunj",
              area: "New Delhi",
              coords: { lat: 28.5425, lng: 77.1528 },
              state: "Delhi",
              country: "India",
              priority: 1
            },
            {
              name: "Saket",
              area: "New Delhi",
              coords: { lat: 28.5245, lng: 77.2069 },
              state: "Delhi",
              country: "India",
              priority: 1
            },
            {
              name: "Greater Kailash",
              area: "New Delhi",
              coords: { lat: 28.548, lng: 77.24 },
              state: "Delhi",
              country: "India",
              priority: 1
            },
            // Gurgaon/Gurugram
            {
              name: "Cyber City",
              area: "Gurugram",
              coords: { lat: 28.496, lng: 77.09 },
              state: "Haryana",
              country: "India",
              priority: 1
            },
            {
              name: "Sector 29",
              area: "Gurugram",
              coords: { lat: 28.45, lng: 77.03 },
              state: "Haryana",
              country: "India",
              priority: 1
            },
            {
              name: "Sector 14",
              area: "Gurugram",
              coords: { lat: 28.46, lng: 77.04 },
              state: "Haryana",
              country: "India",
              priority: 1
            },
            {
              name: "Sector 15",
              area: "Gurugram",
              coords: { lat: 28.47, lng: 77.05 },
              state: "Haryana",
              country: "India",
              priority: 1
            },
            {
              name: "Sector 18",
              area: "Gurugram",
              coords: { lat: 28.48, lng: 77.06 },
              state: "Haryana",
              country: "India",
              priority: 1
            },
            {
              name: "Sector 25",
              area: "Gurugram",
              coords: { lat: 28.49, lng: 77.07 },
              state: "Haryana",
              country: "India",
              priority: 1
            },
            {
              name: "Sector 26",
              area: "Gurugram",
              coords: { lat: 28.5, lng: 77.08 },
              state: "Haryana",
              country: "India",
              priority: 1
            },
            {
              name: "Sector 27",
              area: "Gurugram",
              coords: { lat: 28.51, lng: 77.09 },
              state: "Haryana",
              country: "India",
              priority: 1
            },
            {
              name: "Sector 28",
              area: "Gurugram",
              coords: { lat: 28.52, lng: 77.1 },
              state: "Haryana",
              country: "India",
              priority: 1
            },
            {
              name: "Sector 30",
              area: "Gurugram",
              coords: { lat: 28.53, lng: 77.11 },
              state: "Haryana",
              country: "India",
              priority: 1
            },
            // Noida
            {
              name: "Sector 18",
              area: "Noida",
              coords: { lat: 28.59, lng: 77.32 },
              state: "Uttar Pradesh",
              country: "India",
              priority: 1
            },
            {
              name: "Sector 62",
              area: "Noida",
              coords: { lat: 28.6, lng: 77.33 },
              state: "Uttar Pradesh",
              country: "India",
              priority: 1
            },
            {
              name: "Sector 63",
              area: "Noida",
              coords: { lat: 28.61, lng: 77.34 },
              state: "Uttar Pradesh",
              country: "India",
              priority: 1
            },
            {
              name: "Sector 64",
              area: "Noida",
              coords: { lat: 28.62, lng: 77.35 },
              state: "Uttar Pradesh",
              country: "India",
              priority: 1
            },
            {
              name: "Sector 65",
              area: "Noida",
              coords: { lat: 28.63, lng: 77.36 },
              state: "Uttar Pradesh",
              country: "India",
              priority: 1
            },
            {
              name: "Sector 66",
              area: "Noida",
              coords: { lat: 28.64, lng: 77.37 },
              state: "Uttar Pradesh",
              country: "India",
              priority: 1
            },
            {
              name: "Sector 67",
              area: "Noida",
              coords: { lat: 28.65, lng: 77.38 },
              state: "Uttar Pradesh",
              country: "India",
              priority: 1
            },
            {
              name: "Sector 68",
              area: "Noida",
              coords: { lat: 28.66, lng: 77.39 },
              state: "Uttar Pradesh",
              country: "India",
              priority: 1
            },
            {
              name: "Sector 69",
              area: "Noida",
              coords: { lat: 28.67, lng: 77.4 },
              state: "Uttar Pradesh",
              country: "India",
              priority: 1
            },
            {
              name: "Sector 70",
              area: "Noida",
              coords: { lat: 28.68, lng: 77.41 },
              state: "Uttar Pradesh",
              country: "India",
              priority: 1
            },
            // Greater Noida - Nirala Estate
            {
              name: "Nirala Estate",
              area: "Tech Zone IV, Patwari, Greater Noida",
              coords: { lat: 28.5355, lng: 77.391 },
              state: "Uttar Pradesh",
              country: "India",
              priority: 1
            },
            {
              name: "Nirala Estate Phase 1",
              area: "Greater Noida West Road, Tech Zone IV",
              coords: { lat: 28.536, lng: 77.392 },
              state: "Uttar Pradesh",
              country: "India",
              priority: 1
            },
            {
              name: "Nirala Estate Phase 3",
              area: "Tech Zone IV, Patwari",
              coords: { lat: 28.535, lng: 77.39 },
              state: "Uttar Pradesh",
              country: "India",
              priority: 1
            },
            {
              name: "Nirala Estate Main Gate",
              area: "Patwari, Greater Noida",
              coords: { lat: 28.5365, lng: 77.3915 },
              state: "Uttar Pradesh",
              country: "India",
              priority: 1
            },
            // Greater Noida - Nirala Aspire (matching Fresha.com results)
            {
              name: "Nirala Aspire",
              area: "Sector 16, Panchsheel Greens 2, Greater Noida",
              coords: { lat: 28.5355, lng: 77.391 },
              state: "Uttar Pradesh",
              country: "India",
              priority: 1
            },
            {
              name: "Nirala Aspire",
              area: "Greater Noida West, Panchsheel Greens 2, Ghaziabad",
              coords: { lat: 28.536, lng: 77.392 },
              state: "Uttar Pradesh",
              country: "India",
              priority: 1
            },
            {
              name: "NIRALA ASPIRE",
              area: "Panchsheel Greens 2, Greater Noida",
              coords: { lat: 28.535, lng: 77.39 },
              state: "Uttar Pradesh",
              country: "India",
              priority: 1
            },
            {
              name: "Nirala Aspire Tower A-6",
              area: "Panchsheel Greens 2, Ithaira, Ghaziabad",
              coords: { lat: 28.5364, lng: 77.3924 },
              state: "Uttar Pradesh",
              country: "India",
              priority: 1
            },
            {
              name: "Nirala Aspire Tower D-5",
              area: "Nirala Aspire, Sector 16, Panchsheel Greens 2, Ithaira",
              coords: { lat: 28.5366, lng: 77.3926 },
              state: "Uttar Pradesh",
              country: "India",
              priority: 1
            },
            {
              name: "Nirala Aspire Tower B-3",
              area: "Panchsheel Greens 2, Greater Noida",
              coords: { lat: 28.5368, lng: 77.3928 },
              state: "Uttar Pradesh",
              country: "India",
              priority: 1
            },
            {
              name: "Nirala Aspire Tower C-7",
              area: "Sector 16, Panchsheel Greens 2, Greater Noida",
              coords: { lat: 28.537, lng: 77.393 },
              state: "Uttar Pradesh",
              country: "India",
              priority: 1
            },
            {
              name: "Sector Alpha 1",
              area: "Greater Noida",
              coords: { lat: 28.54, lng: 77.4 },
              state: "Uttar Pradesh",
              country: "India",
              priority: 1
            },
            {
              name: "Sector Alpha 2",
              area: "Greater Noida",
              coords: { lat: 28.55, lng: 77.41 },
              state: "Uttar Pradesh",
              country: "India",
              priority: 1
            },
            {
              name: "Sector Beta 1",
              area: "Greater Noida",
              coords: { lat: 28.56, lng: 77.42 },
              state: "Uttar Pradesh",
              country: "India",
              priority: 1
            },
            {
              name: "Sector Beta 2",
              area: "Greater Noida",
              coords: { lat: 28.57, lng: 77.43 },
              state: "Uttar Pradesh",
              country: "India",
              priority: 1
            },
            {
              name: "Sector Gamma 1",
              area: "Greater Noida",
              coords: { lat: 28.58, lng: 77.44 },
              state: "Uttar Pradesh",
              country: "India",
              priority: 1
            },
            {
              name: "Sector Gamma 2",
              area: "Greater Noida",
              coords: { lat: 28.59, lng: 77.45 },
              state: "Uttar Pradesh",
              country: "India",
              priority: 1
            },
            // Faridabad
            {
              name: "Sector 15",
              area: "Faridabad",
              coords: { lat: 28.4, lng: 77.3 },
              state: "Haryana",
              country: "India",
              priority: 1
            },
            {
              name: "Sector 16",
              area: "Faridabad",
              coords: { lat: 28.41, lng: 77.31 },
              state: "Haryana",
              country: "India",
              priority: 1
            },
            {
              name: "Sector 17",
              area: "Faridabad",
              coords: { lat: 28.42, lng: 77.32 },
              state: "Haryana",
              country: "India",
              priority: 1
            },
            {
              name: "Sector 18",
              area: "Faridabad",
              coords: { lat: 28.43, lng: 77.33 },
              state: "Haryana",
              country: "India",
              priority: 1
            },
            {
              name: "Sector 19",
              area: "Faridabad",
              coords: { lat: 28.44, lng: 77.34 },
              state: "Haryana",
              country: "India",
              priority: 1
            },
            {
              name: "Sector 20",
              area: "Faridabad",
              coords: { lat: 28.45, lng: 77.35 },
              state: "Haryana",
              country: "India",
              priority: 1
            },
            // Ghaziabad
            {
              name: "Vaishali",
              area: "Ghaziabad",
              coords: { lat: 28.65, lng: 77.35 },
              state: "Uttar Pradesh",
              country: "India",
              priority: 1
            },
            {
              name: "Indirapuram",
              area: "Ghaziabad",
              coords: { lat: 28.64, lng: 77.36 },
              state: "Uttar Pradesh",
              country: "India",
              priority: 1
            },
            {
              name: "Crossings Republik",
              area: "Ghaziabad",
              coords: { lat: 28.63, lng: 77.37 },
              state: "Uttar Pradesh",
              country: "India",
              priority: 1
            },
            {
              name: "Raj Nagar",
              area: "Ghaziabad",
              coords: { lat: 28.62, lng: 77.38 },
              state: "Uttar Pradesh",
              country: "India",
              priority: 1
            },
            {
              name: "Kaushambi",
              area: "Ghaziabad",
              coords: { lat: 28.61, lng: 77.39 },
              state: "Uttar Pradesh",
              country: "India",
              priority: 1
            },
            // Popular landmarks and malls
            {
              name: "Trident Embassy",
              area: "Gurugram",
              coords: { lat: 28.496, lng: 77.09 },
              state: "Haryana",
              country: "India",
              priority: 2
            },
            {
              name: "Select City Walk",
              area: "Saket, New Delhi",
              coords: { lat: 28.5245, lng: 77.2069 },
              state: "Delhi",
              country: "India",
              priority: 2
            },
            {
              name: "DLF Cyber Hub",
              area: "Gurugram",
              coords: { lat: 28.496, lng: 77.09 },
              state: "Haryana",
              country: "India",
              priority: 2
            },
            {
              name: "Ambience Mall",
              area: "Gurugram",
              coords: { lat: 28.5, lng: 77.1 },
              state: "Haryana",
              country: "India",
              priority: 2
            },
            {
              name: "Pacific Mall",
              area: "Tagore Garden, New Delhi",
              coords: { lat: 28.6408, lng: 77.1214 },
              state: "Delhi",
              country: "India",
              priority: 2
            },
            {
              name: "Metro Walk",
              area: "Rohini, New Delhi",
              coords: { lat: 28.7433, lng: 77.1028 },
              state: "Delhi",
              country: "India",
              priority: 2
            },
            {
              name: "Cross River Mall",
              area: "Sector 18, Noida",
              coords: { lat: 28.59, lng: 77.32 },
              state: "Uttar Pradesh",
              country: "India",
              priority: 2
            },
            {
              name: "Great India Place",
              area: "Sector 18, Noida",
              coords: { lat: 28.59, lng: 77.32 },
              state: "Uttar Pradesh",
              country: "India",
              priority: 2
            },
            {
              name: "Logix City Centre",
              area: "Sector 32, Noida",
              coords: { lat: 28.6, lng: 77.33 },
              state: "Uttar Pradesh",
              country: "India",
              priority: 2
            },
            {
              name: "DLF Mall of India",
              area: "Sector 18, Noida",
              coords: { lat: 28.5682, lng: 77.325 },
              state: "Uttar Pradesh",
              country: "India",
              priority: 2
            }
          ];
          const searchResults2 = delhiNCRLocations2.filter((loc) => {
            const searchTerms = fallbackQuery.split(" ").filter((term) => term.length > 0);
            const fullText = `${loc.name} ${loc.area} ${loc.state} ${loc.country}`.toLowerCase();
            return searchTerms.every((term) => {
              const lowerTerm = term.toLowerCase();
              if (fullText.includes(lowerTerm)) return true;
              if (lowerTerm === "aspir" && fullText.includes("aspire"))
                return true;
              if (lowerTerm === "aspire" && fullText.includes("aspir"))
                return true;
              if (lowerTerm === "sec" && fullText.includes("sector"))
                return true;
              if (lowerTerm === "sector" && fullText.includes("sec"))
                return true;
              if (lowerTerm === "gr" && fullText.includes("greater"))
                return true;
              if (lowerTerm === "greater" && fullText.includes("gr"))
                return true;
              if (lowerTerm === "noida" && fullText.includes("noida"))
                return true;
              if (lowerTerm === "delhi" && fullText.includes("delhi"))
                return true;
              return false;
            });
          });
          suggestions = searchResults2.sort((a, b) => {
            if (a.priority !== b.priority) {
              return a.priority - b.priority;
            }
            const aExactMatch = a.name.toLowerCase().includes(fallbackQuery);
            const bExactMatch = b.name.toLowerCase().includes(fallbackQuery);
            if (aExactMatch && !bExactMatch) return -1;
            if (!aExactMatch && bExactMatch) return 1;
            return 0;
          }).slice(0, parseInt(queryParams.limit) || 10).map((loc, index2) => ({
            id: `delhi-ncr-${index2}`,
            title: `${loc.name}, ${loc.area}`,
            subtitle: `${loc.state}, ${loc.country}`,
            address: `${loc.name}, ${loc.area}, ${loc.state}, ${loc.country}`,
            coords: loc.coords
          }));
        }
        locationSearchCache.set(cacheKey, {
          results: suggestions,
          timestamp: Date.now()
        });
        console.log(
          `\u2705 Found ${suggestions.length} results for "${searchQuery}"`
        );
        res.json({ results: suggestions });
      } catch (error) {
        console.error("Location search error:", error);
        res.status(500).json({
          error: "Failed to search locations",
          message: "Please try again later"
        });
      }
    }
  );
  app2.get(
    "/api/locations/reverse",
    communicationRateLimits.analytics,
    async (req, res) => {
      res.setHeader("Cache-Control", "no-cache, no-store, must-revalidate");
      res.setHeader("Pragma", "no-cache");
      res.setHeader("Expires", "0");
      try {
        const lat = parseFloat(req.query.lat);
        const lng = parseFloat(req.query.lng);
        if (isNaN(lat) || isNaN(lng)) {
          return res.status(400).json({ error: "Invalid coordinates" });
        }
        const delhiNCRLocations = [
          {
            name: "Connaught Place",
            area: "New Delhi",
            coords: { lat: 28.6315, lng: 77.2167 },
            state: "Delhi"
          },
          {
            name: "Cyber City",
            area: "Gurugram",
            coords: { lat: 28.496, lng: 77.09 },
            state: "Haryana"
          },
          {
            name: "Sector 18",
            area: "Noida",
            coords: { lat: 28.59, lng: 77.32 },
            state: "Uttar Pradesh"
          },
          {
            name: "Nirala Estate",
            area: "Greater Noida",
            coords: { lat: 28.5355, lng: 77.391 },
            state: "Uttar Pradesh"
          },
          {
            name: "Saket",
            area: "New Delhi",
            coords: { lat: 28.5245, lng: 77.2069 },
            state: "Delhi"
          },
          {
            name: "Greater Noida",
            area: "Greater Noida",
            coords: { lat: 28.4744, lng: 77.504 },
            state: "Uttar Pradesh"
          },
          {
            name: "Ghaziabad",
            area: "Ghaziabad",
            coords: { lat: 28.6692, lng: 77.4538 },
            state: "Uttar Pradesh"
          },
          {
            name: "Faridabad",
            area: "Faridabad",
            coords: { lat: 28.4089, lng: 77.3178 },
            state: "Haryana"
          },
          {
            name: "Gurugram",
            area: "Gurugram",
            coords: { lat: 28.4595, lng: 77.0266 },
            state: "Haryana"
          },
          {
            name: "Noida",
            area: "Noida",
            coords: { lat: 28.57, lng: 77.32 },
            state: "Uttar Pradesh"
          },
          {
            name: "Delhi",
            area: "New Delhi",
            coords: { lat: 28.7041, lng: 77.1025 },
            state: "Delhi"
          }
        ];
        const findNearest = (locations) => {
          let nearest = null;
          let minDistance = Infinity;
          for (const loc of locations) {
            const distance = Math.sqrt(
              Math.pow(lat - loc.coords.lat, 2) + Math.pow(lng - loc.coords.lng, 2)
            );
            if (distance < minDistance) {
              minDistance = distance;
              nearest = loc;
            }
          }
          if (minDistance < 0.05 && nearest) {
            return `${nearest.name}, ${nearest.area}`;
          }
          return null;
        };
        const nearestLocation = findNearest(delhiNCRLocations);
        if (nearestLocation) {
          console.log(
            `\u2705 Reverse geocoded to nearby location: ${nearestLocation}`
          );
          return res.json({ address: nearestLocation });
        }
        const googlePlacesKey2 = process.env.GOOGLE_PLACES_API_KEY;
        if (googlePlacesKey2) {
          try {
            const googleUrl = "https://maps.googleapis.com/maps/api/geocode/json";
            const googleParams = new URLSearchParams({
              latlng: `${lat},${lng}`,
              key: googlePlacesKey2,
              result_type: "locality|sublocality|neighborhood"
            });
            const googleResponse = await fetch(`${googleUrl}?${googleParams}`, {
              headers: { Accept: "application/json" }
            });
            if (googleResponse.ok) {
              const data = await googleResponse.json();
              if (data.status === "OK" && data.results && data.results.length > 0) {
                const result = data.results[0];
                const address = result.formatted_address || result.address_components?.[0]?.long_name;
                console.log(`\u2705 Google reverse geocoded: ${address}`);
                return res.json({ address });
              }
            }
          } catch (error) {
            console.error("Google reverse geocoding error:", error);
          }
        }
        const fallbackAddress = "Current location";
        console.log(`\u26A0\uFE0F Reverse geocoding fallback for (${lat}, ${lng})`);
        res.json({ address: fallbackAddress });
      } catch (error) {
        console.error("Reverse geocoding error:", error);
        res.status(500).json({
          error: "Reverse geocoding failed",
          address: "Current location"
        });
      }
    }
  );
  app2.get(
    "/api/locations/details",
    communicationRateLimits.analytics,
    async (req, res) => {
      try {
        const placeId = req.query.place_id;
        if (!placeId) {
          return res.status(400).json({
            error: "Missing place_id parameter"
          });
        }
        const validation = placesDetailsSchema.safeParse({ placeId });
        if (!validation.success) {
          return res.status(400).json({
            error: "Invalid parameters",
            details: validation.error.errors.map((err) => ({
              field: err.path.join("."),
              message: err.message
            }))
          });
        }
        if (!GEOAPIFY_API_KEY) {
          return res.status(503).json({
            error: "Places service not available",
            message: "Geocoding service is not configured"
          });
        }
        const geoapifyParams = {
          apiKey: GEOAPIFY_API_KEY,
          id: placeId
        };
        const geoapifyResponse = await makeGeoapifyRequest(
          "https://api.geoapify.com/v1/geocode/search",
          geoapifyParams
        );
        if (!geoapifyResponse.features || geoapifyResponse.features.length === 0) {
          return res.status(404).json({
            error: "Place not found",
            message: "The specified place could not be found"
          });
        }
        const feature = geoapifyResponse.features[0];
        const result = {
          result: {
            place_id: feature.properties.place_id,
            formatted_address: feature.properties.formatted,
            geometry: {
              location: {
                lat: feature.geometry.coordinates[1],
                lng: feature.geometry.coordinates[0]
              }
            },
            address_components: feature.properties.address_components || [],
            name: feature.properties.name || feature.properties.street || feature.properties.city
          }
        };
        res.json(result);
      } catch (error) {
        console.error("Location details error:", error);
        res.status(500).json({
          error: "Failed to get location details",
          message: "Please try again later"
        });
      }
    }
  );
  app2.get(
    "/api/locations/geocode",
    communicationRateLimits.analytics,
    async (req, res) => {
      try {
        const address = req.query.address;
        const lat = req.query.lat;
        const lng = req.query.lng;
        if (lat && lng) {
          try {
            const nominatimResponse = await fetch(
              `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&addressdetails=1`
            );
            if (nominatimResponse.ok) {
              const nominatimData = await nominatimResponse.json();
              if (nominatimData && nominatimData.display_name) {
                const result2 = {
                  results: [
                    {
                      geometry: {
                        location: {
                          lat: parseFloat(lat),
                          lng: parseFloat(lng)
                        }
                      },
                      formatted_address: nominatimData.display_name,
                      address_components: nominatimData.address || []
                    }
                  ]
                };
                console.log(
                  `Nominatim reverse geocoded ${lat}, ${lng} to:`,
                  result2.results[0].formatted_address
                );
                return res.json(result2);
              }
            }
          } catch (nominatimError) {
            console.error(
              "Nominatim reverse geocoding failed:",
              nominatimError
            );
          }
          return res.status(404).json({
            error: "Location not found",
            message: "The specified coordinates could not be reverse geocoded"
          });
        }
        if (!address) {
          return res.status(400).json({
            error: "Missing address or coordinates parameter"
          });
        }
        const queryParams = {
          address,
          countrycode: req.query.countrycode
        };
        const validation = placesGeocodeSchema.safeParse(queryParams);
        if (!validation.success) {
          return res.status(400).json({
            error: "Invalid parameters",
            details: validation.error.errors.map((err) => ({
              field: err.path.join("."),
              message: err.message
            }))
          });
        }
        const validatedParams = validation.data;
        let result = null;
        if (GEOAPIFY_API_KEY) {
          try {
            const geoapifyParams = {
              apiKey: GEOAPIFY_API_KEY,
              text: validatedParams.address,
              limit: 1
            };
            if (validatedParams.countrycode) {
              geoapifyParams.filter = `countrycode:${validatedParams.countrycode}`;
            }
            const geoapifyResponse = await makeGeoapifyRequest(
              "https://api.geoapify.com/v1/geocode/search",
              geoapifyParams
            );
            if (geoapifyResponse.features && geoapifyResponse.features.length > 0) {
              const feature = geoapifyResponse.features[0];
              result = {
                results: [
                  {
                    geometry: {
                      location: {
                        lat: feature.geometry.coordinates[1],
                        lng: feature.geometry.coordinates[0]
                      }
                    },
                    formatted_address: feature.properties.formatted,
                    address_components: feature.properties.address_components || []
                  }
                ]
              };
            }
          } catch (geoapifyError) {
            console.error("Geoapify geocoding error:", geoapifyError);
          }
        }
        if (!result) {
          try {
            const nominatimResponse = await fetch(
              `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(validatedParams.address)}&limit=1&addressdetails=1`
            );
            if (nominatimResponse.ok) {
              const nominatimData = await nominatimResponse.json();
              if (nominatimData && nominatimData.length > 0) {
                const place = nominatimData[0];
                result = {
                  results: [
                    {
                      geometry: {
                        location: {
                          lat: parseFloat(place.lat),
                          lng: parseFloat(place.lon)
                        }
                      },
                      formatted_address: place.display_name,
                      address_components: place.address || []
                    }
                  ]
                };
                console.log(
                  `Nominatim geocoded "${validatedParams.address}" to:`,
                  result.results[0].geometry.location
                );
              }
            }
          } catch (nominatimError) {
            console.error("Nominatim geocoding also failed:", nominatimError);
          }
        }
        if (!result) {
          return res.status(404).json({
            error: "Address not found",
            message: "The specified address could not be geocoded"
          });
        }
        res.json(result);
      } catch (error) {
        console.error("Location geocode error:", error);
        res.status(500).json({
          error: "Failed to geocode address",
          message: "Please try again later"
        });
      }
    }
  );
  const GEOAPIFY_API_KEY = process.env.GEOAPIFY_API_KEY;
  if (!GEOAPIFY_API_KEY) {
    console.warn(
      "Geoapify API key not configured - Using Nominatim fallback for Places functionality"
    );
  }
  const makeGeoapifyRequest = async (url, params) => {
    if (!GEOAPIFY_API_KEY) {
      throw new Error("Geoapify API key not configured");
    }
    const urlParams = new URLSearchParams({
      ...params,
      apiKey: GEOAPIFY_API_KEY
    });
    const response = await fetch(`${url}?${urlParams.toString()}`, {
      method: "GET",
      headers: {
        Accept: "application/json",
        "User-Agent": "Stylemate/1.0"
      }
    });
    if (!response.ok) {
      const errorText = await response.text();
      console.error(`Geoapify API error (${response.status}):`, errorText);
      throw new Error(`Geoapify API error: ${response.status}`);
    }
    return response.json();
  };
  const makeNominatimRequest = async (url, params, options = {}) => {
    const urlParams = new URLSearchParams({
      ...params,
      format: "json",
      addressdetails: "1",
      limit: params.limit || "10"
    });
    const response = await fetch(`${url}?${urlParams.toString()}`, {
      method: "GET",
      headers: {
        Accept: "application/json",
        "User-Agent": "Stylemate/1.0 (proximity search)"
      },
      ...options
    });
    if (!response.ok) {
      const errorText = await response.text();
      console.error(`Nominatim API error (${response.status}):`, errorText);
      throw new Error(`Nominatim API error: ${response.status}`);
    }
    return response.json();
  };
  app2.get(
    "/api/places/autocomplete",
    communicationRateLimits.analytics,
    async (req, res) => {
      try {
        const queryParams = {
          q: req.query.q,
          lat: req.query.lat ? parseFloat(req.query.lat) : void 0,
          lng: req.query.lng ? parseFloat(req.query.lng) : void 0,
          limit: req.query.limit ? parseInt(req.query.limit) : 10,
          countrycode: req.query.countrycode
        };
        Object.keys(queryParams).forEach((key) => {
          const value = queryParams[key];
          if (value === void 0) {
            delete queryParams[key];
          }
        });
        const validation = placesAutocompleteSchema.safeParse(queryParams);
        if (!validation.success) {
          return res.status(400).json({
            error: "Invalid parameters",
            details: validation.error.errors.map((err) => ({
              field: err.path.join("."),
              message: err.message
            }))
          });
        }
        const validatedParams = validation.data;
        let suggestions = [];
        if (GEOAPIFY_API_KEY) {
          try {
            const geoapifyParams = {
              text: validatedParams.q,
              limit: validatedParams.limit?.toString() || "10"
            };
            if (validatedParams.lat && validatedParams.lng) {
              geoapifyParams.bias = `proximity:${validatedParams.lng},${validatedParams.lat}`;
            }
            if (validatedParams.countrycode) {
              geoapifyParams.filter = `countrycode:${validatedParams.countrycode}`;
            }
            const geoapifyResponse = await makeGeoapifyRequest(
              "https://api.geoapify.com/v1/geocode/autocomplete",
              geoapifyParams
            );
            suggestions = geoapifyResponse.features?.map((feature) => ({
              id: feature.properties.place_id || `${feature.geometry.coordinates[1]}_${feature.geometry.coordinates[0]}`,
              title: feature.properties.formatted || feature.properties.name || "",
              subtitle: [
                feature.properties.city,
                feature.properties.state,
                feature.properties.country
              ].filter(Boolean).join(", "),
              lat: feature.geometry.coordinates[1],
              lng: feature.geometry.coordinates[0]
            })) || [];
          } catch (error) {
            console.warn(
              "Geoapify autocomplete failed, falling back to Nominatim:",
              error
            );
          }
        }
        if (suggestions.length === 0) {
          try {
            console.log(
              "Using Nominatim fallback for autocomplete search:",
              validatedParams.q
            );
            const nominatimParams = {
              q: validatedParams.q,
              limit: validatedParams.limit?.toString() || "10"
            };
            if (validatedParams.countrycode) {
              nominatimParams.countrycodes = validatedParams.countrycode;
            }
            if (validatedParams.lat && validatedParams.lng) {
              const lat = validatedParams.lat;
              const lng = validatedParams.lng;
              const delta = 0.5;
              nominatimParams.viewbox = `${lng - delta},${lat + delta},${lng + delta},${lat - delta}`;
              nominatimParams.bounded = "1";
            }
            const nominatimResponse = await makeNominatimRequest(
              "https://nominatim.openstreetmap.org/search",
              nominatimParams
            );
            suggestions = (nominatimResponse || []).map((place) => ({
              id: place.place_id?.toString() || `${place.lat}_${place.lon}`,
              title: place.display_name?.split(",")[0] || place.name || "",
              subtitle: place.display_name?.split(",").slice(1, 3).join(",").trim() || "",
              lat: parseFloat(place.lat),
              lng: parseFloat(place.lon)
            }));
            console.log(
              `Nominatim returned ${suggestions.length} suggestions for "${validatedParams.q}"`
            );
          } catch (nominatimError) {
            console.error(
              "Nominatim autocomplete also failed:",
              nominatimError
            );
          }
        }
        res.json({
          suggestions,
          query: validatedParams.q,
          source: GEOAPIFY_API_KEY && suggestions.length > 0 ? "geoapify" : "nominatim"
        });
      } catch (error) {
        console.error("Places autocomplete error:", error);
        res.status(500).json({
          error: "Failed to fetch address suggestions",
          message: "Please try again later"
        });
      }
    }
  );
  app2.get(
    "/api/places/details",
    communicationRateLimits.analytics,
    async (req, res) => {
      try {
        if (!GEOAPIFY_API_KEY) {
          return res.status(503).json({
            error: "Places service not available",
            message: "Geocoding service is not configured"
          });
        }
        const validation = placesDetailsSchema.safeParse({
          placeId: req.query.placeId
        });
        if (!validation.success) {
          return res.status(400).json({
            error: "Invalid parameters",
            details: validation.error.errors.map((err) => ({
              field: err.path.join("."),
              message: err.message
            }))
          });
        }
        const { placeId } = validation.data;
        let geoapifyParams;
        if (placeId.includes("_")) {
          const [lat, lng] = placeId.split("_");
          geoapifyParams = {
            lat,
            lon: lng
          };
        } else {
          geoapifyParams = {
            place_id: placeId
          };
        }
        const geoapifyResponse = await makeGeoapifyRequest(
          "https://api.geoapify.com/v1/geocode/reverse",
          geoapifyParams
        );
        if (!geoapifyResponse.features || geoapifyResponse.features.length === 0) {
          return res.status(404).json({
            error: "Place not found",
            message: "The specified place could not be found"
          });
        }
        const feature = geoapifyResponse.features[0];
        const props = feature.properties;
        const result = {
          address: props.formatted || "",
          lat: feature.geometry.coordinates[1],
          lng: feature.geometry.coordinates[0],
          placeId: props.place_id || placeId,
          components: {
            city: props.city || "",
            state: props.state || "",
            country: props.country || "",
            postcode: props.postcode || "",
            street: props.street || "",
            housenumber: props.housenumber || ""
          }
        };
        res.json(result);
      } catch (error) {
        console.error("Places details error:", error);
        res.status(500).json({
          error: "Failed to fetch place details",
          message: "Please try again later"
        });
      }
    }
  );
  app2.get(
    "/api/places/geocode",
    communicationRateLimits.analytics,
    async (req, res) => {
      try {
        const queryParams = {};
        if (req.query.address) {
          queryParams.address = req.query.address;
        }
        if (req.query.lat && req.query.lng) {
          queryParams.lat = parseFloat(req.query.lat);
          queryParams.lng = parseFloat(req.query.lng);
        }
        if (req.query.countrycode) {
          queryParams.countrycode = req.query.countrycode;
        }
        const validation = placesGeocodeSchema.safeParse(queryParams);
        if (!validation.success) {
          return res.status(400).json({
            error: "Invalid parameters",
            details: validation.error.errors.map((err) => ({
              field: err.path.join("."),
              message: err.message
            }))
          });
        }
        const validatedData = validation.data;
        let result = null;
        const isReverseGeocoding = "lat" in validatedData && "lng" in validatedData;
        const isForwardGeocoding = "address" in validatedData;
        if (isReverseGeocoding) {
          const { lat, lng, countrycode } = validatedData;
          console.log(`Reverse geocoding coordinates: ${lat}, ${lng}`);
          if (GEOAPIFY_API_KEY) {
            try {
              const geoapifyParams = {
                lat: lat.toString(),
                lon: lng.toString(),
                limit: "1"
              };
              if (countrycode) {
                geoapifyParams.filter = `countrycode:${countrycode}`;
              }
              const geoapifyResponse = await makeGeoapifyRequest(
                "https://api.geoapify.com/v1/geocode/reverse",
                geoapifyParams
              );
              if (geoapifyResponse.features && geoapifyResponse.features.length > 0) {
                const feature = geoapifyResponse.features[0];
                const props = feature.properties;
                result = {
                  address: props.formatted || `${lat}, ${lng}`,
                  lat,
                  lng,
                  confidence: props.confidence || 0.8,
                  components: {
                    city: props.city || "",
                    state: props.state || "",
                    country: props.country || "",
                    postcode: props.postcode || "",
                    street: props.street || "",
                    housenumber: props.housenumber || ""
                  },
                  source: "geoapify"
                };
              }
            } catch (error) {
              console.warn(
                "Geoapify reverse geocoding failed, falling back to Nominatim:",
                error
              );
            }
          }
          if (!result) {
            try {
              console.log(
                "Using Nominatim fallback for reverse geocoding:",
                lat,
                lng
              );
              const nominatimParams = {
                lat: lat.toString(),
                lon: lng.toString(),
                zoom: "18",
                // High zoom for detailed address
                addressdetails: "1"
              };
              if (countrycode) {
                nominatimParams.countrycodes = countrycode;
              }
              const nominatimResponse = await makeNominatimRequest(
                "https://nominatim.openstreetmap.org/reverse",
                nominatimParams
              );
              if (nominatimResponse) {
                const address = nominatimResponse.display_name || `${lat}, ${lng}`;
                result = {
                  address,
                  lat,
                  lng,
                  confidence: 0.7,
                  components: {
                    city: nominatimResponse.address?.city || nominatimResponse.address?.town || nominatimResponse.address?.village || "",
                    state: nominatimResponse.address?.state || "",
                    country: nominatimResponse.address?.country || "",
                    postcode: nominatimResponse.address?.postcode || "",
                    street: nominatimResponse.address?.road || "",
                    housenumber: nominatimResponse.address?.house_number || ""
                  },
                  source: "nominatim"
                };
                console.log(
                  `Nominatim reverse geocoded ${lat}, ${lng} to:`,
                  address
                );
              }
            } catch (nominatimError) {
              console.error(
                "Nominatim reverse geocoding also failed:",
                nominatimError
              );
            }
          }
          if (!result) {
            return res.status(404).json({
              error: "Location not found",
              message: "The specified coordinates could not be reverse geocoded"
            });
          }
        } else if (isForwardGeocoding) {
          const { address, countrycode } = validatedData;
          console.log(`Forward geocoding address: ${address}`);
          if (GEOAPIFY_API_KEY) {
            try {
              const geoapifyParams = {
                text: address,
                limit: "1"
                // We only need the best match
              };
              if (countrycode) {
                geoapifyParams.filter = `countrycode:${countrycode}`;
              }
              const geoapifyResponse = await makeGeoapifyRequest(
                "https://api.geoapify.com/v1/geocode/search",
                geoapifyParams
              );
              if (geoapifyResponse.features && geoapifyResponse.features.length > 0) {
                const feature = geoapifyResponse.features[0];
                const props = feature.properties;
                result = {
                  address: props.formatted || address,
                  lat: feature.geometry.coordinates[1],
                  lng: feature.geometry.coordinates[0],
                  confidence: props.confidence || 0.5,
                  components: {
                    city: props.city || "",
                    state: props.state || "",
                    country: props.country || "",
                    postcode: props.postcode || "",
                    street: props.street || "",
                    housenumber: props.housenumber || ""
                  },
                  source: "geoapify"
                };
              }
            } catch (error) {
              console.warn(
                "Geoapify geocoding failed, falling back to Nominatim:",
                error
              );
            }
          }
          if (!result) {
            try {
              console.log("Using Nominatim fallback for geocoding:", address);
              const nominatimParams = {
                q: address,
                limit: "1"
              };
              if (countrycode) {
                nominatimParams.countrycodes = countrycode;
              }
              const nominatimResponse = await makeNominatimRequest(
                "https://nominatim.openstreetmap.org/search",
                nominatimParams
              );
              if (nominatimResponse && nominatimResponse.length > 0) {
                const place = nominatimResponse[0];
                result = {
                  address: place.display_name || address,
                  lat: parseFloat(place.lat),
                  lng: parseFloat(place.lon),
                  confidence: place.importance || 0.5,
                  components: {
                    city: place.address?.city || place.address?.town || place.address?.village || "",
                    state: place.address?.state || "",
                    country: place.address?.country || "",
                    postcode: place.address?.postcode || "",
                    street: place.address?.road || "",
                    housenumber: place.address?.house_number || ""
                  },
                  source: "nominatim"
                };
                console.log(
                  `Nominatim geocoded "${address}" to:`,
                  result.lat,
                  result.lng
                );
              }
            } catch (nominatimError) {
              console.error("Nominatim geocoding also failed:", nominatimError);
            }
          }
          if (!result) {
            return res.status(404).json({
              error: "Address not found",
              message: "The specified address could not be geocoded"
            });
          }
        }
        res.json(result);
      } catch (error) {
        console.error("Places geocode error:", error);
        res.status(500).json({
          error: "Failed to process geocode request",
          message: "Please try again later"
        });
      }
    }
  );
  app2.get("/api/razorpay-key", (req, res) => {
    if (!razorpay7) {
      return res.status(503).json({ error: "Payment service not configured" });
    }
    res.json({ key: process.env.RAZORPAY_KEY_ID });
  });
  app2.post(
    "/api/razorpay-webhook",
    express4.raw({ type: "application/json" }),
    async (req, res) => {
      try {
        if (!razorpay7) {
          return res.status(503).json({ error: "Payment service not configured" });
        }
        const signature = req.headers["x-razorpay-signature"];
        if (!signature) {
          console.log("Webhook signature missing");
          return res.status(400).json({ error: "Signature missing" });
        }
        const body = req.body.toString();
        const expectedSignature = crypto12.createHmac(
          "sha256",
          process.env.RAZORPAY_WEBHOOK_SECRET || process.env.RAZORPAY_KEY_SECRET
        ).update(body).digest("hex");
        if (expectedSignature !== signature) {
          console.log("Invalid webhook signature");
          return res.status(400).json({ error: "Invalid signature" });
        }
        const event = JSON.parse(body);
        const { payload } = event;
        console.log("Webhook received:", {
          event: event.event,
          paymentId: payload.payment?.entity?.id,
          orderId: payload.payment?.entity?.order_id,
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        });
        switch (event.event) {
          case "payment.captured":
            await handlePaymentCaptured(payload.payment.entity);
            break;
          case "payment.failed":
            await handlePaymentFailed(payload.payment.entity);
            break;
          case "order.paid":
            await handleOrderPaid(payload.order.entity, payload.payment.entity);
            break;
          default:
            console.log(`Unhandled webhook event: ${event.event}`);
        }
        res.status(200).json({ status: "success" });
      } catch (error) {
        console.error("Webhook processing error:", error);
        res.status(500).json({ error: "Webhook processing failed" });
      }
    }
  );
  async function handlePaymentCaptured(payment) {
    try {
      console.log("Processing payment.captured:", payment.id);
      const paymentRecord = await storage.getPaymentByRazorpayOrderId(
        payment.order_id
      );
      if (!paymentRecord) {
        console.error("Payment record not found for order:", payment.order_id);
        return;
      }
      if (paymentRecord.status === "completed") {
        console.log("Payment already processed:", payment.id);
        return;
      }
      if (payment.amount !== paymentRecord.amountPaisa) {
        console.error("Payment amount mismatch:", {
          expected: paymentRecord.amountPaisa,
          received: payment.amount
        });
        await storage.updatePaymentStatus(paymentRecord.id, "failed");
        return;
      }
      await storage.updatePaymentDetails(
        paymentRecord.id,
        payment.id,
        "webhook_verified"
      );
      await storage.updatePaymentStatus(
        paymentRecord.id,
        "completed",
        /* @__PURE__ */ new Date()
      );
      if (paymentRecord.productOrderId) {
        console.log(
          `Processing product order payment: ${paymentRecord.productOrderId}`
        );
        try {
          await storage.updateOrderStatus(
            paymentRecord.productOrderId,
            "processing"
          );
          console.log(
            `Product order ${paymentRecord.productOrderId} marked as processing after successful payment`
          );
          try {
            const order = await storage.getProductOrder(
              paymentRecord.productOrderId
            );
            if (order) {
              const user = await storage.getUserById(order.customerId);
              const salon = await storage.getSalonById(order.salonId);
              if (user && salon && user.email) {
                const customerName = user.firstName ? `${user.firstName}${user.lastName ? " " + user.lastName : ""}`.trim() : user.email.split("@")[0];
                const orderItemsList = order.items.map(
                  (item, index2) => `${index2 + 1}. ${item.productName}
   Qty: ${item.quantity} x Rs.${(item.priceAtOrderPaisa / 100).toFixed(2)} = Rs.${(item.priceAtOrderPaisa * item.quantity / 100).toFixed(2)}`
                ).join("\n");
                let formattedAddress = "Pickup from salon";
                const addr = order.deliveryAddress;
                if (typeof addr === "object" && addr.line1) {
                  formattedAddress = `${addr.line1}
${addr.line2 ? addr.line2 + "\n" : ""}${addr.city}, ${addr.state} ${addr.pincode}`;
                } else if (typeof addr === "string") {
                  formattedAddress = addr;
                }
                await sendPaymentSuccess(order.salonId, order.id, user.email, {
                  customer_name: customerName,
                  salon_name: salon.name,
                  order_number: order.orderNumber,
                  amount_paid: (order.totalPaisa / 100).toFixed(2),
                  payment_method: "Online Payment",
                  transaction_id: payment.id
                });
                await sendOrderConfirmation(
                  order.salonId,
                  order.id,
                  user.email,
                  {
                    customer_name: customerName,
                    salon_name: salon.name,
                    order_number: order.orderNumber,
                    item_count: order.items.length.toString(),
                    total_amount: (order.totalPaisa / 100).toFixed(2),
                    delivery_address: formattedAddress,
                    order_items: orderItemsList,
                    payment_method: "Online Payment",
                    payment_status: "Paid"
                  }
                );
                console.log(
                  `Payment success and order confirmation emails sent for order ${order.id}`
                );
              }
            }
          } catch (emailError) {
            console.error("Failed to send payment success emails:", emailError);
          }
        } catch (error) {
          console.error("Error processing product order payment:", error);
        }
        return;
      }
      const booking = await storage.getBooking(paymentRecord.bookingId);
      let bookingStatus = "confirmed";
      if (booking && booking.offerId) {
        console.log(
          `Validating offer ${booking.offerId} for booking ${booking.id} before confirmation`
        );
        try {
          const user = booking.guestSessionId ? null : await storage.getUserByEmail(booking.customerEmail);
          if (user) {
            const eligibility = await storage.getUserOfferEligibility(
              user.id,
              booking.offerId
            );
            if (!eligibility.eligible) {
              console.error(
                `\u{1F6A8} CRITICAL: Offer ${booking.offerId} usage limit exceeded for user ${user.id}. Reason: ${eligibility.reason}`
              );
              console.error(
                `   Booking ${booking.id} was created when user was eligible, but limit reached before payment.`
              );
              console.error(
                `   This indicates potential usage limit bypass attempt.`
              );
              bookingStatus = "pending_review";
              const currentNotes = booking.notes || "";
              const securityNote = `

[SECURITY ALERT] Offer usage limit exceeded at payment time. Requires manual admin review before confirmation. User: ${user.id}, Offer: ${booking.offerId}, Reason: ${eligibility.reason}`;
              await storage.updateBooking(booking.id, {
                notes: currentNotes + securityNote
              });
              console.error(
                `   ACTION REQUIRED: Admin must review booking ${booking.id} and either confirm at full price or initiate refund.`
              );
            } else {
              const usageNumber = eligibility.usageCount + 1;
              await storage.trackOfferUsage(
                user.id,
                booking.offerId,
                booking.id,
                booking.discountAmountPaisa || 0,
                usageNumber
              );
              console.log(
                `\u2705 Offer usage tracked for user ${user.id} (usage #${usageNumber})`
              );
              const cashbackAmount = await calculateLaunchOfferCashback(
                user.id,
                booking.offerId,
                booking.originalAmountPaisa || booking.totalAmountPaisa
              );
              if (cashbackAmount > 0) {
                await storage.addWalletCredit(
                  user.id,
                  cashbackAmount,
                  `Cashback from offer on booking ${booking.id}`,
                  booking.id,
                  booking.offerId
                );
                console.log(
                  `\u2705 Cashback of ${cashbackAmount} paisa added to user ${user.id} wallet`
                );
              }
            }
          } else {
            console.log(
              "Guest booking - offer usage not tracked for non-authenticated users"
            );
          }
        } catch (offerError) {
          console.error(
            "Error processing offer tracking/cashback:",
            offerError
          );
          bookingStatus = "pending_review";
        }
      }
      await storage.updateBookingStatus(paymentRecord.bookingId, bookingStatus);
      console.log(
        `Booking ${paymentRecord.bookingId} status updated to: ${bookingStatus}`
      );
      if (bookingStatus === "confirmed") {
        try {
          await schedulingService.scheduleBookingReminders(
            paymentRecord.bookingId
          );
        } catch (scheduleError) {
          console.error(
            "Error scheduling booking reminders via webhook:",
            scheduleError
          );
        }
      } else {
        console.log(
          `Skipping reminder scheduling for booking ${paymentRecord.bookingId} with status: ${bookingStatus}`
        );
      }
      console.log("Payment successfully processed via webhook:", payment.id);
    } catch (error) {
      console.error("Error processing payment.captured:", error);
    }
  }
  async function handlePaymentFailed(payment) {
    try {
      console.log("Processing payment.failed:", payment.id);
      const paymentRecord = await storage.getPaymentByRazorpayOrderId(
        payment.order_id
      );
      if (!paymentRecord) {
        console.error("Payment record not found for order:", payment.order_id);
        return;
      }
      await storage.updatePaymentStatus(paymentRecord.id, "failed");
      if (paymentRecord.productOrderId) {
        console.log(
          `Handling product order payment failure: ${paymentRecord.productOrderId}`
        );
        try {
          const order = await storage.getProductOrder(
            paymentRecord.productOrderId
          );
          if (order && order.items) {
            for (const item of order.items) {
              await storage.releaseProductStock(item.productId, item.quantity);
              console.log(
                `Released ${item.quantity} units of product ${item.productId}`
              );
            }
          }
          await storage.updateOrderStatus(
            paymentRecord.productOrderId,
            "payment_failed"
          );
          try {
            const user = await storage.getUserById(order.customerId);
            const salon = await storage.getSalonById(order.salonId);
            if (user && salon && user.email) {
              const customerName = user.firstName ? `${user.firstName}${user.lastName ? " " + user.lastName : ""}`.trim() : user.email.split("@")[0];
              await sendPaymentFailure(order.salonId, order.id, user.email, {
                customer_name: customerName,
                salon_name: salon.name,
                order_number: order.orderNumber,
                amount: (order.totalPaisa / 100).toFixed(2),
                payment_method: "Online Payment",
                failure_reason: payment.error_description || payment.error_reason || "Payment could not be processed"
              });
              console.log(`Payment failure email sent for order ${order.id}`);
            }
          } catch (emailError) {
            console.error("Failed to send payment failure email:", emailError);
          }
          console.log(
            `Product order ${paymentRecord.productOrderId} marked as payment_failed and stock released`
          );
        } catch (error) {
          console.error("Error handling product order payment failure:", error);
        }
        return;
      }
      await storage.updateBookingStatus(paymentRecord.bookingId, "cancelled");
      try {
        const booking = await storage.getBooking(paymentRecord.bookingId);
        if (booking) {
          await communicationService.sendMessage({
            to: booking.customerEmail,
            channel: "email",
            customContent: {
              subject: "Booking Cancellation - Payment Failed",
              body: `Hi ${booking.customerName || "Valued Customer"},

We're sorry, but your booking has been cancelled due to a payment issue. Please contact us if you'd like to reschedule.

Best regards,
Your Salon Team`
            },
            variables: {},
            salonId: booking.salonId,
            customerId: booking.customerEmail,
            bookingId: booking.id,
            type: "transactional"
          });
        }
      } catch (cancelError) {
        console.error("Error sending cancellation notification:", cancelError);
      }
      console.log("Payment failure processed:", payment.id);
    } catch (error) {
      console.error("Error processing payment.failed:", error);
    }
  }
  async function handleOrderPaid(order, payment) {
    try {
      console.log("Processing order.paid:", order.id);
      await handlePaymentCaptured(payment);
    } catch (error) {
      console.error("Error processing order.paid:", error);
    }
  }
  async function checkAndSendLowStockAlert(productId, salonId) {
    try {
      const product = await storage.getProductById(productId, true);
      if (!product || !product.retailConfig) {
        return;
      }
      const retailStock = parseFloat(
        product.retailConfig.retailStockAllocated || "0"
      );
      const serviceStock = parseFloat(
        product.retailConfig.serviceStockAllocated || "0"
      );
      const threshold = product.retailConfig.lowStockThreshold || 5;
      const totalStock = retailStock + serviceStock;
      if (totalStock <= threshold) {
        console.log(
          `\u26A0\uFE0F Low stock detected for product ${product.name}: ${totalStock} units (threshold: ${threshold})`
        );
        try {
          const salon = await storage.getSalonById(salonId);
          if (salon && salon.ownerId) {
            const owner = await storage.getUserById(salon.ownerId);
            if (owner && owner.email) {
              await sendLowStockAlert(salonId, owner.email, {
                product_name: product.name,
                current_stock: totalStock.toString(),
                threshold: threshold.toString(),
                retail_allocated: retailStock.toString(),
                service_allocated: serviceStock.toString(),
                product_link: `${process.env.APP_URL || "https://stylemate.com"}/admin/inventory/products/${productId}`
              });
              console.log(
                `Low stock alert sent to ${owner.email} for product ${product.name}`
              );
            }
          }
        } catch (emailError) {
          console.error("Failed to send low stock alert:", emailError);
        }
      }
    } catch (error) {
      console.error("Error checking low stock:", error);
    }
  }
  app2.get("/api/search/salons", spikeProtection, async (req, res) => {
    try {
      console.log("\u{1F50D} PROXIMITY SEARCH CALLED:", {
        url: req.url,
        query: req.query,
        userAgent: req.get("User-Agent")?.substring(0, 50),
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
      const rawParams = {
        lat: parseFloat(req.query.lat),
        lng: parseFloat(req.query.lng),
        radiusKm: parseFloat(req.query.radiusKm) || 10,
        category: req.query.category,
        q: req.query.q,
        sort: req.query.sort || "distance",
        page: parseInt(req.query.page) || 1,
        pageSize: parseInt(req.query.pageSize) || 20,
        time: req.query.time,
        date: req.query.date,
        maxPrice: parseInt(req.query.maxPrice) || void 0,
        venueType: req.query.venueType || void 0,
        availableToday: req.query.availableToday === "true" || void 0,
        instantBooking: req.query.instantBooking === "true" || void 0,
        offerDeals: req.query.offerDeals === "true" || void 0,
        acceptGroup: req.query.acceptGroup === "true" || void 0
      };
      console.log("\u{1F4CD} PROXIMITY SEARCH PARAMS:", rawParams);
      const validationResult = salonSearchSchema.safeParse(rawParams);
      if (!validationResult.success) {
        return res.status(400).json({
          error: "Invalid search parameters",
          details: validationResult.error.format()
        });
      }
      const params = validationResult.data;
      console.log(
        `\u{1F30D} Searching salons near (${params.lat}, ${params.lng}) within ${params.radiusKm}km`
      );
      let allResults = await storage.findSalonsNearLocation(
        params.lat,
        params.lng,
        params.radiusKm,
        500
        // Get up to 500 results for filtering/sorting
      );
      console.log(`\u{1F4CA} Found ${allResults.length} salons within radius`);
      if (allResults.length === 0) {
        console.log("No salons found within radius, showing nearby salons...");
        const nearbySalons = await storage.findSalonsNearLocation(
          params.lat,
          params.lng,
          50,
          // Search within 50km
          5
          // Limit to 5 results
        );
        allResults = nearbySalons.map((salon) => ({
          ...salon,
          distance_km: salon.distance_km || 999,
          // Mark as far away
          outside_radius: true
          // Flag to show warning
        }));
      }
      let filteredResults = allResults;
      if (params.category) {
        filteredResults = filteredResults.filter((salon) => {
          const salonCategory = salon.category.toLowerCase();
          const searchCategory = params.category.toLowerCase();
          if (searchCategory === "hair") {
            return salonCategory.includes("hair") || salonCategory.includes("salon") || salonCategory === "hair_salon";
          }
          return salonCategory.includes(searchCategory);
        });
      }
      if (params.q) {
        const searchQuery = params.q.toLowerCase();
        const serviceToCategoryMap = {
          hair: ["hair", "salon", "hair_salon"],
          "hair cut": ["hair", "salon", "hair_salon"],
          haircut: ["hair", "salon", "hair_salon"],
          "hair color": ["hair", "salon", "hair_salon"],
          "hair coloring": ["hair", "salon", "hair_salon"],
          styling: ["hair", "salon", "hair_salon"],
          nails: ["nails", "nail", "nail_salon"],
          manicure: ["nails", "nail", "nail_salon"],
          pedicure: ["nails", "nail", "nail_salon"],
          "nail art": ["nails", "nail", "nail_salon"],
          massage: ["massage", "spa"],
          facial: ["skincare", "facial", "beauty"],
          skincare: ["skincare", "facial", "beauty"],
          eyebrows: ["eyebrows", "brows", "beauty"],
          waxing: ["waxing", "beauty", "hair"],
          makeup: ["makeup", "beauty", "bridal"],
          bridal: ["bridal", "makeup", "beauty"]
        };
        const matchingCategories = /* @__PURE__ */ new Set();
        for (const [service, categories] of Object.entries(
          serviceToCategoryMap
        )) {
          if (searchQuery.includes(service)) {
            categories.forEach((cat) => matchingCategories.add(cat));
          }
        }
        if (matchingCategories.size > 0) {
          filteredResults = filteredResults.filter((salon) => {
            const salonCategory = salon.category.toLowerCase();
            return Array.from(matchingCategories).some(
              (cat) => salonCategory.includes(cat)
            );
          });
        } else {
          filteredResults = filteredResults.filter(
            (salon) => salon.name.toLowerCase().includes(searchQuery) || salon.description && salon.description.toLowerCase().includes(searchQuery) || salon.address.toLowerCase().includes(searchQuery) || salon.city.toLowerCase().includes(searchQuery)
          );
        }
      }
      if (rawParams.maxPrice) {
        filteredResults = filteredResults.filter((salon) => {
          const priceRangeMap = {
            $: 1e3,
            $$: 3e3,
            $$$: 6e3,
            $$$$: 1e4
          };
          const salonMaxPrice = priceRangeMap[salon.priceRange] || 5e3;
          return salonMaxPrice <= rawParams.maxPrice;
        });
      }
      if (rawParams.venueType && rawParams.venueType !== "everyone") {
        filteredResults = filteredResults.filter(
          (salon) => salon.venueType === rawParams.venueType || salon.venueType === "everyone" || !salon.venueType
        );
      }
      if (rawParams.instantBooking) {
        filteredResults = filteredResults.filter(
          (salon) => salon.instantBooking === 1
        );
      }
      if (rawParams.offerDeals) {
        filteredResults = filteredResults.filter(
          (salon) => salon.offerDeals === 1
        );
      }
      if (rawParams.acceptGroup) {
        filteredResults = filteredResults.filter(
          (salon) => salon.acceptGroup === 1
        );
      }
      if (params.time) {
        console.log(`\u23F0 Filtering by time availability: ${params.time}`);
        const timeRange = params.time;
        let startHour;
        let endHour;
        if (timeRange === "morning") {
          startHour = 6;
          endHour = 12;
        } else if (timeRange === "afternoon") {
          startHour = 12;
          endHour = 18;
        } else if (timeRange === "evening") {
          startHour = 18;
          endHour = 23;
        } else if (timeRange.includes(" - ")) {
          const [startTimeStr, endTimeStr] = timeRange.split(" - ");
          const parseTime = (timeStr) => {
            const [time, period] = timeStr.trim().split(" ");
            const [hours, minutes] = time.split(":").map(Number);
            let hour24 = hours;
            if (period === "PM" && hours !== 12) hour24 += 12;
            if (period === "AM" && hours === 12) hour24 = 0;
            return hour24 + minutes / 60;
          };
          startHour = parseTime(startTimeStr);
          endHour = parseTime(endTimeStr);
        } else {
          startHour = 0;
          endHour = 24;
        }
        console.log(
          `\u23F0 Looking for salons available between ${startHour}:00 and ${endHour}:00`
        );
        filteredResults = await Promise.all(
          filteredResults.map(async (salon) => {
            try {
              let dateStr;
              if (params.date) {
                if (params.date === "tomorrow") {
                  const tomorrow = /* @__PURE__ */ new Date();
                  tomorrow.setDate(tomorrow.getDate() + 1);
                  dateStr = tomorrow.toISOString().split("T")[0];
                } else if (params.date === "today") {
                  dateStr = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
                } else {
                  dateStr = params.date;
                }
              } else {
                dateStr = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
              }
              const timeSlots2 = await storage.getAvailableTimeSlots(
                salon.id,
                dateStr
              );
              if (!timeSlots2 || timeSlots2.length === 0) {
                console.log(
                  `\u23F0 Salon ${salon.name} has no time slots, including in results`
                );
                return salon;
              }
              const hasAvailability = timeSlots2.some((slot) => {
                const slotStart = new Date(slot.startDateTime);
                const slotEnd = new Date(slot.endDateTime);
                const slotStartHour = slotStart.getHours() + slotStart.getMinutes() / 60;
                const slotEndHour = slotEnd.getHours() + slotEnd.getMinutes() / 60;
                return slotStartHour < endHour && slotEndHour > startHour;
              });
              return hasAvailability ? salon : null;
            } catch (error) {
              console.log(
                `Error checking availability for salon ${salon.id}:`,
                error.message
              );
              return salon;
            }
          })
        );
        filteredResults = filteredResults.filter((salon) => salon !== null);
        console.log(
          `\u23F0 Time filtering complete: ${filteredResults.length} salons available during requested time`
        );
      }
      switch (params.sort) {
        case "recommended":
          filteredResults.sort((a, b) => {
            const scoreA = parseFloat(a.rating || "0") * Math.log10((a.reviewCount || 1) + 1);
            const scoreB = parseFloat(b.rating || "0") * Math.log10((b.reviewCount || 1) + 1);
            return scoreB - scoreA;
          });
          break;
        case "top-rated":
        case "rating":
          filteredResults.sort((a, b) => {
            const ratingDiff = parseFloat(b.rating || "0") - parseFloat(a.rating || "0");
            if (Math.abs(ratingDiff) < 0.1) {
              return (b.reviewCount || 0) - (a.reviewCount || 0);
            }
            return ratingDiff;
          });
          break;
        case "nearest":
        case "distance":
          filteredResults.sort((a, b) => a.distance - b.distance);
          break;
        case "name":
          filteredResults.sort((a, b) => a.name.localeCompare(b.name));
          break;
        default:
          filteredResults.sort((a, b) => a.distance - b.distance);
          break;
      }
      const totalResults = filteredResults.length;
      console.log(
        `\u2705 PROXIMITY SEARCH COMPLETE: ${totalResults} filtered results, returning page ${params.page}`
      );
      const totalPages = Math.ceil(totalResults / params.pageSize);
      const startIndex = (params.page - 1) * params.pageSize;
      const endIndex = startIndex + params.pageSize;
      const paginatedResults = filteredResults.slice(startIndex, endIndex);
      const mapboxToken = process.env.VITE_MAPBOX_TOKEN;
      const salonsWithDrivingDistance = await Promise.all(
        paginatedResults.map(async (salon) => {
          let drivingDistanceKm = salon.distance;
          if (mapboxToken) {
            try {
              const directionsUrl = `https://api.mapbox.com/directions/v5/mapbox/driving/${params.lng},${params.lat};${salon.longitude},${salon.latitude}?access_token=${mapboxToken}&geometries=geojson`;
              const response2 = await fetch(directionsUrl, {
                method: "GET",
                headers: { Accept: "application/json" }
              });
              if (response2.ok) {
                const data = await response2.json();
                if (data.routes && data.routes.length > 0) {
                  drivingDistanceKm = data.routes[0].distance / 1e3;
                  console.log(
                    `\u{1F697} ${salon.name}: Straight-line ${salon.distance.toFixed(1)}km \u2192 Driving ${drivingDistanceKm.toFixed(1)}km`
                  );
                }
              }
            } catch (error) {
              console.warn(
                `Failed to fetch driving distance for salon ${salon.id}, using straight-line distance`
              );
            }
          }
          return {
            ...salon,
            drivingDistance: drivingDistanceKm
          };
        })
      );
      const response = {
        salons: await Promise.all(
          salonsWithDrivingDistance.map(async (salon) => {
            const mediaAssets2 = await storage.getMediaAssetsBySalonId(salon.id);
            const primaryImage = mediaAssets2?.find((asset) => asset.isPrimary)?.url || mediaAssets2?.find((asset) => asset.assetType === "cover")?.url || "";
            let imageUrls = mediaAssets2?.filter((asset) => asset.assetType === "cover")?.map((asset) => asset.url)?.slice(0, 4) || [];
            if (imageUrls.length === 0 && salon.imageUrls && Array.isArray(salon.imageUrls)) {
              imageUrls = salon.imageUrls.slice(0, 4);
            }
            const services6 = await storage.getServicesBySalonId(salon.id);
            const serviceDetails = services6.slice(0, 3).map((service) => ({
              name: service.name,
              durationMinutes: service.durationMinutes,
              price: service.priceInPaisa / 100,
              // Convert paisa to rupees
              currency: service.currency || "INR",
              imageUrl: service.imageUrl || null
            }));
            let availableTimeSlots = [];
            try {
              let searchDate;
              if (params.date) {
                if (params.date === "tomorrow") {
                  searchDate = new Date(Date.now() + 24 * 60 * 60 * 1e3).toISOString().split("T")[0];
                } else if (params.date === "today") {
                  searchDate = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
                } else {
                  searchDate = params.date;
                }
              } else {
                searchDate = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
              }
              let timeSlots2 = await storage.getAvailableTimeSlots(
                salon.id,
                searchDate
              );
              if (timeSlots2.length === 0 && salon.businessHours) {
                const businessHours = typeof salon.businessHours === "string" ? JSON.parse(salon.businessHours) : salon.businessHours;
                const searchDateObj = /* @__PURE__ */ new Date(searchDate + "T00:00:00");
                const dayNames = [
                  "sunday",
                  "monday",
                  "tuesday",
                  "wednesday",
                  "thursday",
                  "friday",
                  "saturday"
                ];
                const dayName = dayNames[searchDateObj.getDay()];
                const dayHours = businessHours[dayName];
                if (dayHours && dayHours.open && dayHours.start && dayHours.end) {
                  const [startHour, startMin] = dayHours.start.split(":").map(Number);
                  const [endHour, endMin] = dayHours.end.split(":").map(Number);
                  const slots = [];
                  let currentHour = startHour;
                  let currentMin = startMin;
                  while (currentHour < endHour || currentHour === endHour && currentMin < endMin) {
                    const slotDateTime = new Date(searchDateObj);
                    slotDateTime.setHours(currentHour, currentMin, 0, 0);
                    slots.push({
                      startDateTime: slotDateTime.toISOString(),
                      staffName: null
                    });
                    currentMin += 30;
                    if (currentMin >= 60) {
                      currentMin = 0;
                      currentHour++;
                    }
                  }
                  timeSlots2 = slots;
                }
              }
              const confirmedBookings = await storage.getBookingsBySalonId(
                salon.id,
                {
                  status: "confirmed",
                  startDate: searchDate,
                  endDate: searchDate
                }
              );
              const pendingBookings = await storage.getBookingsBySalonId(
                salon.id,
                {
                  status: "pending",
                  startDate: searchDate,
                  endDate: searchDate
                }
              );
              const bookings4 = [...confirmedBookings, ...pendingBookings];
              const now = /* @__PURE__ */ new Date();
              const isToday = searchDate === now.toISOString().split("T")[0];
              const isSlotBooked = (slotTime) => {
                const slotStartMinutes = slotTime.getHours() * 60 + slotTime.getMinutes();
                const slotEndMinutes = slotStartMinutes + 30;
                for (const booking of bookings4) {
                  const [bookingHours, bookingMinutes] = booking.bookingTime.split(":").map(Number);
                  const bookingStartMinutes = bookingHours * 60 + bookingMinutes;
                  const bookingDuration = booking.serviceDuration || 30;
                  const bookingEndMinutes = bookingStartMinutes + bookingDuration;
                  if (slotStartMinutes < bookingEndMinutes && slotEndMinutes > bookingStartMinutes) {
                    return true;
                  }
                }
                return false;
              };
              const isSlotPast = (slotTime) => {
                if (!isToday) return false;
                return slotTime < now;
              };
              let processedSlots = timeSlots2.map((slot) => {
                const slotTime = new Date(slot.startDateTime);
                const isBooked = isSlotBooked(slotTime);
                const isPast = isSlotPast(slotTime);
                return {
                  time: slotTime.toLocaleTimeString("en-US", {
                    hour: "numeric",
                    minute: "2-digit",
                    hour12: true
                  }),
                  staffName: slot.staffName,
                  available: !isBooked && !isPast,
                  // Only available if not booked AND not past
                  booked: isBooked,
                  past: isPast,
                  dateTime: slot.startDateTime
                };
              });
              if (params.time) {
                let startHour;
                let endHour;
                if (params.time === "morning") {
                  startHour = 6;
                  endHour = 12;
                } else if (params.time === "afternoon") {
                  startHour = 12;
                  endHour = 18;
                } else if (params.time === "evening") {
                  startHour = 18;
                  endHour = 23;
                } else if (params.time.includes(" - ")) {
                  const [startTimeStr, endTimeStr] = params.time.split(" - ");
                  const parseTime = (timeStr) => {
                    const [time, period] = timeStr.trim().split(" ");
                    const [hours, minutes] = time.split(":").map(Number);
                    let hour24 = hours;
                    if (period === "PM" && hours !== 12) hour24 += 12;
                    if (period === "AM" && hours === 12) hour24 = 0;
                    return hour24 + minutes / 60;
                  };
                  startHour = parseTime(startTimeStr);
                  endHour = parseTime(endTimeStr);
                } else {
                  startHour = 0;
                  endHour = 24;
                }
                processedSlots = processedSlots.filter((slot) => {
                  const slotDateTime = new Date(slot.dateTime);
                  const slotHour = slotDateTime.getHours() + slotDateTime.getMinutes() / 60;
                  return slotHour >= startHour && slotHour < endHour;
                });
              }
              const availableSlots = processedSlots.filter((s) => s.available).slice(0, 6);
              const unavailableSlots = processedSlots.filter((s) => !s.available).slice(0, 3);
              availableTimeSlots = [...availableSlots, ...unavailableSlots];
            } catch (error) {
              console.log(
                `Error fetching time slots for salon ${salon.id}:`,
                error.message
              );
            }
            return {
              id: salon.id,
              name: salon.name,
              description: salon.description,
              address: salon.address,
              city: salon.city,
              state: salon.state,
              zipCode: salon.zipCode,
              latitude: salon.latitude,
              longitude: salon.longitude,
              phone: salon.phone,
              email: salon.email,
              website: salon.website,
              category: salon.category,
              priceRange: salon.priceRange,
              rating: salon.rating || "0.00",
              reviewCount: salon.reviewCount,
              imageUrl: primaryImage,
              imageUrls,
              // Multiple images for gallery
              services: serviceDetails,
              // Top 3 services with details (name, price, duration)
              availableTimeSlots,
              // Available time slots for filtered time
              openTime: salon.openTime,
              closeTime: salon.closeTime,
              distance_km: Math.max(
                0.01,
                Number(salon.drivingDistance.toFixed(2))
              ),
              // ACTUAL driving distance via roads (industry standard)
              createdAt: salon.createdAt
            };
          })
        ),
        pagination: {
          page: params.page,
          pageSize: params.pageSize,
          total: totalResults,
          totalPages,
          hasMore: params.page < totalPages
        },
        searchParams: {
          lat: params.lat,
          lng: params.lng,
          radiusKm: params.radiusKm,
          category: params.category,
          q: params.q,
          sort: params.sort
        }
      };
      res.json(response);
    } catch (error) {
      console.error("Error in proximity search:", error);
      if (error instanceof Error) {
        if (error.message.includes("Latitude must be") || error.message.includes("Longitude must be") || error.message.includes("Radius must be")) {
          return res.status(400).json({ error: error.message });
        }
      }
      res.status(500).json({ error: "Failed to search salons" });
    }
  });
  app2.get("/api/salons", async (req, res) => {
    try {
      const {
        service,
        location,
        categories,
        minPrice,
        maxPrice,
        minRating,
        lat,
        lng,
        radiusKm
      } = req.query;
      const salons11 = await storage.getAllSalons();
      let salonsWithDistance = salons11;
      if (lat && lng) {
        const userLat = parseFloat(lat);
        const userLng = parseFloat(lng);
        const radius = radiusKm ? parseFloat(radiusKm) : 50;
        salonsWithDistance = salons11.map((salon) => ({
          ...salon,
          distance: calculateDistance(
            userLat,
            userLng,
            salon.latitude,
            salon.longitude
          ) / 1e3
          // Convert meters to kilometers
        })).filter((salon) => salon.distance <= radius).sort((a, b) => a.distance - b.distance);
        const mapboxToken = process.env.VITE_MAPBOX_TOKEN;
        if (mapboxToken) {
          salonsWithDistance = await Promise.all(
            salonsWithDistance.map(async (salon) => {
              let drivingDistanceKm = salon.distance;
              try {
                const directionsUrl = `https://api.mapbox.com/directions/v5/mapbox/driving/${userLng},${userLat};${salon.longitude},${salon.latitude}?access_token=${mapboxToken}&geometries=geojson`;
                const response = await fetch(directionsUrl, {
                  method: "GET",
                  headers: { Accept: "application/json" }
                });
                if (response.ok) {
                  const data = await response.json();
                  if (data.routes && data.routes.length > 0) {
                    drivingDistanceKm = data.routes[0].distance / 1e3;
                    console.log(
                      `\u{1F697} ${salon.name}: Straight-line ${salon.distance.toFixed(1)}km \u2192 Driving ${drivingDistanceKm.toFixed(1)}km`
                    );
                  }
                }
              } catch (error) {
                console.warn(
                  `Failed to fetch driving distance for salon ${salon.id}`
                );
              }
              return {
                ...salon,
                distance: drivingDistanceKm,
                // Replace with actual driving distance
                drivingDistance: drivingDistanceKm
              };
            })
          );
        }
      }
      let formattedSalons = await Promise.all(
        salonsWithDistance.map(async (salon) => {
          try {
            const mediaAssets2 = await storage.getMediaAssetsBySalonId(salon.id);
            const safeAssets = mediaAssets2 ?? [];
            const imageTypes = ["gallery", "cover", "logo"];
            const primaryImageUrl = safeAssets.find(
              (asset) => imageTypes.includes(asset.assetType) && asset.isPrimary === 1
            )?.url || safeAssets.find((asset) => imageTypes.includes(asset.assetType))?.url || "";
            const services6 = await storage.getServicesBySalonId(salon.id);
            const serviceDetails = services6.slice(0, 3).map((service2) => ({
              name: service2.name,
              durationMinutes: service2.durationMinutes,
              price: service2.priceInPaisa / 100,
              // Convert paisa to rupees
              currency: service2.currency || "INR",
              imageUrl: service2.imageUrl || null
            }));
            const packages = await storage.getPackagesBySalonId(salon.id);
            const hasPackages = packages.some((pkg) => pkg.isActive === 1);
            const reviews = await storage.getReviewsBySalonId(
              salon.id,
              "google"
            );
            const hasGoogleReviews = reviews.length > 0;
            const imageUrls = safeAssets.filter((asset) => imageTypes.includes(asset.assetType)).map((asset) => asset.url).slice(0, 4);
            console.log(
              `Salon ${salon.name}: Found ${safeAssets.length} media assets, ${imageUrls.length} images for gallery, ${services6.length} services, ${packages.length} packages, ${reviews.length} Google reviews, primary: ${primaryImageUrl || "none"}`
            );
            let categoryDisplay = salon.category;
            try {
              if (typeof salon.category === "string" && salon.category.startsWith("[")) {
                const categories2 = JSON.parse(salon.category);
                categoryDisplay = Array.isArray(categories2) ? categories2[0] || "Beauty Services" : salon.category;
              }
            } catch (e) {
              categoryDisplay = salon.category;
            }
            return {
              id: salon.id,
              name: salon.name,
              rating: parseFloat(salon.rating?.toString() || "0"),
              reviewCount: salon.reviewCount,
              location: `${salon.address}, ${salon.city}`,
              address: salon.address,
              category: categoryDisplay,
              priceRange: salon.priceRange,
              openTime: salon.closeTime,
              // Show when it closes
              image: primaryImageUrl || "",
              // Include primary image URL
              imageUrls,
              // Add image gallery array for SalonCard
              latitude: salon.latitude,
              longitude: salon.longitude,
              services: serviceDetails,
              // Add services array
              distance_km: salon.distance ? Math.max(0.01, Number(salon.distance.toFixed(2))) : void 0,
              // ACTUAL driving distance
              hasPackages,
              // India-specific: Package deals availability
              hasGoogleReviews
              // India-specific: Google Reviews verification
            };
          } catch (error) {
            console.error(`Error fetching media for salon ${salon.id}:`, error);
            let categoryDisplay = salon.category;
            try {
              if (typeof salon.category === "string" && salon.category.startsWith("[")) {
                const categories2 = JSON.parse(salon.category);
                categoryDisplay = Array.isArray(categories2) ? categories2[0] || "Beauty Services" : salon.category;
              }
            } catch (e) {
              categoryDisplay = salon.category;
            }
            return {
              id: salon.id,
              name: salon.name,
              rating: parseFloat(salon.rating?.toString() || "0"),
              reviewCount: salon.reviewCount,
              location: `${salon.address}, ${salon.city}`,
              address: salon.address,
              category: categoryDisplay,
              priceRange: salon.priceRange,
              openTime: salon.closeTime,
              image: "",
              // Fallback to empty string
              imageUrls: [],
              // Empty image gallery on error
              latitude: salon.latitude,
              longitude: salon.longitude,
              services: [],
              // Empty services on error
              distance_km: salon.distance ? Math.max(0.01, Number(salon.distance.toFixed(2))) : void 0,
              // ACTUAL driving distance
              hasPackages: false,
              // Safe default on error
              hasGoogleReviews: false
              // Safe default on error
            };
          }
        })
      );
      if (service && typeof service === "string") {
        const searchTerm = service.toLowerCase();
        formattedSalons = formattedSalons.filter(
          (salon) => salon.name.toLowerCase().includes(searchTerm) || salon.category.toLowerCase().includes(searchTerm)
        );
      }
      if (location && typeof location === "string") {
        const locationTerm = location.toLowerCase();
        formattedSalons = formattedSalons.filter(
          (salon) => salon.location.toLowerCase().includes(locationTerm)
        );
      }
      if (categories && typeof categories === "string") {
        const categoryList = categories.split(",");
        formattedSalons = formattedSalons.filter(
          (salon) => categoryList.some(
            (cat) => salon.category.toLowerCase().includes(cat.toLowerCase())
          )
        );
      }
      if (minRating && typeof minRating === "string") {
        const minRatingNum = parseFloat(minRating);
        formattedSalons = formattedSalons.filter(
          (salon) => salon.rating >= minRatingNum
        );
      }
      if (minPrice && typeof minPrice === "string") {
        const minPriceNum = parseInt(minPrice);
        formattedSalons = formattedSalons.filter((salon) => {
          return salon.priceRange !== "Budget" || minPriceNum <= 100;
        });
      }
      if (maxPrice && typeof maxPrice === "string") {
        const maxPriceNum = parseInt(maxPrice);
        formattedSalons = formattedSalons.filter((salon) => {
          return salon.priceRange !== "Premium" || maxPriceNum >= 200;
        });
      }
      res.json(formattedSalons);
    } catch (error) {
      console.error("Error fetching salons:", error);
      res.status(500).json({ error: "Failed to fetch salons" });
    }
  });
  app2.get("/api/my/salons", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.id;
      const orgMemberships = await storage.getUserOrganizations(userId);
      const allSalons = await storage.getSalons();
      const accessibleSalons = allSalons.filter((salon) => {
        if (salon.ownerId === userId) return true;
        if (salon.orgId) {
          return orgMemberships.some(
            (membership) => membership.orgId === salon.orgId && ["owner", "manager"].includes(membership.orgRole)
          );
        }
        return false;
      });
      console.log(
        `User ${userId} has access to ${accessibleSalons.length} salons`
      );
      res.json(accessibleSalons);
    } catch (error) {
      console.error("Error fetching user salons:", error);
      res.status(500).json({ error: "Failed to fetch user salons" });
    }
  });
  app2.get(
    "/api/salons/:salonId/bookings",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const { status, startDate, endDate } = req.query;
        const bookings4 = await storage.getBookingsBySalonId(salonId, {
          status,
          startDate,
          endDate
        });
        res.json(bookings4);
      } catch (error) {
        console.error("Error fetching salon bookings:", error);
        res.status(500).json({ error: "Failed to fetch bookings" });
      }
    }
  );
  app2.get(
    "/api/salons/:salonId/bookings/:bookingId",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId, bookingId } = req.params;
        const booking = await storage.getBooking(bookingId);
        if (!booking) {
          return res.status(404).json({ error: "Booking not found" });
        }
        if (booking.salonId !== salonId) {
          return res.status(404).json({ error: "Booking not found" });
        }
        res.json(booking);
      } catch (error) {
        console.error("Error fetching booking:", error);
        res.status(500).json({ error: "Failed to fetch booking" });
      }
    }
  );
  app2.put(
    "/api/salons/:salonId/bookings/:bookingId",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId, bookingId } = req.params;
        const validationResult = updateBookingSchema.safeParse(req.body);
        if (!validationResult.success) {
          return res.status(400).json({
            error: "Invalid input",
            details: validationResult.error.issues
          });
        }
        const input = validationResult.data;
        const booking = await storage.getBooking(bookingId);
        if (!booking) {
          return res.status(404).json({ error: "Booking not found" });
        }
        if (booking.salonId !== salonId) {
          return res.status(404).json({ error: "Booking not found" });
        }
        const transitionValidation = validateStatusTransition(
          booking.status,
          input.status
        );
        if (!transitionValidation.isValid) {
          return res.status(400).json({ error: transitionValidation.error });
        }
        const statusUpdateCount = await storage.updateBookingStatus(
          bookingId,
          input.status
        );
        if (input.status === "completed") {
          try {
            const updatedBooking = await storage.getBooking(bookingId);
            if (updatedBooking) {
              await rebookingService.updateCustomerStatsAfterBooking(updatedBooking);
              await expressRebookingService.updatePreferencesAfterBooking(bookingId);
            }
          } catch (rebookingError) {
            console.error("Error updating rebooking stats:", rebookingError);
          }
        }
        let notesUpdateCount = 0;
        if (input.notes !== void 0) {
          notesUpdateCount = await storage.updateBookingNotes(
            bookingId,
            input.notes
          );
        }
        try {
          await rbacService.logBookingAction(
            req.user.id,
            salonId,
            bookingId,
            "booking_updated",
            { status: booking.status, notes: booking.notes },
            { status: input.status, notes: input.notes },
            req.ip,
            req.get("user-agent")
          );
        } catch (auditError) {
          console.error("Error logging booking action:", auditError);
        }
        const totalAffectedRows = Math.max(statusUpdateCount, notesUpdateCount);
        res.json({
          success: true,
          message: "Booking updated successfully",
          affectedRows: totalAffectedRows
        });
      } catch (error) {
        console.error("Error updating booking:", error);
        res.status(500).json({ error: "Failed to update booking" });
      }
    }
  );
  app2.put(
    "/api/salons/:salonId/bookings/bulk-update",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const validationResult = bulkUpdateBookingSchema.safeParse(req.body);
        if (!validationResult.success) {
          return res.status(400).json({
            error: "Invalid input",
            details: validationResult.error.issues
          });
        }
        const input = validationResult.data;
        const bookingsToUpdate = [];
        for (const bookingId of input.bookingIds) {
          const booking = await storage.getBooking(bookingId);
          if (!booking) {
            return res.status(404).json({ error: `Booking ${bookingId} not found` });
          }
          if (booking.salonId !== salonId) {
            return res.status(404).json({ error: `Booking ${bookingId} not found` });
          }
          const transitionValidation = validateStatusTransition(
            booking.status,
            input.status
          );
          if (!transitionValidation.isValid) {
            return res.status(400).json({
              error: `Invalid transition for booking ${bookingId}: ${transitionValidation.error}`
            });
          }
          bookingsToUpdate.push(booking);
        }
        const affectedRows = await storage.bulkUpdateBookingStatus(
          input.bookingIds,
          input.status,
          salonId
        );
        res.json({
          success: true,
          message: `${affectedRows} booking(s) updated successfully to ${input.status}`,
          affectedRows,
          requestedCount: input.bookingIds.length
        });
      } catch (error) {
        console.error("Error bulk updating bookings:", error);
        res.status(500).json({ error: "Failed to update bookings" });
      }
    }
  );
  app2.patch(
    "/api/salons/:salonId/bookings/:bookingId/reschedule",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId, bookingId } = req.params;
        const validationResult = rescheduleBookingInputSchema.safeParse(
          req.body
        );
        if (!validationResult.success) {
          return res.status(400).json({
            error: "Invalid input",
            details: validationResult.error.issues
          });
        }
        const input = validationResult.data;
        const currentBooking = await storage.getBooking(bookingId);
        if (!currentBooking) {
          return res.status(404).json({ error: "Booking not found" });
        }
        if (currentBooking.salonId !== salonId) {
          return res.status(404).json({ error: "Booking not found" });
        }
        if (!["pending", "confirmed"].includes(currentBooking.status)) {
          return res.status(400).json({
            error: `Cannot reschedule a ${currentBooking.status} booking. Only pending and confirmed bookings can be rescheduled.`
          });
        }
        const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
        if (input.bookingDate < today) {
          return res.status(400).json({
            error: "Cannot reschedule booking to a past date"
          });
        }
        const updatedBooking = await storage.rescheduleBooking(bookingId, {
          bookingDate: input.bookingDate,
          bookingTime: input.bookingTime,
          staffId: input.staffId
        });
        try {
          const salon = await storage.getSalon(salonId);
          const service = await storage.getService(updatedBooking.serviceId);
          const staff5 = updatedBooking.staffId ? await storage.getStaff(updatedBooking.staffId) : null;
          const variables = {
            customer_name: updatedBooking.customerName || "Valued Customer",
            salon_name: salon?.name || "Your Salon",
            service_name: service?.name || "Service",
            staff_name: staff5?.name || "Our team",
            old_date: new Date(currentBooking.bookingDate).toLocaleDateString(),
            old_time: currentBooking.bookingTime,
            new_date: new Date(updatedBooking.bookingDate).toLocaleDateString(),
            new_time: updatedBooking.bookingTime,
            total_amount: (updatedBooking.totalAmountPaisa / 100).toFixed(2)
          };
          await sendRescheduleNotification(
            updatedBooking.salonId,
            updatedBooking.id,
            updatedBooking.customerEmail,
            updatedBooking.customerPhone || void 0,
            variables
          );
        } catch (commError) {
          console.error("Error sending reschedule notification:", commError);
        }
        res.json({
          success: true,
          message: "Booking rescheduled successfully",
          booking: updatedBooking
        });
      } catch (error) {
        console.error("Error rescheduling booking:", error);
        if (error instanceof Error) {
          if (error.message.includes("not available") || error.message.includes("conflicts with existing booking")) {
            return res.status(409).json({
              error: "Scheduling conflict",
              details: error.message
            });
          }
          if (error.message.includes("not found")) {
            return res.status(404).json({ error: error.message });
          }
        }
        res.status(500).json({ error: "Failed to reschedule booking" });
      }
    }
  );
  app2.get(
    "/api/salons/:salonId/analytics",
    isAuthenticated,
    requireSalonAccess(["owner", "manager"], "analytics.shop"),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const { period = "7d" } = req.query;
        const analytics = await storage.getSalonAnalytics(
          salonId,
          period
        );
        res.json(analytics);
      } catch (error) {
        console.error("Error fetching salon analytics:", error);
        res.status(500).json({ error: "Failed to fetch analytics" });
      }
    }
  );
  app2.get(
    "/api/salons/:salonId/analytics/staff",
    isAuthenticated,
    requireSalonAccess(["owner", "manager"], "analytics.shop"),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const { period = "30d" } = req.query;
        const analytics = await storage.getAdvancedStaffAnalytics(
          salonId,
          period
        );
        res.json(analytics);
      } catch (error) {
        console.error("Error fetching advanced staff analytics:", error);
        res.status(500).json({ error: "Failed to fetch staff analytics" });
      }
    }
  );
  app2.get(
    "/api/salons/:salonId/analytics/retention",
    isAuthenticated,
    requireSalonAccess(["owner", "manager"], "analytics.shop"),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const { period = "30d" } = req.query;
        const analytics = await storage.getClientRetentionAnalytics(
          salonId,
          period
        );
        res.json(analytics);
      } catch (error) {
        console.error("Error fetching client retention analytics:", error);
        res.status(500).json({ error: "Failed to fetch retention analytics" });
      }
    }
  );
  app2.get(
    "/api/salons/:salonId/analytics/services",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const { period = "30d" } = req.query;
        const analytics = await storage.getServicePopularityAnalytics(
          salonId,
          period
        );
        res.json(analytics);
      } catch (error) {
        console.error("Error fetching service popularity analytics:", error);
        res.status(500).json({ error: "Failed to fetch service analytics" });
      }
    }
  );
  app2.get(
    "/api/salons/:salonId/analytics/intelligence",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const { period = "30d" } = req.query;
        const analytics = await storage.getBusinessIntelligenceMetrics(
          salonId,
          period
        );
        res.json(analytics);
      } catch (error) {
        console.error("Error fetching business intelligence metrics:", error);
        res.status(500).json({ error: "Failed to fetch intelligence metrics" });
      }
    }
  );
  app2.get(
    "/api/salons/:salonId/analytics/cohorts",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const analytics = await storage.getCohortAnalysis(salonId);
        res.json(analytics);
      } catch (error) {
        console.error("Error fetching cohort analysis:", error);
        res.status(500).json({ error: "Failed to fetch cohort analysis" });
      }
    }
  );
  app2.get(
    "/api/salons/:salonId/analytics/segmentation",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const analytics = await storage.getCustomerSegmentation(salonId);
        res.json(analytics);
      } catch (error) {
        console.error("Error fetching customer segmentation:", error);
        res.status(500).json({ error: "Failed to fetch customer segmentation" });
      }
    }
  );
  app2.get(
    "/api/salons/:salonId/customers",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const customers = await storage.getCustomersBySalonId(salonId);
        res.json(customers);
      } catch (error) {
        console.error("Error fetching customers:", error);
        res.status(500).json({ error: "Failed to fetch customers" });
      }
    }
  );
  app2.get(
    "/api/salons/:salonId/customers/:customerEmail",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId, customerEmail } = req.params;
        const decodedEmail = decodeURIComponent(customerEmail);
        let customerProfile = await storage.getCustomerProfile(
          salonId,
          decodedEmail
        );
        if (!customerProfile) {
          customerProfile = await storage.getOrCreateCustomerProfile(
            salonId,
            decodedEmail
          );
          if (!customerProfile) {
            return res.status(404).json({ error: "Customer not found" });
          }
        }
        const [bookingHistory, customerStats] = await Promise.all([
          storage.getCustomerBookingHistory(salonId, decodedEmail),
          storage.getCustomerStats(salonId, decodedEmail)
        ]);
        res.json({
          profile: customerProfile,
          bookingHistory,
          stats: customerStats
        });
      } catch (error) {
        console.error("Error fetching customer profile:", error);
        res.status(500).json({ error: "Failed to fetch customer profile" });
      }
    }
  );
  app2.put(
    "/api/salons/:salonId/customers/:customerEmail",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId, customerEmail } = req.params;
        const decodedEmail = decodeURIComponent(customerEmail);
        const validation = updateCustomerNotesSchema.safeParse(req.body);
        if (!validation.success) {
          return res.status(400).json({
            error: "Validation failed",
            details: validation.error.errors.map((err) => ({
              field: err.path.join("."),
              message: err.message
            }))
          });
        }
        const allowedFields = ["notes", "preferences", "isVip", "tags"];
        const providedFields = Object.keys(req.body);
        const unknownFields = providedFields.filter(
          (field) => !allowedFields.includes(field)
        );
        if (unknownFields.length > 0) {
          return res.status(400).json({
            error: "Unknown fields provided",
            unknownFields
          });
        }
        let customerProfile = await storage.getCustomerProfile(
          salonId,
          decodedEmail
        );
        if (!customerProfile) {
          return res.status(404).json({ error: "Customer profile not found" });
        }
        await storage.updateCustomerProfile(
          customerProfile.id,
          salonId,
          validation.data
        );
        res.json({
          success: true,
          message: "Customer profile updated successfully"
        });
      } catch (error) {
        console.error("Error updating customer profile:", error);
        res.status(500).json({ error: "Failed to update customer profile" });
      }
    }
  );
  app2.get("/api/services", async (req, res) => {
    try {
      const { salonId } = req.query;
      if (salonId) {
        const services6 = await storage.getServicesBySalonId(salonId);
        res.json(services6);
      } else {
        const services6 = await storage.getAllServices();
        res.json(services6);
      }
    } catch (error) {
      console.error("Error fetching services:", error);
      res.status(500).json({ error: "Failed to fetch services" });
    }
  });
  app2.get("/api/service-templates", async (req, res) => {
    try {
      const { gender, category, isPopular } = req.query;
      const serviceTemplates2 = await storage.getServiceTemplates({
        gender,
        category,
        isPopular: isPopular === "true" ? true : isPopular === "false" ? false : void 0
      });
      res.json(serviceTemplates2 || []);
    } catch (error) {
      console.error("Error fetching service templates:", error);
      res.status(500).json({ error: "Failed to fetch service templates" });
    }
  });
  app2.get("/api/salons/:salonId/services", async (req, res) => {
    try {
      const { salonId } = req.params;
      const t0 = Date.now();
      const services6 = await storage.getServicesBySalonId(salonId);
      const t1 = Date.now();
      console.log(
        `[perf] getServicesBySalonId(salonId=${salonId}) took ${t1 - t0}ms, count=${services6?.length ?? 0}`
      );
      res.json(services6 || []);
    } catch (error) {
      console.error("Error fetching salon services:", error);
      res.status(500).json({ error: "Failed to fetch salon services" });
    }
  });
  app2.get(
    "/api/salons/:salonId/services/manage",
    isAuthenticated,
    requireSalonAccess(["owner", "manager", "staff"]),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const services6 = await storage.getServicesBySalonId(salonId);
        res.json(services6 || []);
      } catch (error) {
        console.error("Error fetching salon services:", error);
        res.status(500).json({ error: "Failed to fetch salon services" });
      }
    }
  );
  app2.post(
    "/api/salons/:salonId/services/bulk",
    isAuthenticated,
    requireSalonAccess(["owner", "manager"]),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const servicesArray = Array.isArray(req.body) ? req.body : [req.body];
        const normalizeIsActive = (value) => {
          if (typeof value === "boolean") return value ? 1 : 0;
          if (typeof value === "number") return value ? 1 : 0;
          if (typeof value === "string")
            return value.toLowerCase() === "true" ? 1 : 0;
          return 1;
        };
        const t0 = Date.now();
        const createdServices = await Promise.all(
          servicesArray.map(
            (service) => storage.createService({
              ...service,
              salonId,
              isActive: normalizeIsActive(service.isActive)
            })
          )
        );
        const t1 = Date.now();
        console.log(
          `[perf] Bulk createService took ${t1 - t0}ms for ${createdServices.length} services (salonId=${salonId})`
        );
        res.json(createdServices);
      } catch (error) {
        console.error("Error creating salon services in bulk:", error);
        res.status(500).json({ error: "Failed to create salon services" });
      }
    }
  );
  app2.post(
    "/api/salons/:salonId/services",
    isAuthenticated,
    requireSalonAccess(["owner", "manager"]),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const normalizeIsActive = (value) => {
          if (typeof value === "boolean") return value ? 1 : 0;
          if (typeof value === "number") return value ? 1 : 0;
          if (typeof value === "string")
            return value.toLowerCase() === "true" ? 1 : 0;
          return 1;
        };
        const serviceData = {
          ...req.body,
          salonId,
          isActive: normalizeIsActive(req.body.isActive)
        };
        const t0 = Date.now();
        const service = await storage.createService(serviceData);
        const t1 = Date.now();
        console.log(
          `[perf] createService took ${t1 - t0}ms (salonId=${salonId})`
        );
        res.json(service);
      } catch (error) {
        console.error("Error creating salon service:", error);
        res.status(500).json({ error: "Failed to create salon service" });
      }
    }
  );
  app2.put(
    "/api/salons/:salonId/services/:serviceId",
    isAuthenticated,
    requireSalonAccess(["owner", "manager"]),
    async (req, res) => {
      try {
        const { salonId, serviceId } = req.params;
        const existingService = await storage.getService(serviceId);
        if (!existingService || existingService.salonId !== salonId) {
          return res.status(404).json({
            error: "Service not found or does not belong to this salon"
          });
        }
        const serviceData = {
          ...req.body,
          id: serviceId,
          salonId
        };
        await storage.updateService(serviceId, req.body);
        try {
          await rbacService.logServiceAction(
            req.user.id,
            salonId,
            serviceId,
            "service_updated",
            { name: existingService.name, price: existingService.price },
            { name: req.body.name, price: req.body.price },
            req.ip,
            req.get("user-agent")
          );
        } catch (auditError) {
          console.error("Error logging service action:", auditError);
        }
        const updatedService = await storage.getService(serviceId);
        res.json(updatedService);
      } catch (error) {
        console.error("Error updating salon service:", error);
        res.status(500).json({ error: "Failed to update salon service" });
      }
    }
  );
  app2.delete(
    "/api/salons/:salonId/services/:serviceId",
    isAuthenticated,
    requireSalonAccess(["owner", "manager"]),
    async (req, res) => {
      try {
        const { salonId, serviceId } = req.params;
        const existingService = await storage.getService(serviceId);
        if (!existingService || existingService.salonId !== salonId) {
          return res.status(404).json({
            error: "Service not found or does not belong to this salon"
          });
        }
        await storage.deleteService(serviceId);
        try {
          await rbacService.logServiceAction(
            req.user.id,
            salonId,
            serviceId,
            "service_deleted",
            { name: existingService.name, price: existingService.price },
            null,
            req.ip,
            req.get("user-agent")
          );
        } catch (auditError) {
          console.error("Error logging service action:", auditError);
        }
        res.json({ success: true });
      } catch (error) {
        console.error("Error deleting salon service:", error);
        res.status(500).json({ error: "Failed to delete salon service" });
      }
    }
  );
  app2.get("/api/salons/:salonId/packages", async (req, res) => {
    try {
      const { salonId } = req.params;
      const packages = await storage.getPackagesBySalonId(salonId);
      res.json(packages || []);
    } catch (error) {
      console.error("Error fetching salon packages:", error);
      res.status(500).json({ error: "Failed to fetch salon packages" });
    }
  });
  app2.get("/api/salons/:salonId/packages/:packageId", async (req, res) => {
    try {
      const { salonId, packageId } = req.params;
      const packageData = await storage.getPackageWithServices(packageId);
      if (!packageData || packageData.salonId !== salonId) {
        return res.status(404).json({
          error: "Package not found or does not belong to this salon"
        });
      }
      res.json(packageData);
    } catch (error) {
      console.error("Error fetching package:", error);
      res.status(500).json({ error: "Failed to fetch package" });
    }
  });
  app2.post(
    "/api/salons/:salonId/packages",
    isAuthenticated,
    requireSalonAccess(["owner", "manager"]),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const validationResult = createPackageSchema.safeParse(req.body);
        if (!validationResult.success) {
          return res.status(400).json({
            error: "Invalid package data",
            details: validationResult.error.errors.map((e) => ({
              field: e.path.join("."),
              message: e.message
            }))
          });
        }
        const { serviceIds, name, description, discountedPricePaisa } = validationResult.data;
        if (!serviceIds || serviceIds.length < 2) {
          return res.status(400).json({ error: "Package must include at least 2 services" });
        }
        const services6 = await Promise.all(
          serviceIds.map((id) => storage.getService(id))
        );
        const invalidService = services6.find(
          (s) => !s || s.salonId !== salonId
        );
        if (invalidService === void 0 && services6.some((s) => !s)) {
          return res.status(400).json({ error: "One or more services not found" });
        }
        if (invalidService) {
          return res.status(400).json({ error: "All services must belong to this salon" });
        }
        const totalDurationMinutes = services6.reduce(
          (sum4, s) => sum4 + (s?.durationMinutes || 0),
          0
        );
        const regularPricePaisa = services6.reduce(
          (sum4, s) => sum4 + (s?.priceInPaisa || 0),
          0
        );
        if (regularPricePaisa <= 0) {
          return res.status(400).json({ error: "Services must have a total price greater than 0" });
        }
        if (discountedPricePaisa >= regularPricePaisa) {
          return res.status(400).json({
            error: "Discounted price must be less than regular price",
            details: {
              regularPrice: regularPricePaisa / 100,
              discountedPrice: discountedPricePaisa / 100
            }
          });
        }
        const discountPercentage = Math.round(
          (regularPricePaisa - discountedPricePaisa) / regularPricePaisa * 100
        );
        const newPackage = await storage.createPackageWithServices(
          {
            name,
            description,
            salonId,
            totalDurationMinutes,
            packagePriceInPaisa: discountedPricePaisa,
            regularPriceInPaisa: regularPricePaisa,
            discountPercentage,
            currency: "INR",
            isActive: 1
          },
          serviceIds,
          salonId
        );
        const packageWithServices = await storage.getPackageWithServices(
          newPackage.id
        );
        res.json(packageWithServices);
      } catch (error) {
        console.error("Error creating package:", error);
        res.status(500).json({ error: "Failed to create package" });
      }
    }
  );
  app2.put(
    "/api/salons/:salonId/packages/:packageId",
    isAuthenticated,
    requireSalonAccess(["owner", "manager"]),
    async (req, res) => {
      try {
        const { salonId, packageId } = req.params;
        const validationResult = updatePackageSchema.safeParse(req.body);
        if (!validationResult.success) {
          return res.status(400).json({
            error: "Invalid package data",
            details: validationResult.error.errors.map((e) => ({
              field: e.path.join("."),
              message: e.message
            }))
          });
        }
        const existingPackage = await storage.getPackage(packageId);
        if (!existingPackage || existingPackage.salonId !== salonId) {
          return res.status(404).json({
            error: "Package not found or does not belong to this salon"
          });
        }
        const { serviceIds, name, description, discountedPricePaisa } = validationResult.data;
        if (serviceIds && serviceIds.length > 0) {
          const services6 = await Promise.all(
            serviceIds.map((id) => storage.getService(id))
          );
          const invalidService = services6.find(
            (s) => !s || s.salonId !== salonId
          );
          if (invalidService === void 0 && services6.some((s) => !s)) {
            return res.status(400).json({ error: "One or more services not found" });
          }
          if (invalidService) {
            return res.status(400).json({ error: "All services must belong to this salon" });
          }
          const totalDurationMinutes = services6.reduce(
            (sum4, s) => sum4 + (s?.durationMinutes || 0),
            0
          );
          const regularPricePaisa = services6.reduce(
            (sum4, s) => sum4 + (s?.priceInPaisa || 0),
            0
          );
          if (regularPricePaisa <= 0) {
            return res.status(400).json({
              error: "Services must have a total price greater than 0"
            });
          }
          const finalDiscountedPrice = discountedPricePaisa || existingPackage.packagePriceInPaisa;
          if (finalDiscountedPrice >= regularPricePaisa) {
            return res.status(400).json({
              error: "Discounted price must be less than regular price",
              details: {
                regularPrice: regularPricePaisa / 100,
                discountedPrice: finalDiscountedPrice / 100
              }
            });
          }
          const discountPercentage = Math.round(
            (regularPricePaisa - finalDiscountedPrice) / regularPricePaisa * 100
          );
          await storage.updatePackageWithServices(
            packageId,
            {
              ...name && { name },
              ...description !== void 0 && { description },
              ...discountedPricePaisa && {
                packagePriceInPaisa: discountedPricePaisa
              },
              totalDurationMinutes,
              regularPriceInPaisa: regularPricePaisa,
              discountPercentage
            },
            serviceIds,
            salonId
          );
        } else {
          await storage.updatePackageWithServices(
            packageId,
            {
              ...name && { name },
              ...description !== void 0 && { description },
              ...discountedPricePaisa && {
                packagePriceInPaisa: discountedPricePaisa,
                discountPercentage: Math.round(
                  (existingPackage.regularPriceInPaisa - discountedPricePaisa) / existingPackage.regularPriceInPaisa * 100
                )
              }
            },
            null,
            salonId
          );
        }
        const updatedPackage = await storage.getPackageWithServices(packageId);
        res.json(updatedPackage);
      } catch (error) {
        console.error("Error updating package:", error);
        res.status(500).json({ error: "Failed to update package" });
      }
    }
  );
  app2.delete(
    "/api/salons/:salonId/packages/:packageId",
    isAuthenticated,
    requireSalonAccess(["owner", "manager"]),
    async (req, res) => {
      try {
        const { salonId, packageId } = req.params;
        const existingPackage = await storage.getPackage(packageId);
        if (!existingPackage || existingPackage.salonId !== salonId) {
          return res.status(404).json({
            error: "Package not found or does not belong to this salon"
          });
        }
        await storage.deletePackage(packageId);
        res.json({ success: true });
      } catch (error) {
        console.error("Error deleting package:", error);
        res.status(500).json({ error: "Failed to delete package" });
      }
    }
  );
  app2.post("/api/bookings", async (req, res) => {
    try {
      const {
        salonId,
        serviceIds,
        date,
        time,
        staffId,
        customerName,
        customerEmail,
        customerPhone,
        paymentMethod,
        isGuest,
        totalPrice,
        totalDuration,
        offerId,
        packageId,
        isPackageBooking
      } = req.body;
      if (!salonId || !serviceIds || !Array.isArray(serviceIds) || serviceIds.length === 0) {
        return res.status(400).json({
          error: "Missing required fields: salonId and serviceIds are required"
        });
      }
      if (!date || !time) {
        return res.status(400).json({
          error: "Missing required fields: date and time are required"
        });
      }
      if (!customerEmail) {
        return res.status(400).json({ error: "Customer email is required" });
      }
      if (!customerPhone) {
        return res.status(400).json({ error: "Phone number is required" });
      }
      console.log(`\u{1F4DE} Booking request for phone: ${customerPhone}`);
      const services6 = await Promise.all(
        serviceIds.map((id) => storage.getService(id))
      );
      for (let i = 0; i < services6.length; i++) {
        const service = services6[i];
        if (!service || !service.isActive) {
          return res.status(404).json({ error: `Service ${serviceIds[i]} not found or inactive` });
        }
        if (service.salonId !== salonId) {
          return res.status(400).json({
            error: `Service ${serviceIds[i]} does not belong to salon ${salonId}`
          });
        }
      }
      if (staffId) {
        const staff5 = await storage.getStaff(staffId);
        if (!staff5) {
          return res.status(404).json({ error: "Staff member not found" });
        }
        if (staff5.salonId !== salonId) {
          return res.status(400).json({ error: "Staff member does not belong to this salon" });
        }
      }
      const serviceTotalPrice = services6.reduce(
        (sum4, service) => sum4 + service.priceInPaisa,
        0
      );
      const serviceTotalDuration = services6.reduce(
        (sum4, service) => sum4 + service.durationMinutes,
        0
      );
      let serverTotalPrice = serviceTotalPrice;
      let serverTotalDuration = serviceTotalDuration;
      if (packageId && isPackageBooking) {
        const packageData = await storage.getPackageWithServices(packageId);
        if (!packageData) {
          return res.status(404).json({ error: "Package not found" });
        }
        if (packageData.salonId !== salonId) {
          return res.status(400).json({ error: "Package does not belong to this salon" });
        }
        if (!packageData.isActive) {
          return res.status(400).json({ error: "Package is no longer active" });
        }
        serverTotalPrice = packageData.packagePriceInPaisa;
        serverTotalDuration = packageData.totalDurationMinutes;
        console.log(`\u{1F4E6} Package booking: using package price ${serverTotalPrice} instead of service total ${serviceTotalPrice}`);
      }
      if (totalPrice !== serverTotalPrice) {
        console.warn(
          `Price mismatch: client sent ${totalPrice}, server calculated ${serverTotalPrice}`
        );
        return res.status(400).json({
          error: "Price validation failed",
          details: "The booking price does not match server calculations"
        });
      }
      if (totalDuration !== serverTotalDuration) {
        console.warn(
          `Duration mismatch: client sent ${totalDuration}, server calculated ${serverTotalDuration}`
        );
        return res.status(400).json({
          error: "Duration validation failed",
          details: "The booking duration does not match server calculations"
        });
      }
      let discountInPaisa = 0;
      let finalAmountInPaisa = serverTotalPrice;
      let offerSnapshot = null;
      let userId = req.user?.id || null;
      if (offerId) {
        const offer = await storage.getOfferById(offerId);
        if (!offer) {
          return res.status(404).json({ error: "Offer not found" });
        }
        if (!offer.isActive || offer.approvalStatus !== "approved") {
          return res.status(400).json({ error: "Offer is not available" });
        }
        if (!offer.isPlatformWide && offer.salonId !== salonId) {
          return res.status(400).json({ error: "Offer does not apply to this salon" });
        }
        const now = /* @__PURE__ */ new Date();
        if (offer.validFrom && new Date(offer.validFrom) > now) {
          return res.status(400).json({ error: "Offer not yet valid" });
        }
        if (offer.validUntil && new Date(offer.validUntil) < now) {
          return res.status(400).json({ error: "Offer has expired" });
        }
        if (userId !== "guest") {
          const eligibility = await storage.getUserOfferEligibility(
            userId,
            offerId
          );
          if (!eligibility.eligible) {
            return res.status(400).json({
              error: "Not eligible for this offer",
              reason: eligibility.reason
            });
          }
        }
        if (offer.minimumPurchase && serverTotalPrice < offer.minimumPurchase) {
          return res.status(400).json({
            error: `Minimum purchase of \u20B9${(offer.minimumPurchase / 100).toFixed(0)} required for this offer`
          });
        }
        if (offer.discountType === "percentage") {
          discountInPaisa = Math.floor(
            serverTotalPrice * offer.discountValue / 100
          );
        } else if (offer.discountType === "fixed") {
          discountInPaisa = offer.discountValue;
        }
        if (offer.maxDiscount && discountInPaisa > offer.maxDiscount) {
          discountInPaisa = offer.maxDiscount;
        }
        if (discountInPaisa > serverTotalPrice) {
          discountInPaisa = serverTotalPrice;
        }
        finalAmountInPaisa = serverTotalPrice - discountInPaisa;
        offerSnapshot = {
          offerId: offer.id,
          offerTitle: offer.title,
          discountType: offer.discountType,
          discountValue: offer.discountValue,
          discountApplied: discountInPaisa
        };
        console.log(
          `\u2705 Offer applied: ${offer.title}, discount: \u20B9${(discountInPaisa / 100).toFixed(0)}`
        );
      }
      let createdUserId = null;
      let tempPasswordForEmail = null;
      if (isGuest || !req.session?.userId) {
        const existingUser = await storage.getUserByEmail(customerEmail.toLowerCase().trim());
        if (existingUser) {
          createdUserId = existingUser.id;
        } else {
          const bcrypt = await import("bcryptjs");
          tempPasswordForEmail = crypto12.randomBytes(8).toString("hex");
          const hashedPassword = await bcrypt.default.hash(tempPasswordForEmail, 10);
          const newUser = await storage.createUser({
            email: customerEmail.toLowerCase().trim(),
            password: hashedPassword,
            firstName: customerName?.split(" ")[0] || "",
            lastName: customerName?.split(" ").slice(1).join(" ") || "",
            phone: customerPhone || null,
            emailVerified: 0,
            phoneVerified: 0,
            isActive: 1
          });
          let customerRole = await storage.getRoleByName("customer");
          if (!customerRole) {
            customerRole = await storage.createRole({ name: "customer", description: "Customer" });
          }
          await storage.assignUserRole(newUser.id, customerRole.id);
          createdUserId = newUser.id;
          console.log(`\u2705 Created guest account for email ending in ...${customerEmail.slice(-10)}`);
        }
      } else {
        createdUserId = req.session?.userId;
      }
      if (createdUserId) {
        userId = createdUserId;
      }
      const bookingId = crypto12.randomUUID();
      const booking = await storage.createBooking({
        salonId,
        serviceId: serviceIds[0],
        // Primary service (for backward compatibility)
        customerName: customerName || "",
        customerEmail,
        customerPhone: customerPhone || null,
        staffId: staffId || null,
        bookingDate: date,
        bookingTime: time,
        status: "pending",
        totalAmountPaisa: serverTotalPrice,
        discountInPaisa,
        finalAmountPaisa: finalAmountInPaisa,
        offerId: offerId || null,
        offerSnapshot: offerSnapshot ? JSON.stringify(offerSnapshot) : null,
        paymentStatus: paymentMethod === "pay_at_salon" ? "pending" : "pending",
        paymentMethod: paymentMethod || "pay_at_salon",
        notes: serviceIds.length > 1 ? `Multiple services: ${services6.map((s) => s.name).join(", ")}` : null,
        guestSessionId: isGuest && !createdUserId ? bookingId : null,
        userId: createdUserId || null
      });
      if (offerId && userId && discountInPaisa > 0) {
        const eligibility = await storage.getUserOfferEligibility(
          userId,
          offerId
        );
        const usageNumber = (eligibility.usageCount || 0) + 1;
        await storage.trackOfferUsage(
          userId,
          offerId,
          booking.id,
          discountInPaisa,
          usageNumber
        );
        console.log(
          `\u2705 Offer usage tracked: user ${userId}, offer ${offerId}, usage #${usageNumber}`
        );
      }
      console.log(
        `\u2705 Booking created: ${booking.id} with ${serviceIds.length} services${offerId ? " and offer applied" : ""}`
      );
      try {
        const salon = await storage.getSalon(salonId);
        const service = services6[0];
        const staff5 = staffId ? await storage.getStaff(staffId) : null;
        await sendBookingConfirmation(
          salonId,
          booking.id,
          customerEmail,
          customerPhone || void 0,
          {
            customer_name: customerName || "Valued Customer",
            salon_name: salon?.businessName || "Our Salon",
            service_name: serviceIds.length > 1 ? `${services6.map((s) => s.name).join(", ")}` : service.name,
            booking_date: date,
            booking_time: time,
            staff_name: staff5?.name || "Our Team",
            total_amount: (finalAmountInPaisa / 100).toFixed(0)
          }
        );
        console.log(
          `\u2705 Booking confirmation notification sent for booking ${booking.id}`
        );
      } catch (notificationError) {
        console.error(
          "Failed to send booking confirmation notification:",
          notificationError
        );
      }
      if (tempPasswordForEmail && customerEmail) {
        try {
          const { sendGuestWelcomeEmail: sendGuestWelcomeEmail2 } = await Promise.resolve().then(() => (init_communicationService(), communicationService_exports));
          await sendGuestWelcomeEmail2(salonId, customerEmail, customerName || "Guest", tempPasswordForEmail);
          console.log(`\u2705 Welcome email sent to new guest account`);
        } catch (welcomeError) {
          console.error("Failed to send welcome email:", welcomeError);
        }
      }
      res.json({
        success: true,
        bookingId: booking.id,
        totalPrice: serverTotalPrice,
        discountApplied: discountInPaisa,
        finalPrice: finalAmountInPaisa,
        totalDuration: serverTotalDuration,
        offerApplied: offerSnapshot,
        message: "Booking created successfully"
      });
    } catch (error) {
      console.error("Error creating booking:", error);
      res.status(500).json({ error: "Failed to create booking" });
    }
  });
  app2.get("/api/bookings/:bookingId/confirmation", async (req, res) => {
    try {
      const { bookingId } = req.params;
      const booking = await storage.getBooking(bookingId);
      if (!booking) {
        return res.status(404).json({ error: "Booking not found" });
      }
      const salon = await storage.getSalon(booking.salonId);
      const service = await storage.getService(booking.serviceId);
      let staff5 = null;
      if (booking.staffId) {
        staff5 = await storage.getStaff(booking.staffId);
      }
      const maskEmail = (email) => {
        if (!email) return null;
        const [local, domain] = email.split("@");
        if (!domain) return null;
        const masked = local.slice(0, 2) + "***";
        return `${masked}@${domain}`;
      };
      res.json({
        id: booking.id,
        salonId: booking.salonId,
        serviceId: booking.serviceId,
        customerName: booking.customerName ? booking.customerName.split(" ")[0] : null,
        // Only first name
        customerEmail: maskEmail(booking.customerEmail),
        // Masked email
        customerPhone: null,
        // Never expose phone in public endpoint
        bookingDate: booking.bookingDate,
        bookingTime: booking.bookingTime,
        status: booking.status,
        totalAmountPaisa: booking.totalAmountPaisa,
        discountInPaisa: booking.discountInPaisa,
        finalAmountPaisa: booking.finalAmountPaisa,
        notes: null,
        // Don't expose notes publicly
        salon: salon ? {
          name: salon.businessName || salon.name,
          address: salon.address,
          city: salon.city
        } : null,
        service: service ? {
          name: service.name,
          durationMinutes: service.durationMinutes
        } : null,
        staff: staff5 ? {
          name: staff5.name
        } : null
      });
    } catch (error) {
      console.error("Error fetching booking confirmation:", error);
      res.status(500).json({ error: "Failed to fetch booking details" });
    }
  });
  app2.post("/api/create-payment-order", async (req, res) => {
    try {
      if (!razorpay7 && req.body.booking?.paymentMethod !== "pay_at_salon") {
        return res.status(503).json({ error: "Payment service not configured" });
      }
      console.log("Payment order request:", {
        salonId: req.body.salonId,
        serviceId: req.body.serviceId,
        bookingDate: req.body.booking?.date,
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
      const validationResult = createPaymentOrderSchema.safeParse(req.body);
      if (!validationResult.success) {
        console.log("Validation failed:", validationResult.error.issues);
        return res.status(400).json({
          error: "Invalid input",
          details: validationResult.error.issues
        });
      }
      const input = validationResult.data;
      const service = await storage.getService(input.serviceId);
      if (!service || !service.isActive) {
        return res.status(404).json({ error: "Service not found or inactive" });
      }
      if (service.salonId !== input.salonId) {
        console.log(
          `Service-salon mismatch: service ${input.serviceId} belongs to salon ${service.salonId}, not ${input.salonId}`
        );
        return res.status(400).json({ error: "Service does not belong to the specified salon" });
      }
      let timeRange;
      try {
        timeRange = storage.computeBookingTimeRange(
          input.booking.date,
          input.booking.time,
          service.durationMinutes
        );
      } catch (timeError) {
        const errorMessage = timeError instanceof Error ? timeError.message : "Invalid time format";
        console.error("Invalid booking time:", errorMessage);
        return res.status(400).json({
          error: "Invalid booking time",
          details: errorMessage
        });
      }
      const { start, end } = timeRange;
      try {
        const overlappingBookings = await storage.findOverlappingBookings(
          input.salonId,
          null,
          // No specific staff member yet
          start,
          end
        );
        if (overlappingBookings.length > 0) {
          return res.status(409).json({
            error: "Scheduling conflict",
            details: "This time slot conflicts with an existing booking. Please choose a different time."
          });
        }
        const now = /* @__PURE__ */ new Date();
        if (start < now) {
          return res.status(400).json({
            error: "Cannot book appointments in the past"
          });
        }
      } catch (conflictError) {
        console.error("Error checking booking conflicts:", conflictError);
        return res.status(500).json({ error: "Failed to validate booking time slot" });
      }
      let offerValidation = {
        isValid: false,
        discountAmount: 0,
        finalAmount: service.priceInPaisa,
        cashbackAmount: 0,
        offer: null
      };
      const userId = req.session?.userId;
      if (input.booking.offerId) {
        console.log(`Validating offer ${input.booking.offerId} for booking`);
        offerValidation = await validateAndCalculateOffer(
          input.booking.offerId,
          userId,
          service.priceInPaisa,
          input.salonId
        );
        if (!offerValidation.isValid) {
          console.log(`Offer validation failed: ${offerValidation.reason}`);
          return res.status(400).json({
            error: "Offer validation failed",
            details: offerValidation.reason || "Invalid offer"
          });
        }
        console.log(
          `\u2705 Offer validated: ${offerValidation.discountAmount} paisa discount applied`
        );
      }
      const tCreateBooking0 = Date.now();
      const booking = await storage.createBooking({
        salonId: input.salonId,
        serviceId: input.serviceId,
        userId: userId || null,
        // Link to authenticated user (null for guests)
        customerName: input.booking.customer.name || "",
        // Empty string for guest bookings
        customerEmail: input.booking.customer.email,
        customerPhone: input.booking.customer.phone || "",
        // Empty string for guest bookings
        bookingDate: input.booking.date,
        bookingTime: input.booking.time,
        status: input.booking.paymentMethod === "pay_at_salon" ? "confirmed" : "pending",
        totalAmountPaisa: offerValidation.finalAmount,
        // Use discounted amount
        currency: service.currency,
        paymentMethod: input.booking.paymentMethod || "pay_now",
        // Include payment method
        notes: input.booking.notes,
        guestSessionId: userId ? null : input.booking.guestSessionId || null,
        // Only use guest session for non-authenticated users
        // Offer-related fields
        offerId: input.booking.offerId || null,
        originalAmountPaisa: input.booking.offerId ? service.priceInPaisa : null,
        discountAmountPaisa: input.booking.offerId ? offerValidation.discountAmount : null,
        finalAmountPaisa: input.booking.offerId ? offerValidation.finalAmount : null
      });
      const tCreateBooking1 = Date.now();
      console.log(
        `[perf] createBooking took ${tCreateBooking1 - tCreateBooking0}ms (bookingId=${booking.id})`
      );
      try {
        const salon = await storage.getSalon(input.salonId);
        const variables = {
          customer_name: booking.customerName || "Valued Customer",
          salon_name: salon?.name || "Your Salon",
          service_name: service.name,
          booking_date: new Date(booking.bookingDate).toLocaleDateString(),
          booking_time: booking.bookingTime,
          staff_name: "Our team"
        };
        await sendBookingConfirmation(
          booking.salonId,
          booking.id,
          booking.customerEmail,
          booking.customerPhone || void 0,
          variables
        );
      } catch (commError) {
        console.error("Error sending booking confirmation:", commError);
      }
      if (input.booking.paymentMethod === "pay_at_salon") {
        res.json({
          booking_id: booking.id,
          payment_method: "pay_at_salon",
          amount: offerValidation.finalAmount,
          original_amount: input.booking.offerId ? service.priceInPaisa : void 0,
          discount: input.booking.offerId ? offerValidation.discountAmount : void 0,
          currency: service.currency,
          status: "confirmed"
        });
      } else {
        const tCreatePayment0 = Date.now();
        const payment = await storage.createPayment({
          bookingId: booking.id,
          amountPaisa: offerValidation.finalAmount,
          // Use discounted amount
          currency: service.currency,
          status: "pending",
          razorpayOrderId: null,
          razorpayPaymentId: null,
          razorpaySignature: null
        });
        const tCreatePayment1 = Date.now();
        console.log(
          `[perf] createPayment took ${tCreatePayment1 - tCreatePayment0}ms (paymentId=${payment.id})`
        );
        const razorpayOrderOptions = {
          amount: offerValidation.finalAmount,
          // Use discounted amount - SERVER CONTROLLED
          currency: service.currency,
          receipt: `bk_${Date.now()}`,
          // Use timestamp to fit 40 char limit
          notes: {
            booking_id: booking.id,
            payment_id: payment.id,
            service_name: service.name,
            customer_email: input.booking.customer.email,
            offer_id: input.booking.offerId || "",
            discount: offerValidation.discountAmount || 0
          }
        };
        if (!razorpay7) {
          return res.status(503).json({ error: "Payment service not configured" });
        }
        const tRz0 = Date.now();
        const order = await razorpay7.orders.create(razorpayOrderOptions);
        const tRz1 = Date.now();
        console.log(
          `[perf] razorpay.orders.create took ${tRz1 - tRz0}ms (orderId=${order.id})`
        );
        const tUpdatePayment0 = Date.now();
        await storage.updatePaymentOrderId(payment.id, order.id);
        const tUpdatePayment1 = Date.now();
        console.log(
          `[perf] updatePaymentOrderId took ${tUpdatePayment1 - tUpdatePayment0}ms (paymentId=${payment.id})`
        );
        res.json({
          id: order.id,
          amount: order.amount,
          currency: order.currency,
          booking_id: booking.id,
          payment_id: payment.id
        });
      }
    } catch (error) {
      console.error("Error creating payment order:", error);
      res.status(500).json({ error: "Failed to create payment order" });
    }
  });
  app2.post("/api/verify-payment", async (req, res) => {
    try {
      if (!razorpay7) {
        return res.status(503).json({ error: "Payment service not configured" });
      }
      const validationResult = verifyPaymentSchema.safeParse(req.body);
      if (!validationResult.success) {
        return res.status(400).json({
          error: "Invalid input",
          details: validationResult.error.issues
        });
      }
      const input = validationResult.data;
      const payment = await storage.getPaymentByRazorpayOrderId(
        input.razorpay_order_id
      );
      if (!payment) {
        return res.status(404).json({ error: "Payment record not found" });
      }
      if (payment.status === "completed") {
        return res.json({
          success: true,
          message: "Payment already verified",
          payment_id: payment.razorpayPaymentId
        });
      }
      const body = input.razorpay_order_id + "|" + input.razorpay_payment_id;
      const expectedSignature = crypto12.createHmac("sha256", process.env.RAZORPAY_KEY_SECRET).update(body.toString()).digest("hex");
      if (expectedSignature !== input.razorpay_signature) {
        await storage.updatePaymentStatus(payment.id, "failed");
        return res.status(400).json({
          success: false,
          error: "Invalid payment signature"
        });
      }
      try {
        const razorpayPayment = await razorpay7.payments.fetch(
          input.razorpay_payment_id
        );
        if (razorpayPayment.order_id !== input.razorpay_order_id) {
          await storage.updatePaymentStatus(payment.id, "failed");
          return res.status(400).json({ error: "Payment order mismatch" });
        }
        if (razorpayPayment.amount !== payment.amountPaisa) {
          await storage.updatePaymentStatus(payment.id, "failed");
          return res.status(400).json({ error: "Payment amount mismatch" });
        }
        if (razorpayPayment.currency !== payment.currency) {
          await storage.updatePaymentStatus(payment.id, "failed");
          return res.status(400).json({ error: "Payment currency mismatch" });
        }
        if (razorpayPayment.status !== "captured") {
          await storage.updatePaymentStatus(payment.id, "failed");
          return res.status(400).json({ error: "Payment not captured" });
        }
      } catch (razorpayError) {
        console.error("Error fetching payment from Razorpay:", razorpayError);
        await storage.updatePaymentStatus(payment.id, "failed");
        return res.status(400).json({ error: "Failed to verify payment with Razorpay" });
      }
      await storage.updatePaymentDetails(
        payment.id,
        input.razorpay_payment_id,
        input.razorpay_signature
      );
      await storage.updatePaymentStatus(payment.id, "completed", /* @__PURE__ */ new Date());
      await storage.updateBookingStatus(payment.bookingId, "confirmed");
      try {
        await schedulingService.scheduleBookingReminders(payment.bookingId);
      } catch (scheduleError) {
        console.error("Error scheduling booking reminders:", scheduleError);
      }
      console.log("Payment verified successfully:", {
        payment_id: payment.id,
        booking_id: payment.bookingId,
        razorpay_payment_id: input.razorpay_payment_id,
        amount: payment.amountPaisa
      });
      res.json({
        success: true,
        message: "Payment verified successfully",
        payment_id: input.razorpay_payment_id,
        booking_id: payment.bookingId
      });
    } catch (error) {
      console.error("Error verifying payment:", error);
      res.status(500).json({ error: "Payment verification failed" });
    }
  });
  app2.get("/api/salons/:salonId/staff", async (req, res) => {
    try {
      const { salonId } = req.params;
      const staff5 = await storage.getStaffBySalonId(salonId);
      res.json(staff5);
    } catch (error) {
      console.error("Error fetching staff:", error);
      res.status(500).json({ error: "Failed to fetch staff" });
    }
  });
  app2.get(
    "/api/salons/:salonId/staff/manage",
    isAuthenticated,
    requireSalonAccess(["owner", "manager"], "staff.view"),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const staff5 = await storage.getStaffBySalonId(salonId);
        res.json(staff5);
      } catch (error) {
        console.error("Error fetching staff:", error);
        res.status(500).json({ error: "Failed to fetch staff" });
      }
    }
  );
  app2.get(
    "/api/salons/:salonId/suggested-roles",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const services6 = await storage.getServicesBySalonId(salonId);
        const activeServices = services6.filter((s) => s.isActive === 1);
        const { getSuggestedRolesFromServices: getSuggestedRolesFromServices2 } = await Promise.resolve().then(() => (init_service_role_mapping(), service_role_mapping_exports));
        const suggestedRoles = getSuggestedRolesFromServices2(activeServices);
        res.json({
          suggestedRoles,
          totalServices: activeServices.length,
          message: activeServices.length === 0 ? "Add services first to get intelligent role suggestions" : `Found ${suggestedRoles.length} suggested role${suggestedRoles.length !== 1 ? "s" : ""} based on your ${activeServices.length} service${activeServices.length !== 1 ? "s" : ""}`
        });
      } catch (error) {
        console.error("Error getting suggested roles:", error);
        res.status(500).json({ error: "Failed to get suggested roles" });
      }
    }
  );
  app2.post(
    "/api/salons/:salonId/staff",
    isAuthenticated,
    requireSalonAccess(["owner", "manager"], "staff.create"),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const staffData = { ...req.body, salonId };
        const newStaff = await storage.createStaff(staffData);
        res.status(201).json(newStaff);
      } catch (error) {
        console.error("Error creating staff:", error);
        res.status(500).json({ error: "Failed to create staff member" });
      }
    }
  );
  app2.put(
    "/api/salons/:salonId/staff/:staffId",
    isAuthenticated,
    requireSalonAccess(["owner", "manager"], "staff.edit"),
    async (req, res) => {
      try {
        const { staffId, salonId } = req.params;
        const existingStaff = await storage.getStaff(staffId);
        if (!existingStaff) {
          return res.status(404).json({ error: "Staff member not found" });
        }
        if (existingStaff.salonId !== salonId) {
          return res.status(403).json({ error: "Staff member does not belong to this salon" });
        }
        const { id, createdAt, salonId: _, orgId, ...updateData } = req.body;
        await storage.updateStaff(staffId, updateData);
        try {
          await rbacService.logStaffAction(
            req.user.id,
            salonId,
            staffId,
            "staff_updated",
            { name: existingStaff.name, role: existingStaff.role },
            { name: updateData.name, role: updateData.role },
            req.ip,
            req.get("user-agent")
          );
        } catch (auditError) {
          console.error("Error logging staff action:", auditError);
        }
        const updatedStaff = await storage.getStaff(staffId);
        res.json(updatedStaff);
      } catch (error) {
        console.error("Error updating staff:", error);
        res.status(500).json({ error: "Failed to update staff member" });
      }
    }
  );
  app2.get(
    "/api/salons/:salonId/availability-patterns",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const patterns = await storage.getAvailabilityPatternsBySalonId(salonId);
        res.json(patterns);
      } catch (error) {
        console.error("Error fetching availability patterns:", error);
        res.status(500).json({ error: "Failed to fetch availability patterns" });
      }
    }
  );
  app2.post(
    "/api/salons/:salonId/availability-patterns",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const patternData = { ...req.body, salonId };
        const newPattern = await storage.createAvailabilityPattern(patternData);
        const startDate = /* @__PURE__ */ new Date();
        const endDate = /* @__PURE__ */ new Date();
        endDate.setDate(endDate.getDate() + 90);
        await storage.generateTimeSlotsFromPattern(
          newPattern.id,
          startDate,
          endDate
        );
        res.status(201).json(newPattern);
      } catch (error) {
        console.error("Error creating availability pattern:", error);
        res.status(500).json({ error: "Failed to create availability pattern" });
      }
    }
  );
  app2.put(
    "/api/availability-patterns/:patternId",
    isAuthenticated,
    async (req, res) => {
      try {
        const { patternId } = req.params;
        const pattern = await storage.getAvailabilityPattern(patternId);
        if (!pattern) {
          return res.status(404).json({ error: "Availability pattern not found" });
        }
        const salon = await storage.getSalonById(pattern.salonId);
        if (!salon) {
          return res.status(404).json({ error: "Salon not found" });
        }
        const hasAccess = req.user?.orgMemberships?.some(
          (membership) => membership.orgId === salon.orgId && ["owner", "manager"].includes(membership.orgRole)
        );
        if (!hasAccess) {
          return res.status(403).json({ error: "Access denied to this salon" });
        }
        await storage.updateAvailabilityPattern(patternId, req.body);
        const startDate = /* @__PURE__ */ new Date();
        const endDate = /* @__PURE__ */ new Date();
        endDate.setDate(endDate.getDate() + 90);
        await storage.generateTimeSlotsFromPattern(
          patternId,
          startDate,
          endDate
        );
        res.json({ success: true });
      } catch (error) {
        console.error("Error updating availability pattern:", error);
        res.status(500).json({ error: "Failed to update availability pattern" });
      }
    }
  );
  app2.delete(
    "/api/availability-patterns/:patternId",
    isAuthenticated,
    async (req, res) => {
      try {
        const { patternId } = req.params;
        const pattern = await storage.getAvailabilityPattern(patternId);
        if (!pattern) {
          return res.status(404).json({ error: "Availability pattern not found" });
        }
        const salon = await storage.getSalonById(pattern.salonId);
        if (!salon) {
          return res.status(404).json({ error: "Salon not found" });
        }
        const hasAccess = req.user?.orgMemberships?.some(
          (membership) => membership.orgId === salon.orgId && ["owner", "manager"].includes(membership.orgRole)
        );
        if (!hasAccess) {
          return res.status(403).json({ error: "Access denied to this salon" });
        }
        await storage.deleteAvailabilityPattern(patternId);
        res.json({ success: true });
      } catch (error) {
        console.error("Error deleting availability pattern:", error);
        res.status(500).json({ error: "Failed to delete availability pattern" });
      }
    }
  );
  app2.get("/api/salons/:salonId/available-slots", async (req, res) => {
    try {
      const { salonId } = req.params;
      const { date, staffId } = req.query;
      if (!date || typeof date !== "string") {
        return res.status(400).json({ error: "Date parameter is required" });
      }
      const availableSlots = await storage.getAvailableTimeSlots(
        salonId,
        date,
        staffId
      );
      res.json(availableSlots);
    } catch (error) {
      console.error("Error fetching available slots:", error);
      res.status(500).json({ error: "Failed to fetch available slots" });
    }
  });
  app2.get(
    "/api/salons/:salonId/time-slots",
    isAuthenticated,
    requireSalonAccess(["owner", "manager", "staff"]),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const { startDate, endDate } = req.query;
        if (!startDate || !endDate || typeof startDate !== "string" || typeof endDate !== "string") {
          return res.status(400).json({ error: "startDate and endDate parameters are required" });
        }
        const timeSlots2 = await storage.getTimeSlotsByDateRange(
          salonId,
          startDate,
          endDate
        );
        res.json(timeSlots2);
      } catch (error) {
        console.error("Error fetching time slots:", error);
        res.status(500).json({ error: "Failed to fetch time slots" });
      }
    }
  );
  app2.post(
    "/api/time-slots/:slotId/block",
    isAuthenticated,
    async (req, res) => {
      try {
        const { slotId } = req.params;
        const slot = await storage.getTimeSlot(slotId);
        if (!slot) {
          return res.status(404).json({ error: "Time slot not found" });
        }
        const salon = await storage.getSalonById(slot.salonId);
        if (!salon) {
          return res.status(404).json({ error: "Salon not found" });
        }
        const hasManagementAccess = req.user?.orgMemberships?.some(
          (membership) => membership.orgId === salon.orgId && ["owner", "manager"].includes(membership.orgRole)
        );
        const isStaff = await storage.isUserStaffOfSalon(
          req.user.id,
          slot.salonId
        );
        if (!hasManagementAccess && !isStaff) {
          return res.status(403).json({ error: "Access denied to manage this time slot" });
        }
        await storage.blockTimeSlot(slotId);
        res.json({ success: true });
      } catch (error) {
        console.error("Error blocking time slot:", error);
        res.status(500).json({ error: "Failed to block time slot" });
      }
    }
  );
  app2.post(
    "/api/time-slots/:slotId/unblock",
    isAuthenticated,
    async (req, res) => {
      try {
        const { slotId } = req.params;
        const slot = await storage.getTimeSlot(slotId);
        if (!slot) {
          return res.status(404).json({ error: "Time slot not found" });
        }
        const salon = await storage.getSalonById(slot.salonId);
        if (!salon) {
          return res.status(404).json({ error: "Salon not found" });
        }
        const hasManagementAccess = req.user?.orgMemberships?.some(
          (membership) => membership.orgId === salon.orgId && ["owner", "manager"].includes(membership.orgRole)
        );
        const isStaff = await storage.isUserStaffOfSalon(
          req.user.id,
          slot.salonId
        );
        if (!hasManagementAccess && !isStaff) {
          return res.status(403).json({ error: "Access denied to manage this time slot" });
        }
        await storage.unblockTimeSlot(slotId);
        res.json({ success: true });
      } catch (error) {
        console.error("Error unblocking time slot:", error);
        res.status(500).json({ error: "Failed to unblock time slot" });
      }
    }
  );
  app2.post(
    "/api/salons/:salonId/regenerate-availability",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const { startDate: startDateStr, endDate: endDateStr } = req.body;
        const startDate = startDateStr ? new Date(startDateStr) : /* @__PURE__ */ new Date();
        const endDate = endDateStr ? new Date(endDateStr) : (() => {
          const date = /* @__PURE__ */ new Date();
          date.setDate(date.getDate() + 90);
          return date;
        })();
        await storage.regenerateTimeSlotsForSalon(salonId, startDate, endDate);
        res.json({
          success: true,
          message: "Availability regenerated successfully",
          startDate: startDate.toISOString(),
          endDate: endDate.toISOString()
        });
      } catch (error) {
        console.error("Error regenerating availability:", error);
        res.status(500).json({ error: "Failed to regenerate availability" });
      }
    }
  );
  app2.get(
    "/api/salons/:salonId/booking-settings",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const settings = await storage.getBookingSettings(salonId);
        res.json(settings);
      } catch (error) {
        console.error("Error fetching booking settings:", error);
        res.status(500).json({ error: "Failed to fetch booking settings" });
      }
    }
  );
  app2.post(
    "/api/salons/:salonId/booking-settings",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const validationResult = insertBookingSettingsSchema.safeParse({
          ...req.body,
          salonId
        });
        if (!validationResult.success) {
          return res.status(400).json({
            error: "Invalid input",
            details: validationResult.error.issues
          });
        }
        const existingSettings = await storage.getBookingSettings(salonId);
        if (existingSettings) {
          await storage.updateBookingSettings(salonId, validationResult.data);
          const updatedSettings = await storage.getBookingSettings(salonId);
          return res.json(updatedSettings);
        }
        const newSettings = await storage.createBookingSettings(
          validationResult.data
        );
        res.status(201).json(newSettings);
      } catch (error) {
        console.error("Error creating booking settings:", error);
        res.status(500).json({ error: "Failed to create booking settings" });
      }
    }
  );
  app2.put(
    "/api/salons/:salonId/booking-settings",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const partialSchema = insertBookingSettingsSchema.omit({ salonId: true }).partial();
        const validationResult = partialSchema.safeParse(req.body);
        if (!validationResult.success) {
          return res.status(400).json({
            error: "Invalid input",
            details: validationResult.error.issues
          });
        }
        const existingSettings = await storage.getBookingSettings(salonId);
        if (!existingSettings) {
          return res.status(404).json({ error: "Booking settings not found" });
        }
        await storage.updateBookingSettings(salonId, validationResult.data);
        const updatedSettings = await storage.getBookingSettings(salonId);
        res.json(updatedSettings);
      } catch (error) {
        console.error("Error updating booking settings:", error);
        res.status(500).json({ error: "Failed to update booking settings" });
      }
    }
  );
  app2.get(
    "/api/salons/:salonId/resources",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const resources2 = await storage.getResourcesBySalonId(salonId);
        res.json(resources2);
      } catch (error) {
        console.error("Error fetching resources:", error);
        res.status(500).json({ error: "Failed to fetch resources" });
      }
    }
  );
  app2.post(
    "/api/salons/:salonId/resources",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const validationResult = insertResourceSchema.safeParse({
          ...req.body,
          salonId
        });
        if (!validationResult.success) {
          return res.status(400).json({
            error: "Invalid input",
            details: validationResult.error.issues
          });
        }
        const newResource = await storage.createResource(validationResult.data);
        res.status(201).json(newResource);
      } catch (error) {
        console.error("Error creating resource:", error);
        res.status(500).json({ error: "Failed to create resource" });
      }
    }
  );
  app2.put(
    "/api/salons/:salonId/resources/:resourceId",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId, resourceId } = req.params;
        const partialSchema = insertResourceSchema.omit({ salonId: true }).partial();
        const validationResult = partialSchema.safeParse(req.body);
        if (!validationResult.success) {
          return res.status(400).json({
            error: "Invalid input",
            details: validationResult.error.issues
          });
        }
        const existingResource = await storage.getResource(resourceId);
        if (!existingResource) {
          return res.status(404).json({ error: "Resource not found" });
        }
        if (existingResource.salonId !== salonId) {
          return res.status(403).json({ error: "Resource does not belong to this salon" });
        }
        await storage.updateResource(
          resourceId,
          salonId,
          validationResult.data
        );
        const updatedResource = await storage.getResource(resourceId);
        res.json(updatedResource);
      } catch (error) {
        console.error("Error updating resource:", error);
        res.status(500).json({ error: "Failed to update resource" });
      }
    }
  );
  app2.delete(
    "/api/salons/:salonId/resources/:resourceId",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId, resourceId } = req.params;
        await storage.deleteResource(resourceId, salonId);
        res.json({ success: true });
      } catch (error) {
        console.error("Error deleting resource:", error);
        res.status(500).json({ error: "Failed to delete resource" });
      }
    }
  );
  app2.get(
    "/api/salons/:salonId/staff-services",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const { staffId, serviceId } = req.query;
        if (staffId && serviceId) {
          const staffService = await storage.getStaffService(
            staffId,
            serviceId
          );
          res.json(staffService);
        } else {
          const staffServices2 = await storage.getStaffServicesBySalonId(salonId);
          res.json(staffServices2);
        }
      } catch (error) {
        console.error("Error fetching staff services:", error);
        res.status(500).json({ error: "Failed to fetch staff services" });
      }
    }
  );
  app2.post(
    "/api/salons/:salonId/staff-services",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const validationResult = insertStaffServiceSchema.safeParse({
          ...req.body,
          salonId
        });
        if (!validationResult.success) {
          return res.status(400).json({
            error: "Invalid input",
            details: validationResult.error.issues
          });
        }
        const newStaffService = await storage.createStaffService(
          validationResult.data
        );
        res.status(201).json(newStaffService);
      } catch (error) {
        console.error("Error creating staff service:", error);
        res.status(500).json({ error: "Failed to create staff service" });
      }
    }
  );
  app2.put(
    "/api/salons/:salonId/staff-services/:staffId/:serviceId",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { staffId, serviceId } = req.params;
        await storage.updateStaffService(staffId, serviceId, req.body);
        res.json({ success: true });
      } catch (error) {
        console.error("Error updating staff service:", error);
        res.status(500).json({ error: "Failed to update staff service" });
      }
    }
  );
  app2.delete(
    "/api/salons/:salonId/staff-services/:staffId/:serviceId",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { staffId, serviceId } = req.params;
        await storage.deleteStaffService(staffId, serviceId);
        res.json({ success: true });
      } catch (error) {
        console.error("Error deleting staff service:", error);
        res.status(500).json({ error: "Failed to delete staff service" });
      }
    }
  );
  app2.get(
    "/api/salons/:salonId/service-resources",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const { serviceId, resourceId } = req.query;
        if (serviceId && resourceId) {
          const serviceResource = await storage.getServiceResource(
            serviceId,
            resourceId
          );
          res.json(serviceResource);
        } else {
          const serviceResources2 = await storage.getServiceResourcesBySalonId(salonId);
          res.json(serviceResources2);
        }
      } catch (error) {
        console.error("Error fetching service resources:", error);
        res.status(500).json({ error: "Failed to fetch service resources" });
      }
    }
  );
  app2.post(
    "/api/salons/:salonId/service-resources",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const validationResult = insertServiceResourceSchema.safeParse({
          ...req.body,
          salonId
        });
        if (!validationResult.success) {
          return res.status(400).json({
            error: "Invalid input",
            details: validationResult.error.issues
          });
        }
        const newServiceResource = await storage.createServiceResource(
          validationResult.data
        );
        res.status(201).json(newServiceResource);
      } catch (error) {
        console.error("Error creating service resource:", error);
        res.status(500).json({ error: "Failed to create service resource" });
      }
    }
  );
  app2.put(
    "/api/salons/:salonId/service-resources/:serviceId/:resourceId",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { serviceId, resourceId } = req.params;
        await storage.updateServiceResource(serviceId, resourceId, req.body);
        res.json({ success: true });
      } catch (error) {
        console.error("Error updating service resource:", error);
        res.status(500).json({ error: "Failed to update service resource" });
      }
    }
  );
  app2.delete(
    "/api/salons/:salonId/service-resources/:serviceId/:resourceId",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { serviceId, resourceId } = req.params;
        await storage.deleteServiceResource(serviceId, resourceId);
        res.json({ success: true });
      } catch (error) {
        console.error("Error deleting service resource:", error);
        res.status(500).json({ error: "Failed to delete service resource" });
      }
    }
  );
  app2.get("/api/salons/:salonId/media-assets", async (req, res) => {
    try {
      const { salonId } = req.params;
      const { assetType } = req.query;
      if (assetType) {
        const assets = await storage.getMediaAssetsByType(
          salonId,
          assetType
        );
        res.json(assets);
      } else {
        const assets = await storage.getMediaAssetsBySalonId(salonId);
        res.json(assets);
      }
    } catch (error) {
      console.error("Error fetching media assets:", error);
      res.status(500).json({ error: "Failed to fetch media assets" });
    }
  });
  app2.get(
    "/api/salons/:salonId/media-assets/manage",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const { assetType } = req.query;
        if (assetType) {
          const assets = await storage.getMediaAssetsByType(
            salonId,
            assetType
          );
          res.json(assets);
        } else {
          const assets = await storage.getMediaAssetsBySalonId(salonId);
          res.json(assets);
        }
      } catch (error) {
        console.error("Error fetching media assets:", error);
        res.status(500).json({ error: "Failed to fetch media assets" });
      }
    }
  );
  app2.post(
    "/api/salons/:salonId/media-assets",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const validationResult = insertMediaAssetSchema.safeParse({
          ...req.body,
          salonId
        });
        if (!validationResult.success) {
          return res.status(400).json({
            error: "Invalid input",
            details: validationResult.error.issues
          });
        }
        const newAsset = await storage.createMediaAsset(validationResult.data);
        res.status(201).json(newAsset);
      } catch (error) {
        console.error("Error creating media asset:", error);
        res.status(500).json({ error: "Failed to create media asset" });
      }
    }
  );
  app2.put(
    "/api/salons/:salonId/media-assets/:assetId",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId, assetId } = req.params;
        await storage.updateMediaAsset(assetId, salonId, req.body);
        res.json({ success: true });
      } catch (error) {
        console.error("Error updating media asset:", error);
        res.status(500).json({ error: "Failed to update media asset" });
      }
    }
  );
  app2.delete(
    "/api/salons/:salonId/media-assets/:assetId",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId, assetId } = req.params;
        await storage.deleteMediaAsset(assetId, salonId);
        res.json({ success: true });
      } catch (error) {
        console.error("Error deleting media asset:", error);
        res.status(500).json({ error: "Failed to delete media asset" });
      }
    }
  );
  app2.put(
    "/api/salons/:salonId/media-assets/:mediaId/set-primary",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId, mediaId } = req.params;
        if (!salonId || !mediaId) {
          return res.status(400).json({ error: "Salon ID and Media ID are required" });
        }
        const existingAsset = await storage.getMediaAsset(mediaId);
        if (!existingAsset) {
          return res.status(404).json({ error: "Media asset not found" });
        }
        if (existingAsset.salonId !== salonId) {
          return res.status(403).json({ error: "Media asset does not belong to this salon" });
        }
        const updatedAsset = await storage.setPrimaryMediaAsset(
          salonId,
          mediaId
        );
        res.json(updatedAsset);
      } catch (error) {
        console.error("Error setting primary media asset:", error);
        if (error instanceof Error && error.message === "Media asset not found") {
          return res.status(404).json({ error: "Media asset not found" });
        }
        res.status(500).json({ error: "Failed to set primary media asset" });
      }
    }
  );
  app2.get(
    "/api/salons/:salonId/tax-rates",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const taxRates2 = await storage.getTaxRatesBySalonId(salonId);
        res.json(taxRates2);
      } catch (error) {
        console.error("Error fetching tax rates:", error);
        res.status(500).json({ error: "Failed to fetch tax rates" });
      }
    }
  );
  app2.post(
    "/api/salons/:salonId/tax-rates",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const validationResult = insertTaxRateSchema.safeParse({
          ...req.body,
          salonId
        });
        if (!validationResult.success) {
          return res.status(400).json({
            error: "Invalid input",
            details: validationResult.error.issues
          });
        }
        const newTaxRate = await storage.createTaxRate(validationResult.data);
        res.status(201).json(newTaxRate);
      } catch (error) {
        console.error("Error creating tax rate:", error);
        res.status(500).json({ error: "Failed to create tax rate" });
      }
    }
  );
  app2.put(
    "/api/salons/:salonId/tax-rates/:taxRateId",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId, taxRateId } = req.params;
        const partialSchema = insertTaxRateSchema.omit({ salonId: true }).partial();
        const validationResult = partialSchema.safeParse(req.body);
        if (!validationResult.success) {
          return res.status(400).json({
            error: "Invalid input",
            details: validationResult.error.issues
          });
        }
        const existingTaxRate = await storage.getTaxRate(taxRateId);
        if (!existingTaxRate) {
          return res.status(404).json({ error: "Tax rate not found" });
        }
        if (existingTaxRate.salonId !== salonId) {
          return res.status(403).json({ error: "Tax rate does not belong to this salon" });
        }
        await storage.updateTaxRate(taxRateId, salonId, validationResult.data);
        const updatedTaxRate = await storage.getTaxRate(taxRateId);
        res.json(updatedTaxRate);
      } catch (error) {
        console.error("Error updating tax rate:", error);
        res.status(500).json({ error: "Failed to update tax rate" });
      }
    }
  );
  app2.post(
    "/api/salons/:salonId/tax-rates/:taxRateId/set-default",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId, taxRateId } = req.params;
        await storage.setDefaultTaxRate(salonId, taxRateId);
        res.json({ success: true });
      } catch (error) {
        console.error("Error setting default tax rate:", error);
        res.status(500).json({ error: "Failed to set default tax rate" });
      }
    }
  );
  app2.delete(
    "/api/salons/:salonId/tax-rates/:taxRateId",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId, taxRateId } = req.params;
        const existingTaxRate = await storage.getTaxRate(taxRateId);
        if (!existingTaxRate) {
          return res.status(404).json({ error: "Tax rate not found" });
        }
        if (existingTaxRate.salonId !== salonId) {
          return res.status(403).json({ error: "Tax rate does not belong to this salon" });
        }
        await storage.deleteTaxRate(taxRateId, salonId);
        res.json({ success: true, message: "Tax rate deleted successfully" });
      } catch (error) {
        console.error("Error deleting tax rate:", error);
        res.status(500).json({ error: "Failed to delete tax rate" });
      }
    }
  );
  app2.get(
    "/api/salons/:salonId/payout-accounts",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const accounts = await storage.getPayoutAccountsBySalonId(salonId);
        res.json(accounts);
      } catch (error) {
        console.error("Error fetching payout accounts:", error);
        res.status(500).json({ error: "Failed to fetch payout accounts" });
      }
    }
  );
  app2.post(
    "/api/salons/:salonId/payout-accounts",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const validationResult = insertPayoutAccountSchema.safeParse({
          ...req.body,
          salonId
        });
        if (!validationResult.success) {
          return res.status(400).json({
            error: "Invalid input",
            details: validationResult.error.issues
          });
        }
        const newAccount = await storage.createPayoutAccount(
          validationResult.data
        );
        res.status(201).json(newAccount);
      } catch (error) {
        console.error("Error creating payout account:", error);
        res.status(500).json({ error: "Failed to create payout account" });
      }
    }
  );
  app2.put(
    "/api/salons/:salonId/payout-accounts/:accountId",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId, accountId } = req.params;
        await storage.updatePayoutAccount(accountId, salonId, req.body);
        res.json({ success: true });
      } catch (error) {
        console.error("Error updating payout account:", error);
        res.status(500).json({ error: "Failed to update payout account" });
      }
    }
  );
  app2.post(
    "/api/salons/:salonId/payout-accounts/:accountId/set-default",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId, accountId } = req.params;
        await storage.setDefaultPayoutAccount(salonId, accountId);
        res.json({ success: true });
      } catch (error) {
        console.error("Error setting default payout account:", error);
        res.status(500).json({ error: "Failed to set default payout account" });
      }
    }
  );
  app2.delete(
    "/api/salons/:salonId/payout-accounts/:accountId",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId, accountId } = req.params;
        await storage.deletePayoutAccount(accountId, salonId);
        res.json({ success: true });
      } catch (error) {
        console.error("Error deleting payout account:", error);
        res.status(500).json({ error: "Failed to delete payout account" });
      }
    }
  );
  app2.get(
    "/api/salons/:salonId/publish-state",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const state = await storage.getPublishState(salonId);
        if (!state) {
          return res.status(404).json({ error: "Publish state not found" });
        }
        res.json(state);
      } catch (error) {
        console.error("Error fetching publish state:", error);
        res.status(500).json({ error: "Failed to fetch publish state" });
      }
    }
  );
  app2.post(
    "/api/salons/:salonId/publish-state",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const validationResult = insertPublishStateSchema.safeParse({
          ...req.body,
          salonId
        });
        if (!validationResult.success) {
          return res.status(400).json({
            error: "Invalid input",
            details: validationResult.error.issues
          });
        }
        const existingState = await storage.getPublishState(salonId);
        if (existingState) {
          await storage.updatePublishState(salonId, validationResult.data);
          const updatedState = await storage.getPublishState(salonId);
          return res.json(updatedState);
        }
        const newState = await storage.createPublishState(
          validationResult.data
        );
        res.status(201).json(newState);
      } catch (error) {
        console.error("Error creating publish state:", error);
        res.status(500).json({ error: "Failed to create publish state" });
      }
    }
  );
  app2.put(
    "/api/salons/:salonId/publish-state",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const partialSchema = insertPublishStateSchema.omit({ salonId: true }).partial();
        const validationResult = partialSchema.safeParse(req.body);
        if (!validationResult.success) {
          return res.status(400).json({
            error: "Invalid input",
            details: validationResult.error.issues
          });
        }
        const existingState = await storage.getPublishState(salonId);
        if (!existingState) {
          return res.status(404).json({ error: "Publish state not found" });
        }
        await storage.updatePublishState(salonId, validationResult.data);
        const updatedState = await storage.getPublishState(salonId);
        res.json(updatedState);
      } catch (error) {
        console.error("Error updating publish state:", error);
        res.status(500).json({ error: "Failed to update publish state" });
      }
    }
  );
  app2.get(
    "/api/salons/:salonId/dashboard-completion",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const completion = await storage.checkDashboardCompletion(salonId);
        console.log(
          "\u{1F4CA} Dashboard Completion Debug:",
          JSON.stringify(completion, null, 2)
        );
        res.json(completion);
      } catch (error) {
        console.error("Error fetching dashboard completion:", error);
        res.status(500).json({ error: "Failed to fetch dashboard completion status" });
      }
    }
  );
  app2.get(
    "/api/salons/:salonId/expense-categories",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const categories = await storage.getExpenseCategoriesBySalonId(salonId);
        res.json(categories);
      } catch (error) {
        console.error("Error fetching expense categories:", error);
        res.status(500).json({ error: "Failed to fetch expense categories" });
      }
    }
  );
  app2.post(
    "/api/salons/:salonId/expense-categories",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const validationResult = insertExpenseCategorySchema.safeParse({
          ...req.body,
          salonId
        });
        if (!validationResult.success) {
          return res.status(400).json({
            error: "Invalid input",
            details: validationResult.error.issues
          });
        }
        const category = await storage.createExpenseCategory(
          validationResult.data
        );
        res.status(201).json(category);
      } catch (error) {
        console.error("Error creating expense category:", error);
        res.status(500).json({ error: "Failed to create expense category" });
      }
    }
  );
  app2.put(
    "/api/salons/:salonId/expense-categories/:categoryId",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId, categoryId } = req.params;
        const partialSchema = insertExpenseCategorySchema.omit({ salonId: true }).partial();
        const validationResult = partialSchema.safeParse(req.body);
        if (!validationResult.success) {
          return res.status(400).json({
            error: "Invalid input",
            details: validationResult.error.issues
          });
        }
        await storage.updateExpenseCategory(
          categoryId,
          salonId,
          validationResult.data
        );
        const updatedCategory = await storage.getExpenseCategory(categoryId);
        res.json(updatedCategory);
      } catch (error) {
        console.error("Error updating expense category:", error);
        res.status(500).json({ error: "Failed to update expense category" });
      }
    }
  );
  app2.delete(
    "/api/salons/:salonId/expense-categories/:categoryId",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId, categoryId } = req.params;
        await storage.deleteExpenseCategory(categoryId, salonId);
        res.status(204).send();
      } catch (error) {
        console.error("Error deleting expense category:", error);
        res.status(500).json({ error: "Failed to delete expense category" });
      }
    }
  );
  app2.post(
    "/api/salons/:salonId/expense-categories/default",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const categories = await storage.createDefaultExpenseCategories(salonId);
        res.status(201).json(categories);
      } catch (error) {
        console.error("Error creating default expense categories:", error);
        res.status(500).json({ error: "Failed to create default expense categories" });
      }
    }
  );
  app2.get(
    "/api/salons/:salonId/expenses",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const { categoryId, status, startDate, endDate, createdBy } = req.query;
        const filters = {
          categoryId,
          status,
          startDate,
          endDate,
          createdBy
        };
        const expenses2 = await storage.getExpensesBySalonId(salonId, filters);
        res.json(expenses2);
      } catch (error) {
        console.error("Error fetching expenses:", error);
        res.status(500).json({ error: "Failed to fetch expenses" });
      }
    }
  );
  app2.post(
    "/api/salons/:salonId/expenses",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const validationResult = insertExpenseSchema.safeParse({
          ...req.body,
          salonId,
          createdBy: req.user.id
        });
        if (!validationResult.success) {
          return res.status(400).json({
            error: "Invalid input",
            details: validationResult.error.issues
          });
        }
        const expense = await storage.createExpense(validationResult.data);
        res.status(201).json(expense);
      } catch (error) {
        console.error("Error creating expense:", error);
        res.status(500).json({ error: "Failed to create expense" });
      }
    }
  );
  app2.put(
    "/api/salons/:salonId/expenses/:expenseId",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId, expenseId } = req.params;
        const partialSchema = insertExpenseSchema.omit({ salonId: true, createdBy: true }).partial();
        const validationResult = partialSchema.safeParse(req.body);
        if (!validationResult.success) {
          return res.status(400).json({
            error: "Invalid input",
            details: validationResult.error.issues
          });
        }
        await storage.updateExpense(expenseId, salonId, validationResult.data);
        const updatedExpense = await storage.getExpense(expenseId);
        res.json(updatedExpense);
      } catch (error) {
        console.error("Error updating expense:", error);
        res.status(500).json({ error: "Failed to update expense" });
      }
    }
  );
  app2.post(
    "/api/salons/:salonId/expenses/:expenseId/approve",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId, expenseId } = req.params;
        await storage.approveExpense(expenseId, req.user.id);
        const updatedExpense = await storage.getExpense(expenseId);
        res.json(updatedExpense);
      } catch (error) {
        console.error("Error approving expense:", error);
        res.status(500).json({ error: "Failed to approve expense" });
      }
    }
  );
  app2.post(
    "/api/salons/:salonId/expenses/:expenseId/reject",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId, expenseId } = req.params;
        await storage.rejectExpense(expenseId, req.user.id);
        const updatedExpense = await storage.getExpense(expenseId);
        res.json(updatedExpense);
      } catch (error) {
        console.error("Error rejecting expense:", error);
        res.status(500).json({ error: "Failed to reject expense" });
      }
    }
  );
  app2.get(
    "/api/salons/:salonId/expenses/analytics",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const { period = "monthly" } = req.query;
        const analytics = await storage.getExpenseAnalytics(
          salonId,
          period
        );
        res.json(analytics);
      } catch (error) {
        console.error("Error fetching expense analytics:", error);
        res.status(500).json({ error: "Failed to fetch expense analytics" });
      }
    }
  );
  app2.get(
    "/api/salons/:salonId/commission-rates",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const rates = await storage.getCommissionRatesBySalonId(salonId);
        res.json(rates);
      } catch (error) {
        console.error("Error fetching commission rates:", error);
        res.status(500).json({ error: "Failed to fetch commission rates" });
      }
    }
  );
  app2.post(
    "/api/salons/:salonId/commission-rates",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const validationResult = insertCommissionRateSchema.safeParse({
          ...req.body,
          salonId
        });
        if (!validationResult.success) {
          return res.status(400).json({
            error: "Invalid input",
            details: validationResult.error.issues
          });
        }
        const rate = await storage.createCommissionRate(validationResult.data);
        res.status(201).json(rate);
      } catch (error) {
        console.error("Error creating commission rate:", error);
        res.status(500).json({ error: "Failed to create commission rate" });
      }
    }
  );
  app2.put(
    "/api/salons/:salonId/commission-rates/:rateId",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId, rateId } = req.params;
        const partialSchema = insertCommissionRateSchema.omit({ salonId: true }).partial();
        const validationResult = partialSchema.safeParse(req.body);
        if (!validationResult.success) {
          return res.status(400).json({
            error: "Invalid input",
            details: validationResult.error.issues
          });
        }
        await storage.updateCommissionRate(
          rateId,
          salonId,
          validationResult.data
        );
        const updatedRate = await storage.getCommissionRate(rateId);
        res.json(updatedRate);
      } catch (error) {
        console.error("Error updating commission rate:", error);
        res.status(500).json({ error: "Failed to update commission rate" });
      }
    }
  );
  app2.post(
    "/api/salons/:salonId/commission-rates/:rateId/deactivate",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { rateId } = req.params;
        await storage.deactivateCommissionRate(rateId);
        const updatedRate = await storage.getCommissionRate(rateId);
        res.json(updatedRate);
      } catch (error) {
        console.error("Error deactivating commission rate:", error);
        res.status(500).json({ error: "Failed to deactivate commission rate" });
      }
    }
  );
  app2.get(
    "/api/salons/:salonId/commissions",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const { staffId, period, paymentStatus, startDate, endDate } = req.query;
        const filters = {
          staffId,
          period,
          paymentStatus,
          startDate,
          endDate
        };
        const commissions2 = await storage.getCommissionsBySalonId(
          salonId,
          filters
        );
        res.json(commissions2);
      } catch (error) {
        console.error("Error fetching commissions:", error);
        res.status(500).json({ error: "Failed to fetch commissions" });
      }
    }
  );
  app2.post(
    "/api/salons/:salonId/commissions",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const validationResult = insertCommissionSchema.safeParse({
          ...req.body,
          salonId
        });
        if (!validationResult.success) {
          return res.status(400).json({
            error: "Invalid input",
            details: validationResult.error.issues
          });
        }
        const commission = await storage.createCommission(
          validationResult.data
        );
        res.status(201).json(commission);
      } catch (error) {
        console.error("Error creating commission:", error);
        res.status(500).json({ error: "Failed to create commission" });
      }
    }
  );
  app2.post(
    "/api/salons/:salonId/commissions/pay-bulk",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { commissionIds, paymentMethod, paymentReference } = req.body;
        if (!Array.isArray(commissionIds) || commissionIds.length === 0) {
          return res.status(400).json({ error: "Commission IDs are required" });
        }
        const paidCount = await storage.payCommissions(
          commissionIds,
          req.user.id,
          paymentMethod,
          paymentReference
        );
        res.json({
          paidCount,
          message: `${paidCount} commissions paid successfully`
        });
      } catch (error) {
        console.error("Error paying commissions:", error);
        res.status(500).json({ error: "Failed to pay commissions" });
      }
    }
  );
  app2.get(
    "/api/salons/:salonId/commissions/analytics",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const { period = "monthly" } = req.query;
        const analytics = await storage.getCommissionAnalytics(
          salonId,
          period
        );
        res.json(analytics);
      } catch (error) {
        console.error("Error fetching commission analytics:", error);
        res.status(500).json({ error: "Failed to fetch commission analytics" });
      }
    }
  );
  app2.get(
    "/api/salons/:salonId/commissions/summary",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const { startDate, endDate } = req.query;
        const start = startDate ? new Date(startDate) : new Date((/* @__PURE__ */ new Date()).getFullYear(), (/* @__PURE__ */ new Date()).getMonth(), 1);
        let end = endDate ? new Date(endDate) : /* @__PURE__ */ new Date();
        end = new Date(end.getFullYear(), end.getMonth(), end.getDate(), 23, 59, 59, 999);
        const allCommissions = await db.select().from(commissions).where(
          and56(
            eq58(commissions.salonId, salonId),
            gte30(commissions.serviceDate, start),
            lte24(commissions.serviceDate, end)
          )
        );
        const totalCommission = allCommissions.reduce((sum4, c) => sum4 + c.commissionAmountPaisa, 0);
        const totalServices = allCommissions.length;
        const pendingCommissions = allCommissions.filter((c) => c.paymentStatus === "pending");
        const pendingAmount = pendingCommissions.reduce((sum4, c) => sum4 + c.commissionAmountPaisa, 0);
        const pendingCount = pendingCommissions.length;
        const paidCommissions = allCommissions.filter((c) => c.paymentStatus === "paid");
        const paidAmount = paidCommissions.reduce((sum4, c) => sum4 + c.commissionAmountPaisa, 0);
        const paidCount = paidCommissions.length;
        const uniqueStaffIds = new Set(allCommissions.map((c) => c.staffId));
        const staffCount = uniqueStaffIds.size;
        const averagePerStaff = staffCount > 0 ? Math.round(totalCommission / staffCount) : 0;
        res.json({
          totalCommission,
          totalServices,
          pendingAmount,
          pendingCount,
          paidAmount,
          paidCount,
          averagePerStaff,
          staffCount
        });
      } catch (error) {
        console.error("Error fetching commission summary:", error);
        res.status(500).json({ error: "Failed to fetch commission summary" });
      }
    }
  );
  app2.get(
    "/api/salons/:salonId/commissions/by-staff",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const { startDate, endDate } = req.query;
        const start = startDate ? new Date(startDate) : new Date((/* @__PURE__ */ new Date()).getFullYear(), (/* @__PURE__ */ new Date()).getMonth(), 1);
        let end = endDate ? new Date(endDate) : /* @__PURE__ */ new Date();
        end = new Date(end.getFullYear(), end.getMonth(), end.getDate(), 23, 59, 59, 999);
        const commissionsWithStaff = await db.select({
          staffId: commissions.staffId,
          staffName: staff.name,
          staffPhoto: staff.profileImage,
          baseAmountPaisa: commissions.baseAmountPaisa,
          commissionAmountPaisa: commissions.commissionAmountPaisa,
          paymentStatus: commissions.paymentStatus
        }).from(commissions).leftJoin(staff, eq58(commissions.staffId, staff.id)).where(
          and56(
            eq58(commissions.salonId, salonId),
            gte30(commissions.serviceDate, start),
            lte24(commissions.serviceDate, end)
          )
        );
        const staffMap = /* @__PURE__ */ new Map();
        for (const commission of commissionsWithStaff) {
          const existing = staffMap.get(commission.staffId);
          const isPending = commission.paymentStatus === "pending";
          const isPaid = commission.paymentStatus === "paid";
          if (existing) {
            existing.servicesCompleted += 1;
            existing.totalServiceValue += commission.baseAmountPaisa;
            existing.totalCommission += commission.commissionAmountPaisa;
            if (isPending) {
              existing.pendingAmount += commission.commissionAmountPaisa;
            }
            if (isPaid) {
              existing.paidAmount += commission.commissionAmountPaisa;
            }
          } else {
            staffMap.set(commission.staffId, {
              staffId: commission.staffId,
              staffName: commission.staffName || "Unknown Staff",
              staffPhoto: commission.staffPhoto || null,
              servicesCompleted: 1,
              totalServiceValue: commission.baseAmountPaisa,
              totalCommission: commission.commissionAmountPaisa,
              pendingAmount: isPending ? commission.commissionAmountPaisa : 0,
              paidAmount: isPaid ? commission.commissionAmountPaisa : 0
            });
          }
        }
        const staffCommissions = Array.from(staffMap.values()).sort((a, b) => b.totalCommission - a.totalCommission);
        res.json(staffCommissions);
      } catch (error) {
        console.error("Error fetching commissions by staff:", error);
        res.status(500).json({ error: "Failed to fetch commissions by staff" });
      }
    }
  );
  app2.post(
    "/api/salons/:salonId/commissions/payout",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const { staffId, paymentMethod, notes, startDate, endDate } = req.body;
        if (!staffId) {
          return res.status(400).json({ error: "Staff ID is required" });
        }
        const staffMember = await db.select().from(staff).where(and56(
          eq58(staff.id, staffId),
          eq58(staff.salonId, salonId)
        )).limit(1);
        if (staffMember.length === 0) {
          return res.status(400).json({ error: "Staff member not found in this salon" });
        }
        const start = startDate ? new Date(startDate) : new Date((/* @__PURE__ */ new Date()).getFullYear(), (/* @__PURE__ */ new Date()).getMonth(), 1);
        let end = endDate ? new Date(endDate) : /* @__PURE__ */ new Date();
        end = new Date(end.getFullYear(), end.getMonth(), end.getDate(), 23, 59, 59, 999);
        if (start > end) {
          return res.status(400).json({ error: "Start date cannot be after end date" });
        }
        const pendingCommissions = await db.select().from(commissions).where(
          and56(
            eq58(commissions.salonId, salonId),
            eq58(commissions.staffId, staffId),
            eq58(commissions.paymentStatus, "pending"),
            gte30(commissions.serviceDate, start),
            lte24(commissions.serviceDate, end)
          )
        );
        if (pendingCommissions.length === 0) {
          return res.status(400).json({ error: "No pending commissions found for this staff in the selected period" });
        }
        const commissionIds = pendingCommissions.map((c) => c.id);
        const paidAt = /* @__PURE__ */ new Date();
        const totalPaid = pendingCommissions.reduce((sum4, c) => sum4 + c.commissionAmountPaisa, 0);
        await db.transaction(async (tx) => {
          await tx.update(commissions).set({
            paymentStatus: "paid",
            paidAt,
            paidBy: req.user.id,
            paymentMethod: paymentMethod || "cash",
            notes: notes || null,
            updatedAt: /* @__PURE__ */ new Date()
          }).where(inArray22(commissions.id, commissionIds));
        });
        res.json({
          success: true,
          updatedCount: commissionIds.length,
          totalPaidAmount: totalPaid,
          message: `Marked ${commissionIds.length} commissions as paid totaling \u20B9${(totalPaid / 100).toFixed(2)}`
        });
      } catch (error) {
        console.error("Error processing commission payout:", error);
        res.status(500).json({ error: "Failed to process commission payout" });
      }
    }
  );
  app2.get(
    "/api/salons/:salonId/budgets",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const { categoryId, budgetType, isActive } = req.query;
        const filters = {
          categoryId,
          budgetType,
          isActive: isActive === "true" ? true : isActive === "false" ? false : void 0
        };
        const budgets2 = await storage.getBudgetsBySalonId(salonId, filters);
        res.json(budgets2);
      } catch (error) {
        console.error("Error fetching budgets:", error);
        res.status(500).json({ error: "Failed to fetch budgets" });
      }
    }
  );
  app2.post(
    "/api/salons/:salonId/budgets",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const validationResult = insertBudgetSchema.safeParse({
          ...req.body,
          salonId,
          createdBy: req.user.id
        });
        if (!validationResult.success) {
          return res.status(400).json({
            error: "Invalid input",
            details: validationResult.error.issues
          });
        }
        const budget = await storage.createBudget(validationResult.data);
        res.status(201).json(budget);
      } catch (error) {
        console.error("Error creating budget:", error);
        res.status(500).json({ error: "Failed to create budget" });
      }
    }
  );
  app2.put(
    "/api/salons/:salonId/budgets/:budgetId",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId, budgetId } = req.params;
        const partialSchema = insertBudgetSchema.omit({ salonId: true, createdBy: true }).partial();
        const validationResult = partialSchema.safeParse(req.body);
        if (!validationResult.success) {
          return res.status(400).json({
            error: "Invalid input",
            details: validationResult.error.issues
          });
        }
        await storage.updateBudget(budgetId, salonId, validationResult.data);
        const updatedBudget = await storage.getBudget(budgetId);
        res.json(updatedBudget);
      } catch (error) {
        console.error("Error updating budget:", error);
        res.status(500).json({ error: "Failed to update budget" });
      }
    }
  );
  app2.get(
    "/api/salons/:salonId/budgets/analytics",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const { period = "monthly" } = req.query;
        const analytics = await storage.getBudgetAnalytics(
          salonId,
          period
        );
        res.json(analytics);
      } catch (error) {
        console.error("Error fetching budget analytics:", error);
        res.status(500).json({ error: "Failed to fetch budget analytics" });
      }
    }
  );
  app2.get(
    "/api/salons/:salonId/financial-analytics/kpis/:period",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId, period } = req.params;
        const kpis = await storage.getFinancialKPIs(salonId, period);
        res.json(kpis);
      } catch (error) {
        console.error("Error fetching financial KPIs:", error);
        res.status(500).json({ error: "Failed to fetch financial KPIs" });
      }
    }
  );
  app2.get(
    "/api/salons/:salonId/financial-analytics/forecast/:months",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId, months } = req.params;
        const monthsNum = parseInt(months);
        if (isNaN(monthsNum) || monthsNum < 1 || monthsNum > 24) {
          return res.status(400).json({ error: "Months must be a number between 1 and 24" });
        }
        const forecast = await storage.getFinancialForecast(salonId, monthsNum);
        res.json(forecast);
      } catch (error) {
        console.error("Error fetching financial forecast:", error);
        res.status(500).json({ error: "Failed to fetch financial forecast" });
      }
    }
  );
  app2.get(
    "/api/salons/:salonId/financial-reports",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const { reportType, reportPeriod } = req.query;
        const filters = {
          reportType,
          reportPeriod
        };
        const reports = await storage.getFinancialReportsBySalonId(
          salonId,
          filters
        );
        res.json(reports);
      } catch (error) {
        console.error("Error fetching financial reports:", error);
        res.status(500).json({ error: "Failed to fetch financial reports" });
      }
    }
  );
  app2.post(
    "/api/salons/:salonId/financial-reports",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const validationResult = insertFinancialReportSchema.safeParse({
          ...req.body,
          salonId,
          generatedBy: req.user.id
        });
        if (!validationResult.success) {
          return res.status(400).json({
            error: "Invalid input",
            details: validationResult.error.issues
          });
        }
        const report = await storage.createFinancialReport(
          validationResult.data
        );
        res.status(201).json(report);
      } catch (error) {
        console.error("Error creating financial report:", error);
        res.status(500).json({ error: "Failed to create financial report" });
      }
    }
  );
  app2.get(
    "/api/salons/:salonId/financial-reports/profit-loss",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const { startDate, endDate } = req.query;
        if (!startDate || !endDate) {
          return res.status(400).json({ error: "Start date and end date are required" });
        }
        const plStatement = await storage.generateProfitLossStatement(
          salonId,
          startDate,
          endDate
        );
        res.json(plStatement);
      } catch (error) {
        console.error("Error generating P&L statement:", error);
        res.status(500).json({ error: "Failed to generate P&L statement" });
      }
    }
  );
  app2.get(
    "/api/salons/:salonId/financial-reports/profit-loss/:startDate/:endDate",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId, startDate, endDate } = req.params;
        if (!startDate || !endDate) {
          return res.status(400).json({ error: "Start date and end date are required" });
        }
        const plStatement = await storage.generateProfitLossStatement(
          salonId,
          startDate,
          endDate
        );
        res.json(plStatement);
      } catch (error) {
        console.error("Error generating P&L statement:", error);
        res.status(500).json({ error: "Failed to generate P&L statement" });
      }
    }
  );
  app2.get(
    "/api/salons/:salonId/financial-reports/cash-flow",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const { startDate, endDate } = req.query;
        if (!startDate || !endDate) {
          return res.status(400).json({ error: "Start date and end date are required" });
        }
        const cashFlowStatement = await storage.generateCashFlowStatement(
          salonId,
          startDate,
          endDate
        );
        res.json(cashFlowStatement);
      } catch (error) {
        console.error("Error generating cash flow statement:", error);
        res.status(500).json({ error: "Failed to generate cash flow statement" });
      }
    }
  );
  app2.get(
    "/api/salons/:salonId/tax-settings",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const settings = await storage.getTaxSettingsBySalonId(salonId);
        res.json(settings);
      } catch (error) {
        console.error("Error fetching tax settings:", error);
        res.status(500).json({ error: "Failed to fetch tax settings" });
      }
    }
  );
  app2.post(
    "/api/salons/:salonId/tax-settings",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const validationResult = insertTaxSettingSchema.safeParse({
          ...req.body,
          salonId
        });
        if (!validationResult.success) {
          return res.status(400).json({
            error: "Invalid input",
            details: validationResult.error.issues
          });
        }
        const setting = await storage.createTaxSetting(validationResult.data);
        res.status(201).json(setting);
      } catch (error) {
        console.error("Error creating tax setting:", error);
        res.status(500).json({ error: "Failed to create tax setting" });
      }
    }
  );
  app2.get(
    "/api/salons/:salonId/tax-settings/liability",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const { period = "monthly" } = req.query;
        const liability = await storage.calculateTaxLiability(
          salonId,
          period
        );
        res.json(liability);
      } catch (error) {
        console.error("Error calculating tax liability:", error);
        res.status(500).json({ error: "Failed to calculate tax liability" });
      }
    }
  );
  app2.get(
    "/api/salons/:salonId/financial-analytics/kpis",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const { period = "monthly" } = req.query;
        const kpis = await storage.getFinancialKPIs(salonId, period);
        res.json(kpis);
      } catch (error) {
        console.error("Error fetching financial KPIs:", error);
        res.status(500).json({ error: "Failed to fetch financial KPIs" });
      }
    }
  );
  app2.get(
    "/api/salons/:salonId/financial-analytics/forecast",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const { months = 12 } = req.query;
        const forecast = await storage.getFinancialForecast(
          salonId,
          parseInt(months)
        );
        res.json(forecast);
      } catch (error) {
        console.error("Error fetching financial forecast:", error);
        res.status(500).json({ error: "Failed to fetch financial forecast" });
      }
    }
  );
  app2.get(
    "/api/salons/:salonId/message-templates",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const { type } = req.query;
        const templates = await storage.getMessageTemplatesBySalonId(
          salonId,
          type
        );
        res.json(templates);
      } catch (error) {
        console.error("Error fetching message templates:", error);
        res.status(500).json({ error: "Failed to fetch message templates" });
      }
    }
  );
  app2.post(
    "/api/salons/:salonId/message-templates",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const validationResult = insertMessageTemplateSchema.safeParse({
          ...req.body,
          salonId,
          createdBy: req.user.id
        });
        if (!validationResult.success) {
          return res.status(400).json({
            error: "Validation failed",
            details: validationResult.error.issues
          });
        }
        const template = await storage.createMessageTemplate(
          validationResult.data
        );
        res.status(201).json(template);
      } catch (error) {
        console.error("Error creating message template:", error);
        res.status(500).json({ error: "Failed to create message template" });
      }
    }
  );
  app2.put(
    "/api/salons/:salonId/message-templates/:templateId",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId, templateId } = req.params;
        const updates = req.body;
        await storage.updateMessageTemplate(templateId, salonId, updates);
        res.json({ success: true });
      } catch (error) {
        console.error("Error updating message template:", error);
        res.status(500).json({ error: "Failed to update message template" });
      }
    }
  );
  app2.delete(
    "/api/salons/:salonId/message-templates/:templateId",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId, templateId } = req.params;
        await storage.deleteMessageTemplate(templateId, salonId);
        res.json({ success: true });
      } catch (error) {
        console.error("Error deleting message template:", error);
        res.status(500).json({ error: "Failed to delete message template" });
      }
    }
  );
  app2.get(
    "/api/salons/:salonId/ab-test-campaigns",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const { status, testType } = req.query;
        const filters = {};
        if (status) filters.status = status;
        if (testType) filters.testType = testType;
        const campaigns = await storage.getAbTestCampaignsBySalonId(
          salonId,
          filters
        );
        res.json(campaigns);
      } catch (error) {
        console.error("Error fetching A/B test campaigns:", error);
        res.status(500).json({ error: "Failed to fetch A/B test campaigns" });
      }
    }
  );
  app2.get(
    "/api/salons/:salonId/ab-test-campaigns/:testId",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { testId } = req.params;
        const campaign = await storage.getAbTestCampaign(testId);
        if (!campaign) {
          return res.status(404).json({ error: "A/B test campaign not found" });
        }
        res.json(campaign);
      } catch (error) {
        console.error("Error fetching A/B test campaign:", error);
        res.status(500).json({ error: "Failed to fetch A/B test campaign" });
      }
    }
  );
  app2.post(
    "/api/salons/:salonId/ab-test-campaigns",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const validationResult = insertAbTestCampaignSchema.safeParse({
          ...req.body,
          salonId,
          createdBy: req.user.id
        });
        if (!validationResult.success) {
          return res.status(400).json({
            error: "Invalid input",
            details: validationResult.error.issues
          });
        }
        if (validationResult.data.baseTemplateId) {
          const template = await storage.getMessageTemplate(
            validationResult.data.baseTemplateId
          );
          if (!template || template.salonId !== salonId) {
            return res.status(400).json({ error: "Invalid base template ID" });
          }
        }
        if (validationResult.data.targetSegmentId) {
          const segment = await storage.getCustomerSegmentation(
            validationResult.data.targetSegmentId
          );
          if (!segment || segment.salonId !== salonId) {
            return res.status(400).json({ error: "Invalid target segment ID" });
          }
        }
        const newCampaign = await storage.createAbTestCampaign(
          validationResult.data
        );
        res.status(201).json(newCampaign);
      } catch (error) {
        console.error("Error creating A/B test campaign:", error);
        res.status(500).json({ error: "Failed to create A/B test campaign" });
      }
    }
  );
  app2.put(
    "/api/salons/:salonId/ab-test-campaigns/:testId",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId, testId } = req.params;
        const existingCampaign = await storage.getAbTestCampaign(testId);
        if (!existingCampaign) {
          return res.status(404).json({ error: "A/B test campaign not found" });
        }
        if (existingCampaign.salonId !== salonId) {
          return res.status(403).json({ error: "Access denied to this A/B test campaign" });
        }
        const partialSchema = insertAbTestCampaignSchema.partial();
        const validationResult = partialSchema.safeParse(req.body);
        if (!validationResult.success) {
          return res.status(400).json({
            error: "Invalid input",
            details: validationResult.error.issues
          });
        }
        await storage.updateAbTestCampaign(testId, validationResult.data);
        const updatedCampaign = await storage.getAbTestCampaign(testId);
        res.json(updatedCampaign);
      } catch (error) {
        console.error("Error updating A/B test campaign:", error);
        res.status(500).json({ error: "Failed to update A/B test campaign" });
      }
    }
  );
  app2.delete(
    "/api/salons/:salonId/ab-test-campaigns/:testId",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId, testId } = req.params;
        const existingCampaign = await storage.getAbTestCampaign(testId);
        if (!existingCampaign) {
          return res.status(404).json({ error: "A/B test campaign not found" });
        }
        if (existingCampaign.salonId !== salonId) {
          return res.status(403).json({ error: "Access denied to this A/B test campaign" });
        }
        await storage.deleteAbTestCampaign(testId);
        res.json({ success: true });
      } catch (error) {
        console.error("Error deleting A/B test campaign:", error);
        res.status(500).json({ error: "Failed to delete A/B test campaign" });
      }
    }
  );
  app2.get(
    "/api/salons/:salonId/ab-test-campaigns/:testId/variants",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId, testId } = req.params;
        const campaign = await storage.getAbTestCampaign(testId);
        if (!campaign) {
          return res.status(404).json({ error: "A/B test campaign not found" });
        }
        if (campaign.salonId !== salonId) {
          return res.status(403).json({ error: "Access denied to this A/B test campaign" });
        }
        const variants = await storage.getTestVariantsByTestId(testId);
        res.json(variants);
      } catch (error) {
        console.error("Error fetching test variants:", error);
        res.status(500).json({ error: "Failed to fetch test variants" });
      }
    }
  );
  app2.get(
    "/api/salons/:salonId/ab-test-campaigns/:testId/variants/:variantId",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId, testId, variantId } = req.params;
        const campaign = await storage.getAbTestCampaign(testId);
        if (!campaign) {
          return res.status(404).json({ error: "A/B test campaign not found" });
        }
        if (campaign.salonId !== salonId) {
          return res.status(403).json({ error: "Access denied to this A/B test campaign" });
        }
        const variant = await storage.getTestVariant(variantId);
        if (!variant) {
          return res.status(404).json({ error: "Test variant not found" });
        }
        if (variant.testCampaignId !== testId) {
          return res.status(404).json({ error: "Test variant not found in this campaign" });
        }
        res.json(variant);
      } catch (error) {
        console.error("Error fetching test variant:", error);
        res.status(500).json({ error: "Failed to fetch test variant" });
      }
    }
  );
  app2.post(
    "/api/salons/:salonId/ab-test-campaigns/:testId/variants",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId, testId } = req.params;
        const campaign = await storage.getAbTestCampaign(testId);
        if (!campaign) {
          return res.status(404).json({ error: "A/B test campaign not found" });
        }
        if (campaign.salonId !== salonId) {
          return res.status(403).json({ error: "Access denied to this A/B test campaign" });
        }
        const validationResult = insertTestVariantSchema.safeParse({
          ...req.body,
          testCampaignId: testId
        });
        if (!validationResult.success) {
          return res.status(400).json({
            error: "Invalid input",
            details: validationResult.error.issues
          });
        }
        if (validationResult.data.templateOverrides) {
          try {
            if (typeof validationResult.data.templateOverrides === "string") {
              JSON.parse(validationResult.data.templateOverrides);
            }
          } catch (e) {
            return res.status(400).json({ error: "Invalid template overrides JSON" });
          }
        }
        const newVariant = await storage.createTestVariant(
          validationResult.data
        );
        res.status(201).json(newVariant);
      } catch (error) {
        console.error("Error creating test variant:", error);
        res.status(500).json({ error: "Failed to create test variant" });
      }
    }
  );
  app2.put(
    "/api/salons/:salonId/ab-test-campaigns/:testId/variants/:variantId",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId, testId, variantId } = req.params;
        const campaign = await storage.getAbTestCampaign(testId);
        if (!campaign) {
          return res.status(404).json({ error: "A/B test campaign not found" });
        }
        if (campaign.salonId !== salonId) {
          return res.status(403).json({ error: "Access denied to this A/B test campaign" });
        }
        const existingVariant = await storage.getTestVariant(variantId);
        if (!existingVariant || existingVariant.testCampaignId !== testId) {
          return res.status(404).json({ error: "Test variant not found" });
        }
        const partialSchema = insertTestVariantSchema.partial();
        const validationResult = partialSchema.safeParse(req.body);
        if (!validationResult.success) {
          return res.status(400).json({
            error: "Invalid input",
            details: validationResult.error.issues
          });
        }
        await storage.updateTestVariant(variantId, validationResult.data);
        const updatedVariant = await storage.getTestVariant(variantId);
        res.json(updatedVariant);
      } catch (error) {
        console.error("Error updating test variant:", error);
        res.status(500).json({ error: "Failed to update test variant" });
      }
    }
  );
  app2.delete(
    "/api/salons/:salonId/ab-test-campaigns/:testId/variants/:variantId",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId, testId, variantId } = req.params;
        const campaign = await storage.getAbTestCampaign(testId);
        if (!campaign) {
          return res.status(404).json({ error: "A/B test campaign not found" });
        }
        if (campaign.salonId !== salonId) {
          return res.status(403).json({ error: "Access denied to this A/B test campaign" });
        }
        const existingVariant = await storage.getTestVariant(variantId);
        if (!existingVariant || existingVariant.testCampaignId !== testId) {
          return res.status(404).json({ error: "Test variant not found" });
        }
        await storage.deleteTestVariant(variantId);
        res.json({ success: true });
      } catch (error) {
        console.error("Error deleting test variant:", error);
        res.status(500).json({ error: "Failed to delete test variant" });
      }
    }
  );
  app2.get(
    "/api/salons/:salonId/ab-test-campaigns/:testId/metrics",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId, testId } = req.params;
        const { startDate, endDate } = req.query;
        const campaign = await storage.getAbTestCampaign(testId);
        if (!campaign) {
          return res.status(404).json({ error: "A/B test campaign not found" });
        }
        if (campaign.salonId !== salonId) {
          return res.status(403).json({ error: "Access denied to this A/B test campaign" });
        }
        const dateRange = startDate && endDate ? { start: startDate, end: endDate } : void 0;
        const metrics = await storage.getTestMetricsByTestId(testId, dateRange);
        res.json(metrics);
      } catch (error) {
        console.error("Error fetching test metrics:", error);
        res.status(500).json({ error: "Failed to fetch test metrics" });
      }
    }
  );
  app2.post(
    "/api/salons/:salonId/ab-test-campaigns/:testId/metrics",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId, testId } = req.params;
        const campaign = await storage.getAbTestCampaign(testId);
        if (!campaign) {
          return res.status(404).json({ error: "A/B test campaign not found" });
        }
        if (campaign.salonId !== salonId) {
          return res.status(403).json({ error: "Access denied to this A/B test campaign" });
        }
        const validationResult = insertTestMetricSchema.safeParse({
          ...req.body,
          testCampaignId: testId
        });
        if (!validationResult.success) {
          return res.status(400).json({
            error: "Invalid input",
            details: validationResult.error.issues
          });
        }
        if (validationResult.data.variantId) {
          const variant = await storage.getTestVariant(
            validationResult.data.variantId
          );
          if (!variant || variant.testCampaignId !== testId) {
            return res.status(400).json({ error: "Invalid variant ID for this test campaign" });
          }
        }
        const newMetric = await storage.createTestMetric(validationResult.data);
        res.status(201).json(newMetric);
      } catch (error) {
        console.error("Error creating test metric:", error);
        res.status(500).json({ error: "Failed to create test metric" });
      }
    }
  );
  app2.get(
    "/api/salons/:salonId/ab-test-campaigns/:testId/performance-summary",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId, testId } = req.params;
        const campaign = await storage.getAbTestCampaign(testId);
        if (!campaign) {
          return res.status(404).json({ error: "A/B test campaign not found" });
        }
        if (campaign.salonId !== salonId) {
          return res.status(403).json({ error: "Access denied to this A/B test campaign" });
        }
        const summary = await storage.getAbTestPerformanceSummary(testId);
        res.json(summary);
      } catch (error) {
        console.error("Error fetching performance summary:", error);
        res.status(500).json({ error: "Failed to fetch performance summary" });
      }
    }
  );
  app2.get(
    "/api/salons/:salonId/ab-test-analytics",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const { period = "monthly" } = req.query;
        const analytics = await storage.getAbTestCampaignAnalytics(
          salonId,
          period
        );
        res.json(analytics);
      } catch (error) {
        console.error("Error fetching A/B test analytics:", error);
        res.status(500).json({ error: "Failed to fetch A/B test analytics" });
      }
    }
  );
  app2.get(
    "/api/salons/:salonId/ab-test-campaigns/:testId/results",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId, testId } = req.params;
        const campaign = await storage.getAbTestCampaign(testId);
        if (!campaign) {
          return res.status(404).json({ error: "A/B test campaign not found" });
        }
        if (campaign.salonId !== salonId) {
          return res.status(403).json({ error: "Access denied to this A/B test campaign" });
        }
        const result = await storage.getTestResultByTestId(testId);
        if (!result) {
          return res.status(404).json({ error: "Test results not found" });
        }
        res.json(result);
      } catch (error) {
        console.error("Error fetching test results:", error);
        res.status(500).json({ error: "Failed to fetch test results" });
      }
    }
  );
  app2.post(
    "/api/salons/:salonId/ab-test-campaigns/:testId/results",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId, testId } = req.params;
        const campaign = await storage.getAbTestCampaign(testId);
        if (!campaign) {
          return res.status(404).json({ error: "A/B test campaign not found" });
        }
        if (campaign.salonId !== salonId) {
          return res.status(403).json({ error: "Access denied to this A/B test campaign" });
        }
        const validationResult = insertTestResultSchema.safeParse({
          ...req.body,
          testCampaignId: testId,
          completedAt: req.body.completedAt || /* @__PURE__ */ new Date()
        });
        if (!validationResult.success) {
          return res.status(400).json({
            error: "Invalid input",
            details: validationResult.error.issues
          });
        }
        if (validationResult.data.winnerVariantId) {
          const variant = await storage.getTestVariant(
            validationResult.data.winnerVariantId
          );
          if (!variant || variant.testCampaignId !== testId) {
            return res.status(400).json({
              error: "Invalid winner variant ID for this test campaign"
            });
          }
        }
        const existingResult = await storage.getTestResultByTestId(testId);
        let result;
        if (existingResult) {
          await storage.updateTestResult(
            existingResult.id,
            validationResult.data
          );
          result = await storage.getTestResultByTestId(testId);
        } else {
          result = await storage.createTestResult(validationResult.data);
        }
        await storage.updateAbTestCampaign(testId, {
          status: "completed"
        });
        res.status(201).json(result);
      } catch (error) {
        console.error("Error creating/updating test results:", error);
        res.status(500).json({ error: "Failed to create/update test results" });
      }
    }
  );
  app2.post(
    "/api/salons/:salonId/ab-test-campaigns/:testId/select-winner",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId, testId } = req.params;
        const { winnerVariantId, notes } = req.body;
        const campaign = await storage.getAbTestCampaign(testId);
        if (!campaign) {
          return res.status(404).json({ error: "A/B test campaign not found" });
        }
        if (campaign.salonId !== salonId) {
          return res.status(403).json({ error: "Access denied to this A/B test campaign" });
        }
        if (!winnerVariantId) {
          return res.status(400).json({ error: "Winner variant ID is required" });
        }
        const variant = await storage.getTestVariant(winnerVariantId);
        if (!variant || variant.testCampaignId !== testId) {
          return res.status(400).json({
            error: "Invalid winner variant ID for this test campaign"
          });
        }
        const existingResult = await storage.getTestResultByTestId(testId);
        const resultData = {
          testCampaignId: testId,
          winnerVariantId,
          completedAt: /* @__PURE__ */ new Date(),
          actionTaken: "manual_selection",
          notes: notes || "Winner manually selected",
          implementedAt: /* @__PURE__ */ new Date()
        };
        let result;
        if (existingResult) {
          await storage.updateTestResult(existingResult.id, resultData);
          result = await storage.getTestResultByTestId(testId);
        } else {
          result = await storage.createTestResult(resultData);
        }
        await storage.updateAbTestCampaign(testId, {
          status: "completed"
        });
        await storage.updateTestVariant(winnerVariantId, { status: "winner" });
        const allVariants = await storage.getTestVariantsByTestId(testId);
        for (const v of allVariants) {
          if (v.id !== winnerVariantId) {
            await storage.updateTestVariant(v.id, { status: "loser" });
          }
        }
        res.json({
          success: true,
          result,
          message: `Variant "${variant.variantName}" selected as winner`
        });
      } catch (error) {
        console.error("Error selecting winner:", error);
        res.status(500).json({ error: "Failed to select winner" });
      }
    }
  );
  app2.post(
    "/api/salons/:salonId/ab-test-campaigns/:testId/start",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId, testId } = req.params;
        const campaign = await storage.getAbTestCampaign(testId);
        if (!campaign) {
          return res.status(404).json({ error: "A/B test campaign not found" });
        }
        if (campaign.salonId !== salonId) {
          return res.status(403).json({ error: "Access denied to this A/B test campaign" });
        }
        if (campaign.status !== "draft" && campaign.status !== "paused") {
          return res.status(400).json({
            error: `Cannot start campaign with status: ${campaign.status}`
          });
        }
        const variants = await storage.getTestVariantsByTestId(testId);
        if (variants.length === 0) {
          return res.status(400).json({
            error: "Campaign must have at least one test variant before starting"
          });
        }
        await storage.updateAbTestCampaign(testId, {
          status: "active"
        });
        const updatedCampaign = await storage.getAbTestCampaign(testId);
        res.json({
          success: true,
          campaign: updatedCampaign,
          message: "A/B test campaign started successfully"
        });
      } catch (error) {
        console.error("Error starting A/B test campaign:", error);
        res.status(500).json({ error: "Failed to start A/B test campaign" });
      }
    }
  );
  app2.post(
    "/api/salons/:salonId/ab-test-campaigns/:testId/pause",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId, testId } = req.params;
        const campaign = await storage.getAbTestCampaign(testId);
        if (!campaign) {
          return res.status(404).json({ error: "A/B test campaign not found" });
        }
        if (campaign.salonId !== salonId) {
          return res.status(403).json({ error: "Access denied to this A/B test campaign" });
        }
        if (campaign.status !== "active") {
          return res.status(400).json({
            error: `Cannot pause campaign with status: ${campaign.status}`
          });
        }
        await storage.updateAbTestCampaign(testId, {
          status: "paused"
        });
        const updatedCampaign = await storage.getAbTestCampaign(testId);
        res.json({
          success: true,
          campaign: updatedCampaign,
          message: "A/B test campaign paused successfully"
        });
      } catch (error) {
        console.error("Error pausing A/B test campaign:", error);
        res.status(500).json({ error: "Failed to pause A/B test campaign" });
      }
    }
  );
  app2.post(
    "/api/salons/:salonId/ab-test-campaigns/:testId/complete",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId, testId } = req.params;
        const { winnerVariantId, notes } = req.body;
        const campaign = await storage.getAbTestCampaign(testId);
        if (!campaign) {
          return res.status(404).json({ error: "A/B test campaign not found" });
        }
        if (campaign.salonId !== salonId) {
          return res.status(403).json({ error: "Access denied to this A/B test campaign" });
        }
        if (campaign.status === "completed") {
          return res.status(400).json({ error: "Campaign is already completed" });
        }
        await storage.updateAbTestCampaign(testId, {
          status: "completed"
        });
        if (winnerVariantId) {
          const variant = await storage.getTestVariant(winnerVariantId);
          if (!variant || variant.testCampaignId !== testId) {
            return res.status(400).json({
              error: "Invalid winner variant ID for this test campaign"
            });
          }
          const existingResult = await storage.getTestResultByTestId(testId);
          const resultData = {
            testCampaignId: testId,
            winnerVariantId,
            completedAt: /* @__PURE__ */ new Date(),
            actionTaken: "manual_selection",
            notes: notes || "Campaign completed with manual winner selection"
          };
          if (existingResult) {
            await storage.updateTestResult(existingResult.id, resultData);
          } else {
            await storage.createTestResult(resultData);
          }
          await storage.updateTestVariant(winnerVariantId, {
            status: "winner"
          });
          const allVariants = await storage.getTestVariantsByTestId(testId);
          for (const v of allVariants) {
            if (v.id !== winnerVariantId) {
              await storage.updateTestVariant(v.id, { status: "loser" });
            }
          }
        }
        const updatedCampaign = await storage.getAbTestCampaign(testId);
        res.json({
          success: true,
          campaign: updatedCampaign,
          message: "A/B test campaign completed successfully"
        });
      } catch (error) {
        console.error("Error completing A/B test campaign:", error);
        res.status(500).json({ error: "Failed to complete A/B test campaign" });
      }
    }
  );
  app2.get(
    "/api/salons/:salonId/ab-test-campaigns/:testId/auto-optimize",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId, testId } = req.params;
        const campaign = await storage.getAbTestCampaign(testId);
        if (!campaign) {
          return res.status(404).json({ error: "A/B test campaign not found" });
        }
        if (campaign.salonId !== salonId) {
          return res.status(403).json({ error: "Access denied to this A/B test campaign" });
        }
        const performanceSummary = await storage.getAbTestPerformanceSummary(testId);
        const autoOptimizationEnabled = campaign.autoOptimization === 1;
        let optimizationRecommendation = null;
        let shouldOptimize = false;
        if (campaign.status === "active" && performanceSummary.variants.length > 1) {
          const sortedVariants = performanceSummary.variants.sort((a, b) => {
            const metricA = campaign.successMetric === "open_rate" ? a.openRate : campaign.successMetric === "click_rate" ? a.clickRate : campaign.successMetric === "conversion_rate" ? a.conversionRate : a.bookingRate;
            const metricB = campaign.successMetric === "open_rate" ? b.openRate : campaign.successMetric === "click_rate" ? b.clickRate : campaign.successMetric === "conversion_rate" ? b.conversionRate : b.bookingRate;
            return metricB - metricA;
          });
          const bestVariant = sortedVariants[0];
          const controlVariant = performanceSummary.variants.find(
            (v) => v.variantId === campaign.baseTemplateId
          );
          if (controlVariant && bestVariant && performanceSummary.totalParticipants > 100) {
            const controlMetric = campaign.successMetric === "open_rate" ? controlVariant.openRate : campaign.successMetric === "click_rate" ? controlVariant.clickRate : campaign.successMetric === "conversion_rate" ? controlVariant.conversionRate : controlVariant.bookingRate;
            const bestMetric = campaign.successMetric === "open_rate" ? bestVariant.openRate : campaign.successMetric === "click_rate" ? bestVariant.clickRate : campaign.successMetric === "conversion_rate" ? bestVariant.conversionRate : bestVariant.bookingRate;
            const improvement = controlMetric > 0 ? (bestMetric - controlMetric) / controlMetric * 100 : 0;
            if (improvement > 20) {
              shouldOptimize = true;
              optimizationRecommendation = {
                recommendedWinner: bestVariant,
                improvement,
                confidence: "medium",
                // Could be enhanced with statistical significance testing
                reason: `Best variant shows ${improvement.toFixed(1)}% improvement over control`
              };
            }
          }
        }
        res.json({
          autoOptimizationEnabled,
          shouldOptimize,
          optimizationRecommendation,
          campaign: {
            id: campaign.id,
            status: campaign.status,
            successMetric: campaign.successMetric,
            autoOptimization: campaign.autoOptimization
          },
          performanceSummary
        });
      } catch (error) {
        console.error("Error checking auto-optimization status:", error);
        res.status(500).json({ error: "Failed to check auto-optimization status" });
      }
    }
  );
  const requireCustomerAuth = async (req, res, next) => {
    await isAuthenticated(req, res, async () => {
      try {
        if (!req.user?.roles?.includes("customer")) {
          return res.status(403).json({ message: "Customer access required" });
        }
        next();
      } catch (error) {
        console.error("Customer authorization error:", error);
        return res.status(403).json({ message: "Authorization failed" });
      }
    });
  };
  app2.get(
    "/api/customer/appointments",
    requireCustomerAuth,
    async (req, res) => {
      try {
        const customerId = req.user.id;
        const filters = {
          status: req.query.status || "all",
          limit: parseInt(req.query.limit) || 50,
          offset: parseInt(req.query.offset) || 0
        };
        const validStatuses = ["upcoming", "completed", "cancelled", "history", "all"];
        if (!validStatuses.includes(filters.status)) {
          return res.status(400).json({
            error: "Invalid status parameter",
            validValues: validStatuses
          });
        }
        if (filters.limit > 100) {
          return res.status(400).json({
            error: "Limit cannot exceed 100"
          });
        }
        const appointments = await storage.getCustomerAppointments(
          customerId,
          filters
        );
        res.json(appointments);
      } catch (error) {
        console.error("Error fetching customer appointments:", error);
        res.status(500).json({ error: "Failed to fetch appointments" });
      }
    }
  );
  app2.get(
    "/api/customer/profile",
    requireCustomerAuth,
    async (req, res) => {
      try {
        const customerId = req.user.id;
        const profile = await storage.getCustomerProfileWithStats(customerId);
        res.json(profile);
      } catch (error) {
        console.error("Error fetching customer profile:", error);
        res.status(500).json({ error: "Failed to fetch customer profile" });
      }
    }
  );
  app2.get(
    "/api/customer/payments",
    requireCustomerAuth,
    async (req, res) => {
      try {
        const customerId = req.user.id;
        const payments3 = await storage.getCustomerPaymentHistory(customerId);
        res.json(payments3);
      } catch (error) {
        console.error("Error fetching customer payment history:", error);
        res.status(500).json({ error: "Failed to fetch payment history" });
      }
    }
  );
  app2.patch(
    "/api/customer/profile",
    requireCustomerAuth,
    async (req, res) => {
      try {
        const customerId = req.user.id;
        const validation = updateCustomerProfileSchema.safeParse(req.body);
        if (!validation.success) {
          return res.status(400).json({
            error: "Validation failed",
            details: validation.error.errors.map((err) => ({
              field: err.path.join("."),
              message: err.message
            }))
          });
        }
        const { firstName, lastName, phone, preferences } = validation.data;
        const updateData = {};
        if (firstName !== void 0) updateData.firstName = firstName;
        if (lastName !== void 0) updateData.lastName = lastName;
        if (phone !== void 0) updateData.phone = phone;
        if (Object.keys(updateData).length > 0) {
          await storage.updateUser(customerId, updateData);
        }
        if (preferences !== void 0) {
          await storage.updateUserPreferences(customerId, preferences);
        }
        res.json({
          success: true,
          message: "Profile updated successfully"
        });
      } catch (error) {
        console.error("Error updating customer profile:", error);
        res.status(500).json({ error: "Failed to update profile" });
      }
    }
  );
  app2.patch(
    "/api/customer/appointments/:id",
    requireCustomerAuth,
    async (req, res) => {
      try {
        const { id } = req.params;
        const { status } = req.body;
        if (!["cancelled", "confirmed", "pending"].includes(status)) {
          return res.status(400).json({
            error: "Invalid status. Must be one of: cancelled, confirmed, pending"
          });
        }
        await storage.updateBookingStatusWithCustomerValidation(
          id,
          req.user.email,
          status
        );
        res.json({
          success: true,
          message: `Appointment ${status} successfully`
        });
      } catch (error) {
        console.error("Error updating appointment status:", error);
        if (error.message === "Booking not found or access denied") {
          res.status(404).json({ error: "Appointment not found or access denied" });
        } else {
          res.status(500).json({ error: "Failed to update appointment" });
        }
      }
    }
  );
  app2.post(
    "/api/admin/migrate/geocode-salons",
    isAuthenticated,
    async (req, res) => {
      try {
        const userRoles2 = req.user?.roles || [];
        if (!userRoles2.includes("admin") && !userRoles2.includes("owner")) {
          return res.status(403).json({ error: "Unauthorized - Admin access required" });
        }
        console.log("Starting salon geocoding migration...");
        const migrationResults = {
          startTime: (/* @__PURE__ */ new Date()).toISOString(),
          totalSalons: 0,
          successfulGeocode: 0,
          failedGeocode: 0,
          alreadyAccurate: 0,
          updated: 0,
          errors: [],
          details: [],
          endTime: ""
        };
        const salons11 = await storage.getAllSalons();
        const activeSalons = salons11.filter((salon) => salon.isActive);
        migrationResults.totalSalons = activeSalons.length;
        console.log(`Found ${activeSalons.length} active salons to process`);
        for (const salon of activeSalons) {
          const salonDetail = {
            id: salon.id,
            name: salon.name,
            originalAddress: `${salon.address}, ${salon.city}, ${salon.state}`,
            originalLat: salon.latitude ? parseFloat(salon.latitude) : null,
            originalLng: salon.longitude ? parseFloat(salon.longitude) : null,
            newLat: null,
            newLng: null,
            status: "pending",
            error: null
          };
          try {
            const fullAddress = `${salon.address}, ${salon.city}, ${salon.state}`;
            console.log(
              `Geocoding salon "${salon.name}" at address: ${fullAddress}`
            );
            const geocodeUrl = `http://localhost:5000/api/places/geocode?address=${encodeURIComponent(fullAddress)}`;
            const geocodeResponse = await fetch(geocodeUrl);
            if (geocodeResponse.ok) {
              const geocodeData = await geocodeResponse.json();
              if (geocodeData.lat && geocodeData.lng) {
                const newLat = parseFloat(geocodeData.lat);
                const newLng = parseFloat(geocodeData.lng);
                if (newLat >= -90 && newLat <= 90 && newLng >= -180 && newLng <= 180) {
                  salonDetail.newLat = newLat;
                  salonDetail.newLng = newLng;
                  const coordsChanged = !salon.latitude || !salon.longitude || Math.abs(newLat - parseFloat(salon.latitude)) > 1e-3 || Math.abs(newLng - parseFloat(salon.longitude)) > 1e-3;
                  if (coordsChanged) {
                    await storage.updateSalon(salon.id, {
                      latitude: newLat.toString(),
                      longitude: newLng.toString()
                    });
                    salonDetail.status = "updated";
                    migrationResults.updated++;
                    console.log(
                      `\u2705 Updated coordinates for "${salon.name}": ${newLat}, ${newLng}`
                    );
                  } else {
                    salonDetail.status = "already_accurate";
                    migrationResults.alreadyAccurate++;
                    console.log(
                      `\u2713 Coordinates already accurate for "${salon.name}"`
                    );
                  }
                  migrationResults.successfulGeocode++;
                } else {
                  salonDetail.status = "invalid_coordinates";
                  salonDetail.error = `Invalid coordinate ranges: lat=${newLat}, lng=${newLng}`;
                  migrationResults.failedGeocode++;
                  migrationResults.errors.push(
                    `${salon.name}: Invalid coordinate ranges`
                  );
                  console.warn(
                    `\u26A0\uFE0F Invalid coordinates for "${salon.name}": ${newLat}, ${newLng}`
                  );
                }
              } else {
                salonDetail.status = "geocode_no_result";
                salonDetail.error = "Geocoding returned no coordinates";
                migrationResults.failedGeocode++;
                migrationResults.errors.push(
                  `${salon.name}: No coordinates returned`
                );
                console.warn(`\u26A0\uFE0F No coordinates returned for "${salon.name}"`);
              }
            } else {
              const errorData = await geocodeResponse.text();
              salonDetail.status = "geocode_failed";
              salonDetail.error = `Geocoding API error: ${geocodeResponse.status}`;
              migrationResults.failedGeocode++;
              migrationResults.errors.push(
                `${salon.name}: Geocoding API error`
              );
              console.error(
                `\u274C Geocoding failed for "${salon.name}": ${errorData}`
              );
            }
          } catch (error) {
            salonDetail.status = "exception";
            salonDetail.error = error instanceof Error ? error.message : "Unknown error";
            migrationResults.failedGeocode++;
            migrationResults.errors.push(`${salon.name}: ${salonDetail.error}`);
            console.error(`\u274C Exception geocoding "${salon.name}":`, error);
          }
          migrationResults.details.push(salonDetail);
          await new Promise((resolve) => setTimeout(resolve, 200));
        }
        migrationResults.endTime = (/* @__PURE__ */ new Date()).toISOString();
        console.log("Salon geocoding migration completed:");
        console.log(`- Total salons: ${migrationResults.totalSalons}`);
        console.log(
          `- Successfully geocoded: ${migrationResults.successfulGeocode}`
        );
        console.log(`- Updated coordinates: ${migrationResults.updated}`);
        console.log(`- Already accurate: ${migrationResults.alreadyAccurate}`);
        console.log(`- Failed geocoding: ${migrationResults.failedGeocode}`);
        res.json({
          success: true,
          message: "Salon geocoding migration completed",
          results: migrationResults
        });
      } catch (error) {
        console.error("Migration error:", error);
        res.status(500).json({
          error: "Migration failed",
          message: error.message,
          details: "Check server logs for more information"
        });
      }
    }
  );
  app2.get(
    "/api/admin/platform-stats",
    populateUserFromSession,
    requireSuperAdmin(),
    async (req, res) => {
      try {
        const { period } = req.query;
        const stats = await storage.getPlatformStats(period);
        res.json(stats);
      } catch (error) {
        console.error("Error fetching platform stats:", error);
        res.status(500).json({ error: error.message });
      }
    }
  );
  app2.get(
    "/api/admin/salons",
    populateUserFromSession,
    requireSuperAdmin(),
    async (req, res) => {
      try {
        const { status, approvalStatus, city, search } = req.query;
        const salons11 = await storage.getAllSalonsForAdmin({
          status,
          approvalStatus,
          city,
          search
        });
        res.json(salons11);
      } catch (error) {
        console.error("Error fetching salons for admin:", error);
        res.status(500).json({ error: error.message });
      }
    }
  );
  app2.post(
    "/api/admin/salons/:salonId/approve",
    populateUserFromSession,
    requireSuperAdmin(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        await storage.approveSalon(salonId, req.user.id);
        res.json({ success: true, message: "Salon approved successfully" });
      } catch (error) {
        console.error("Error approving salon:", error);
        res.status(500).json({ error: error.message });
      }
    }
  );
  app2.post(
    "/api/admin/salons/:salonId/reject",
    populateUserFromSession,
    requireSuperAdmin(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const { reason } = req.body;
        await storage.rejectSalon(salonId, reason, req.user.id);
        res.json({ success: true, message: "Salon rejected successfully" });
      } catch (error) {
        console.error("Error rejecting salon:", error);
        res.status(500).json({ error: error.message });
      }
    }
  );
  app2.post(
    "/api/admin/salons/:salonId/toggle-status",
    populateUserFromSession,
    requireSuperAdmin(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const { isActive, reason } = req.body;
        if (typeof isActive !== "boolean") {
          return res.status(400).json({ error: "isActive must be a boolean" });
        }
        await storage.toggleSalonStatusBySuperAdmin(salonId, isActive, req.user.id, reason);
        res.json({
          success: true,
          message: isActive ? "Salon enabled successfully" : "Salon disabled successfully",
          isActive
        });
      } catch (error) {
        console.error("Error toggling salon status:", error);
        res.status(500).json({ error: error.message });
      }
    }
  );
  app2.get(
    "/api/admin/users",
    populateUserFromSession,
    requireSuperAdmin(),
    async (req, res) => {
      try {
        const { role, isActive, search } = req.query;
        const users8 = await storage.getAllUsersForAdmin({
          role,
          isActive: isActive ? parseInt(isActive) : void 0,
          search
        });
        res.json(users8);
      } catch (error) {
        console.error("Error fetching users for admin:", error);
        res.status(500).json({ error: error.message });
      }
    }
  );
  app2.patch(
    "/api/admin/users/:userId/toggle-active",
    populateUserFromSession,
    requireSuperAdmin(),
    async (req, res) => {
      try {
        const { userId } = req.params;
        const { isActive } = req.body;
        await storage.toggleUserActive(userId, isActive);
        res.json({
          success: true,
          message: "User status updated successfully"
        });
      } catch (error) {
        console.error("Error toggling user status:", error);
        res.status(500).json({ error: error.message });
      }
    }
  );
  app2.get(
    "/api/admin/bookings",
    populateUserFromSession,
    requireSuperAdmin(),
    async (req, res) => {
      try {
        const { status, salonId, startDate, endDate } = req.query;
        const bookings4 = await storage.getAllBookingsForAdmin({
          status,
          salonId,
          startDate,
          endDate
        });
        res.json(bookings4);
      } catch (error) {
        console.error("Error fetching bookings for admin:", error);
        res.status(500).json({ error: error.message });
      }
    }
  );
  app2.get(
    "/api/admin/salons/:salonId/stats",
    populateUserFromSession,
    requireSuperAdmin(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const stats = await storage.getSalonBookingStats(salonId);
        res.json(stats);
      } catch (error) {
        console.error("Error fetching salon stats:", error);
        res.status(500).json({ error: error.message });
      }
    }
  );
  app2.get(
    "/api/admin/config/:key",
    populateUserFromSession,
    requireSuperAdmin(),
    async (req, res) => {
      try {
        const { key } = req.params;
        const value = await storage.getPlatformConfig(key);
        res.json({ key, value });
      } catch (error) {
        console.error("Error fetching platform config:", error);
        res.status(500).json({ error: error.message });
      }
    }
  );
  app2.post(
    "/api/admin/config",
    populateUserFromSession,
    requireSuperAdmin(),
    async (req, res) => {
      try {
        const { key, value } = req.body;
        await storage.setPlatformConfig(key, value, req.user.id);
        res.json({
          success: true,
          message: "Platform config updated successfully"
        });
      } catch (error) {
        console.error("Error updating platform config:", error);
        res.status(500).json({ error: error.message });
      }
    }
  );
  app2.get(
    "/api/admin/settings",
    populateUserFromSession,
    requireSuperAdmin(),
    async (req, res) => {
      try {
        const offerApprovalSettings = await storage.getPlatformConfig(
          "offerApprovalSettings"
        ) || { autoApproveSalonOffers: true };
        res.json({
          offerApprovalSettings
        });
      } catch (error) {
        console.error("Error fetching platform settings:", error);
        res.status(500).json({ error: error.message });
      }
    }
  );
  app2.patch(
    "/api/admin/settings",
    populateUserFromSession,
    requireSuperAdmin(),
    async (req, res) => {
      try {
        const { offerApprovalSettings } = req.body;
        if (offerApprovalSettings !== void 0) {
          const settingsSchema = z23.object({
            autoApproveSalonOffers: z23.boolean()
          });
          const validatedSettings = settingsSchema.parse(offerApprovalSettings);
          console.log(
            `[ADMIN_ANALYTICS] Settings updated by ${req.user.id}:`,
            {
              setting: "offerApprovalSettings",
              oldValue: await storage.getPlatformConfig(
                "offerApprovalSettings"
              ),
              newValue: validatedSettings,
              timestamp: (/* @__PURE__ */ new Date()).toISOString()
            }
          );
          await storage.setPlatformConfig(
            "offerApprovalSettings",
            validatedSettings,
            req.user.id
          );
          res.json({
            success: true,
            message: "Platform settings updated successfully",
            settings: {
              offerApprovalSettings: validatedSettings
            }
          });
        } else {
          res.json({
            success: true,
            message: "No settings to update",
            settings: {
              offerApprovalSettings: await storage.getPlatformConfig(
                "offerApprovalSettings"
              )
            }
          });
        }
      } catch (error) {
        console.error("Error updating platform settings:", error);
        const status = error.name === "ZodError" ? 400 : 500;
        res.status(status).json({ error: error.message });
      }
    }
  );
  app2.get(
    "/api/admin/salons/:salonId/earnings",
    populateUserFromSession,
    requireSuperAdmin(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const earnings = await storage.getSalonEarnings(salonId);
        res.json(earnings);
      } catch (error) {
        console.error("Error fetching salon earnings:", error);
        res.status(500).json({ error: error.message });
      }
    }
  );
  app2.post(
    "/api/admin/payouts",
    populateUserFromSession,
    requireSuperAdmin(),
    async (req, res) => {
      try {
        const { salonId, amount } = req.body;
        const payout = await storage.createPayout(salonId, amount);
        res.json(payout);
      } catch (error) {
        console.error("Error creating payout:", error);
        res.status(500).json({ error: error.message });
      }
    }
  );
  app2.post(
    "/api/admin/payouts/:payoutId/approve",
    populateUserFromSession,
    requireSuperAdmin(),
    async (req, res) => {
      try {
        const { payoutId } = req.params;
        await storage.approvePayout(payoutId, req.user.id);
        res.json({ success: true, message: "Payout approved successfully" });
      } catch (error) {
        console.error("Error approving payout:", error);
        res.status(500).json({ error: error.message });
      }
    }
  );
  app2.post(
    "/api/admin/payouts/:payoutId/reject",
    populateUserFromSession,
    requireSuperAdmin(),
    async (req, res) => {
      try {
        const { payoutId } = req.params;
        const { reason } = req.body;
        await storage.rejectPayout(payoutId, reason, req.user.id);
        res.json({ success: true, message: "Payout rejected successfully" });
      } catch (error) {
        console.error("Error rejecting payout:", error);
        res.status(500).json({ error: error.message });
      }
    }
  );
  app2.get(
    "/api/admin/payouts",
    populateUserFromSession,
    requireSuperAdmin(),
    async (req, res) => {
      try {
        const { status, salonId } = req.query;
        const payouts = await storage.getAllPayouts({
          status,
          salonId
        });
        res.json(payouts);
      } catch (error) {
        console.error("Error fetching payouts:", error);
        res.status(500).json({ error: error.message });
      }
    }
  );
  app2.get(
    "/api/salons/:salonId/offers",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const offers = await storage.getSalonOffers(salonId);
        res.json(offers);
      } catch (error) {
        console.error("Error fetching salon offers:", error);
        res.status(500).json({ error: error.message });
      }
    }
  );
  app2.post(
    "/api/salons/:salonId/offers",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const validatedData = createOfferSchema.parse(req.body);
        const offer = await storage.createSalonOffer(
          salonId,
          validatedData,
          req.user.id
        );
        res.json({
          ...offer,
          _meta: {
            autoApproved: offer.autoApproved === 1,
            needsApproval: offer.approvalStatus === "pending"
          }
        });
      } catch (error) {
        console.error("Error creating salon offer:", error);
        res.status(400).json({ error: error.message });
      }
    }
  );
  app2.patch(
    "/api/salons/:salonId/offers/:offerId",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId, offerId } = req.params;
        const validatedData = updateOfferSchema.parse(req.body);
        const offerBefore = await storage.getOfferById(offerId);
        if (!offerBefore) {
          return res.status(404).json({ error: "Offer not found" });
        }
        await storage.updateSalonOffer(
          offerId,
          salonId,
          validatedData,
          req.user.id
        );
        const offerAfter = await storage.getOfferById(offerId);
        if (!offerAfter) {
          return res.status(500).json({ error: "Failed to retrieve updated offer" });
        }
        res.json({
          success: true,
          message: "Offer updated successfully",
          offer: offerAfter,
          _meta: {
            requiresReapproval: offerBefore.approvalStatus === "approved" && offerAfter.approvalStatus === "pending",
            approvalStatus: offerAfter.approvalStatus,
            autoApproved: offerAfter.autoApproved === 1
          }
        });
      } catch (error) {
        console.error("Error updating salon offer:", error);
        const status = error.message.includes("Unauthorized") ? 403 : 400;
        res.status(status).json({ error: error.message });
      }
    }
  );
  app2.post(
    "/api/salons/:salonId/offers/:offerId/toggle",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId, offerId } = req.params;
        const validatedData = toggleOfferStatusSchema.parse(req.body);
        await storage.toggleSalonOfferStatus(
          offerId,
          salonId,
          validatedData.isActive
        );
        res.json({
          success: true,
          message: "Offer status updated successfully"
        });
      } catch (error) {
        console.error("Error toggling salon offer status:", error);
        res.status(400).json({ error: error.message });
      }
    }
  );
  app2.delete(
    "/api/salons/:salonId/offers/:offerId",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId, offerId } = req.params;
        await storage.deleteSalonOffer(offerId, salonId);
        res.json({ success: true, message: "Offer deleted successfully" });
      } catch (error) {
        console.error("Error deleting salon offer:", error);
        res.status(400).json({ error: error.message });
      }
    }
  );
  const googlePlacesRateLimiter = rateLimit9({
    windowMs: 60 * 1e3,
    // 1 minute
    max: 10,
    // 10 requests per minute
    message: "Too many requests to Google Places API. Please try again later.",
    standardHeaders: true,
    legacyHeaders: false
  });
  app2.post(
    "/api/google-places/search",
    isAuthenticated,
    googlePlacesRateLimiter,
    async (req, res) => {
      try {
        const schema = z23.object({
          latitude: z23.number(),
          longitude: z23.number(),
          businessName: z23.string().min(1),
          radius: z23.number().optional().default(50)
        });
        const validatedData = schema.parse(req.body);
        const googlePlacesService2 = getGooglePlacesService();
        const results = await googlePlacesService2.searchNearby(validatedData);
        res.json({ results });
      } catch (error) {
        console.error("Google Places search error:", error);
        res.status(500).json({
          error: error.message || "Failed to search nearby businesses"
        });
      }
    }
  );
  app2.post(
    "/api/salons/:salonId/google-places/import",
    isAuthenticated,
    requireSalonAccess(),
    googlePlacesRateLimiter,
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const schema = z23.object({
          placeId: z23.string().min(1)
        });
        const validatedData = schema.parse(req.body);
        const googlePlacesService2 = getGooglePlacesService();
        const result = await googlePlacesService2.importReviews({
          placeId: validatedData.placeId,
          salonId
        });
        res.json(result);
      } catch (error) {
        console.error("Google reviews import error:", error);
        res.status(500).json({ error: error.message || "Failed to import Google reviews" });
      }
    }
  );
  app2.get("/api/salons/:salonId/reviews", async (req, res) => {
    try {
      const { salonId } = req.params;
      const { source } = req.query;
      const sourceFilter = source === "google" || source === "stylemate" ? source : void 0;
      const reviews = await storage.getReviewsBySalonId(salonId, sourceFilter);
      res.json({ reviews });
    } catch (error) {
      console.error("Get reviews error:", error);
      res.status(500).json({ error: "Failed to get reviews" });
    }
  });
  app2.post(
    "/api/salons/:salonId/reviews",
    isAuthenticated,
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const userId = req.user.id;
        const schema = z23.object({
          bookingId: z23.string().uuid(),
          rating: z23.number().min(1).max(5),
          comment: z23.string().optional()
        });
        const validatedData = schema.parse(req.body);
        const booking = await storage.getBooking(validatedData.bookingId);
        if (!booking) {
          return res.status(404).json({ error: "Booking not found" });
        }
        if (booking.customerEmail !== req.user.email) {
          return res.status(403).json({ error: "You can only review your own bookings" });
        }
        if (booking.status !== "completed") {
          return res.status(400).json({ error: "You can only review completed bookings" });
        }
        const review = await storage.createReview({
          salonId,
          customerId: userId,
          bookingId: validatedData.bookingId,
          rating: validatedData.rating,
          comment: validatedData.comment || null,
          source: "stylemate",
          isVerified: 1,
          googleAuthorName: null,
          googleAuthorPhoto: null,
          googleReviewId: null,
          googlePublishedAt: null
        });
        await storage.updateSalonRating(salonId);
        res.json({ review });
      } catch (error) {
        console.error("Create review error:", error);
        res.status(500).json({ error: error.message || "Failed to create review" });
      }
    }
  );
  app2.get(
    "/api/admin/offers",
    populateUserFromSession,
    requireSuperAdmin(),
    async (req, res) => {
      try {
        const {
          status,
          approvalStatus,
          isPlatformWide,
          salonId,
          ownedBySalonId,
          autoApproved
        } = req.query;
        const offers = await storage.getAllOffers({
          status,
          approvalStatus,
          isPlatformWide: isPlatformWide ? parseInt(isPlatformWide) : void 0,
          salonId,
          ownedBySalonId
        });
        let filteredOffers = offers;
        if (autoApproved !== void 0) {
          const isAutoApproved = autoApproved === "1" || autoApproved === "true";
          filteredOffers = offers.filter(
            (o) => o.autoApproved === 1 === isAutoApproved
          );
        }
        const enrichedOffers = filteredOffers.map((offer) => ({
          ...offer,
          _meta: {
            approvalSource: offer.autoApproved === 1 ? "auto" : "manual",
            isSalonOwned: offer.ownedBySalonId !== null,
            isPlatformOffer: offer.ownedBySalonId === null
          }
        }));
        res.json(enrichedOffers);
      } catch (error) {
        console.error("Error fetching offers:", error);
        res.status(500).json({ error: error.message });
      }
    }
  );
  app2.post(
    "/api/admin/offers",
    populateUserFromSession,
    requireSuperAdmin(),
    async (req, res) => {
      try {
        const validatedData = createOfferSchema.parse(req.body);
        const offerData = {
          ...validatedData,
          isPlatformWide: 1,
          // Force platform-wide
          salonId: null,
          // No specific salon
          ownedBySalonId: null,
          // Created by super admin
          approvalStatus: "approved",
          // Super admin offers are auto-approved
          createdBy: req.user.id,
          validFrom: new Date(validatedData.validFrom),
          validUntil: new Date(validatedData.validUntil),
          imageUrl: validatedData.imageUrl
          // Promotional image for offer card
        };
        const offer = await storage.createOffer(offerData);
        res.json(offer);
      } catch (error) {
        console.error("Error creating offer:", error);
        res.status(400).json({ error: error.message });
      }
    }
  );
  app2.patch(
    "/api/admin/offers/:offerId",
    populateUserFromSession,
    requireSuperAdmin(),
    async (req, res) => {
      try {
        const { offerId } = req.params;
        const validatedData = updateOfferSchema.parse(req.body);
        await storage.updateOffer(offerId, validatedData);
        res.json({ success: true, message: "Offer updated successfully" });
      } catch (error) {
        console.error("Error updating offer:", error);
        res.status(400).json({ error: error.message });
      }
    }
  );
  app2.post(
    "/api/admin/offers/:offerId/approve",
    populateUserFromSession,
    requireSuperAdmin(),
    async (req, res) => {
      try {
        const { offerId } = req.params;
        await storage.approveOffer(offerId, req.user.id);
        res.json({ success: true, message: "Offer approved successfully" });
      } catch (error) {
        console.error("Error approving offer:", error);
        res.status(500).json({ error: error.message });
      }
    }
  );
  app2.post(
    "/api/admin/offers/:offerId/reject",
    populateUserFromSession,
    requireSuperAdmin(),
    async (req, res) => {
      try {
        const { offerId } = req.params;
        const { reason } = approveRejectOfferSchema.parse(req.body);
        if (!reason) {
          return res.status(400).json({ error: "Rejection reason is required" });
        }
        await storage.rejectOffer(offerId, reason, req.user.id);
        res.json({ success: true, message: "Offer rejected successfully" });
      } catch (error) {
        console.error("Error rejecting offer:", error);
        res.status(400).json({ error: error.message });
      }
    }
  );
  app2.post(
    "/api/admin/offers/:offerId/toggle",
    populateUserFromSession,
    requireSuperAdmin(),
    async (req, res) => {
      try {
        const { offerId } = req.params;
        const { isActive } = toggleOfferStatusSchema.parse(req.body);
        await storage.toggleOfferStatus(offerId, isActive);
        res.json({
          success: true,
          message: "Offer status updated successfully"
        });
      } catch (error) {
        console.error("Error toggling offer status:", error);
        res.status(400).json({ error: error.message });
      }
    }
  );
  app2.delete(
    "/api/admin/offers/:offerId",
    populateUserFromSession,
    requireSuperAdmin(),
    async (req, res) => {
      try {
        const { offerId } = req.params;
        await storage.deleteOffer(offerId);
        res.json({ success: true, message: "Offer deleted successfully" });
      } catch (error) {
        console.error("Error deleting offer:", error);
        res.status(500).json({ error: error.message });
      }
    }
  );
  app2.get(
    "/api/wallet",
    isAuthenticated,
    async (req, res) => {
      try {
        let wallet = await storage.getUserWallet(req.user.id);
        if (!wallet) {
          wallet = await storage.createUserWallet(req.user.id);
        }
        res.json(wallet);
      } catch (error) {
        console.error("Error getting wallet:", error);
        res.status(500).json({ error: error.message });
      }
    }
  );
  app2.get(
    "/api/wallet/transactions",
    isAuthenticated,
    async (req, res) => {
      try {
        const transactions = await storage.getWalletTransactions(req.user.id);
        res.json(transactions);
      } catch (error) {
        console.error("Error getting wallet transactions:", error);
        res.status(500).json({ error: error.message });
      }
    }
  );
  app2.get(
    "/api/customer/gift-cards",
    isAuthenticated,
    async (req, res) => {
      try {
        const userId = req.user.id;
        const purchased = await db.select({
          id: giftCards.id,
          code: giftCards.code,
          balancePaisa: giftCards.balancePaisa,
          originalValuePaisa: giftCards.originalValuePaisa,
          status: giftCards.status,
          expiresAt: giftCards.expiresAt,
          recipientName: giftCards.recipientName,
          recipientEmail: giftCards.recipientEmail,
          salonId: giftCards.salonId,
          salonName: salons.name,
          purchasedAt: giftCards.purchasedAt,
          qrCodeUrl: giftCards.qrCodeUrl
        }).from(giftCards).leftJoin(salons, eq58(giftCards.salonId, salons.id)).where(eq58(giftCards.purchasedBy, userId)).orderBy(sql44`${giftCards.createdAt} DESC`);
        const user = await db.select().from(users).where(eq58(users.id, userId)).limit(1);
        const userEmail = user[0]?.email;
        const userPhone = user[0]?.phone;
        let received = [];
        if (userEmail || userPhone) {
          const conditions = [];
          if (userEmail) conditions.push(eq58(giftCards.recipientEmail, userEmail));
          if (userPhone) conditions.push(eq58(giftCards.recipientPhone, userPhone));
          received = await db.select({
            id: giftCards.id,
            code: giftCards.code,
            balancePaisa: giftCards.balancePaisa,
            originalValuePaisa: giftCards.originalValuePaisa,
            status: giftCards.status,
            expiresAt: giftCards.expiresAt,
            personalMessage: giftCards.personalMessage,
            salonId: giftCards.salonId,
            salonName: salons.name,
            deliveredAt: giftCards.deliveredAt,
            qrCodeUrl: giftCards.qrCodeUrl
          }).from(giftCards).leftJoin(salons, eq58(giftCards.salonId, salons.id)).where(and56(or18(...conditions), eq58(giftCards.status, "active"))).orderBy(sql44`${giftCards.deliveredAt} DESC`);
        }
        res.json({ purchased, received });
      } catch (error) {
        console.error("Error fetching customer gift cards:", error);
        res.status(500).json({ error: error.message });
      }
    }
  );
  app2.get("/api/offers", async (req, res) => {
    try {
      const { salonId } = req.query;
      const userId = req.user?.id || "guest";
      const offers = await storage.getCustomerOffers(userId, salonId);
      res.json(offers);
    } catch (error) {
      console.error("Error getting customer offers:", error);
      res.status(500).json({ error: error.message });
    }
  });
  app2.post("/api/offers/calculate", async (req, res) => {
    try {
      const { salonId, totalAmountPaisa, promoCode } = req.body;
      if (!salonId || totalAmountPaisa === void 0) {
        return res.status(400).json({
          error: "Missing required fields: salonId and totalAmountPaisa"
        });
      }
      const userId = req.user?.id || "guest";
      const offers = await storage.getCustomerOffers(userId, salonId);
      const activeOffers = offers.filter(
        (offer) => offer.isActive === 1 && offer.approvalStatus === "approved"
      );
      const calculatedOffers = OfferCalculator.calculateAllOffers(
        activeOffers,
        totalAmountPaisa,
        salonId
      );
      const bestOffer = OfferCalculator.getBestOffer(
        activeOffers,
        totalAmountPaisa,
        salonId,
        promoCode
      );
      const priceBreakdown = OfferCalculator.getPriceBreakdown(
        totalAmountPaisa,
        bestOffer
      );
      res.json({
        bestOffer,
        allOffers: calculatedOffers,
        priceBreakdown,
        hasApplicableOffers: bestOffer !== null
      });
    } catch (error) {
      console.error("Error calculating offers:", error);
      res.status(500).json({ error: error.message });
    }
  });
  app2.post(
    "/api/offers/validate-promo",
    async (req, res) => {
      try {
        const { salonId, promoCode, totalAmountPaisa } = req.body;
        if (!salonId || !promoCode || totalAmountPaisa === void 0) {
          return res.status(400).json({
            error: "Missing required fields: salonId, promoCode, and totalAmountPaisa"
          });
        }
        const userId = req.user?.id || "guest";
        const offers = await storage.getCustomerOffers(userId, salonId);
        const matchedOffer = OfferCalculator.validatePromoCode(
          promoCode,
          offers
        );
        if (!matchedOffer) {
          return res.json({
            valid: false,
            message: "Invalid promo code"
          });
        }
        if (!OfferCalculator.isOfferValid(matchedOffer)) {
          return res.json({
            valid: false,
            message: "This promo code has expired"
          });
        }
        if (!OfferCalculator.hasUsageRemaining(matchedOffer)) {
          return res.json({
            valid: false,
            message: "This promo code has reached its usage limit"
          });
        }
        const discountAmount = OfferCalculator.calculateDiscount(
          matchedOffer,
          totalAmountPaisa
        );
        if (discountAmount === 0) {
          return res.json({
            valid: false,
            message: `Minimum purchase of \u20B9${matchedOffer.minimumPurchase / 100} required`
          });
        }
        res.json({
          valid: true,
          offer: matchedOffer,
          discountAmount,
          finalAmount: totalAmountPaisa - discountAmount,
          message: "Promo code applied successfully!"
        });
      } catch (error) {
        console.error("Error validating promo code:", error);
        res.status(500).json({ error: error.message });
      }
    }
  );
  app2.get(
    "/api/offers/:offerId/eligibility",
    isAuthenticated,
    async (req, res) => {
      try {
        const { offerId } = req.params;
        const eligibility = await storage.getUserOfferEligibility(
          req.user.id,
          offerId
        );
        res.json(eligibility);
      } catch (error) {
        console.error("Error checking offer eligibility:", error);
        res.status(500).json({ error: error.message });
      }
    }
  );
  app2.get("/api/offers/customer", async (req, res) => {
    try {
      const { salonId } = req.query;
      const userId = "guest";
      const offers = await storage.getCustomerOffers(userId, salonId);
      res.json(offers);
    } catch (error) {
      console.error("Error fetching customer offers:", error);
      res.status(500).json({ error: error.message });
    }
  });
  app2.get("/api/launch-offers", async (req, res) => {
    try {
      const offers = await storage.getActiveLaunchOffers();
      res.json(offers);
    } catch (error) {
      console.error("Error getting launch offers:", error);
      res.status(500).json({ error: error.message });
    }
  });
  app2.get("/api/offers/all-with-salons", async (req, res) => {
    try {
      const offers = await storage.getAllOffersWithSalons();
      res.json(offers);
    } catch (error) {
      console.error("Error fetching all offers with salons:", error);
      res.status(500).json({ error: error.message });
    }
  });
  app2.get("/api/beauty-products", async (req, res) => {
    try {
      const {
        brand,
        category,
        search,
        skinTone,
        gender,
        limit = "100",
        offset = "0"
      } = req.query;
      const conditions = [];
      if (brand) {
        const brands = brand.split(",").map((b) => b.trim());
        conditions.push(inArray22(beautyProducts.brand, brands));
      }
      if (category) {
        conditions.push(eq58(beautyProducts.category, category));
      }
      if (search) {
        const searchTerm = `%${search}%`;
        conditions.push(
          or18(
            sql44`${beautyProducts.name} ILIKE ${searchTerm}`,
            sql44`${beautyProducts.brand} ILIKE ${searchTerm}`,
            sql44`${beautyProducts.productLine} ILIKE ${searchTerm}`
          )
        );
      }
      if (skinTone) {
        const skinTonePattern = `%${skinTone}%`;
        conditions.push(
          sql44`${beautyProducts.skinToneCompatibility} ILIKE ${skinTonePattern}`
        );
      }
      if (gender) {
        conditions.push(
          or18(
            eq58(beautyProducts.gender, gender),
            eq58(beautyProducts.gender, "unisex")
          )
        );
      }
      let query = db.select().from(beautyProducts);
      if (conditions.length > 0) {
        query = query.where(and56(...conditions));
      }
      const limitNum = parseInt(limit);
      const offsetNum = parseInt(offset);
      query = query.limit(limitNum).offset(offsetNum);
      const products2 = await query;
      const totalCountResult = await db.select({ count: sql44`count(*)::int` }).from(beautyProducts).where(conditions.length > 0 ? and56(...conditions) : void 0);
      const totalCount = totalCountResult[0]?.count || 0;
      const DEFAULT_PLACEHOLDER_IMAGE = "https://placehold.co/400x400/f3f4f6/94a3b8?text=No+Image";
      const productsWithImages = products2.map((product) => ({
        ...product,
        image_url: product.image_url || DEFAULT_PLACEHOLDER_IMAGE
      }));
      res.json({
        products: productsWithImages,
        pagination: {
          limit: limitNum,
          offset: offsetNum,
          total: totalCount,
          hasMore: offsetNum + products2.length < totalCount
        }
      });
    } catch (error) {
      console.error("Error fetching beauty products:", error);
      res.status(500).json({ error: error.message });
    }
  });
  app2.get(
    "/api/salons/:salonId/inventory",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const inventory = await db.select({
          inventoryId: salonInventory.id,
          productId: salonInventory.productId,
          quantity: salonInventory.quantity,
          lowStockThreshold: salonInventory.lowStockThreshold,
          lastRestockedAt: salonInventory.lastRestockedAt,
          createdAt: salonInventory.createdAt,
          product: {
            id: beautyProducts.id,
            brand: beautyProducts.brand,
            productLine: beautyProducts.productLine,
            name: beautyProducts.name,
            category: beautyProducts.category,
            shade: beautyProducts.shade,
            sku: beautyProducts.sku,
            finishType: beautyProducts.finishType,
            price: beautyProducts.price,
            imageUrl: beautyProducts.imageUrl,
            description: beautyProducts.description
          }
        }).from(salonInventory).innerJoin(
          beautyProducts,
          eq58(salonInventory.productId, beautyProducts.id)
        ).where(eq58(salonInventory.salonId, salonId)).orderBy(beautyProducts.category, beautyProducts.brand);
        res.json(inventory);
      } catch (error) {
        console.error("Error fetching salon inventory:", error);
        res.status(500).json({ error: error.message });
      }
    }
  );
  app2.post(
    "/api/salons/:salonId/inventory",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const { productId, quantity, lowStockThreshold = 5 } = req.body;
        if (!productId) {
          return res.status(400).json({ error: "productId is required" });
        }
        if (quantity === void 0 || quantity < 0) {
          return res.status(400).json({ error: "Valid quantity is required" });
        }
        const product = await db.select().from(beautyProducts).where(eq58(beautyProducts.id, productId)).limit(1);
        if (product.length === 0) {
          return res.status(404).json({ error: "Product not found" });
        }
        const existing = await db.select().from(salonInventory).where(
          and56(
            eq58(salonInventory.salonId, salonId),
            eq58(salonInventory.productId, productId)
          )
        ).limit(1);
        let result;
        if (existing.length > 0) {
          result = await db.update(salonInventory).set({
            quantity,
            lowStockThreshold,
            lastRestockedAt: sql44`CURRENT_TIMESTAMP`
          }).where(
            and56(
              eq58(salonInventory.salonId, salonId),
              eq58(salonInventory.productId, productId)
            )
          ).returning();
        } else {
          result = await db.insert(salonInventory).values({
            salonId,
            productId,
            quantity,
            lowStockThreshold,
            lastRestockedAt: sql44`CURRENT_TIMESTAMP`
          }).returning();
        }
        res.json({
          success: true,
          inventory: result[0],
          message: existing.length > 0 ? "Inventory updated successfully" : "Product added to inventory successfully"
        });
      } catch (error) {
        console.error("Error adding product to inventory:", error);
        res.status(500).json({ error: error.message });
      }
    }
  );
  app2.delete(
    "/api/salons/:salonId/inventory/:productId",
    isAuthenticated,
    requireSalonAccess(),
    async (req, res) => {
      try {
        const { salonId, productId } = req.params;
        await db.delete(salonInventory).where(
          and56(
            eq58(salonInventory.salonId, salonId),
            eq58(salonInventory.productId, productId)
          )
        );
        res.json({ success: true, message: "Product removed from inventory" });
      } catch (error) {
        console.error("Error removing product from inventory:", error);
        res.status(500).json({ error: error.message });
      }
    }
  );
  app2.get("/api/temp-images/:id", async (req, res) => {
    try {
      const { id } = req.params;
      const image = tempImageStorage.getImage(id);
      if (!image) {
        return res.status(404).json({ message: "Image not found or expired" });
      }
      res.setHeader("Content-Type", image.mimeType);
      res.setHeader("Cache-Control", "public, max-age=3600");
      res.send(image.buffer);
    } catch (error) {
      console.error("[TempImages] Error serving image:", error);
      res.status(500).json({ message: "Failed to serve image" });
    }
  });
  app2.use("/api/premium/ai-look", isAuthenticated, ai_look_routes_default);
  registerMobileAuthRoutes(app2);
  registerWalletRoutes(app2);
  registerNotificationRoutes(app2);
  app2.get("/api/mobile/users/stats", authenticateMobileUser, async (req, res) => {
    try {
      const userId = req.user.id;
      const now = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
      const upcomingBookings = await db.select({ count: sql44`count(*)` }).from(bookings).where(
        and56(
          eq58(bookings.userId, userId),
          or18(
            eq58(bookings.status, "pending"),
            eq58(bookings.status, "confirmed")
          ),
          sql44`${bookings.bookingDate} >= ${now}`
        )
      );
      const totalBookingsResult = await db.select({ count: sql44`count(*)` }).from(bookings).where(eq58(bookings.userId, userId));
      const shopOrdersTotal = await db.select({ total: sql44`COALESCE(SUM(${productOrders.totalAmountPaisa}), 0)` }).from(productOrders).where(eq58(productOrders.userId, userId));
      const bookingsTotal = await db.select({ total: sql44`COALESCE(SUM(${bookings.finalAmountPaisa}), 0)` }).from(bookings).where(
        and56(
          eq58(bookings.userId, userId),
          ne5(bookings.status, "cancelled")
        )
      );
      const totalSpentPaisa = (shopOrdersTotal[0]?.total || 0) + (bookingsTotal[0]?.total || 0);
      const favoriteServiceResult = await db.select({
        serviceName: services.name,
        count: sql44`count(*)`
      }).from(bookings).leftJoin(services, eq58(bookings.serviceId, services.id)).where(eq58(bookings.userId, userId)).groupBy(services.id, services.name).orderBy(sql44`count(*) DESC`).limit(1);
      const favoriteService = favoriteServiceResult[0]?.serviceName || "None";
      const favoriteServiceCount = favoriteServiceResult[0]?.count || 0;
      res.json({
        success: true,
        stats: {
          upcomingBookings: Number(upcomingBookings[0]?.count || 0),
          totalBookings: Number(totalBookingsResult[0]?.count || 0),
          totalSpent: totalSpentPaisa,
          favoriteService,
          favoriteServiceCount: Number(favoriteServiceCount)
        }
      });
    } catch (error) {
      console.error("Error fetching user stats:", error);
      res.status(500).json({ error: "Failed to fetch user statistics" });
    }
  });
  app2.patch("/api/mobile/users/profile", authenticateMobileUser, async (req, res) => {
    try {
      const userId = req.user.id;
      const { firstName, lastName, phoneNumber } = req.body;
      const updates = {};
      if (firstName !== void 0) updates.firstName = firstName;
      if (lastName !== void 0) updates.lastName = lastName;
      if (phoneNumber !== void 0) updates.phoneNumber = phoneNumber;
      if (Object.keys(updates).length === 0) {
        return res.status(400).json({ error: "No valid fields to update" });
      }
      await storage.updateUser(userId, updates);
      const updatedUser = await storage.getUser(userId);
      res.json({
        success: true,
        message: "Profile updated successfully",
        user: updatedUser
      });
    } catch (error) {
      console.error("Error updating profile:", error);
      res.status(500).json({ error: "Failed to update profile" });
    }
  });
  console.log("\u2705 Mobile user profile routes registered");
  app2.use("/api/events", events_routes_default);
  registerShopRoutes(app2);
  app2.use("/api/payment", payment_routes_default);
  console.log("\u2705 Payment routes registered");
  app2.use("/api/mobile/loyalty", authenticateMobileUser, loyalty_default);
  console.log("\u2705 Loyalty & Rewards routes registered");
  app2.use("/api/mobile/favorites", authenticateMobileUser, favorites_default);
  console.log("\u2705 Favorites routes registered");
  app2.use("/api/mobile/referrals", authenticateMobileUser, referrals_default);
  console.log("\u2705 Referral routes registered");
  app2.use("/api/chat", authenticateChatUser, chat_routes_default);
  console.log("\u2705 Chat routes registered");
  app2.use("/api/ai-consultant", ai_consultant_routes_default);
  initializeAIConsultantRoutes().then((available) => {
    console.log(`\u2705 AI Beauty Consultant routes registered ${available ? "(Gemini API available)" : "(Gemini API unavailable)"}`);
  }).catch((error) => {
    console.error("Failed to initialize AI consultant routes:", error);
  });
  app2.use("/api/business", isAuthenticated, client_profiles_routes_default);
  console.log("\u2705 Client Profile routes registered");
  app2.use("/api/premium-analytics", premiumAnalytics_default);
  console.log("\u2705 Premium Analytics routes registered");
  app2.use("/api/phone-verification", phone_verification_routes_default);
  console.log("\u2705 Phone verification routes registered");
  app2.use("/api/business", isAuthenticated, deposits_routes_default);
  console.log("\u2705 Deposits routes registered");
  registerJobCardRoutes(app2);
  console.log("\u2705 Job Card routes registered");
  registerCommissionPayoutRoutes(app2);
  console.log("\u2705 Commission & Payout routes registered");
  app2.use("/api/deposits", publicDepositsRouter);
  console.log("\u2705 Public Deposits routes registered");
  app2.use("/api/business/gift-cards", isAuthenticated, gift_cards_routes_default);
  app2.use("/api/gift-cards", publicGiftCardsRouter);
  console.log("\u2705 Gift Cards routes registered");
  app2.use("/api/rebooking", isAuthenticated, rebooking_routes_default);
  registerMobileRebookingRoutes(app2);
  console.log("\u2705 Rebooking routes registered (web + mobile)");
  app2.use("/api/express-rebook", isAuthenticated, expressRebooking_routes_default);
  registerMobileExpressRebookingRoutes(app2);
  console.log("\u2705 Express Rebooking routes registered (web + mobile)");
  app2.use("/api/dynamic-pricing", dynamicPricing_routes_default);
  registerMobileDynamicPricingRoutes(app2, authenticateMobileUser);
  console.log("\u2705 Dynamic Pricing routes registered (web + mobile)");
  app2.use("/api/late-arrival", late_arrival_routes_default);
  app2.use("/api/mobile/late-arrival", mobileRouter);
  console.log("\u2705 Late Arrival routes registered (web + mobile)");
  app2.use("/api", departure_alerts_routes_default);
  app2.use("/api/mobile/departure-alerts", mobileDepartureAlertsRouter);
  console.log("\u2705 Smart Departure Notification routes registered (web + mobile)");
  app2.use("/api/service-bundles", serviceBundle_routes_default);
  app2.use("/api/mobile/service-bundles", mobileRouter2);
  console.log("\u2705 Service Bundle routes registered (web + mobile)");
  app2.use("/api", membership_routes_default);
  console.log("\u2705 Customer Membership routes registered");
  app2.use("/api/shop-admin", isAuthenticated, shopAdminRoutes_default);
  console.log("\u2705 Shop Admin RBAC routes registered");
  registerCustomerImportRoutes(app2);
  console.log("\u2705 Customer Import routes registered");
  registerCampaignRoutes(app2);
  console.log("\u2705 Invitation Campaign routes registered");
  registerWelcomeOfferRoutes(app2);
  console.log("\u2705 Welcome Offer routes registered");
  registerOnboardingAnalyticsRoutes(app2);
  console.log("\u2705 Onboarding Analytics routes registered");
  app2.use("/api/subscriptions", subscription_routes_default);
  console.log("\u2705 Subscription tier routes registered");
  app2.use("/api/payment/webhooks", razorpay_webhook_routes_default);
  console.log("\u2705 Razorpay webhook routes registered");
  app2.use("/api/meta", meta_routes_default);
  console.log("\u2705 Meta (Facebook/Instagram) integration routes registered");
  app2.use("/api/settings", settings_routes_default);
  console.log("\u2705 Platform Settings routes registered");
  try {
    await subscriptionService.initializeTiers();
  } catch (error) {
    console.error("Failed to initialize subscription tiers:", error);
  }
  app2.get("/api/users/search", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user?.id || req.session?.userId;
      if (!userId) {
        return res.status(401).json({ success: false, message: "Authentication required" });
      }
      const { rbacService: rbacService2 } = await Promise.resolve().then(() => (init_rbacService(), rbacService_exports));
      const userSalons = await rbacService2.getSalonsForUser(userId);
      const isOwner = userSalons.some((s) => s.role === "business_owner");
      if (!isOwner) {
        return res.status(403).json({ success: false, message: "Only business owners can search users" });
      }
      const { email } = req.query;
      if (!email || typeof email !== "string" || email.length < 3) {
        return res.status(400).json({ success: false, message: "Email query must be at least 3 characters" });
      }
      const users8 = await storage.searchUsersByEmail(email, 10);
      return res.json({
        success: true,
        users: users8.map((u) => ({
          id: u.id,
          firstName: u.firstName,
          lastName: u.lastName,
          email: u.email,
          profileImageUrl: u.profileImageUrl
        }))
      });
    } catch (error) {
      console.error("Error searching users:", error);
      return res.status(500).json({ success: false, message: "Failed to search users" });
    }
  });
  console.log("\u2705 User search routes registered");
  registerMobileDepositRoutes(app2);
  console.log("\u2705 Mobile deposit routes registered");
  registerMobileUserRoutes(app2);
  console.log("\u2705 Mobile user profile routes registered");
  registerMobileBookingsRoutes(app2);
  console.log("\u2705 Mobile bookings routes registered");
  registerMobilePackagesRoutes(app2);
  registerMobileCancellationRoutes(app2);
  console.log("\u2705 Mobile cancellation routes registered");
  registerCancellationRoutes(app2);
  console.log("\u2705 Cancellation routes registered");
  app2.use("/api/waitlist", waitlist_routes_default);
  console.log("\u2705 Waitlist routes registered");
  app2.use("/api/mobile/waitlist", authenticateMobileUser, mobile_waitlist_routes_default);
  console.log("\u2705 Mobile waitlist routes registered");
  startWaitlistJobs();
  console.log("\u2705 Waitlist background jobs started");
  startExpressRebookingJobs();
  console.log("\u2705 Express Rebooking background jobs started");
  startDynamicPricingJobs();
  console.log("\u2705 Dynamic Pricing background jobs started");
  startServiceBundleJobs();
  console.log("\u2705 Service Bundle background jobs started");
  startDepartureAlertsJobs();
  console.log("\u2705 Smart Departure Alerts background jobs started");
  startMLAnalyticsJobs();
  console.log("\u2705 ML Analytics background jobs started");
  registerMobileOffersRoutes(app2);
  console.log("\u2705 Mobile offers routes registered");
  app2.get("/api/salons/:salonId/products/retail", async (req, res) => {
    try {
      const { salonId } = req.params;
      const {
        categoryId,
        search,
        minPrice,
        maxPrice,
        featured,
        limit = "50",
        offset = "0"
      } = req.query;
      const products2 = await storage.getRetailProducts(salonId, {
        categoryId,
        search,
        minPrice: minPrice ? parseInt(minPrice) : void 0,
        maxPrice: maxPrice ? parseInt(maxPrice) : void 0,
        featured: featured === "true",
        limit: parseInt(limit),
        offset: parseInt(offset)
      });
      res.json({ success: true, data: { products: products2 } });
    } catch (error) {
      console.error("Error fetching retail products:", error);
      res.status(500).json({ error: error.message });
    }
  });
  app2.get("/api/products/search", async (req, res) => {
    try {
      const {
        query,
        salonId,
        categoryId,
        minPrice,
        maxPrice,
        limit = "50"
      } = req.query;
      if (!query || query === "") {
        const rawProducts2 = await storage.getRetailProducts(
          salonId || "",
          {
            categoryId,
            minPrice: minPrice ? parseInt(minPrice) : void 0,
            maxPrice: maxPrice ? parseInt(maxPrice) : void 0,
            limit: parseInt(limit)
          }
        );
        const products3 = rawProducts2.filter((p) => {
          const effectiveStock = p.retailConfig?.useAllocatedStock === 0 ? parseFloat(String(p.currentStock || 0)) : parseFloat(String(p.retailConfig?.retailStockAllocated || 0));
          return p.availableForRetail === 1 && p.isActive === 1 && (p.retailPriceInPaisa || 0) > 0 && effectiveStock > 0;
        }).map((p) => ({
          id: p.id,
          name: p.name,
          brand: p.brand,
          retailPriceInPaisa: p.retailPriceInPaisa,
          retailImages: p.retailConfig?.retailImages || [],
          // Hybrid stock mode: Use warehouse stock if useAllocatedStock=0, else use allocated stock
          stock: p.retailConfig?.useAllocatedStock === 0 ? parseFloat(String(p.currentStock || 0)) : parseFloat(String(p.retailConfig?.retailStockAllocated || 0)),
          averageRating: null,
          // TODO: Implement ratings
          reviewCount: 0,
          // TODO: Implement reviews
          salonId: p.salonId
        }));
        return res.json({ success: true, data: { products: products3 } });
      }
      const rawProducts = await storage.searchProducts(query, {
        salonId,
        categoryId,
        minPrice: minPrice ? parseInt(minPrice) : void 0,
        maxPrice: maxPrice ? parseInt(maxPrice) : void 0,
        limit: parseInt(limit)
      });
      const products2 = rawProducts.filter((p) => {
        const effectiveStock = p.retailConfig?.useAllocatedStock === 0 ? parseFloat(String(p.currentStock || 0)) : parseFloat(String(p.retailConfig?.retailStockAllocated || 0));
        return p.availableForRetail === 1 && p.isActive === 1 && (p.retailPriceInPaisa || 0) > 0 && effectiveStock > 0;
      }).map((p) => ({
        id: p.id,
        name: p.name,
        brand: p.brand,
        retailPriceInPaisa: p.retailPriceInPaisa,
        retailImages: p.retailConfig?.retailImages || [],
        // Hybrid stock mode: Use warehouse stock if useAllocatedStock=0, else use allocated stock
        stock: p.retailConfig?.useAllocatedStock === 0 ? parseFloat(String(p.currentStock || 0)) : parseFloat(String(p.retailConfig?.retailStockAllocated || 0)),
        averageRating: null,
        // TODO: Implement ratings
        reviewCount: 0,
        // TODO: Implement reviews
        salonId: p.salonId
      }));
      res.json({ success: true, data: { products: products2 } });
    } catch (error) {
      console.error("Error searching products:", error);
      res.status(500).json({ error: error.message });
    }
  });
  app2.get("/api/products/:productId", async (req, res) => {
    try {
      const { productId } = req.params;
      const { includeVariants = "true" } = req.query;
      const rawProduct = await storage.getProductById(
        productId,
        includeVariants === "true"
      );
      if (!rawProduct) {
        return res.status(404).json({ error: "Product not found" });
      }
      const product = {
        id: rawProduct.id,
        name: rawProduct.name,
        brand: rawProduct.brand,
        description: rawProduct.description,
        retailPriceInPaisa: rawProduct.retailPriceInPaisa,
        costPriceInPaisa: rawProduct.costPriceInPaisa,
        retailImages: rawProduct.retailConfig?.retailImages || [],
        // Hybrid stock mode: Use warehouse stock if useAllocatedStock=0, else use allocated stock
        stock: rawProduct.retailConfig?.useAllocatedStock === 0 ? parseFloat(String(rawProduct.currentStock || 0)) : parseFloat(
          String(rawProduct.retailConfig?.retailStockAllocated || 0)
        ),
        averageRating: null,
        // TODO: Implement ratings
        reviewCount: 0,
        // TODO: Implement reviews
        categoryId: rawProduct.categoryId,
        salonId: rawProduct.salonId
      };
      res.json({ success: true, data: { product } });
    } catch (error) {
      console.error("Error fetching product:", error);
      res.status(500).json({ error: error.message });
    }
  });
  app2.get("/api/products/:productId/variants", async (req, res) => {
    try {
      const { productId } = req.params;
      const variants = await storage.getProductVariants(productId);
      res.json({ success: true, data: { variants } });
    } catch (error) {
      console.error("Error fetching product variants:", error);
      res.status(500).json({ error: error.message });
    }
  });
  app2.get(
    "/api/cart",
    isAuthenticated,
    async (req, res) => {
      try {
        const userId = req.user.id;
        const { salonId } = req.query;
        if (!salonId) {
          const items = await storage.getUserCartItems(userId);
          const transformedItems = items.map((item) => {
            const retailPriceInPaisa = item.product?.retailConfig?.retailPriceInPaisa ? parseInt(
              item.product.retailConfig.retailPriceInPaisa.toString()
            ) : item.priceAtAdd;
            const retailImages = item.product?.retailConfig?.retailImages || [];
            const productImage = retailImages.length > 0 ? retailImages[0] : null;
            const useAllocatedStock = item.product?.retailConfig?.useAllocatedStock || 0;
            const stock = useAllocatedStock === 1 ? item.product?.retailConfig?.retailStockAllocated ? parseFloat(
              item.product.retailConfig.retailStockAllocated.toString()
            ) : 0 : item.product?.currentStock ? parseFloat(item.product.currentStock.toString()) : 0;
            return {
              id: item.id,
              productId: item.productId,
              productName: item.product?.name || "Unknown Product",
              productImage,
              variantId: item.variantId,
              variantValue: item.variant?.variantValue || null,
              quantity: item.quantity,
              unitPriceInPaisa: retailPriceInPaisa,
              totalPriceInPaisa: retailPriceInPaisa * item.quantity,
              stock,
              isAvailable: item.product?.isActive && stock >= item.quantity
            };
          });
          const subtotalInPaisa = transformedItems.reduce(
            (sum4, item) => sum4 + item.totalPriceInPaisa,
            0
          );
          const taxInPaisa = Math.round(subtotalInPaisa * 0.18);
          const deliveryChargeInPaisa = subtotalInPaisa >= 5e4 ? 0 : 5e3;
          const totalInPaisa = subtotalInPaisa + taxInPaisa + deliveryChargeInPaisa;
          const cart3 = {
            id: "combined",
            // Virtual cart ID for combined items
            items: transformedItems,
            subtotalInPaisa,
            discountInPaisa: 0,
            deliveryChargeInPaisa,
            taxInPaisa,
            totalInPaisa,
            appliedCoupon: null
          };
          return res.json({ success: true, data: { cart: cart3 } });
        }
        const cart2 = await storage.getActiveCart(userId, salonId);
        res.json({ success: true, data: { cart: cart2 || null } });
      } catch (error) {
        console.error("Error fetching cart:", error);
        res.status(500).json({ error: error.message });
      }
    }
  );
  app2.post(
    "/api/cart/items",
    isAuthenticated,
    async (req, res) => {
      try {
        const userId = req.user.id;
        const validation = addToCartSchema.safeParse(req.body);
        if (!validation.success) {
          return res.status(400).json({
            error: "Validation failed",
            details: validation.error.errors
          });
        }
        const { salonId, productId, variantId, quantity } = validation.data;
        const cart2 = await storage.createOrGetCart(userId, salonId);
        const product = await storage.getProductById(productId, true);
        if (!product) {
          return res.status(404).json({ error: "Product not found" });
        }
        if (!product.availableForRetail) {
          return res.status(400).json({ error: "Product not available for retail" });
        }
        let serverPrice = product.retailPriceInPaisa;
        if (variantId && product.variants) {
          const variant = product.variants.find((v) => v.id === variantId);
          if (!variant) {
            return res.status(404).json({ error: "Variant not found" });
          }
          if (variant.priceAdjustmentPaisa) {
            serverPrice = product.retailPriceInPaisa + variant.priceAdjustmentPaisa;
          }
        }
        const retailConfig = product.retailConfig;
        const availableStock = retailConfig?.retailStockAllocated || 0;
        if (availableStock < quantity) {
          return res.status(400).json({
            error: "Insufficient stock",
            available: availableStock
          });
        }
        const item = await storage.addCartItem(cart2.id, {
          productId,
          variantId,
          quantity,
          priceAtAdd: serverPrice
        });
        res.json({ success: true, data: { item } });
      } catch (error) {
        console.error("Error adding to cart:", error);
        res.status(500).json({ error: error.message });
      }
    }
  );
  app2.put(
    "/api/cart/items/:itemId",
    isAuthenticated,
    async (req, res) => {
      try {
        const { itemId } = req.params;
        const validation = updateCartItemSchema.safeParse(req.body);
        if (!validation.success) {
          return res.status(400).json({
            error: "Validation failed",
            details: validation.error.errors
          });
        }
        const { quantity } = validation.data;
        await storage.updateCartItem(itemId, quantity);
        res.json({ success: true, data: { message: "Cart item updated" } });
      } catch (error) {
        console.error("Error updating cart item:", error);
        res.status(500).json({ error: error.message });
      }
    }
  );
  app2.delete(
    "/api/cart/items/:itemId",
    isAuthenticated,
    async (req, res) => {
      try {
        const { itemId } = req.params;
        await storage.removeCartItem(itemId);
        res.json({ success: true, data: { message: "Cart item removed" } });
      } catch (error) {
        console.error("Error removing cart item:", error);
        res.status(500).json({ error: error.message });
      }
    }
  );
  app2.post(
    "/api/product-orders",
    isAuthenticated,
    async (req, res) => {
      try {
        const userId = req.user.id;
        const validation = createProductOrderSchema.safeParse(req.body);
        if (!validation.success) {
          return res.status(400).json({
            error: "Validation failed",
            details: validation.error.errors
          });
        }
        let {
          salonId,
          cartId,
          deliveryAddress,
          addressId,
          paymentMethod,
          fulfillmentType
        } = validation.data;
        let cartItems2 = [];
        if (cartId && cartId !== "combined" && salonId) {
          const cart2 = await storage.getActiveCart(userId, salonId);
          if (!cart2 || cart2.id !== cartId) {
            return res.status(404).json({ error: "Cart not found" });
          }
          cartItems2 = cart2.items || [];
        } else {
          const userItems = await storage.getUserCartItems(userId);
          cartItems2 = userItems.map((item) => ({
            productId: item.productId,
            variantId: item.variantId,
            quantity: item.quantity,
            salonId: item.salonId
          }));
        }
        if (cartItems2.length === 0) {
          return res.status(400).json({ error: "Cart is empty" });
        }
        if (!salonId) {
          salonId = cartItems2[0].salonId;
        }
        const invalidItems = cartItems2.filter(
          (item) => item.salonId !== salonId
        );
        if (invalidItems.length > 0) {
          return res.status(400).json({
            error: "Cannot place order with items from multiple salons. Please checkout one salon at a time."
          });
        }
        if (!cartId || cartId === "combined") {
          const salonCart = await storage.createOrGetCart(userId, salonId);
          cartId = salonCart.id;
        }
        if (fulfillmentType === "delivery" && addressId && !deliveryAddress) {
          const savedAddress = await db.select().from(void 0).where(
            and56(
              eq58((void 0).id, addressId),
              eq58((void 0).userId, userId)
            )
          ).limit(1);
          if (savedAddress.length === 0) {
            return res.status(404).json({ error: "Saved address not found" });
          }
          const addr = savedAddress[0];
          deliveryAddress = {
            fullName: addr.fullName,
            phone: addr.phone,
            addressLine1: addr.addressLine1,
            addressLine2: addr.addressLine2 || void 0,
            city: addr.city,
            state: addr.state,
            pincode: addr.pincode
          };
        }
        let subtotalPaisa = 0;
        const orderItems = [];
        for (const item of cart.items) {
          const product = await storage.getProductById(item.productId, true);
          if (!product) {
            return res.status(404).json({ error: `Product ${item.productId} not found` });
          }
          if (!product.availableForRetail) {
            return res.status(400).json({
              error: `Product ${product.name} not available for retail`
            });
          }
          const retailConfig = product.retailConfig;
          const availableStock = parseFloat(
            retailConfig?.retailStockAllocated || "0"
          );
          if (availableStock < item.quantity) {
            return res.status(400).json({
              error: `Insufficient stock for ${product.name}`,
              available: availableStock,
              requested: item.quantity
            });
          }
          let serverPrice = product.retailPriceInPaisa;
          if (item.variantId && product.variants) {
            const variant = product.variants.find(
              (v) => v.id === item.variantId
            );
            if (variant?.priceAdjustmentPaisa) {
              serverPrice += variant.priceAdjustmentPaisa;
            }
          }
          subtotalPaisa += serverPrice * item.quantity;
          orderItems.push({
            productId: item.productId,
            variantId: item.variantId,
            quantity: item.quantity,
            priceAtOrderPaisa: serverPrice,
            productName: product.name,
            productImage: product.images?.[0] || null
          });
        }
        const deliverySettings2 = await db.select().from(deliverySettings).where(eq58(deliverySettings.salonId, salonId)).limit(1);
        let deliveryFeePaisa = 0;
        if (fulfillmentType === "delivery") {
          const settings = deliverySettings2[0];
          if (settings?.enableHomeDelivery === 1) {
            deliveryFeePaisa = settings.deliveryChargePaisa || 0;
            if (settings.freeDeliveryAbovePaisa && subtotalPaisa >= settings.freeDeliveryAbovePaisa) {
              deliveryFeePaisa = 0;
            }
          } else {
            return res.status(400).json({ error: "Home delivery not enabled for this salon" });
          }
        }
        if ((paymentMethod === "online" || paymentMethod === "upi") && !razorpay7) {
          return res.status(503).json({ error: "Payment service not configured" });
        }
        const taxPaisa = Math.round(subtotalPaisa * 0.18);
        const totalPaisa = subtotalPaisa + taxPaisa + deliveryFeePaisa;
        try {
          const result = await db.transaction(async (tx) => {
            for (const item of orderItems) {
              const [updatedConfig] = await tx.update(productRetailConfig).set({
                retailStockAllocated: sql44`${productRetailConfig.retailStockAllocated} - ${item.quantity}`,
                updatedAt: /* @__PURE__ */ new Date()
              }).where(
                and56(
                  eq58(productRetailConfig.productId, item.productId),
                  sql44`${productRetailConfig.retailStockAllocated} >= ${item.quantity}`
                  // Ensure sufficient stock
                )
              ).returning();
              if (!updatedConfig) {
                throw new Error(
                  `Insufficient stock for ${item.productName} (concurrent purchase)`
                );
              }
            }
            const order2 = await storage.createProductOrder({
              userId,
              salonId,
              cartId,
              deliveryAddress,
              paymentMethod,
              fulfillmentType,
              items: orderItems,
              subtotalInPaisa: subtotalPaisa,
              taxInPaisa: taxPaisa,
              deliveryFeeInPaisa: deliveryFeePaisa,
              totalInPaisa: totalPaisa
            });
            return { order: order2 };
          });
          const { order } = result;
          for (const item of orderItems) {
            checkAndSendLowStockAlert(item.productId, salonId).catch(
              (err) => console.error(
                `Failed to check low stock for product ${item.productId}:`,
                err
              )
            );
          }
          if (paymentMethod === "online" || paymentMethod === "upi") {
            try {
              const razorpayOrderOptions = {
                amount: totalPaisa,
                currency: "INR",
                receipt: `product_order_${order.id}`,
                notes: {
                  orderId: order.id,
                  userId,
                  salonId,
                  orderType: "product_order"
                }
              };
              const razorpayOrder = await razorpay7.orders.create(razorpayOrderOptions);
              await storage.createPayment({
                userId,
                productOrderId: order.id,
                amountPaisa: totalPaisa,
                paymentMethod,
                razorpayOrderId: razorpayOrder.id,
                status: "pending"
              });
              await storage.updateOrderStatus(order.id, "payment_pending");
              return res.json({
                success: true,
                data: {
                  order,
                  razorpayOrder: {
                    id: razorpayOrder.id,
                    amount: razorpayOrder.amount,
                    currency: razorpayOrder.currency
                  },
                  razorpayKeyId: process.env.RAZORPAY_KEY_ID
                }
              });
            } catch (razorpayError) {
              console.error(
                "Razorpay payment initialization failed:",
                razorpayError
              );
              await storage.createPayment({
                userId,
                productOrderId: order.id,
                amountPaisa: totalPaisa,
                paymentMethod,
                razorpayOrderId: null,
                // Razorpay order not created
                status: "failed"
              });
              await storage.updateOrderStatus(order.id, "payment_failed");
              return res.status(500).json({
                error: "Payment initialization failed. Please try again.",
                orderId: order.id,
                canRetry: true
              });
            }
          } else {
            try {
              const user = await storage.getUserById(userId);
              const salon = await storage.getSalonById(salonId);
              if (user && salon && user.email) {
                const customerName = user.firstName ? `${user.firstName}${user.lastName ? " " + user.lastName : ""}`.trim() : user.email.split("@")[0];
                const orderItemsList = orderItems.map(
                  (item, index2) => `${index2 + 1}. ${item.productName}
   Qty: ${item.quantity} x Rs.${(item.priceAtOrderPaisa / 100).toFixed(2)} = Rs.${(item.priceAtOrderPaisa * item.quantity / 100).toFixed(2)}`
                ).join("\n");
                let formattedAddress = "Pickup from salon";
                if (typeof deliveryAddress === "object" && deliveryAddress.line1) {
                  formattedAddress = `${deliveryAddress.line1}
${deliveryAddress.line2 ? deliveryAddress.line2 + "\n" : ""}${deliveryAddress.city}, ${deliveryAddress.state} ${deliveryAddress.pincode}`;
                } else if (typeof deliveryAddress === "string") {
                  formattedAddress = deliveryAddress;
                }
                await sendOrderConfirmation(salonId, order.id, user.email, {
                  customer_name: customerName,
                  salon_name: salon.name,
                  order_number: order.orderNumber,
                  item_count: orderItems.length.toString(),
                  total_amount: (totalPaisa / 100).toFixed(2),
                  delivery_address: formattedAddress,
                  order_items: orderItemsList,
                  payment_method: paymentMethod === "cod" ? "Cash on Delivery" : paymentMethod,
                  payment_status: "Pending (COD)"
                });
              }
            } catch (emailError) {
              console.error(
                "Failed to send order confirmation email:",
                emailError
              );
            }
            return res.json({ success: true, data: { order } });
          }
        } catch (error) {
          console.error("Error creating product order:", error);
          const statusCode = error.message.includes("not configured") ? 503 : error.message.includes("not enabled") ? 400 : error.message.includes("Insufficient stock") ? 400 : 500;
          return res.status(statusCode).json({ error: error.message });
        }
      } catch (error) {
        console.error("Error creating product order:", error);
        res.status(500).json({ error: error.message });
      }
    }
  );
  app2.get(
    "/api/product-orders/:orderId",
    isAuthenticated,
    async (req, res) => {
      try {
        const { orderId } = req.params;
        const order = await storage.getProductOrder(orderId);
        if (!order) {
          return res.status(404).json({ error: "Order not found" });
        }
        res.json({ success: true, data: { order } });
      } catch (error) {
        console.error("Error fetching product order:", error);
        res.status(500).json({ error: error.message });
      }
    }
  );
  app2.get(
    "/api/product-orders",
    isAuthenticated,
    async (req, res) => {
      try {
        const userId = req.user.id;
        const { limit = "50" } = req.query;
        const orders = await storage.getProductOrdersByUser(
          userId,
          parseInt(limit)
        );
        res.json({ success: true, data: { orders } });
      } catch (error) {
        console.error("Error fetching product orders:", error);
        res.status(500).json({ error: error.message });
      }
    }
  );
  app2.put(
    "/api/product-orders/:orderId/cancel",
    isAuthenticated,
    async (req, res) => {
      try {
        const { orderId } = req.params;
        const validation = cancelOrderSchema.safeParse(req.body);
        if (!validation.success) {
          return res.status(400).json({
            error: "Validation failed",
            details: validation.error.errors
          });
        }
        const { reason } = validation.data;
        await storage.cancelProductOrder(orderId, reason);
        res.json({ success: true, data: { message: "Order cancelled" } });
      } catch (error) {
        console.error("Error cancelling product order:", error);
        res.status(500).json({ error: error.message });
      }
    }
  );
  app2.get(
    "/api/wishlist",
    isAuthenticated,
    async (req, res) => {
      try {
        const userId = req.user.id;
        const { salonId } = req.query;
        const wishlist = await storage.getWishlist(userId, salonId);
        res.json({ success: true, data: { wishlist } });
      } catch (error) {
        console.error("Error fetching wishlist:", error);
        res.status(500).json({ error: error.message });
      }
    }
  );
  app2.post(
    "/api/wishlist",
    isAuthenticated,
    async (req, res) => {
      try {
        const userId = req.user.id;
        const validation = addToWishlistSchema.safeParse(req.body);
        if (!validation.success) {
          return res.status(400).json({
            error: "Validation failed",
            details: validation.error.errors
          });
        }
        const { productId, variantId } = validation.data;
        const wishlistItem = await storage.addToWishlist(
          userId,
          productId,
          variantId
        );
        res.json({ success: true, data: { wishlistItem } });
      } catch (error) {
        console.error("Error adding to wishlist:", error);
        res.status(500).json({ error: error.message });
      }
    }
  );
  app2.delete(
    "/api/wishlist/:wishlistId",
    isAuthenticated,
    async (req, res) => {
      try {
        const { wishlistId } = req.params;
        await storage.removeFromWishlist(wishlistId);
        res.json({
          success: true,
          data: { message: "Item removed from wishlist" }
        });
      } catch (error) {
        console.error("Error removing from wishlist:", error);
        res.status(500).json({ error: error.message });
      }
    }
  );
  app2.get("/api/products/:productId/reviews", async (req, res) => {
    try {
      const { productId } = req.params;
      const { rating, verified, limit = "50", offset = "0" } = req.query;
      const reviews = await storage.getProductReviews(productId, {
        rating: rating ? parseInt(rating) : void 0,
        verified: verified === "true",
        limit: parseInt(limit),
        offset: parseInt(offset)
      });
      res.json({ success: true, data: { reviews } });
    } catch (error) {
      console.error("Error fetching product reviews:", error);
      res.status(500).json({ error: error.message });
    }
  });
  app2.post(
    "/api/products/:productId/reviews",
    isAuthenticated,
    async (req, res) => {
      try {
        const userId = req.user.id;
        const { productId } = req.params;
        const validation = createReviewSchema.safeParse(req.body);
        if (!validation.success) {
          return res.status(400).json({
            error: "Validation failed",
            details: validation.error.errors
          });
        }
        const { orderId, rating, title, reviewText, images } = validation.data;
        const review = await storage.createProductReview({
          productId,
          userId,
          orderId,
          rating,
          title,
          reviewText,
          images
        });
        res.json({ success: true, data: { review } });
      } catch (error) {
        console.error("Error creating product review:", error);
        res.status(500).json({ error: error.message });
      }
    }
  );
  app2.post("/api/products/:productId/view", async (req, res) => {
    try {
      const { productId } = req.params;
      const userId = req.user?.id || null;
      const validation = trackProductViewSchema.safeParse(req.body);
      if (!validation.success) {
        return res.status(400).json({
          error: "Validation failed",
          details: validation.error.errors
        });
      }
      const { sessionId } = validation.data;
      await storage.trackProductView(userId, productId, sessionId);
      res.json({ success: true, data: { message: "View tracked" } });
    } catch (error) {
      console.error("Error tracking product view:", error);
      res.status(500).json({ error: error.message });
    }
  });
  app2.get(
    "/api/admin/salons/:salonId/products/retail",
    requireSalonAccess,
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const {
          availableForRetail,
          categoryId,
          search,
          limit = "50",
          offset = "0"
        } = req.query;
        const products2 = await storage.getAdminProductList(salonId, {
          availableForRetail: availableForRetail === "true" ? true : availableForRetail === "false" ? false : void 0,
          categoryId,
          search,
          limit: parseInt(limit),
          offset: parseInt(offset)
        });
        res.json({ success: true, data: { products: products2 } });
      } catch (error) {
        console.error("Error fetching admin products:", error);
        res.status(500).json({ error: error.message });
      }
    }
  );
  app2.get(
    "/api/admin/salons/:salonId/products/stats",
    requireSalonAccess,
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const allProducts = await db.select().from(products).where(eq58(products.salonId, salonId));
        const today = /* @__PURE__ */ new Date();
        today.setHours(0, 0, 0, 0);
        const todayOrders = await db.select({ id: productOrders.id }).from(productOrders).where(
          and56(
            eq58(productOrders.salonId, salonId),
            sql44`${productOrders.createdAt} >= ${today.toISOString()}`
          )
        );
        const stats = {
          totalProducts: allProducts.length,
          retailEnabled: allProducts.filter((p) => p.availableForRetail).length,
          lowStock: allProducts.filter((p) => p.stock < 10).length,
          ordersToday: todayOrders.length
        };
        res.json({ success: true, data: stats });
      } catch (error) {
        console.error("Error fetching product stats:", error);
        res.status(500).json({ error: error.message });
      }
    }
  );
  app2.put(
    "/api/admin/salons/:salonId/products/:productId/retail-config",
    requireSalonAccess,
    async (req, res) => {
      try {
        const { salonId, productId } = req.params;
        const validation = configureRetailSchema.safeParse(req.body);
        if (!validation.success) {
          return res.status(400).json({
            error: "Validation failed",
            details: validation.error.errors
          });
        }
        await storage.configureProductForRetail(
          productId,
          salonId,
          validation.data
        );
        res.json({
          success: true,
          data: { message: "Product retail configuration updated" }
        });
      } catch (error) {
        console.error("Error configuring product for retail:", error);
        res.status(500).json({ error: error.message });
      }
    }
  );
  app2.get(
    "/api/admin/salons/:salonId/product-orders/summary",
    requireSalonAccess,
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const allOrders = await db.select({ status: productOrders.status }).from(productOrders).where(eq58(productOrders.salonId, salonId));
        const summary = {
          new: allOrders.filter((o) => o.status === "pending").length,
          preparing: allOrders.filter((o) => o.status === "processing").length,
          ready: allOrders.filter(
            (o) => o.status === "ready_for_pickup" || o.status === "out_for_delivery"
          ).length,
          delivered: allOrders.filter(
            (o) => o.status === "delivered" || o.status === "completed"
          ).length,
          cancelled: allOrders.filter((o) => o.status === "cancelled").length
        };
        res.json({ success: true, data: summary });
      } catch (error) {
        console.error("Error fetching order summary:", error);
        res.status(500).json({ error: error.message });
      }
    }
  );
  app2.get(
    "/api/admin/salons/:salonId/product-orders",
    requireSalonAccess,
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const {
          status,
          fulfillmentType,
          dateFrom,
          dateTo,
          search,
          limit = "50",
          offset = "0"
        } = req.query;
        const result = await storage.getAdminOrders(salonId, {
          status,
          fulfillmentType,
          dateFrom,
          dateTo,
          search,
          limit: parseInt(limit),
          offset: parseInt(offset)
        });
        res.json({ success: true, data: result });
      } catch (error) {
        console.error("Error fetching admin orders:", error);
        res.status(500).json({ error: error.message });
      }
    }
  );
  app2.put(
    "/api/admin/salons/:salonId/product-orders/:orderId/status",
    requireSalonAccess,
    async (req, res) => {
      try {
        const { salonId, orderId } = req.params;
        const validation = updateOrderStatusSchema.safeParse(req.body);
        if (!validation.success) {
          return res.status(400).json({
            error: "Validation failed",
            details: validation.error.errors
          });
        }
        await storage.updateOrderStatus(orderId, salonId, validation.data);
        try {
          const order = await storage.getProductOrder(orderId);
          if (order && validation.data.status) {
            const user = await storage.getUserById(order.customerId);
            const salon = await storage.getSalonById(salonId);
            if (user && salon && user.email) {
              const customerName = user.firstName ? `${user.firstName}${user.lastName ? " " + user.lastName : ""}`.trim() : user.email.split("@")[0];
              const newStatus = validation.data.status;
              if (["processing", "packed", "shipped", "delivered"].includes(
                newStatus
              )) {
                await sendOrderStatusUpdate(
                  salonId,
                  orderId,
                  user.email,
                  newStatus,
                  {
                    customer_name: customerName,
                    salon_name: salon.name,
                    order_number: order.orderNumber,
                    tracking_number: validation.data.trackingInfo || "",
                    estimated_delivery: validation.data.estimatedDeliveryDate || "TBD",
                    delivered_date: newStatus === "delivered" ? (/* @__PURE__ */ new Date()).toLocaleDateString("en-IN") : "",
                    delivery_method_pickup: order.fulfillmentType === "pickup" ? "true" : "",
                    salon_address: salon.address || ""
                  }
                );
                console.log(
                  `Status update email sent for order ${orderId}, new status: ${newStatus}`
                );
              }
            }
          }
        } catch (emailError) {
          console.error("Failed to send status update email:", emailError);
        }
        res.json({ success: true, data: { message: "Order status updated" } });
      } catch (error) {
        console.error("Error updating order status:", error);
        res.status(500).json({ error: error.message });
      }
    }
  );
  app2.post(
    "/api/admin/salons/:salonId/product-orders/:orderId/cancel",
    requireSalonAccess,
    async (req, res) => {
      try {
        const { salonId, orderId } = req.params;
        const validation = cancelOrderAdminSchema.safeParse(req.body);
        if (!validation.success) {
          return res.status(400).json({
            error: "Validation failed",
            details: validation.error.errors
          });
        }
        const { reason, refundAmountPaisa } = validation.data;
        await storage.cancelOrderAdmin(
          orderId,
          salonId,
          reason,
          refundAmountPaisa
        );
        try {
          const order = await storage.getProductOrder(orderId);
          if (order) {
            const user = await storage.getUserById(order.customerId);
            const salon = await storage.getSalonById(salonId);
            if (user && salon && user.email) {
              const customerName = user.firstName ? `${user.firstName}${user.lastName ? " " + user.lastName : ""}`.trim() : user.email.split("@")[0];
              await sendOrderCancellation(salonId, orderId, user.email, {
                customer_name: customerName,
                salon_name: salon.name,
                order_number: order.orderNumber,
                cancellation_reason: reason,
                cancelled_date: (/* @__PURE__ */ new Date()).toLocaleDateString("en-IN"),
                refund_applicable: refundAmountPaisa && refundAmountPaisa > 0 ? "true" : "",
                refund_amount: refundAmountPaisa ? (refundAmountPaisa / 100).toFixed(2) : "0",
                refund_method: order.paymentMethod === "cod" ? "N/A" : "Original payment method",
                refund_timeline: order.paymentMethod === "cod" ? "N/A" : "5-7 business days"
              });
              console.log(`Cancellation email sent for order ${orderId}`);
            }
          }
        } catch (emailError) {
          console.error("Failed to send cancellation email:", emailError);
        }
        res.json({
          success: true,
          data: { message: "Order cancelled successfully" }
        });
      } catch (error) {
        console.error("Error cancelling order:", error);
        res.status(500).json({ error: error.message });
      }
    }
  );
  app2.get(
    "/api/admin/salons/:salonId/analytics/products",
    requireSalonAccess,
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const { period, dateFrom, dateTo } = req.query;
        const analytics = await storage.getProductAnalytics(salonId, {
          period,
          dateFrom,
          dateTo
        });
        res.json({ success: true, data: analytics });
      } catch (error) {
        console.error("Error fetching product analytics:", error);
        res.status(500).json({ error: error.message });
      }
    }
  );
  app2.get(
    "/api/admin/salons/:salonId/delivery-settings",
    requireSalonAccess,
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const settings = await storage.getDeliverySettings(salonId);
        res.json({ success: true, data: { settings } });
      } catch (error) {
        console.error("Error fetching delivery settings:", error);
        res.status(500).json({ error: error.message });
      }
    }
  );
  app2.put(
    "/api/admin/salons/:salonId/delivery-settings",
    requireSalonAccess,
    async (req, res) => {
      try {
        const { salonId } = req.params;
        const validation = updateDeliverySettingsSchema.safeParse(
          req.body
        );
        if (!validation.success) {
          return res.status(400).json({
            error: "Validation failed",
            details: validation.error.errors
          });
        }
        await storage.updateDeliverySettings(salonId, validation.data);
        res.json({
          success: true,
          data: { message: "Delivery settings updated" }
        });
      } catch (error) {
        console.error("Error updating delivery settings:", error);
        res.status(500).json({ error: error.message });
      }
    }
  );
  const httpServer = createServer(app2);
  initializeChatSocket(httpServer);
  initializeQueueSocketEvents();
  return httpServer;
}

// server/vite.ts
import express5 from "express";
import fs from "fs";
import path2 from "path";
import { createServer as createViteServer, createLogger } from "vite";

// vite.config.ts
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import { fileURLToPath } from "url";
import path from "path";
import runtimeErrorOverlay from "@replit/vite-plugin-runtime-error-modal";
var __filename = fileURLToPath(import.meta.url);
var __dirname = path.dirname(__filename);
var vite_config_default = defineConfig({
  plugins: [
    react(),
    runtimeErrorOverlay(),
    ...process.env.NODE_ENV !== "production" && process.env.REPL_ID !== void 0 ? [
      await import("@replit/vite-plugin-cartographer").then(
        (m) => m.cartographer()
      )
    ] : []
  ],
  define: {
    // Expose Banuba client token to frontend (safe - it's a public client-side token)
    "import.meta.env.VITE_BANUBA_CLIENT_TOKEN": JSON.stringify(process.env.BANUBA_CLIENT_TOKEN || "")
  },
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "client", "src"),
      "@shared": path.resolve(__dirname, "shared"),
      "@assets": path.resolve(__dirname, "attached_assets")
    }
  },
  root: path.resolve(__dirname, "client"),
  build: {
    outDir: path.resolve(__dirname, "dist/public"),
    emptyOutDir: true
  },
  server: {
    host: "0.0.0.0",
    port: 5e3,
    allowedHosts: ["*"],
    fs: {
      strict: true,
      deny: ["**/.*"]
    }
    // No proxy needed - Express routes are integrated via middlewareMode in server/vite.ts
  }
});

// server/vite.ts
import { nanoid } from "nanoid";
var viteLogger = createLogger();
function log(message, source = "express") {
  const formattedTime = (/* @__PURE__ */ new Date()).toLocaleTimeString("en-US", {
    hour: "numeric",
    minute: "2-digit",
    second: "2-digit",
    hour12: true
  });
  console.log(`${formattedTime} [${source}] ${message}`);
}
async function setupVite(app2, server) {
  const isReplit = process.env.REPL_ID !== void 0;
  const serverOptions = {
    middlewareMode: true,
    hmr: isReplit ? false : { server },
    allowedHosts: true
  };
  const vite = await createViteServer({
    ...vite_config_default,
    configFile: false,
    customLogger: {
      ...viteLogger,
      error: (msg, options) => {
        viteLogger.error(msg, options);
        process.exit(1);
      }
    },
    server: serverOptions,
    appType: "custom"
  });
  app2.use(vite.middlewares);
  app2.use("*", async (req, res, next) => {
    const url = req.originalUrl;
    try {
      const clientTemplate = path2.resolve(
        import.meta.dirname,
        "..",
        "client",
        "index.html"
      );
      let template = await fs.promises.readFile(clientTemplate, "utf-8");
      template = template.replace(
        `src="/src/main.tsx"`,
        `src="/src/main.tsx?v=${nanoid()}"`
      );
      const page = await vite.transformIndexHtml(url, template);
      res.status(200).set({ "Content-Type": "text/html" }).end(page);
    } catch (e) {
      vite.ssrFixStacktrace(e);
      next(e);
    }
  });
}
function serveStatic(app2) {
  const distPath = path2.resolve(import.meta.dirname, "public");
  if (!fs.existsSync(distPath)) {
    throw new Error(
      `Could not find the build directory: ${distPath}, make sure to build the client first`
    );
  }
  app2.use(express5.static(distPath));
  app2.use("*", (_req, res) => {
    res.sendFile(path2.resolve(distPath, "index.html"));
  });
}

// server/services/registration-cleanup.service.ts
init_db();
init_schema();
import cron8 from "node-cron";
import { and as and57, eq as eq59, sql as sql45, lt as lt8 } from "drizzle-orm";
var RegistrationCleanupService = class _RegistrationCleanupService {
  static instance;
  cronJob = null;
  constructor() {
  }
  static getInstance() {
    if (!_RegistrationCleanupService.instance) {
      _RegistrationCleanupService.instance = new _RegistrationCleanupService();
    }
    return _RegistrationCleanupService.instance;
  }
  start() {
    if (this.cronJob) {
      console.log("\u26A0\uFE0F  Registration cleanup service already running");
      return;
    }
    this.cronJob = cron8.schedule("*/5 * * * *", async () => {
      await this.cleanupExpiredRegistrations();
    });
    console.log("\u2705 Registration cleanup service started (runs every 5 minutes)");
  }
  stop() {
    if (this.cronJob) {
      this.cronJob.stop();
      this.cronJob = null;
      console.log("Registration cleanup service stopped");
    }
  }
  async cleanupExpiredRegistrations() {
    try {
      const now = /* @__PURE__ */ new Date();
      const expiredRegistrations = await db.select({
        id: eventRegistrations.id,
        bookingId: eventRegistrations.bookingId,
        attendeeEmail: eventRegistrations.attendeeEmail,
        expiresAt: eventRegistrations.expiresAt
      }).from(eventRegistrations).where(
        and57(
          eq59(eventRegistrations.status, "pending"),
          eq59(eventRegistrations.paymentStatus, "pending"),
          sql45`${eventRegistrations.expiresAt} IS NOT NULL`,
          lt8(eventRegistrations.expiresAt, now)
        )
      );
      if (expiredRegistrations.length === 0) {
        return;
      }
      const registrationIds = expiredRegistrations.map((r) => r.id);
      await db.update(eventRegistrations).set({
        status: "cancelled",
        cancelledAt: now,
        cancellationReason: "Payment window expired (automatic cleanup)",
        updatedAt: now
      }).where(
        sql45`${eventRegistrations.id} IN (${sql45.join(
          registrationIds.map((id) => sql45`${id}`),
          sql45`, `
        )})`
      );
      console.log(
        `\u{1F9F9} Cleanup: Cancelled ${expiredRegistrations.length} expired registration(s)`,
        {
          count: expiredRegistrations.length,
          bookingIds: expiredRegistrations.map((r) => r.bookingId),
          timestamp: now.toISOString()
        }
      );
    } catch (error) {
      console.error("\u274C Error in registration cleanup service:", error);
    }
  }
  async runManualCleanup() {
    await this.cleanupExpiredRegistrations();
    const result = await db.select({
      count: sql45`CAST(COUNT(*) AS INTEGER)`
    }).from(eventRegistrations).where(
      and57(
        eq59(eventRegistrations.status, "cancelled"),
        eq59(eventRegistrations.cancellationReason, "Payment window expired (automatic cleanup)")
      )
    );
    return result[0]?.count || 0;
  }
};
var registrationCleanupService = RegistrationCleanupService.getInstance();

// server/index.ts
var app = express6();
app.use(express6.json({ limit: "20mb" }));
app.use(express6.urlencoded({ extended: false, limit: "20mb" }));
app.use(cookieParser());
app.use((req, res, next) => {
  const start = Date.now();
  const path3 = req.path;
  let capturedJsonResponse = void 0;
  const originalResJson = res.json;
  res.json = function(bodyJson, ...args) {
    capturedJsonResponse = bodyJson;
    return originalResJson.apply(res, [bodyJson, ...args]);
  };
  res.on("finish", () => {
    const duration = Date.now() - start;
    if (path3.startsWith("/api")) {
      let logLine = `${req.method} ${path3} ${res.statusCode} in ${duration}ms`;
      if (capturedJsonResponse) {
        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;
      }
      if (logLine.length > 80) {
        logLine = logLine.slice(0, 79) + "\u2026";
      }
      log(logLine);
    }
  });
  next();
});
(async () => {
  const server = await registerRoutes(app);
  app.use((err, _req, res, _next) => {
    const status = err.status || err.statusCode || 500;
    const message = err.message || "Internal Server Error";
    res.status(status).json({ message });
    throw err;
  });
  if (app.get("env") === "development") {
    await setupVite(app, server);
  } else {
    serveStatic(app);
  }
  const port = parseInt(process.env.PORT || "5000", 10);
  server.listen({
    port,
    host: "0.0.0.0",
    reusePort: true
  }, () => {
    log(`serving on port ${port}`);
  });
  registrationCleanupService.start();
})();
